"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jszip";
exports.ids = ["vendor-chunks/jszip"];
exports.modules = {

/***/ "(ssr)/./node_modules/jszip/lib/base64.js":
/*!******************************************!*\
  !*** ./node_modules/jszip/lib/base64.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nvar support = __webpack_require__(/*! ./support */ \"(ssr)/./node_modules/jszip/lib/support.js\");\n// private property\nvar _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n// public method for encoding\nexports.encode = function(input) {\n    var output = [];\n    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n    var i = 0, len = input.length, remainingBytes = len;\n    var isArray = utils.getTypeOf(input) !== \"string\";\n    while(i < input.length){\n        remainingBytes = len - i;\n        if (!isArray) {\n            chr1 = input.charCodeAt(i++);\n            chr2 = i < len ? input.charCodeAt(i++) : 0;\n            chr3 = i < len ? input.charCodeAt(i++) : 0;\n        } else {\n            chr1 = input[i++];\n            chr2 = i < len ? input[i++] : 0;\n            chr3 = i < len ? input[i++] : 0;\n        }\n        enc1 = chr1 >> 2;\n        enc2 = (chr1 & 3) << 4 | chr2 >> 4;\n        enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;\n        enc4 = remainingBytes > 2 ? chr3 & 63 : 64;\n        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));\n    }\n    return output.join(\"\");\n};\n// public method for decoding\nexports.decode = function(input) {\n    var chr1, chr2, chr3;\n    var enc1, enc2, enc3, enc4;\n    var i = 0, resultIndex = 0;\n    var dataUrlPrefix = \"data:\";\n    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {\n        // This is a common error: people give a data url\n        // (data:image/png;base64,iVBOR...) with a {base64: true} and\n        // wonders why things don't work.\n        // We can detect that the string input looks like a data url but we\n        // *can't* be sure it is one: removing everything up to the comma would\n        // be too dangerous.\n        throw new Error(\"Invalid base64 input, it looks like a data url.\");\n    }\n    input = input.replace(/[^A-Za-z0-9+/=]/g, \"\");\n    var totalLength = input.length * 3 / 4;\n    if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {\n        totalLength--;\n    }\n    if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {\n        totalLength--;\n    }\n    if (totalLength % 1 !== 0) {\n        // totalLength is not an integer, the length does not match a valid\n        // base64 content. That can happen if:\n        // - the input is not a base64 content\n        // - the input is *almost* a base64 content, with a extra chars at the\n        //   beginning or at the end\n        // - the input uses a base64 variant (base64url for example)\n        throw new Error(\"Invalid base64 input, bad content length.\");\n    }\n    var output;\n    if (support.uint8array) {\n        output = new Uint8Array(totalLength | 0);\n    } else {\n        output = new Array(totalLength | 0);\n    }\n    while(i < input.length){\n        enc1 = _keyStr.indexOf(input.charAt(i++));\n        enc2 = _keyStr.indexOf(input.charAt(i++));\n        enc3 = _keyStr.indexOf(input.charAt(i++));\n        enc4 = _keyStr.indexOf(input.charAt(i++));\n        chr1 = enc1 << 2 | enc2 >> 4;\n        chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n        chr3 = (enc3 & 3) << 6 | enc4;\n        output[resultIndex++] = chr1;\n        if (enc3 !== 64) {\n            output[resultIndex++] = chr2;\n        }\n        if (enc4 !== 64) {\n            output[resultIndex++] = chr3;\n        }\n    }\n    return output;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2Jhc2U2NC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDLHdEQUFTO0FBQzdCLElBQUlDLFVBQVVELG1CQUFPQSxDQUFDLDREQUFXO0FBQ2pDLG1CQUFtQjtBQUNuQixJQUFJRSxVQUFVO0FBR2QsNkJBQTZCO0FBQzdCQyxjQUFjLEdBQUcsU0FBU0UsS0FBSztJQUMzQixJQUFJQyxTQUFTLEVBQUU7SUFDZixJQUFJQyxNQUFNQyxNQUFNQyxNQUFNQyxNQUFNQyxNQUFNQyxNQUFNQztJQUN4QyxJQUFJQyxJQUFJLEdBQUdDLE1BQU1WLE1BQU1XLE1BQU0sRUFBRUMsaUJBQWlCRjtJQUVoRCxJQUFJRyxVQUFVbkIsTUFBTW9CLFNBQVMsQ0FBQ2QsV0FBVztJQUN6QyxNQUFPUyxJQUFJVCxNQUFNVyxNQUFNLENBQUU7UUFDckJDLGlCQUFpQkYsTUFBTUQ7UUFFdkIsSUFBSSxDQUFDSSxTQUFTO1lBQ1ZYLE9BQU9GLE1BQU1lLFVBQVUsQ0FBQ047WUFDeEJOLE9BQU9NLElBQUlDLE1BQU1WLE1BQU1lLFVBQVUsQ0FBQ04sT0FBTztZQUN6Q0wsT0FBT0ssSUFBSUMsTUFBTVYsTUFBTWUsVUFBVSxDQUFDTixPQUFPO1FBQzdDLE9BQU87WUFDSFAsT0FBT0YsS0FBSyxDQUFDUyxJQUFJO1lBQ2pCTixPQUFPTSxJQUFJQyxNQUFNVixLQUFLLENBQUNTLElBQUksR0FBRztZQUM5QkwsT0FBT0ssSUFBSUMsTUFBTVYsS0FBSyxDQUFDUyxJQUFJLEdBQUc7UUFDbEM7UUFFQUosT0FBT0gsUUFBUTtRQUNmSSxPQUFPLENBQUVKLE9BQU8sTUFBTSxJQUFNQyxRQUFRO1FBQ3BDSSxPQUFPSyxpQkFBaUIsSUFBSyxDQUFFVCxPQUFPLEVBQUMsS0FBTSxJQUFNQyxRQUFRLElBQU07UUFDakVJLE9BQU9JLGlCQUFpQixJQUFLUixPQUFPLEtBQU07UUFFMUNILE9BQU9lLElBQUksQ0FBQ25CLFFBQVFvQixNQUFNLENBQUNaLFFBQVFSLFFBQVFvQixNQUFNLENBQUNYLFFBQVFULFFBQVFvQixNQUFNLENBQUNWLFFBQVFWLFFBQVFvQixNQUFNLENBQUNUO0lBRXBHO0lBRUEsT0FBT1AsT0FBT2lCLElBQUksQ0FBQztBQUN2QjtBQUVBLDZCQUE2QjtBQUM3QnBCLGNBQWMsR0FBRyxTQUFTRSxLQUFLO0lBQzNCLElBQUlFLE1BQU1DLE1BQU1DO0lBQ2hCLElBQUlDLE1BQU1DLE1BQU1DLE1BQU1DO0lBQ3RCLElBQUlDLElBQUksR0FBR1csY0FBYztJQUV6QixJQUFJQyxnQkFBZ0I7SUFFcEIsSUFBSXJCLE1BQU1zQixNQUFNLENBQUMsR0FBR0QsY0FBY1YsTUFBTSxNQUFNVSxlQUFlO1FBQ3pELGlEQUFpRDtRQUNqRCw2REFBNkQ7UUFDN0QsaUNBQWlDO1FBQ2pDLG1FQUFtRTtRQUNuRSx1RUFBdUU7UUFDdkUsb0JBQW9CO1FBQ3BCLE1BQU0sSUFBSUUsTUFBTTtJQUNwQjtJQUVBdkIsUUFBUUEsTUFBTXdCLE9BQU8sQ0FBQyxvQkFBb0I7SUFFMUMsSUFBSUMsY0FBY3pCLE1BQU1XLE1BQU0sR0FBRyxJQUFJO0lBQ3JDLElBQUdYLE1BQU1pQixNQUFNLENBQUNqQixNQUFNVyxNQUFNLEdBQUcsT0FBT2QsUUFBUW9CLE1BQU0sQ0FBQyxLQUFLO1FBQ3REUTtJQUNKO0lBQ0EsSUFBR3pCLE1BQU1pQixNQUFNLENBQUNqQixNQUFNVyxNQUFNLEdBQUcsT0FBT2QsUUFBUW9CLE1BQU0sQ0FBQyxLQUFLO1FBQ3REUTtJQUNKO0lBQ0EsSUFBSUEsY0FBYyxNQUFNLEdBQUc7UUFDdkIsbUVBQW1FO1FBQ25FLHNDQUFzQztRQUN0QyxzQ0FBc0M7UUFDdEMsc0VBQXNFO1FBQ3RFLDRCQUE0QjtRQUM1Qiw0REFBNEQ7UUFDNUQsTUFBTSxJQUFJRixNQUFNO0lBQ3BCO0lBQ0EsSUFBSXRCO0lBQ0osSUFBSUwsUUFBUThCLFVBQVUsRUFBRTtRQUNwQnpCLFNBQVMsSUFBSTBCLFdBQVdGLGNBQVk7SUFDeEMsT0FBTztRQUNIeEIsU0FBUyxJQUFJMkIsTUFBTUgsY0FBWTtJQUNuQztJQUVBLE1BQU9oQixJQUFJVCxNQUFNVyxNQUFNLENBQUU7UUFFckJOLE9BQU9SLFFBQVFnQyxPQUFPLENBQUM3QixNQUFNaUIsTUFBTSxDQUFDUjtRQUNwQ0gsT0FBT1QsUUFBUWdDLE9BQU8sQ0FBQzdCLE1BQU1pQixNQUFNLENBQUNSO1FBQ3BDRixPQUFPVixRQUFRZ0MsT0FBTyxDQUFDN0IsTUFBTWlCLE1BQU0sQ0FBQ1I7UUFDcENELE9BQU9YLFFBQVFnQyxPQUFPLENBQUM3QixNQUFNaUIsTUFBTSxDQUFDUjtRQUVwQ1AsT0FBTyxRQUFTLElBQU1JLFFBQVE7UUFDOUJILE9BQU8sQ0FBRUcsT0FBTyxFQUFDLEtBQU0sSUFBTUMsUUFBUTtRQUNyQ0gsT0FBTyxDQUFFRyxPQUFPLE1BQU0sSUFBS0M7UUFFM0JQLE1BQU0sQ0FBQ21CLGNBQWMsR0FBR2xCO1FBRXhCLElBQUlLLFNBQVMsSUFBSTtZQUNiTixNQUFNLENBQUNtQixjQUFjLEdBQUdqQjtRQUM1QjtRQUNBLElBQUlLLFNBQVMsSUFBSTtZQUNiUCxNQUFNLENBQUNtQixjQUFjLEdBQUdoQjtRQUM1QjtJQUVKO0lBRUEsT0FBT0g7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL3RzYS1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvYmFzZTY0LmpzP2Q2OTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBzdXBwb3J0ID0gcmVxdWlyZShcIi4vc3VwcG9ydFwiKTtcbi8vIHByaXZhdGUgcHJvcGVydHlcbnZhciBfa2V5U3RyID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiO1xuXG5cbi8vIHB1YmxpYyBtZXRob2QgZm9yIGVuY29kaW5nXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgdmFyIG91dHB1dCA9IFtdO1xuICAgIHZhciBjaHIxLCBjaHIyLCBjaHIzLCBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0O1xuICAgIHZhciBpID0gMCwgbGVuID0gaW5wdXQubGVuZ3RoLCByZW1haW5pbmdCeXRlcyA9IGxlbjtcblxuICAgIHZhciBpc0FycmF5ID0gdXRpbHMuZ2V0VHlwZU9mKGlucHV0KSAhPT0gXCJzdHJpbmdcIjtcbiAgICB3aGlsZSAoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICByZW1haW5pbmdCeXRlcyA9IGxlbiAtIGk7XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KSB7XG4gICAgICAgICAgICBjaHIxID0gaW5wdXQuY2hhckNvZGVBdChpKyspO1xuICAgICAgICAgICAgY2hyMiA9IGkgPCBsZW4gPyBpbnB1dC5jaGFyQ29kZUF0KGkrKykgOiAwO1xuICAgICAgICAgICAgY2hyMyA9IGkgPCBsZW4gPyBpbnB1dC5jaGFyQ29kZUF0KGkrKykgOiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hyMSA9IGlucHV0W2krK107XG4gICAgICAgICAgICBjaHIyID0gaSA8IGxlbiA/IGlucHV0W2krK10gOiAwO1xuICAgICAgICAgICAgY2hyMyA9IGkgPCBsZW4gPyBpbnB1dFtpKytdIDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGVuYzEgPSBjaHIxID4+IDI7XG4gICAgICAgIGVuYzIgPSAoKGNocjEgJiAzKSA8PCA0KSB8IChjaHIyID4+IDQpO1xuICAgICAgICBlbmMzID0gcmVtYWluaW5nQnl0ZXMgPiAxID8gKCgoY2hyMiAmIDE1KSA8PCAyKSB8IChjaHIzID4+IDYpKSA6IDY0O1xuICAgICAgICBlbmM0ID0gcmVtYWluaW5nQnl0ZXMgPiAyID8gKGNocjMgJiA2MykgOiA2NDtcblxuICAgICAgICBvdXRwdXQucHVzaChfa2V5U3RyLmNoYXJBdChlbmMxKSArIF9rZXlTdHIuY2hhckF0KGVuYzIpICsgX2tleVN0ci5jaGFyQXQoZW5jMykgKyBfa2V5U3RyLmNoYXJBdChlbmM0KSk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0LmpvaW4oXCJcIik7XG59O1xuXG4vLyBwdWJsaWMgbWV0aG9kIGZvciBkZWNvZGluZ1xuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIHZhciBjaHIxLCBjaHIyLCBjaHIzO1xuICAgIHZhciBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0O1xuICAgIHZhciBpID0gMCwgcmVzdWx0SW5kZXggPSAwO1xuXG4gICAgdmFyIGRhdGFVcmxQcmVmaXggPSBcImRhdGE6XCI7XG5cbiAgICBpZiAoaW5wdXQuc3Vic3RyKDAsIGRhdGFVcmxQcmVmaXgubGVuZ3RoKSA9PT0gZGF0YVVybFByZWZpeCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgY29tbW9uIGVycm9yOiBwZW9wbGUgZ2l2ZSBhIGRhdGEgdXJsXG4gICAgICAgIC8vIChkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1IuLi4pIHdpdGggYSB7YmFzZTY0OiB0cnVlfSBhbmRcbiAgICAgICAgLy8gd29uZGVycyB3aHkgdGhpbmdzIGRvbid0IHdvcmsuXG4gICAgICAgIC8vIFdlIGNhbiBkZXRlY3QgdGhhdCB0aGUgc3RyaW5nIGlucHV0IGxvb2tzIGxpa2UgYSBkYXRhIHVybCBidXQgd2VcbiAgICAgICAgLy8gKmNhbid0KiBiZSBzdXJlIGl0IGlzIG9uZTogcmVtb3ZpbmcgZXZlcnl0aGluZyB1cCB0byB0aGUgY29tbWEgd291bGRcbiAgICAgICAgLy8gYmUgdG9vIGRhbmdlcm91cy5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBiYXNlNjQgaW5wdXQsIGl0IGxvb2tzIGxpa2UgYSBkYXRhIHVybC5cIik7XG4gICAgfVxuXG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9bXkEtWmEtejAtOSsvPV0vZywgXCJcIik7XG5cbiAgICB2YXIgdG90YWxMZW5ndGggPSBpbnB1dC5sZW5ndGggKiAzIC8gNDtcbiAgICBpZihpbnB1dC5jaGFyQXQoaW5wdXQubGVuZ3RoIC0gMSkgPT09IF9rZXlTdHIuY2hhckF0KDY0KSkge1xuICAgICAgICB0b3RhbExlbmd0aC0tO1xuICAgIH1cbiAgICBpZihpbnB1dC5jaGFyQXQoaW5wdXQubGVuZ3RoIC0gMikgPT09IF9rZXlTdHIuY2hhckF0KDY0KSkge1xuICAgICAgICB0b3RhbExlbmd0aC0tO1xuICAgIH1cbiAgICBpZiAodG90YWxMZW5ndGggJSAxICE9PSAwKSB7XG4gICAgICAgIC8vIHRvdGFsTGVuZ3RoIGlzIG5vdCBhbiBpbnRlZ2VyLCB0aGUgbGVuZ3RoIGRvZXMgbm90IG1hdGNoIGEgdmFsaWRcbiAgICAgICAgLy8gYmFzZTY0IGNvbnRlbnQuIFRoYXQgY2FuIGhhcHBlbiBpZjpcbiAgICAgICAgLy8gLSB0aGUgaW5wdXQgaXMgbm90IGEgYmFzZTY0IGNvbnRlbnRcbiAgICAgICAgLy8gLSB0aGUgaW5wdXQgaXMgKmFsbW9zdCogYSBiYXNlNjQgY29udGVudCwgd2l0aCBhIGV4dHJhIGNoYXJzIGF0IHRoZVxuICAgICAgICAvLyAgIGJlZ2lubmluZyBvciBhdCB0aGUgZW5kXG4gICAgICAgIC8vIC0gdGhlIGlucHV0IHVzZXMgYSBiYXNlNjQgdmFyaWFudCAoYmFzZTY0dXJsIGZvciBleGFtcGxlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJhc2U2NCBpbnB1dCwgYmFkIGNvbnRlbnQgbGVuZ3RoLlwiKTtcbiAgICB9XG4gICAgdmFyIG91dHB1dDtcbiAgICBpZiAoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgIG91dHB1dCA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RofDApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dCA9IG5ldyBBcnJheSh0b3RhbExlbmd0aHwwKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoaSA8IGlucHV0Lmxlbmd0aCkge1xuXG4gICAgICAgIGVuYzEgPSBfa2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICAgICAgICBlbmMyID0gX2tleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgZW5jMyA9IF9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGVuYzQgPSBfa2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuXG4gICAgICAgIGNocjEgPSAoZW5jMSA8PCAyKSB8IChlbmMyID4+IDQpO1xuICAgICAgICBjaHIyID0gKChlbmMyICYgMTUpIDw8IDQpIHwgKGVuYzMgPj4gMik7XG4gICAgICAgIGNocjMgPSAoKGVuYzMgJiAzKSA8PCA2KSB8IGVuYzQ7XG5cbiAgICAgICAgb3V0cHV0W3Jlc3VsdEluZGV4KytdID0gY2hyMTtcblxuICAgICAgICBpZiAoZW5jMyAhPT0gNjQpIHtcbiAgICAgICAgICAgIG91dHB1dFtyZXN1bHRJbmRleCsrXSA9IGNocjI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuYzQgIT09IDY0KSB7XG4gICAgICAgICAgICBvdXRwdXRbcmVzdWx0SW5kZXgrK10gPSBjaHIzO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcbiJdLCJuYW1lcyI6WyJ1dGlscyIsInJlcXVpcmUiLCJzdXBwb3J0IiwiX2tleVN0ciIsImV4cG9ydHMiLCJlbmNvZGUiLCJpbnB1dCIsIm91dHB1dCIsImNocjEiLCJjaHIyIiwiY2hyMyIsImVuYzEiLCJlbmMyIiwiZW5jMyIsImVuYzQiLCJpIiwibGVuIiwibGVuZ3RoIiwicmVtYWluaW5nQnl0ZXMiLCJpc0FycmF5IiwiZ2V0VHlwZU9mIiwiY2hhckNvZGVBdCIsInB1c2giLCJjaGFyQXQiLCJqb2luIiwiZGVjb2RlIiwicmVzdWx0SW5kZXgiLCJkYXRhVXJsUHJlZml4Iiwic3Vic3RyIiwiRXJyb3IiLCJyZXBsYWNlIiwidG90YWxMZW5ndGgiLCJ1aW50OGFycmF5IiwiVWludDhBcnJheSIsIkFycmF5IiwiaW5kZXhPZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/base64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/compressedObject.js":
/*!****************************************************!*\
  !*** ./node_modules/jszip/lib/compressedObject.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar external = __webpack_require__(/*! ./external */ \"(ssr)/./node_modules/jszip/lib/external.js\");\nvar DataWorker = __webpack_require__(/*! ./stream/DataWorker */ \"(ssr)/./node_modules/jszip/lib/stream/DataWorker.js\");\nvar Crc32Probe = __webpack_require__(/*! ./stream/Crc32Probe */ \"(ssr)/./node_modules/jszip/lib/stream/Crc32Probe.js\");\nvar DataLengthProbe = __webpack_require__(/*! ./stream/DataLengthProbe */ \"(ssr)/./node_modules/jszip/lib/stream/DataLengthProbe.js\");\n/**\n * Represent a compressed object, with everything needed to decompress it.\n * @constructor\n * @param {number} compressedSize the size of the data compressed.\n * @param {number} uncompressedSize the size of the data after decompression.\n * @param {number} crc32 the crc32 of the decompressed file.\n * @param {object} compression the type of compression, see lib/compressions.js.\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the compressed data.\n */ function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {\n    this.compressedSize = compressedSize;\n    this.uncompressedSize = uncompressedSize;\n    this.crc32 = crc32;\n    this.compression = compression;\n    this.compressedContent = data;\n}\nCompressedObject.prototype = {\n    /**\n     * Create a worker to get the uncompressed content.\n     * @return {GenericWorker} the worker.\n     */ getContentWorker: function() {\n        var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe(\"data_length\"));\n        var that = this;\n        worker.on(\"end\", function() {\n            if (this.streamInfo[\"data_length\"] !== that.uncompressedSize) {\n                throw new Error(\"Bug : uncompressed data size mismatch\");\n            }\n        });\n        return worker;\n    },\n    /**\n     * Create a worker to get the compressed content.\n     * @return {GenericWorker} the worker.\n     */ getCompressedWorker: function() {\n        return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo(\"compressedSize\", this.compressedSize).withStreamInfo(\"uncompressedSize\", this.uncompressedSize).withStreamInfo(\"crc32\", this.crc32).withStreamInfo(\"compression\", this.compression);\n    }\n};\n/**\n * Chain the given worker with other workers to compress the content with the\n * given compression.\n * @param {GenericWorker} uncompressedWorker the worker to pipe.\n * @param {Object} compression the compression object.\n * @param {Object} compressionOptions the options to use when compressing.\n * @return {GenericWorker} the new worker compressing the content.\n */ CompressedObject.createWorkerFrom = function(uncompressedWorker, compression, compressionOptions) {\n    return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe(\"uncompressedSize\")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe(\"compressedSize\")).withStreamInfo(\"compression\", compression);\n};\nmodule.exports = CompressedObject;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2NvbXByZXNzZWRPYmplY3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixJQUFJQSxXQUFXQyxtQkFBT0EsQ0FBQyw4REFBWTtBQUNuQyxJQUFJQyxhQUFhRCxtQkFBT0EsQ0FBQyxnRkFBcUI7QUFDOUMsSUFBSUUsYUFBYUYsbUJBQU9BLENBQUMsZ0ZBQXFCO0FBQzlDLElBQUlHLGtCQUFrQkgsbUJBQU9BLENBQUMsMEZBQTBCO0FBRXhEOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU0ksaUJBQWlCQyxjQUFjLEVBQUVDLGdCQUFnQixFQUFFQyxLQUFLLEVBQUVDLFdBQVcsRUFBRUMsSUFBSTtJQUNoRixJQUFJLENBQUNKLGNBQWMsR0FBR0E7SUFDdEIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBR0E7SUFDeEIsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO0lBQ2IsSUFBSSxDQUFDQyxXQUFXLEdBQUdBO0lBQ25CLElBQUksQ0FBQ0UsaUJBQWlCLEdBQUdEO0FBQzdCO0FBRUFMLGlCQUFpQk8sU0FBUyxHQUFHO0lBQ3pCOzs7S0FHQyxHQUNEQyxrQkFBa0I7UUFDZCxJQUFJQyxTQUFTLElBQUlaLFdBQVdGLFNBQVNlLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDLElBQUksQ0FBQ0wsaUJBQWlCLEdBQ3RFTSxJQUFJLENBQUMsSUFBSSxDQUFDUixXQUFXLENBQUNTLGdCQUFnQixJQUN0Q0QsSUFBSSxDQUFDLElBQUliLGdCQUFnQjtRQUU5QixJQUFJZSxPQUFPLElBQUk7UUFDZkwsT0FBT00sRUFBRSxDQUFDLE9BQU87WUFDYixJQUFJLElBQUksQ0FBQ0MsVUFBVSxDQUFDLGNBQWMsS0FBS0YsS0FBS1osZ0JBQWdCLEVBQUU7Z0JBQzFELE1BQU0sSUFBSWUsTUFBTTtZQUNwQjtRQUNKO1FBQ0EsT0FBT1I7SUFDWDtJQUNBOzs7S0FHQyxHQUNEUyxxQkFBcUI7UUFDakIsT0FBTyxJQUFJckIsV0FBV0YsU0FBU2UsT0FBTyxDQUFDQyxPQUFPLENBQUMsSUFBSSxDQUFDTCxpQkFBaUIsR0FDaEVhLGNBQWMsQ0FBQyxrQkFBa0IsSUFBSSxDQUFDbEIsY0FBYyxFQUNwRGtCLGNBQWMsQ0FBQyxvQkFBb0IsSUFBSSxDQUFDakIsZ0JBQWdCLEVBQ3hEaUIsY0FBYyxDQUFDLFNBQVMsSUFBSSxDQUFDaEIsS0FBSyxFQUNsQ2dCLGNBQWMsQ0FBQyxlQUFlLElBQUksQ0FBQ2YsV0FBVztJQUV2RDtBQUNKO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNESixpQkFBaUJvQixnQkFBZ0IsR0FBRyxTQUFVQyxrQkFBa0IsRUFBRWpCLFdBQVcsRUFBRWtCLGtCQUFrQjtJQUM3RixPQUFPRCxtQkFDRlQsSUFBSSxDQUFDLElBQUlkLGNBQ1RjLElBQUksQ0FBQyxJQUFJYixnQkFBZ0IscUJBQ3pCYSxJQUFJLENBQUNSLFlBQVltQixjQUFjLENBQUNELHFCQUNoQ1YsSUFBSSxDQUFDLElBQUliLGdCQUFnQixtQkFDekJvQixjQUFjLENBQUMsZUFBZWY7QUFDdkM7QUFFQW9CLE9BQU9DLE9BQU8sR0FBR3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHNhLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9jb21wcmVzc2VkT2JqZWN0LmpzPzk1MTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBleHRlcm5hbCA9IHJlcXVpcmUoXCIuL2V4dGVybmFsXCIpO1xudmFyIERhdGFXb3JrZXIgPSByZXF1aXJlKFwiLi9zdHJlYW0vRGF0YVdvcmtlclwiKTtcbnZhciBDcmMzMlByb2JlID0gcmVxdWlyZShcIi4vc3RyZWFtL0NyYzMyUHJvYmVcIik7XG52YXIgRGF0YUxlbmd0aFByb2JlID0gcmVxdWlyZShcIi4vc3RyZWFtL0RhdGFMZW5ndGhQcm9iZVwiKTtcblxuLyoqXG4gKiBSZXByZXNlbnQgYSBjb21wcmVzc2VkIG9iamVjdCwgd2l0aCBldmVyeXRoaW5nIG5lZWRlZCB0byBkZWNvbXByZXNzIGl0LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gY29tcHJlc3NlZFNpemUgdGhlIHNpemUgb2YgdGhlIGRhdGEgY29tcHJlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB1bmNvbXByZXNzZWRTaXplIHRoZSBzaXplIG9mIHRoZSBkYXRhIGFmdGVyIGRlY29tcHJlc3Npb24uXG4gKiBAcGFyYW0ge251bWJlcn0gY3JjMzIgdGhlIGNyYzMyIG9mIHRoZSBkZWNvbXByZXNzZWQgZmlsZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wcmVzc2lvbiB0aGUgdHlwZSBvZiBjb21wcmVzc2lvbiwgc2VlIGxpYi9jb21wcmVzc2lvbnMuanMuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gZGF0YSB0aGUgY29tcHJlc3NlZCBkYXRhLlxuICovXG5mdW5jdGlvbiBDb21wcmVzc2VkT2JqZWN0KGNvbXByZXNzZWRTaXplLCB1bmNvbXByZXNzZWRTaXplLCBjcmMzMiwgY29tcHJlc3Npb24sIGRhdGEpIHtcbiAgICB0aGlzLmNvbXByZXNzZWRTaXplID0gY29tcHJlc3NlZFNpemU7XG4gICAgdGhpcy51bmNvbXByZXNzZWRTaXplID0gdW5jb21wcmVzc2VkU2l6ZTtcbiAgICB0aGlzLmNyYzMyID0gY3JjMzI7XG4gICAgdGhpcy5jb21wcmVzc2lvbiA9IGNvbXByZXNzaW9uO1xuICAgIHRoaXMuY29tcHJlc3NlZENvbnRlbnQgPSBkYXRhO1xufVxuXG5Db21wcmVzc2VkT2JqZWN0LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB3b3JrZXIgdG8gZ2V0IHRoZSB1bmNvbXByZXNzZWQgY29udGVudC5cbiAgICAgKiBAcmV0dXJuIHtHZW5lcmljV29ya2VyfSB0aGUgd29ya2VyLlxuICAgICAqL1xuICAgIGdldENvbnRlbnRXb3JrZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdvcmtlciA9IG5ldyBEYXRhV29ya2VyKGV4dGVybmFsLlByb21pc2UucmVzb2x2ZSh0aGlzLmNvbXByZXNzZWRDb250ZW50KSlcbiAgICAgICAgICAgIC5waXBlKHRoaXMuY29tcHJlc3Npb24udW5jb21wcmVzc1dvcmtlcigpKVxuICAgICAgICAgICAgLnBpcGUobmV3IERhdGFMZW5ndGhQcm9iZShcImRhdGFfbGVuZ3RoXCIpKTtcblxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHdvcmtlci5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdHJlYW1JbmZvW1wiZGF0YV9sZW5ndGhcIl0gIT09IHRoYXQudW5jb21wcmVzc2VkU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZyA6IHVuY29tcHJlc3NlZCBkYXRhIHNpemUgbWlzbWF0Y2hcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gd29ya2VyO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgd29ya2VyIHRvIGdldCB0aGUgY29tcHJlc3NlZCBjb250ZW50LlxuICAgICAqIEByZXR1cm4ge0dlbmVyaWNXb3JrZXJ9IHRoZSB3b3JrZXIuXG4gICAgICovXG4gICAgZ2V0Q29tcHJlc3NlZFdvcmtlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGFXb3JrZXIoZXh0ZXJuYWwuUHJvbWlzZS5yZXNvbHZlKHRoaXMuY29tcHJlc3NlZENvbnRlbnQpKVxuICAgICAgICAgICAgLndpdGhTdHJlYW1JbmZvKFwiY29tcHJlc3NlZFNpemVcIiwgdGhpcy5jb21wcmVzc2VkU2l6ZSlcbiAgICAgICAgICAgIC53aXRoU3RyZWFtSW5mbyhcInVuY29tcHJlc3NlZFNpemVcIiwgdGhpcy51bmNvbXByZXNzZWRTaXplKVxuICAgICAgICAgICAgLndpdGhTdHJlYW1JbmZvKFwiY3JjMzJcIiwgdGhpcy5jcmMzMilcbiAgICAgICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImNvbXByZXNzaW9uXCIsIHRoaXMuY29tcHJlc3Npb24pXG4gICAgICAgIDtcbiAgICB9XG59O1xuXG4vKipcbiAqIENoYWluIHRoZSBnaXZlbiB3b3JrZXIgd2l0aCBvdGhlciB3b3JrZXJzIHRvIGNvbXByZXNzIHRoZSBjb250ZW50IHdpdGggdGhlXG4gKiBnaXZlbiBjb21wcmVzc2lvbi5cbiAqIEBwYXJhbSB7R2VuZXJpY1dvcmtlcn0gdW5jb21wcmVzc2VkV29ya2VyIHRoZSB3b3JrZXIgdG8gcGlwZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb21wcmVzc2lvbiB0aGUgY29tcHJlc3Npb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IGNvbXByZXNzaW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2Ugd2hlbiBjb21wcmVzc2luZy5cbiAqIEByZXR1cm4ge0dlbmVyaWNXb3JrZXJ9IHRoZSBuZXcgd29ya2VyIGNvbXByZXNzaW5nIHRoZSBjb250ZW50LlxuICovXG5Db21wcmVzc2VkT2JqZWN0LmNyZWF0ZVdvcmtlckZyb20gPSBmdW5jdGlvbiAodW5jb21wcmVzc2VkV29ya2VyLCBjb21wcmVzc2lvbiwgY29tcHJlc3Npb25PcHRpb25zKSB7XG4gICAgcmV0dXJuIHVuY29tcHJlc3NlZFdvcmtlclxuICAgICAgICAucGlwZShuZXcgQ3JjMzJQcm9iZSgpKVxuICAgICAgICAucGlwZShuZXcgRGF0YUxlbmd0aFByb2JlKFwidW5jb21wcmVzc2VkU2l6ZVwiKSlcbiAgICAgICAgLnBpcGUoY29tcHJlc3Npb24uY29tcHJlc3NXb3JrZXIoY29tcHJlc3Npb25PcHRpb25zKSlcbiAgICAgICAgLnBpcGUobmV3IERhdGFMZW5ndGhQcm9iZShcImNvbXByZXNzZWRTaXplXCIpKVxuICAgICAgICAud2l0aFN0cmVhbUluZm8oXCJjb21wcmVzc2lvblwiLCBjb21wcmVzc2lvbik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXByZXNzZWRPYmplY3Q7XG4iXSwibmFtZXMiOlsiZXh0ZXJuYWwiLCJyZXF1aXJlIiwiRGF0YVdvcmtlciIsIkNyYzMyUHJvYmUiLCJEYXRhTGVuZ3RoUHJvYmUiLCJDb21wcmVzc2VkT2JqZWN0IiwiY29tcHJlc3NlZFNpemUiLCJ1bmNvbXByZXNzZWRTaXplIiwiY3JjMzIiLCJjb21wcmVzc2lvbiIsImRhdGEiLCJjb21wcmVzc2VkQ29udGVudCIsInByb3RvdHlwZSIsImdldENvbnRlbnRXb3JrZXIiLCJ3b3JrZXIiLCJQcm9taXNlIiwicmVzb2x2ZSIsInBpcGUiLCJ1bmNvbXByZXNzV29ya2VyIiwidGhhdCIsIm9uIiwic3RyZWFtSW5mbyIsIkVycm9yIiwiZ2V0Q29tcHJlc3NlZFdvcmtlciIsIndpdGhTdHJlYW1JbmZvIiwiY3JlYXRlV29ya2VyRnJvbSIsInVuY29tcHJlc3NlZFdvcmtlciIsImNvbXByZXNzaW9uT3B0aW9ucyIsImNvbXByZXNzV29ya2VyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/compressedObject.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/compressions.js":
/*!************************************************!*\
  !*** ./node_modules/jszip/lib/compressions.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ \"(ssr)/./node_modules/jszip/lib/stream/GenericWorker.js\");\nexports.STORE = {\n    magic: \"\\x00\\x00\",\n    compressWorker: function() {\n        return new GenericWorker(\"STORE compression\");\n    },\n    uncompressWorker: function() {\n        return new GenericWorker(\"STORE decompression\");\n    }\n};\nexports.DEFLATE = __webpack_require__(/*! ./flate */ \"(ssr)/./node_modules/jszip/lib/flate.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2NvbXByZXNzaW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLElBQUlBLGdCQUFnQkMsbUJBQU9BLENBQUMsc0ZBQXdCO0FBRXBEQyxhQUFhLEdBQUc7SUFDWkUsT0FBTztJQUNQQyxnQkFBaUI7UUFDYixPQUFPLElBQUlMLGNBQWM7SUFDN0I7SUFDQU0sa0JBQW1CO1FBQ2YsT0FBTyxJQUFJTixjQUFjO0lBQzdCO0FBQ0o7QUFDQUUsK0ZBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHNhLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9jb21wcmVzc2lvbnMuanM/ZjU3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKFwiLi9zdHJlYW0vR2VuZXJpY1dvcmtlclwiKTtcblxuZXhwb3J0cy5TVE9SRSA9IHtcbiAgICBtYWdpYzogXCJcXHgwMFxceDAwXCIsXG4gICAgY29tcHJlc3NXb3JrZXIgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgR2VuZXJpY1dvcmtlcihcIlNUT1JFIGNvbXByZXNzaW9uXCIpO1xuICAgIH0sXG4gICAgdW5jb21wcmVzc1dvcmtlciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljV29ya2VyKFwiU1RPUkUgZGVjb21wcmVzc2lvblwiKTtcbiAgICB9XG59O1xuZXhwb3J0cy5ERUZMQVRFID0gcmVxdWlyZShcIi4vZmxhdGVcIik7XG4iXSwibmFtZXMiOlsiR2VuZXJpY1dvcmtlciIsInJlcXVpcmUiLCJleHBvcnRzIiwiU1RPUkUiLCJtYWdpYyIsImNvbXByZXNzV29ya2VyIiwidW5jb21wcmVzc1dvcmtlciIsIkRFRkxBVEUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/compressions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/crc32.js":
/*!*****************************************!*\
  !*** ./node_modules/jszip/lib/crc32.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\n/**\n * The following functions come from pako, from pako/lib/zlib/crc32.js\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */ // Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n    var c, table = [];\n    for(var n = 0; n < 256; n++){\n        c = n;\n        for(var k = 0; k < 8; k++){\n            c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;\n        }\n        table[n] = c;\n    }\n    return table;\n}\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\nfunction crc32(crc, buf, len, pos) {\n    var t = crcTable, end = pos + len;\n    crc = crc ^ -1;\n    for(var i = pos; i < end; i++){\n        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];\n    }\n    return crc ^ -1; // >>> 0;\n}\n// That's all for the pako functions.\n/**\n * Compute the crc32 of a string.\n * This is almost the same as the function crc32, but for strings. Using the\n * same function for the two use cases leads to horrible performances.\n * @param {Number} crc the starting value of the crc.\n * @param {String} str the string to use.\n * @param {Number} len the length of the string.\n * @param {Number} pos the starting position for the crc32 computation.\n * @return {Number} the computed crc32.\n */ function crc32str(crc, str, len, pos) {\n    var t = crcTable, end = pos + len;\n    crc = crc ^ -1;\n    for(var i = pos; i < end; i++){\n        crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 0xFF];\n    }\n    return crc ^ -1; // >>> 0;\n}\nmodule.exports = function crc32wrapper(input, crc) {\n    if (typeof input === \"undefined\" || !input.length) {\n        return 0;\n    }\n    var isArray = utils.getTypeOf(input) !== \"string\";\n    if (isArray) {\n        return crc32(crc | 0, input, input.length, 0);\n    } else {\n        return crc32str(crc | 0, input, input.length, 0);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2NyYzMyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUMsd0RBQVM7QUFFN0I7OztDQUdDLEdBRUQsd0RBQXdEO0FBQ3hELFNBQVNDO0lBQ0wsSUFBSUMsR0FBR0MsUUFBUSxFQUFFO0lBRWpCLElBQUksSUFBSUMsSUFBRyxHQUFHQSxJQUFJLEtBQUtBLElBQUk7UUFDdkJGLElBQUlFO1FBQ0osSUFBSSxJQUFJQyxJQUFHLEdBQUdBLElBQUksR0FBR0EsSUFBSTtZQUNyQkgsSUFBSyxJQUFHLElBQU0sYUFBY0EsTUFBTSxJQUFPQSxNQUFNO1FBQ25EO1FBQ0FDLEtBQUssQ0FBQ0MsRUFBRSxHQUFHRjtJQUNmO0lBRUEsT0FBT0M7QUFDWDtBQUVBLDhEQUE4RDtBQUM5RCxJQUFJRyxXQUFXTDtBQUdmLFNBQVNNLE1BQU1DLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUc7SUFDN0IsSUFBSUMsSUFBSU4sVUFBVU8sTUFBTUYsTUFBTUQ7SUFFOUJGLE1BQU1BLE1BQU8sQ0FBQztJQUVkLElBQUssSUFBSU0sSUFBSUgsS0FBS0csSUFBSUQsS0FBS0MsSUFBTTtRQUM3Qk4sTUFBTSxRQUFTLElBQUtJLENBQUMsQ0FBQyxDQUFDSixNQUFNQyxHQUFHLENBQUNLLEVBQUUsSUFBSSxLQUFLO0lBQ2hEO0lBRUEsT0FBUU4sTUFBTyxDQUFDLEdBQUssU0FBUztBQUNsQztBQUVBLHFDQUFxQztBQUVyQzs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTTyxTQUFTUCxHQUFHLEVBQUVRLEdBQUcsRUFBRU4sR0FBRyxFQUFFQyxHQUFHO0lBQ2hDLElBQUlDLElBQUlOLFVBQVVPLE1BQU1GLE1BQU1EO0lBRTlCRixNQUFNQSxNQUFPLENBQUM7SUFFZCxJQUFLLElBQUlNLElBQUlILEtBQUtHLElBQUlELEtBQUtDLElBQU07UUFDN0JOLE1BQU0sUUFBUyxJQUFLSSxDQUFDLENBQUMsQ0FBQ0osTUFBTVEsSUFBSUMsVUFBVSxDQUFDSCxFQUFDLElBQUssS0FBSztJQUMzRDtJQUVBLE9BQVFOLE1BQU8sQ0FBQyxHQUFLLFNBQVM7QUFDbEM7QUFFQVUsT0FBT0MsT0FBTyxHQUFHLFNBQVNDLGFBQWFDLEtBQUssRUFBRWIsR0FBRztJQUM3QyxJQUFJLE9BQU9hLFVBQVUsZUFBZSxDQUFDQSxNQUFNQyxNQUFNLEVBQUU7UUFDL0MsT0FBTztJQUNYO0lBRUEsSUFBSUMsVUFBVXhCLE1BQU15QixTQUFTLENBQUNILFdBQVc7SUFFekMsSUFBR0UsU0FBUztRQUNSLE9BQU9oQixNQUFNQyxNQUFJLEdBQUdhLE9BQU9BLE1BQU1DLE1BQU0sRUFBRTtJQUM3QyxPQUFPO1FBQ0gsT0FBT1AsU0FBU1AsTUFBSSxHQUFHYSxPQUFPQSxNQUFNQyxNQUFNLEVBQUU7SUFDaEQ7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL3RzYS1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvY3JjMzIuanM/OGY4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5cbi8qKlxuICogVGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgY29tZSBmcm9tIHBha28sIGZyb20gcGFrby9saWIvemxpYi9jcmMzMi5qc1xuICogcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLCBzZWUgcGFrbyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL3Bha28vXG4gKi9cblxuLy8gVXNlIG9yZGluYXJ5IGFycmF5LCBzaW5jZSB1bnR5cGVkIG1ha2VzIG5vIGJvb3N0IGhlcmVcbmZ1bmN0aW9uIG1ha2VUYWJsZSgpIHtcbiAgICB2YXIgYywgdGFibGUgPSBbXTtcblxuICAgIGZvcih2YXIgbiA9MDsgbiA8IDI1NjsgbisrKXtcbiAgICAgICAgYyA9IG47XG4gICAgICAgIGZvcih2YXIgayA9MDsgayA8IDg7IGsrKyl7XG4gICAgICAgICAgICBjID0gKChjJjEpID8gKDB4RURCODgzMjAgXiAoYyA+Pj4gMSkpIDogKGMgPj4+IDEpKTtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZVtuXSA9IGM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhYmxlO1xufVxuXG4vLyBDcmVhdGUgdGFibGUgb24gbG9hZC4gSnVzdCAyNTUgc2lnbmVkIGxvbmdzLiBOb3QgYSBwcm9ibGVtLlxudmFyIGNyY1RhYmxlID0gbWFrZVRhYmxlKCk7XG5cblxuZnVuY3Rpb24gY3JjMzIoY3JjLCBidWYsIGxlbiwgcG9zKSB7XG4gICAgdmFyIHQgPSBjcmNUYWJsZSwgZW5kID0gcG9zICsgbGVuO1xuXG4gICAgY3JjID0gY3JjIF4gKC0xKTtcblxuICAgIGZvciAodmFyIGkgPSBwb3M7IGkgPCBlbmQ7IGkrKyApIHtcbiAgICAgICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0WyhjcmMgXiBidWZbaV0pICYgMHhGRl07XG4gICAgfVxuXG4gICAgcmV0dXJuIChjcmMgXiAoLTEpKTsgLy8gPj4+IDA7XG59XG5cbi8vIFRoYXQncyBhbGwgZm9yIHRoZSBwYWtvIGZ1bmN0aW9ucy5cblxuLyoqXG4gKiBDb21wdXRlIHRoZSBjcmMzMiBvZiBhIHN0cmluZy5cbiAqIFRoaXMgaXMgYWxtb3N0IHRoZSBzYW1lIGFzIHRoZSBmdW5jdGlvbiBjcmMzMiwgYnV0IGZvciBzdHJpbmdzLiBVc2luZyB0aGVcbiAqIHNhbWUgZnVuY3Rpb24gZm9yIHRoZSB0d28gdXNlIGNhc2VzIGxlYWRzIHRvIGhvcnJpYmxlIHBlcmZvcm1hbmNlcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBjcmMgdGhlIHN0YXJ0aW5nIHZhbHVlIG9mIHRoZSBjcmMuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gdXNlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbiB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcuXG4gKiBAcGFyYW0ge051bWJlcn0gcG9zIHRoZSBzdGFydGluZyBwb3NpdGlvbiBmb3IgdGhlIGNyYzMyIGNvbXB1dGF0aW9uLlxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgY29tcHV0ZWQgY3JjMzIuXG4gKi9cbmZ1bmN0aW9uIGNyYzMyc3RyKGNyYywgc3RyLCBsZW4sIHBvcykge1xuICAgIHZhciB0ID0gY3JjVGFibGUsIGVuZCA9IHBvcyArIGxlbjtcblxuICAgIGNyYyA9IGNyYyBeICgtMSk7XG5cbiAgICBmb3IgKHZhciBpID0gcG9zOyBpIDwgZW5kOyBpKysgKSB7XG4gICAgICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdFsoY3JjIF4gc3RyLmNoYXJDb2RlQXQoaSkpICYgMHhGRl07XG4gICAgfVxuXG4gICAgcmV0dXJuIChjcmMgXiAoLTEpKTsgLy8gPj4+IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JjMzJ3cmFwcGVyKGlucHV0LCBjcmMpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIGlzQXJyYXkgPSB1dGlscy5nZXRUeXBlT2YoaW5wdXQpICE9PSBcInN0cmluZ1wiO1xuXG4gICAgaWYoaXNBcnJheSkge1xuICAgICAgICByZXR1cm4gY3JjMzIoY3JjfDAsIGlucHV0LCBpbnB1dC5sZW5ndGgsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjcmMzMnN0cihjcmN8MCwgaW5wdXQsIGlucHV0Lmxlbmd0aCwgMCk7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6WyJ1dGlscyIsInJlcXVpcmUiLCJtYWtlVGFibGUiLCJjIiwidGFibGUiLCJuIiwiayIsImNyY1RhYmxlIiwiY3JjMzIiLCJjcmMiLCJidWYiLCJsZW4iLCJwb3MiLCJ0IiwiZW5kIiwiaSIsImNyYzMyc3RyIiwic3RyIiwiY2hhckNvZGVBdCIsIm1vZHVsZSIsImV4cG9ydHMiLCJjcmMzMndyYXBwZXIiLCJpbnB1dCIsImxlbmd0aCIsImlzQXJyYXkiLCJnZXRUeXBlT2YiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/crc32.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/jszip/lib/defaults.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nexports.base64 = false;\nexports.binary = false;\nexports.dir = false;\nexports.createFolders = true;\nexports.date = null;\nexports.compression = null;\nexports.compressionOptions = null;\nexports.comment = null;\nexports.unixPermissions = null;\nexports.dosPermissions = null;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2RlZmF1bHRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLGNBQWMsR0FBRztBQUNqQkEsY0FBYyxHQUFHO0FBQ2pCQSxXQUFXLEdBQUc7QUFDZEEscUJBQXFCLEdBQUc7QUFDeEJBLFlBQVksR0FBRztBQUNmQSxtQkFBbUIsR0FBRztBQUN0QkEsMEJBQTBCLEdBQUc7QUFDN0JBLGVBQWUsR0FBRztBQUNsQkEsdUJBQXVCLEdBQUc7QUFDMUJBLHNCQUFzQixHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHNhLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9kZWZhdWx0cy5qcz81NDFlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5iYXNlNjQgPSBmYWxzZTtcbmV4cG9ydHMuYmluYXJ5ID0gZmFsc2U7XG5leHBvcnRzLmRpciA9IGZhbHNlO1xuZXhwb3J0cy5jcmVhdGVGb2xkZXJzID0gdHJ1ZTtcbmV4cG9ydHMuZGF0ZSA9IG51bGw7XG5leHBvcnRzLmNvbXByZXNzaW9uID0gbnVsbDtcbmV4cG9ydHMuY29tcHJlc3Npb25PcHRpb25zID0gbnVsbDtcbmV4cG9ydHMuY29tbWVudCA9IG51bGw7XG5leHBvcnRzLnVuaXhQZXJtaXNzaW9ucyA9IG51bGw7XG5leHBvcnRzLmRvc1Blcm1pc3Npb25zID0gbnVsbDtcbiJdLCJuYW1lcyI6WyJleHBvcnRzIiwiYmFzZTY0IiwiYmluYXJ5IiwiZGlyIiwiY3JlYXRlRm9sZGVycyIsImRhdGUiLCJjb21wcmVzc2lvbiIsImNvbXByZXNzaW9uT3B0aW9ucyIsImNvbW1lbnQiLCJ1bml4UGVybWlzc2lvbnMiLCJkb3NQZXJtaXNzaW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/defaults.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/external.js":
/*!********************************************!*\
  !*** ./node_modules/jszip/lib/external.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n// load the global object first:\n// - it should be better integrated in the system (unhandledRejection in node)\n// - the environment may have a custom Promise implementation (see zone.js)\nvar ES6Promise = null;\nif (typeof Promise !== \"undefined\") {\n    ES6Promise = Promise;\n} else {\n    ES6Promise = __webpack_require__(/*! lie */ \"(ssr)/./node_modules/lie/lib/index.js\");\n}\n/**\n * Let the user use/change some implementations.\n */ module.exports = {\n    Promise: ES6Promise\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2V4dGVybmFsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsZ0NBQWdDO0FBQ2hDLDhFQUE4RTtBQUM5RSwyRUFBMkU7QUFDM0UsSUFBSUEsYUFBYTtBQUNqQixJQUFJLE9BQU9DLFlBQVksYUFBYTtJQUNoQ0QsYUFBYUM7QUFDakIsT0FBTztJQUNIRCxhQUFhRSxtQkFBT0EsQ0FBQyxrREFBSztBQUM5QjtBQUVBOztDQUVDLEdBQ0RDLE9BQU9DLE9BQU8sR0FBRztJQUNiSCxTQUFTRDtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHNhLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9leHRlcm5hbC5qcz81MGQzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vLyBsb2FkIHRoZSBnbG9iYWwgb2JqZWN0IGZpcnN0OlxuLy8gLSBpdCBzaG91bGQgYmUgYmV0dGVyIGludGVncmF0ZWQgaW4gdGhlIHN5c3RlbSAodW5oYW5kbGVkUmVqZWN0aW9uIGluIG5vZGUpXG4vLyAtIHRoZSBlbnZpcm9ubWVudCBtYXkgaGF2ZSBhIGN1c3RvbSBQcm9taXNlIGltcGxlbWVudGF0aW9uIChzZWUgem9uZS5qcylcbnZhciBFUzZQcm9taXNlID0gbnVsbDtcbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIEVTNlByb21pc2UgPSBQcm9taXNlO1xufSBlbHNlIHtcbiAgICBFUzZQcm9taXNlID0gcmVxdWlyZShcImxpZVwiKTtcbn1cblxuLyoqXG4gKiBMZXQgdGhlIHVzZXIgdXNlL2NoYW5nZSBzb21lIGltcGxlbWVudGF0aW9ucy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgUHJvbWlzZTogRVM2UHJvbWlzZVxufTtcbiJdLCJuYW1lcyI6WyJFUzZQcm9taXNlIiwiUHJvbWlzZSIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/external.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/flate.js":
/*!*****************************************!*\
  !*** ./node_modules/jszip/lib/flate.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar USE_TYPEDARRAY = typeof Uint8Array !== \"undefined\" && typeof Uint16Array !== \"undefined\" && typeof Uint32Array !== \"undefined\";\nvar pako = __webpack_require__(/*! pako */ \"(ssr)/./node_modules/pako/index.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nvar GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ \"(ssr)/./node_modules/jszip/lib/stream/GenericWorker.js\");\nvar ARRAY_TYPE = USE_TYPEDARRAY ? \"uint8array\" : \"array\";\nexports.magic = \"\\b\\x00\";\n/**\n * Create a worker that uses pako to inflate/deflate.\n * @constructor\n * @param {String} action the name of the pako function to call : either \"Deflate\" or \"Inflate\".\n * @param {Object} options the options to use when (de)compressing.\n */ function FlateWorker(action, options) {\n    GenericWorker.call(this, \"FlateWorker/\" + action);\n    this._pako = null;\n    this._pakoAction = action;\n    this._pakoOptions = options;\n    // the `meta` object from the last chunk received\n    // this allow this worker to pass around metadata\n    this.meta = {};\n}\nutils.inherits(FlateWorker, GenericWorker);\n/**\n * @see GenericWorker.processChunk\n */ FlateWorker.prototype.processChunk = function(chunk) {\n    this.meta = chunk.meta;\n    if (this._pako === null) {\n        this._createPako();\n    }\n    this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);\n};\n/**\n * @see GenericWorker.flush\n */ FlateWorker.prototype.flush = function() {\n    GenericWorker.prototype.flush.call(this);\n    if (this._pako === null) {\n        this._createPako();\n    }\n    this._pako.push([], true);\n};\n/**\n * @see GenericWorker.cleanUp\n */ FlateWorker.prototype.cleanUp = function() {\n    GenericWorker.prototype.cleanUp.call(this);\n    this._pako = null;\n};\n/**\n * Create the _pako object.\n * TODO: lazy-loading this object isn't the best solution but it's the\n * quickest. The best solution is to lazy-load the worker list. See also the\n * issue #446.\n */ FlateWorker.prototype._createPako = function() {\n    this._pako = new pako[this._pakoAction]({\n        raw: true,\n        level: this._pakoOptions.level || -1 // default compression\n    });\n    var self = this;\n    this._pako.onData = function(data) {\n        self.push({\n            data: data,\n            meta: self.meta\n        });\n    };\n};\nexports.compressWorker = function(compressionOptions) {\n    return new FlateWorker(\"Deflate\", compressionOptions);\n};\nexports.uncompressWorker = function() {\n    return new FlateWorker(\"Inflate\", {});\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2ZsYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsaUJBQWlCLE9BQVFDLGVBQWUsZUFBaUIsT0FBT0MsZ0JBQWdCLGVBQWlCLE9BQU9DLGdCQUFnQjtBQUU1SCxJQUFJQyxPQUFPQyxtQkFBT0EsQ0FBQyxnREFBTTtBQUN6QixJQUFJQyxRQUFRRCxtQkFBT0EsQ0FBQyx3REFBUztBQUM3QixJQUFJRSxnQkFBZ0JGLG1CQUFPQSxDQUFDLHNGQUF3QjtBQUVwRCxJQUFJRyxhQUFhUixpQkFBaUIsZUFBZTtBQUVqRFMsYUFBYSxHQUFHO0FBRWhCOzs7OztDQUtDLEdBQ0QsU0FBU0UsWUFBWUMsTUFBTSxFQUFFQyxPQUFPO0lBQ2hDTixjQUFjTyxJQUFJLENBQUMsSUFBSSxFQUFFLGlCQUFpQkY7SUFFMUMsSUFBSSxDQUFDRyxLQUFLLEdBQUc7SUFDYixJQUFJLENBQUNDLFdBQVcsR0FBR0o7SUFDbkIsSUFBSSxDQUFDSyxZQUFZLEdBQUdKO0lBQ3BCLGlEQUFpRDtJQUNqRCxpREFBaUQ7SUFDakQsSUFBSSxDQUFDSyxJQUFJLEdBQUcsQ0FBQztBQUNqQjtBQUVBWixNQUFNYSxRQUFRLENBQUNSLGFBQWFKO0FBRTVCOztDQUVDLEdBQ0RJLFlBQVlTLFNBQVMsQ0FBQ0MsWUFBWSxHQUFHLFNBQVVDLEtBQUs7SUFDaEQsSUFBSSxDQUFDSixJQUFJLEdBQUdJLE1BQU1KLElBQUk7SUFDdEIsSUFBSSxJQUFJLENBQUNILEtBQUssS0FBSyxNQUFNO1FBQ3JCLElBQUksQ0FBQ1EsV0FBVztJQUNwQjtJQUNBLElBQUksQ0FBQ1IsS0FBSyxDQUFDUyxJQUFJLENBQUNsQixNQUFNbUIsV0FBVyxDQUFDakIsWUFBWWMsTUFBTUksSUFBSSxHQUFHO0FBQy9EO0FBRUE7O0NBRUMsR0FDRGYsWUFBWVMsU0FBUyxDQUFDTyxLQUFLLEdBQUc7SUFDMUJwQixjQUFjYSxTQUFTLENBQUNPLEtBQUssQ0FBQ2IsSUFBSSxDQUFDLElBQUk7SUFDdkMsSUFBSSxJQUFJLENBQUNDLEtBQUssS0FBSyxNQUFNO1FBQ3JCLElBQUksQ0FBQ1EsV0FBVztJQUNwQjtJQUNBLElBQUksQ0FBQ1IsS0FBSyxDQUFDUyxJQUFJLENBQUMsRUFBRSxFQUFFO0FBQ3hCO0FBQ0E7O0NBRUMsR0FDRGIsWUFBWVMsU0FBUyxDQUFDUSxPQUFPLEdBQUc7SUFDNUJyQixjQUFjYSxTQUFTLENBQUNRLE9BQU8sQ0FBQ2QsSUFBSSxDQUFDLElBQUk7SUFDekMsSUFBSSxDQUFDQyxLQUFLLEdBQUc7QUFDakI7QUFFQTs7Ozs7Q0FLQyxHQUNESixZQUFZUyxTQUFTLENBQUNHLFdBQVcsR0FBRztJQUNoQyxJQUFJLENBQUNSLEtBQUssR0FBRyxJQUFJWCxJQUFJLENBQUMsSUFBSSxDQUFDWSxXQUFXLENBQUMsQ0FBQztRQUNwQ2EsS0FBSztRQUNMQyxPQUFPLElBQUksQ0FBQ2IsWUFBWSxDQUFDYSxLQUFLLElBQUksQ0FBQyxFQUFFLHNCQUFzQjtJQUMvRDtJQUNBLElBQUlDLE9BQU8sSUFBSTtJQUNmLElBQUksQ0FBQ2hCLEtBQUssQ0FBQ2lCLE1BQU0sR0FBRyxTQUFTTixJQUFJO1FBQzdCSyxLQUFLUCxJQUFJLENBQUM7WUFDTkUsTUFBT0E7WUFDUFIsTUFBT2EsS0FBS2IsSUFBSTtRQUNwQjtJQUNKO0FBQ0o7QUFFQVQsc0JBQXNCLEdBQUcsU0FBVXlCLGtCQUFrQjtJQUNqRCxPQUFPLElBQUl2QixZQUFZLFdBQVd1QjtBQUN0QztBQUNBekIsd0JBQXdCLEdBQUc7SUFDdkIsT0FBTyxJQUFJRSxZQUFZLFdBQVcsQ0FBQztBQUN2QyIsInNvdXJjZXMiOlsid2VicGFjazovL3RzYS1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvZmxhdGUuanM/Y2RjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBVU0VfVFlQRURBUlJBWSA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIikgJiYgKHR5cGVvZiBVaW50MTZBcnJheSAhPT0gXCJ1bmRlZmluZWRcIikgJiYgKHR5cGVvZiBVaW50MzJBcnJheSAhPT0gXCJ1bmRlZmluZWRcIik7XG5cbnZhciBwYWtvID0gcmVxdWlyZShcInBha29cIik7XG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZShcIi4vc3RyZWFtL0dlbmVyaWNXb3JrZXJcIik7XG5cbnZhciBBUlJBWV9UWVBFID0gVVNFX1RZUEVEQVJSQVkgPyBcInVpbnQ4YXJyYXlcIiA6IFwiYXJyYXlcIjtcblxuZXhwb3J0cy5tYWdpYyA9IFwiXFx4MDhcXHgwMFwiO1xuXG4vKipcbiAqIENyZWF0ZSBhIHdvcmtlciB0aGF0IHVzZXMgcGFrbyB0byBpbmZsYXRlL2RlZmxhdGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb24gdGhlIG5hbWUgb2YgdGhlIHBha28gZnVuY3Rpb24gdG8gY2FsbCA6IGVpdGhlciBcIkRlZmxhdGVcIiBvciBcIkluZmxhdGVcIi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZSB3aGVuIChkZSljb21wcmVzc2luZy5cbiAqL1xuZnVuY3Rpb24gRmxhdGVXb3JrZXIoYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiRmxhdGVXb3JrZXIvXCIgKyBhY3Rpb24pO1xuXG4gICAgdGhpcy5fcGFrbyA9IG51bGw7XG4gICAgdGhpcy5fcGFrb0FjdGlvbiA9IGFjdGlvbjtcbiAgICB0aGlzLl9wYWtvT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgLy8gdGhlIGBtZXRhYCBvYmplY3QgZnJvbSB0aGUgbGFzdCBjaHVuayByZWNlaXZlZFxuICAgIC8vIHRoaXMgYWxsb3cgdGhpcyB3b3JrZXIgdG8gcGFzcyBhcm91bmQgbWV0YWRhdGFcbiAgICB0aGlzLm1ldGEgPSB7fTtcbn1cblxudXRpbHMuaW5oZXJpdHMoRmxhdGVXb3JrZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuRmxhdGVXb3JrZXIucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHRoaXMubWV0YSA9IGNodW5rLm1ldGE7XG4gICAgaWYgKHRoaXMuX3Bha28gPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlUGFrbygpO1xuICAgIH1cbiAgICB0aGlzLl9wYWtvLnB1c2godXRpbHMudHJhbnNmb3JtVG8oQVJSQVlfVFlQRSwgY2h1bmsuZGF0YSksIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmZsdXNoXG4gKi9cbkZsYXRlV29ya2VyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5mbHVzaC5jYWxsKHRoaXMpO1xuICAgIGlmICh0aGlzLl9wYWtvID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVBha28oKTtcbiAgICB9XG4gICAgdGhpcy5fcGFrby5wdXNoKFtdLCB0cnVlKTtcbn07XG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5jbGVhblVwXG4gKi9cbkZsYXRlV29ya2VyLnByb3RvdHlwZS5jbGVhblVwID0gZnVuY3Rpb24gKCkge1xuICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLmNsZWFuVXAuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9wYWtvID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBfcGFrbyBvYmplY3QuXG4gKiBUT0RPOiBsYXp5LWxvYWRpbmcgdGhpcyBvYmplY3QgaXNuJ3QgdGhlIGJlc3Qgc29sdXRpb24gYnV0IGl0J3MgdGhlXG4gKiBxdWlja2VzdC4gVGhlIGJlc3Qgc29sdXRpb24gaXMgdG8gbGF6eS1sb2FkIHRoZSB3b3JrZXIgbGlzdC4gU2VlIGFsc28gdGhlXG4gKiBpc3N1ZSAjNDQ2LlxuICovXG5GbGF0ZVdvcmtlci5wcm90b3R5cGUuX2NyZWF0ZVBha28gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcGFrbyA9IG5ldyBwYWtvW3RoaXMuX3Bha29BY3Rpb25dKHtcbiAgICAgICAgcmF3OiB0cnVlLFxuICAgICAgICBsZXZlbDogdGhpcy5fcGFrb09wdGlvbnMubGV2ZWwgfHwgLTEgLy8gZGVmYXVsdCBjb21wcmVzc2lvblxuICAgIH0pO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl9wYWtvLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgc2VsZi5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiBkYXRhLFxuICAgICAgICAgICAgbWV0YSA6IHNlbGYubWV0YVxuICAgICAgICB9KTtcbiAgICB9O1xufTtcblxuZXhwb3J0cy5jb21wcmVzc1dvcmtlciA9IGZ1bmN0aW9uIChjb21wcmVzc2lvbk9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEZsYXRlV29ya2VyKFwiRGVmbGF0ZVwiLCBjb21wcmVzc2lvbk9wdGlvbnMpO1xufTtcbmV4cG9ydHMudW5jb21wcmVzc1dvcmtlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IEZsYXRlV29ya2VyKFwiSW5mbGF0ZVwiLCB7fSk7XG59O1xuIl0sIm5hbWVzIjpbIlVTRV9UWVBFREFSUkFZIiwiVWludDhBcnJheSIsIlVpbnQxNkFycmF5IiwiVWludDMyQXJyYXkiLCJwYWtvIiwicmVxdWlyZSIsInV0aWxzIiwiR2VuZXJpY1dvcmtlciIsIkFSUkFZX1RZUEUiLCJleHBvcnRzIiwibWFnaWMiLCJGbGF0ZVdvcmtlciIsImFjdGlvbiIsIm9wdGlvbnMiLCJjYWxsIiwiX3Bha28iLCJfcGFrb0FjdGlvbiIsIl9wYWtvT3B0aW9ucyIsIm1ldGEiLCJpbmhlcml0cyIsInByb3RvdHlwZSIsInByb2Nlc3NDaHVuayIsImNodW5rIiwiX2NyZWF0ZVBha28iLCJwdXNoIiwidHJhbnNmb3JtVG8iLCJkYXRhIiwiZmx1c2giLCJjbGVhblVwIiwicmF3IiwibGV2ZWwiLCJzZWxmIiwib25EYXRhIiwiY29tcHJlc3NXb3JrZXIiLCJjb21wcmVzc2lvbk9wdGlvbnMiLCJ1bmNvbXByZXNzV29ya2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/flate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/generate/ZipFileWorker.js":
/*!**********************************************************!*\
  !*** ./node_modules/jszip/lib/generate/ZipFileWorker.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nvar GenericWorker = __webpack_require__(/*! ../stream/GenericWorker */ \"(ssr)/./node_modules/jszip/lib/stream/GenericWorker.js\");\nvar utf8 = __webpack_require__(/*! ../utf8 */ \"(ssr)/./node_modules/jszip/lib/utf8.js\");\nvar crc32 = __webpack_require__(/*! ../crc32 */ \"(ssr)/./node_modules/jszip/lib/crc32.js\");\nvar signature = __webpack_require__(/*! ../signature */ \"(ssr)/./node_modules/jszip/lib/signature.js\");\n/**\n * Transform an integer into a string in hexadecimal.\n * @private\n * @param {number} dec the number to convert.\n * @param {number} bytes the number of bytes to generate.\n * @returns {string} the result.\n */ var decToHex = function(dec, bytes) {\n    var hex = \"\", i;\n    for(i = 0; i < bytes; i++){\n        hex += String.fromCharCode(dec & 0xff);\n        dec = dec >>> 8;\n    }\n    return hex;\n};\n/**\n * Generate the UNIX part of the external file attributes.\n * @param {Object} unixPermissions the unix permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :\n *\n * TTTTsstrwxrwxrwx0000000000ADVSHR\n * ^^^^____________________________ file type, see zipinfo.c (UNX_*)\n *     ^^^_________________________ setuid, setgid, sticky\n *        ^^^^^^^^^________________ permissions\n *                 ^^^^^^^^^^______ not used ?\n *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only\n */ var generateUnixExternalFileAttr = function(unixPermissions, isDir) {\n    var result = unixPermissions;\n    if (!unixPermissions) {\n        // I can't use octal values in strict mode, hence the hexa.\n        //  040775 => 0x41fd\n        // 0100664 => 0x81b4\n        result = isDir ? 0x41fd : 0x81b4;\n    }\n    return (result & 0xFFFF) << 16;\n};\n/**\n * Generate the DOS part of the external file attributes.\n * @param {Object} dosPermissions the dos permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * Bit 0     Read-Only\n * Bit 1     Hidden\n * Bit 2     System\n * Bit 3     Volume Label\n * Bit 4     Directory\n * Bit 5     Archive\n */ var generateDosExternalFileAttr = function(dosPermissions) {\n    // the dir flag is already set for compatibility\n    return (dosPermissions || 0) & 0x3F;\n};\n/**\n * Generate the various parts used in the construction of the final zip file.\n * @param {Object} streamInfo the hash with information about the compressed file.\n * @param {Boolean} streamedContent is the content streamed ?\n * @param {Boolean} streamingEnded is the stream finished ?\n * @param {number} offset the current offset from the start of the zip file.\n * @param {String} platform let's pretend we are this platform (change platform dependents fields)\n * @param {Function} encodeFileName the function to encode the file name / comment.\n * @return {Object} the zip parts.\n */ var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {\n    var file = streamInfo[\"file\"], compression = streamInfo[\"compression\"], useCustomEncoding = encodeFileName !== utf8.utf8encode, encodedFileName = utils.transformTo(\"string\", encodeFileName(file.name)), utfEncodedFileName = utils.transformTo(\"string\", utf8.utf8encode(file.name)), comment = file.comment, encodedComment = utils.transformTo(\"string\", encodeFileName(comment)), utfEncodedComment = utils.transformTo(\"string\", utf8.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, dosTime, dosDate, extraFields = \"\", unicodePathExtraField = \"\", unicodeCommentExtraField = \"\", dir = file.dir, date = file.date;\n    var dataInfo = {\n        crc32: 0,\n        compressedSize: 0,\n        uncompressedSize: 0\n    };\n    // if the content is streamed, the sizes/crc32 are only available AFTER\n    // the end of the stream.\n    if (!streamedContent || streamingEnded) {\n        dataInfo.crc32 = streamInfo[\"crc32\"];\n        dataInfo.compressedSize = streamInfo[\"compressedSize\"];\n        dataInfo.uncompressedSize = streamInfo[\"uncompressedSize\"];\n    }\n    var bitflag = 0;\n    if (streamedContent) {\n        // Bit 3: the sizes/crc32 are set to zero in the local header.\n        // The correct values are put in the data descriptor immediately\n        // following the compressed data.\n        bitflag |= 0x0008;\n    }\n    if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {\n        // Bit 11: Language encoding flag (EFS).\n        bitflag |= 0x0800;\n    }\n    var extFileAttr = 0;\n    var versionMadeBy = 0;\n    if (dir) {\n        // dos or unix, we set the dos dir flag\n        extFileAttr |= 0x00010;\n    }\n    if (platform === \"UNIX\") {\n        versionMadeBy = 0x031E; // UNIX, version 3.0\n        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);\n    } else {\n        versionMadeBy = 0x0014; // DOS, version 2.0\n        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);\n    }\n    // date\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html\n    dosTime = date.getUTCHours();\n    dosTime = dosTime << 6;\n    dosTime = dosTime | date.getUTCMinutes();\n    dosTime = dosTime << 5;\n    dosTime = dosTime | date.getUTCSeconds() / 2;\n    dosDate = date.getUTCFullYear() - 1980;\n    dosDate = dosDate << 4;\n    dosDate = dosDate | date.getUTCMonth() + 1;\n    dosDate = dosDate << 5;\n    dosDate = dosDate | date.getUTCDate();\n    if (useUTF8ForFileName) {\n        // set the unicode path extra field. unzip needs at least one extra\n        // field to correctly handle unicode path, so using the path is as good\n        // as any other information. This could improve the situation with\n        // other archive managers too.\n        // This field is usually used without the utf8 flag, with a non\n        // unicode path in the header (winrar, winzip). This helps (a bit)\n        // with the messy Windows' default compressed folders feature but\n        // breaks on p7zip which doesn't seek the unicode path extra field.\n        // So for now, UTF-8 everywhere !\n        unicodePathExtraField = // Version\n        decToHex(1, 1) + // NameCRC32\n        decToHex(crc32(encodedFileName), 4) + // UnicodeName\n        utfEncodedFileName;\n        extraFields += // Info-ZIP Unicode Path Extra Field\n        \"up\" + // size\n        decToHex(unicodePathExtraField.length, 2) + // content\n        unicodePathExtraField;\n    }\n    if (useUTF8ForComment) {\n        unicodeCommentExtraField = // Version\n        decToHex(1, 1) + // CommentCRC32\n        decToHex(crc32(encodedComment), 4) + // UnicodeName\n        utfEncodedComment;\n        extraFields += // Info-ZIP Unicode Path Extra Field\n        \"uc\" + // size\n        decToHex(unicodeCommentExtraField.length, 2) + // content\n        unicodeCommentExtraField;\n    }\n    var header = \"\";\n    // version needed to extract\n    header += \"\\n\\x00\";\n    // general purpose bit flag\n    header += decToHex(bitflag, 2);\n    // compression method\n    header += compression.magic;\n    // last mod file time\n    header += decToHex(dosTime, 2);\n    // last mod file date\n    header += decToHex(dosDate, 2);\n    // crc-32\n    header += decToHex(dataInfo.crc32, 4);\n    // compressed size\n    header += decToHex(dataInfo.compressedSize, 4);\n    // uncompressed size\n    header += decToHex(dataInfo.uncompressedSize, 4);\n    // file name length\n    header += decToHex(encodedFileName.length, 2);\n    // extra field length\n    header += decToHex(extraFields.length, 2);\n    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;\n    var dirRecord = signature.CENTRAL_FILE_HEADER + // version made by (00: DOS)\n    decToHex(versionMadeBy, 2) + // file header (common to file and central directory)\n    header + // file comment length\n    decToHex(encodedComment.length, 2) + // disk number start\n    \"\\x00\\x00\" + // internal file attributes TODO\n    \"\\x00\\x00\" + // external file attributes\n    decToHex(extFileAttr, 4) + // relative offset of local header\n    decToHex(offset, 4) + // file name\n    encodedFileName + // extra field\n    extraFields + // file comment\n    encodedComment;\n    return {\n        fileRecord: fileRecord,\n        dirRecord: dirRecord\n    };\n};\n/**\n * Generate the EOCD record.\n * @param {Number} entriesCount the number of entries in the zip file.\n * @param {Number} centralDirLength the length (in bytes) of the central dir.\n * @param {Number} localDirLength the length (in bytes) of the local dir.\n * @param {String} comment the zip file comment as a binary string.\n * @param {Function} encodeFileName the function to encode the comment.\n * @return {String} the EOCD record.\n */ var generateCentralDirectoryEnd = function(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {\n    var dirEnd = \"\";\n    var encodedComment = utils.transformTo(\"string\", encodeFileName(comment));\n    // end of central dir signature\n    dirEnd = signature.CENTRAL_DIRECTORY_END + // number of this disk\n    \"\\x00\\x00\" + // number of the disk with the start of the central directory\n    \"\\x00\\x00\" + // total number of entries in the central directory on this disk\n    decToHex(entriesCount, 2) + // total number of entries in the central directory\n    decToHex(entriesCount, 2) + // size of the central directory   4 bytes\n    decToHex(centralDirLength, 4) + // offset of start of central directory with respect to the starting disk number\n    decToHex(localDirLength, 4) + // .ZIP file comment length\n    decToHex(encodedComment.length, 2) + // .ZIP file comment\n    encodedComment;\n    return dirEnd;\n};\n/**\n * Generate data descriptors for a file entry.\n * @param {Object} streamInfo the hash generated by a worker, containing information\n * on the file entry.\n * @return {String} the data descriptors.\n */ var generateDataDescriptors = function(streamInfo) {\n    var descriptor = \"\";\n    descriptor = signature.DATA_DESCRIPTOR + // crc-32                          4 bytes\n    decToHex(streamInfo[\"crc32\"], 4) + // compressed size                 4 bytes\n    decToHex(streamInfo[\"compressedSize\"], 4) + // uncompressed size               4 bytes\n    decToHex(streamInfo[\"uncompressedSize\"], 4);\n    return descriptor;\n};\n/**\n * A worker to concatenate other workers to create a zip file.\n * @param {Boolean} streamFiles `true` to stream the content of the files,\n * `false` to accumulate it.\n * @param {String} comment the comment to use.\n * @param {String} platform the platform to use, \"UNIX\" or \"DOS\".\n * @param {Function} encodeFileName the function to encode file names and comments.\n */ function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {\n    GenericWorker.call(this, \"ZipFileWorker\");\n    // The number of bytes written so far. This doesn't count accumulated chunks.\n    this.bytesWritten = 0;\n    // The comment of the zip file\n    this.zipComment = comment;\n    // The platform \"generating\" the zip file.\n    this.zipPlatform = platform;\n    // the function to encode file names and comments.\n    this.encodeFileName = encodeFileName;\n    // Should we stream the content of the files ?\n    this.streamFiles = streamFiles;\n    // If `streamFiles` is false, we will need to accumulate the content of the\n    // files to calculate sizes / crc32 (and write them *before* the content).\n    // This boolean indicates if we are accumulating chunks (it will change a lot\n    // during the lifetime of this worker).\n    this.accumulate = false;\n    // The buffer receiving chunks when accumulating content.\n    this.contentBuffer = [];\n    // The list of generated directory records.\n    this.dirRecords = [];\n    // The offset (in bytes) from the beginning of the zip file for the current source.\n    this.currentSourceOffset = 0;\n    // The total number of entries in this zip file.\n    this.entriesCount = 0;\n    // the name of the file currently being added, null when handling the end of the zip file.\n    // Used for the emitted metadata.\n    this.currentFile = null;\n    this._sources = [];\n}\nutils.inherits(ZipFileWorker, GenericWorker);\n/**\n * @see GenericWorker.push\n */ ZipFileWorker.prototype.push = function(chunk) {\n    var currentFilePercent = chunk.meta.percent || 0;\n    var entriesCount = this.entriesCount;\n    var remainingFiles = this._sources.length;\n    if (this.accumulate) {\n        this.contentBuffer.push(chunk);\n    } else {\n        this.bytesWritten += chunk.data.length;\n        GenericWorker.prototype.push.call(this, {\n            data: chunk.data,\n            meta: {\n                currentFile: this.currentFile,\n                percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100\n            }\n        });\n    }\n};\n/**\n * The worker started a new source (an other worker).\n * @param {Object} streamInfo the streamInfo object from the new source.\n */ ZipFileWorker.prototype.openedSource = function(streamInfo) {\n    this.currentSourceOffset = this.bytesWritten;\n    this.currentFile = streamInfo[\"file\"].name;\n    var streamedContent = this.streamFiles && !streamInfo[\"file\"].dir;\n    // don't stream folders (because they don't have any content)\n    if (streamedContent) {\n        var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n        this.push({\n            data: record.fileRecord,\n            meta: {\n                percent: 0\n            }\n        });\n    } else {\n        // we need to wait for the whole file before pushing anything\n        this.accumulate = true;\n    }\n};\n/**\n * The worker finished a source (an other worker).\n * @param {Object} streamInfo the streamInfo object from the finished source.\n */ ZipFileWorker.prototype.closedSource = function(streamInfo) {\n    this.accumulate = false;\n    var streamedContent = this.streamFiles && !streamInfo[\"file\"].dir;\n    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n    this.dirRecords.push(record.dirRecord);\n    if (streamedContent) {\n        // after the streamed file, we put data descriptors\n        this.push({\n            data: generateDataDescriptors(streamInfo),\n            meta: {\n                percent: 100\n            }\n        });\n    } else {\n        // the content wasn't streamed, we need to push everything now\n        // first the file record, then the content\n        this.push({\n            data: record.fileRecord,\n            meta: {\n                percent: 0\n            }\n        });\n        while(this.contentBuffer.length){\n            this.push(this.contentBuffer.shift());\n        }\n    }\n    this.currentFile = null;\n};\n/**\n * @see GenericWorker.flush\n */ ZipFileWorker.prototype.flush = function() {\n    var localDirLength = this.bytesWritten;\n    for(var i = 0; i < this.dirRecords.length; i++){\n        this.push({\n            data: this.dirRecords[i],\n            meta: {\n                percent: 100\n            }\n        });\n    }\n    var centralDirLength = this.bytesWritten - localDirLength;\n    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);\n    this.push({\n        data: dirEnd,\n        meta: {\n            percent: 100\n        }\n    });\n};\n/**\n * Prepare the next source to be read.\n */ ZipFileWorker.prototype.prepareNextSource = function() {\n    this.previous = this._sources.shift();\n    this.openedSource(this.previous.streamInfo);\n    if (this.isPaused) {\n        this.previous.pause();\n    } else {\n        this.previous.resume();\n    }\n};\n/**\n * @see GenericWorker.registerPrevious\n */ ZipFileWorker.prototype.registerPrevious = function(previous) {\n    this._sources.push(previous);\n    var self = this;\n    previous.on(\"data\", function(chunk) {\n        self.processChunk(chunk);\n    });\n    previous.on(\"end\", function() {\n        self.closedSource(self.previous.streamInfo);\n        if (self._sources.length) {\n            self.prepareNextSource();\n        } else {\n            self.end();\n        }\n    });\n    previous.on(\"error\", function(e) {\n        self.error(e);\n    });\n    return this;\n};\n/**\n * @see GenericWorker.resume\n */ ZipFileWorker.prototype.resume = function() {\n    if (!GenericWorker.prototype.resume.call(this)) {\n        return false;\n    }\n    if (!this.previous && this._sources.length) {\n        this.prepareNextSource();\n        return true;\n    }\n    if (!this.previous && !this._sources.length && !this.generatedError) {\n        this.end();\n        return true;\n    }\n};\n/**\n * @see GenericWorker.error\n */ ZipFileWorker.prototype.error = function(e) {\n    var sources = this._sources;\n    if (!GenericWorker.prototype.error.call(this, e)) {\n        return false;\n    }\n    for(var i = 0; i < sources.length; i++){\n        try {\n            sources[i].error(e);\n        } catch (e) {\n        // the `error` exploded, nothing to do\n        }\n    }\n    return true;\n};\n/**\n * @see GenericWorker.lock\n */ ZipFileWorker.prototype.lock = function() {\n    GenericWorker.prototype.lock.call(this);\n    var sources = this._sources;\n    for(var i = 0; i < sources.length; i++){\n        sources[i].lock();\n    }\n};\nmodule.exports = ZipFileWorker;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2dlbmVyYXRlL1ppcEZpbGVXb3JrZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQyx5REFBVTtBQUM5QixJQUFJQyxnQkFBZ0JELG1CQUFPQSxDQUFDLHVGQUF5QjtBQUNyRCxJQUFJRSxPQUFPRixtQkFBT0EsQ0FBQyx1REFBUztBQUM1QixJQUFJRyxRQUFRSCxtQkFBT0EsQ0FBQyx5REFBVTtBQUM5QixJQUFJSSxZQUFZSixtQkFBT0EsQ0FBQyxpRUFBYztBQUV0Qzs7Ozs7O0NBTUMsR0FDRCxJQUFJSyxXQUFXLFNBQVNDLEdBQUcsRUFBRUMsS0FBSztJQUM5QixJQUFJQyxNQUFNLElBQUlDO0lBQ2QsSUFBS0EsSUFBSSxHQUFHQSxJQUFJRixPQUFPRSxJQUFLO1FBQ3hCRCxPQUFPRSxPQUFPQyxZQUFZLENBQUNMLE1BQU07UUFDakNBLE1BQU1BLFFBQVE7SUFDbEI7SUFDQSxPQUFPRTtBQUNYO0FBRUE7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDRCxJQUFJSSwrQkFBK0IsU0FBVUMsZUFBZSxFQUFFQyxLQUFLO0lBRS9ELElBQUlDLFNBQVNGO0lBQ2IsSUFBSSxDQUFDQSxpQkFBaUI7UUFDbEIsMkRBQTJEO1FBQzNELG9CQUFvQjtRQUNwQixvQkFBb0I7UUFDcEJFLFNBQVNELFFBQVEsU0FBUztJQUM5QjtJQUNBLE9BQU8sQ0FBQ0MsU0FBUyxNQUFLLEtBQU07QUFDaEM7QUFFQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRCxJQUFJQyw4QkFBOEIsU0FBVUMsY0FBYztJQUN0RCxnREFBZ0Q7SUFDaEQsT0FBTyxDQUFDQSxrQkFBa0IsS0FBTTtBQUNwQztBQUVBOzs7Ozs7Ozs7Q0FTQyxHQUNELElBQUlDLG1CQUFtQixTQUFTQyxVQUFVLEVBQUVDLGVBQWUsRUFBRUMsY0FBYyxFQUFFQyxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsY0FBYztJQUN6RyxJQUFJQyxPQUFPTixVQUFV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QyxVQUFVLElBQUksQ0FBQzVCLFFBQVE7SUFDM0IsSUFBSSxJQUFJM0UsSUFBSSxHQUFHQSxJQUFJdUcsUUFBUTNFLE1BQU0sRUFBRTVCLElBQUs7UUFDcEN1RyxPQUFPLENBQUN2RyxFQUFFLENBQUN3RyxJQUFJO0lBQ25CO0FBQ0o7QUFFQUMsT0FBT0MsT0FBTyxHQUFHMUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90c2EtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2dlbmVyYXRlL1ppcEZpbGVXb3JrZXIuanM/NWUzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKFwiLi4vc3RyZWFtL0dlbmVyaWNXb3JrZXJcIik7XG52YXIgdXRmOCA9IHJlcXVpcmUoXCIuLi91dGY4XCIpO1xudmFyIGNyYzMyID0gcmVxdWlyZShcIi4uL2NyYzMyXCIpO1xudmFyIHNpZ25hdHVyZSA9IHJlcXVpcmUoXCIuLi9zaWduYXR1cmVcIik7XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGludGVnZXIgaW50byBhIHN0cmluZyBpbiBoZXhhZGVjaW1hbC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gZGVjIHRoZSBudW1iZXIgdG8gY29udmVydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGdlbmVyYXRlLlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIHJlc3VsdC5cbiAqL1xudmFyIGRlY1RvSGV4ID0gZnVuY3Rpb24oZGVjLCBieXRlcykge1xuICAgIHZhciBoZXggPSBcIlwiLCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBieXRlczsgaSsrKSB7XG4gICAgICAgIGhleCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRlYyAmIDB4ZmYpO1xuICAgICAgICBkZWMgPSBkZWMgPj4+IDg7XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBVTklYIHBhcnQgb2YgdGhlIGV4dGVybmFsIGZpbGUgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSB1bml4UGVybWlzc2lvbnMgdGhlIHVuaXggcGVybWlzc2lvbnMgb3IgbnVsbC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNEaXIgdHJ1ZSBpZiB0aGUgZW50cnkgaXMgYSBkaXJlY3RvcnksIGZhbHNlIG90aGVyd2lzZS5cbiAqIEByZXR1cm4ge051bWJlcn0gYSAzMiBiaXQgaW50ZWdlci5cbiAqXG4gKiBhZGFwdGVkIGZyb20gaHR0cDovL3VuaXguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzE0NzA1L3RoZS16aXAtZm9ybWF0cy1leHRlcm5hbC1maWxlLWF0dHJpYnV0ZSA6XG4gKlxuICogVFRUVHNzdHJ3eHJ3eHJ3eDAwMDAwMDAwMDBBRFZTSFJcbiAqIF5eXl5fX19fX19fX19fX19fX19fX19fX19fX19fX19fIGZpbGUgdHlwZSwgc2VlIHppcGluZm8uYyAoVU5YXyopXG4gKiAgICAgXl5eX19fX19fX19fX19fX19fX19fX19fX19fXyBzZXR1aWQsIHNldGdpZCwgc3RpY2t5XG4gKiAgICAgICAgXl5eXl5eXl5eX19fX19fX19fX19fX19fXyBwZXJtaXNzaW9uc1xuICogICAgICAgICAgICAgICAgIF5eXl5eXl5eXl5fX19fX18gbm90IHVzZWQgP1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl4gRE9TIGF0dHJpYnV0ZSBiaXRzIDogQXJjaGl2ZSwgRGlyZWN0b3J5LCBWb2x1bWUgbGFiZWwsIFN5c3RlbSBmaWxlLCBIaWRkZW4sIFJlYWQgb25seVxuICovXG52YXIgZ2VuZXJhdGVVbml4RXh0ZXJuYWxGaWxlQXR0ciA9IGZ1bmN0aW9uICh1bml4UGVybWlzc2lvbnMsIGlzRGlyKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gdW5peFBlcm1pc3Npb25zO1xuICAgIGlmICghdW5peFBlcm1pc3Npb25zKSB7XG4gICAgICAgIC8vIEkgY2FuJ3QgdXNlIG9jdGFsIHZhbHVlcyBpbiBzdHJpY3QgbW9kZSwgaGVuY2UgdGhlIGhleGEuXG4gICAgICAgIC8vICAwNDA3NzUgPT4gMHg0MWZkXG4gICAgICAgIC8vIDAxMDA2NjQgPT4gMHg4MWI0XG4gICAgICAgIHJlc3VsdCA9IGlzRGlyID8gMHg0MWZkIDogMHg4MWI0O1xuICAgIH1cbiAgICByZXR1cm4gKHJlc3VsdCAmIDB4RkZGRikgPDwgMTY7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBET1MgcGFydCBvZiB0aGUgZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHtPYmplY3R9IGRvc1Blcm1pc3Npb25zIHRoZSBkb3MgcGVybWlzc2lvbnMgb3IgbnVsbC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNEaXIgdHJ1ZSBpZiB0aGUgZW50cnkgaXMgYSBkaXJlY3RvcnksIGZhbHNlIG90aGVyd2lzZS5cbiAqIEByZXR1cm4ge051bWJlcn0gYSAzMiBiaXQgaW50ZWdlci5cbiAqXG4gKiBCaXQgMCAgICAgUmVhZC1Pbmx5XG4gKiBCaXQgMSAgICAgSGlkZGVuXG4gKiBCaXQgMiAgICAgU3lzdGVtXG4gKiBCaXQgMyAgICAgVm9sdW1lIExhYmVsXG4gKiBCaXQgNCAgICAgRGlyZWN0b3J5XG4gKiBCaXQgNSAgICAgQXJjaGl2ZVxuICovXG52YXIgZ2VuZXJhdGVEb3NFeHRlcm5hbEZpbGVBdHRyID0gZnVuY3Rpb24gKGRvc1Blcm1pc3Npb25zKSB7XG4gICAgLy8gdGhlIGRpciBmbGFnIGlzIGFscmVhZHkgc2V0IGZvciBjb21wYXRpYmlsaXR5XG4gICAgcmV0dXJuIChkb3NQZXJtaXNzaW9ucyB8fCAwKSAgJiAweDNGO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgdmFyaW91cyBwYXJ0cyB1c2VkIGluIHRoZSBjb25zdHJ1Y3Rpb24gb2YgdGhlIGZpbmFsIHppcCBmaWxlLlxuICogQHBhcmFtIHtPYmplY3R9IHN0cmVhbUluZm8gdGhlIGhhc2ggd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY29tcHJlc3NlZCBmaWxlLlxuICogQHBhcmFtIHtCb29sZWFufSBzdHJlYW1lZENvbnRlbnQgaXMgdGhlIGNvbnRlbnQgc3RyZWFtZWQgP1xuICogQHBhcmFtIHtCb29sZWFufSBzdHJlYW1pbmdFbmRlZCBpcyB0aGUgc3RyZWFtIGZpbmlzaGVkID9cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgdGhlIGN1cnJlbnQgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGF0Zm9ybSBsZXQncyBwcmV0ZW5kIHdlIGFyZSB0aGlzIHBsYXRmb3JtIChjaGFuZ2UgcGxhdGZvcm0gZGVwZW5kZW50cyBmaWVsZHMpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmNvZGVGaWxlTmFtZSB0aGUgZnVuY3Rpb24gdG8gZW5jb2RlIHRoZSBmaWxlIG5hbWUgLyBjb21tZW50LlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgemlwIHBhcnRzLlxuICovXG52YXIgZ2VuZXJhdGVaaXBQYXJ0cyA9IGZ1bmN0aW9uKHN0cmVhbUluZm8sIHN0cmVhbWVkQ29udGVudCwgc3RyZWFtaW5nRW5kZWQsIG9mZnNldCwgcGxhdGZvcm0sIGVuY29kZUZpbGVOYW1lKSB7XG4gICAgdmFyIGZpbGUgPSBzdHJlYW1JbmZvW1wiZmlsZVwiXSxcbiAgICAgICAgY29tcHJlc3Npb24gPSBzdHJlYW1JbmZvW1wiY29tcHJlc3Npb25cIl0sXG4gICAgICAgIHVzZUN1c3RvbUVuY29kaW5nID0gZW5jb2RlRmlsZU5hbWUgIT09IHV0ZjgudXRmOGVuY29kZSxcbiAgICAgICAgZW5jb2RlZEZpbGVOYW1lID0gdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgZW5jb2RlRmlsZU5hbWUoZmlsZS5uYW1lKSksXG4gICAgICAgIHV0ZkVuY29kZWRGaWxlTmFtZSA9IHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIHV0ZjgudXRmOGVuY29kZShmaWxlLm5hbWUpKSxcbiAgICAgICAgY29tbWVudCA9IGZpbGUuY29tbWVudCxcbiAgICAgICAgZW5jb2RlZENvbW1lbnQgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCBlbmNvZGVGaWxlTmFtZShjb21tZW50KSksXG4gICAgICAgIHV0ZkVuY29kZWRDb21tZW50ID0gdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgdXRmOC51dGY4ZW5jb2RlKGNvbW1lbnQpKSxcbiAgICAgICAgdXNlVVRGOEZvckZpbGVOYW1lID0gdXRmRW5jb2RlZEZpbGVOYW1lLmxlbmd0aCAhPT0gZmlsZS5uYW1lLmxlbmd0aCxcbiAgICAgICAgdXNlVVRGOEZvckNvbW1lbnQgPSB1dGZFbmNvZGVkQ29tbWVudC5sZW5ndGggIT09IGNvbW1lbnQubGVuZ3RoLFxuICAgICAgICBkb3NUaW1lLFxuICAgICAgICBkb3NEYXRlLFxuICAgICAgICBleHRyYUZpZWxkcyA9IFwiXCIsXG4gICAgICAgIHVuaWNvZGVQYXRoRXh0cmFGaWVsZCA9IFwiXCIsXG4gICAgICAgIHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZCA9IFwiXCIsXG4gICAgICAgIGRpciA9IGZpbGUuZGlyLFxuICAgICAgICBkYXRlID0gZmlsZS5kYXRlO1xuXG5cbiAgICB2YXIgZGF0YUluZm8gPSB7XG4gICAgICAgIGNyYzMyIDogMCxcbiAgICAgICAgY29tcHJlc3NlZFNpemUgOiAwLFxuICAgICAgICB1bmNvbXByZXNzZWRTaXplIDogMFxuICAgIH07XG5cbiAgICAvLyBpZiB0aGUgY29udGVudCBpcyBzdHJlYW1lZCwgdGhlIHNpemVzL2NyYzMyIGFyZSBvbmx5IGF2YWlsYWJsZSBBRlRFUlxuICAgIC8vIHRoZSBlbmQgb2YgdGhlIHN0cmVhbS5cbiAgICBpZiAoIXN0cmVhbWVkQ29udGVudCB8fCBzdHJlYW1pbmdFbmRlZCkge1xuICAgICAgICBkYXRhSW5mby5jcmMzMiA9IHN0cmVhbUluZm9bXCJjcmMzMlwiXTtcbiAgICAgICAgZGF0YUluZm8uY29tcHJlc3NlZFNpemUgPSBzdHJlYW1JbmZvW1wiY29tcHJlc3NlZFNpemVcIl07XG4gICAgICAgIGRhdGFJbmZvLnVuY29tcHJlc3NlZFNpemUgPSBzdHJlYW1JbmZvW1widW5jb21wcmVzc2VkU2l6ZVwiXTtcbiAgICB9XG5cbiAgICB2YXIgYml0ZmxhZyA9IDA7XG4gICAgaWYgKHN0cmVhbWVkQ29udGVudCkge1xuICAgICAgICAvLyBCaXQgMzogdGhlIHNpemVzL2NyYzMyIGFyZSBzZXQgdG8gemVybyBpbiB0aGUgbG9jYWwgaGVhZGVyLlxuICAgICAgICAvLyBUaGUgY29ycmVjdCB2YWx1ZXMgYXJlIHB1dCBpbiB0aGUgZGF0YSBkZXNjcmlwdG9yIGltbWVkaWF0ZWx5XG4gICAgICAgIC8vIGZvbGxvd2luZyB0aGUgY29tcHJlc3NlZCBkYXRhLlxuICAgICAgICBiaXRmbGFnIHw9IDB4MDAwODtcbiAgICB9XG4gICAgaWYgKCF1c2VDdXN0b21FbmNvZGluZyAmJiAodXNlVVRGOEZvckZpbGVOYW1lIHx8IHVzZVVURjhGb3JDb21tZW50KSkge1xuICAgICAgICAvLyBCaXQgMTE6IExhbmd1YWdlIGVuY29kaW5nIGZsYWcgKEVGUykuXG4gICAgICAgIGJpdGZsYWcgfD0gMHgwODAwO1xuICAgIH1cblxuXG4gICAgdmFyIGV4dEZpbGVBdHRyID0gMDtcbiAgICB2YXIgdmVyc2lvbk1hZGVCeSA9IDA7XG4gICAgaWYgKGRpcikge1xuICAgICAgICAvLyBkb3Mgb3IgdW5peCwgd2Ugc2V0IHRoZSBkb3MgZGlyIGZsYWdcbiAgICAgICAgZXh0RmlsZUF0dHIgfD0gMHgwMDAxMDtcbiAgICB9XG4gICAgaWYocGxhdGZvcm0gPT09IFwiVU5JWFwiKSB7XG4gICAgICAgIHZlcnNpb25NYWRlQnkgPSAweDAzMUU7IC8vIFVOSVgsIHZlcnNpb24gMy4wXG4gICAgICAgIGV4dEZpbGVBdHRyIHw9IGdlbmVyYXRlVW5peEV4dGVybmFsRmlsZUF0dHIoZmlsZS51bml4UGVybWlzc2lvbnMsIGRpcik7XG4gICAgfSBlbHNlIHsgLy8gRE9TIG9yIG90aGVyLCBmYWxsYmFjayB0byBET1NcbiAgICAgICAgdmVyc2lvbk1hZGVCeSA9IDB4MDAxNDsgLy8gRE9TLCB2ZXJzaW9uIDIuMFxuICAgICAgICBleHRGaWxlQXR0ciB8PSBnZW5lcmF0ZURvc0V4dGVybmFsRmlsZUF0dHIoZmlsZS5kb3NQZXJtaXNzaW9ucywgZGlyKTtcbiAgICB9XG5cbiAgICAvLyBkYXRlXG4gICAgLy8gQHNlZSBodHRwOi8vd3d3LmRlbG9yaWUuY29tL2RqZ3BwL2RvYy9yYmludGVyL2l0LzUyLzEzLmh0bWxcbiAgICAvLyBAc2VlIGh0dHA6Ly93d3cuZGVsb3JpZS5jb20vZGpncHAvZG9jL3JiaW50ZXIvaXQvNjUvMTYuaHRtbFxuICAgIC8vIEBzZWUgaHR0cDovL3d3dy5kZWxvcmllLmNvbS9kamdwcC9kb2MvcmJpbnRlci9pdC82Ni8xNi5odG1sXG5cbiAgICBkb3NUaW1lID0gZGF0ZS5nZXRVVENIb3VycygpO1xuICAgIGRvc1RpbWUgPSBkb3NUaW1lIDw8IDY7XG4gICAgZG9zVGltZSA9IGRvc1RpbWUgfCBkYXRlLmdldFVUQ01pbnV0ZXMoKTtcbiAgICBkb3NUaW1lID0gZG9zVGltZSA8PCA1O1xuICAgIGRvc1RpbWUgPSBkb3NUaW1lIHwgZGF0ZS5nZXRVVENTZWNvbmRzKCkgLyAyO1xuXG4gICAgZG9zRGF0ZSA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKSAtIDE5ODA7XG4gICAgZG9zRGF0ZSA9IGRvc0RhdGUgPDwgNDtcbiAgICBkb3NEYXRlID0gZG9zRGF0ZSB8IChkYXRlLmdldFVUQ01vbnRoKCkgKyAxKTtcbiAgICBkb3NEYXRlID0gZG9zRGF0ZSA8PCA1O1xuICAgIGRvc0RhdGUgPSBkb3NEYXRlIHwgZGF0ZS5nZXRVVENEYXRlKCk7XG5cbiAgICBpZiAodXNlVVRGOEZvckZpbGVOYW1lKSB7XG4gICAgICAgIC8vIHNldCB0aGUgdW5pY29kZSBwYXRoIGV4dHJhIGZpZWxkLiB1bnppcCBuZWVkcyBhdCBsZWFzdCBvbmUgZXh0cmFcbiAgICAgICAgLy8gZmllbGQgdG8gY29ycmVjdGx5IGhhbmRsZSB1bmljb2RlIHBhdGgsIHNvIHVzaW5nIHRoZSBwYXRoIGlzIGFzIGdvb2RcbiAgICAgICAgLy8gYXMgYW55IG90aGVyIGluZm9ybWF0aW9uLiBUaGlzIGNvdWxkIGltcHJvdmUgdGhlIHNpdHVhdGlvbiB3aXRoXG4gICAgICAgIC8vIG90aGVyIGFyY2hpdmUgbWFuYWdlcnMgdG9vLlxuICAgICAgICAvLyBUaGlzIGZpZWxkIGlzIHVzdWFsbHkgdXNlZCB3aXRob3V0IHRoZSB1dGY4IGZsYWcsIHdpdGggYSBub25cbiAgICAgICAgLy8gdW5pY29kZSBwYXRoIGluIHRoZSBoZWFkZXIgKHdpbnJhciwgd2luemlwKS4gVGhpcyBoZWxwcyAoYSBiaXQpXG4gICAgICAgIC8vIHdpdGggdGhlIG1lc3N5IFdpbmRvd3MnIGRlZmF1bHQgY29tcHJlc3NlZCBmb2xkZXJzIGZlYXR1cmUgYnV0XG4gICAgICAgIC8vIGJyZWFrcyBvbiBwN3ppcCB3aGljaCBkb2Vzbid0IHNlZWsgdGhlIHVuaWNvZGUgcGF0aCBleHRyYSBmaWVsZC5cbiAgICAgICAgLy8gU28gZm9yIG5vdywgVVRGLTggZXZlcnl3aGVyZSAhXG4gICAgICAgIHVuaWNvZGVQYXRoRXh0cmFGaWVsZCA9XG4gICAgICAgICAgICAvLyBWZXJzaW9uXG4gICAgICAgICAgICBkZWNUb0hleCgxLCAxKSArXG4gICAgICAgICAgICAvLyBOYW1lQ1JDMzJcbiAgICAgICAgICAgIGRlY1RvSGV4KGNyYzMyKGVuY29kZWRGaWxlTmFtZSksIDQpICtcbiAgICAgICAgICAgIC8vIFVuaWNvZGVOYW1lXG4gICAgICAgICAgICB1dGZFbmNvZGVkRmlsZU5hbWU7XG5cbiAgICAgICAgZXh0cmFGaWVsZHMgKz1cbiAgICAgICAgICAgIC8vIEluZm8tWklQIFVuaWNvZGUgUGF0aCBFeHRyYSBGaWVsZFxuICAgICAgICAgICAgXCJcXHg3NVxceDcwXCIgK1xuICAgICAgICAgICAgLy8gc2l6ZVxuICAgICAgICAgICAgZGVjVG9IZXgodW5pY29kZVBhdGhFeHRyYUZpZWxkLmxlbmd0aCwgMikgK1xuICAgICAgICAgICAgLy8gY29udGVudFxuICAgICAgICAgICAgdW5pY29kZVBhdGhFeHRyYUZpZWxkO1xuICAgIH1cblxuICAgIGlmKHVzZVVURjhGb3JDb21tZW50KSB7XG5cbiAgICAgICAgdW5pY29kZUNvbW1lbnRFeHRyYUZpZWxkID1cbiAgICAgICAgICAgIC8vIFZlcnNpb25cbiAgICAgICAgICAgIGRlY1RvSGV4KDEsIDEpICtcbiAgICAgICAgICAgIC8vIENvbW1lbnRDUkMzMlxuICAgICAgICAgICAgZGVjVG9IZXgoY3JjMzIoZW5jb2RlZENvbW1lbnQpLCA0KSArXG4gICAgICAgICAgICAvLyBVbmljb2RlTmFtZVxuICAgICAgICAgICAgdXRmRW5jb2RlZENvbW1lbnQ7XG5cbiAgICAgICAgZXh0cmFGaWVsZHMgKz1cbiAgICAgICAgICAgIC8vIEluZm8tWklQIFVuaWNvZGUgUGF0aCBFeHRyYSBGaWVsZFxuICAgICAgICAgICAgXCJcXHg3NVxceDYzXCIgK1xuICAgICAgICAgICAgLy8gc2l6ZVxuICAgICAgICAgICAgZGVjVG9IZXgodW5pY29kZUNvbW1lbnRFeHRyYUZpZWxkLmxlbmd0aCwgMikgK1xuICAgICAgICAgICAgLy8gY29udGVudFxuICAgICAgICAgICAgdW5pY29kZUNvbW1lbnRFeHRyYUZpZWxkO1xuICAgIH1cblxuICAgIHZhciBoZWFkZXIgPSBcIlwiO1xuXG4gICAgLy8gdmVyc2lvbiBuZWVkZWQgdG8gZXh0cmFjdFxuICAgIGhlYWRlciArPSBcIlxceDBBXFx4MDBcIjtcbiAgICAvLyBnZW5lcmFsIHB1cnBvc2UgYml0IGZsYWdcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoYml0ZmxhZywgMik7XG4gICAgLy8gY29tcHJlc3Npb24gbWV0aG9kXG4gICAgaGVhZGVyICs9IGNvbXByZXNzaW9uLm1hZ2ljO1xuICAgIC8vIGxhc3QgbW9kIGZpbGUgdGltZVxuICAgIGhlYWRlciArPSBkZWNUb0hleChkb3NUaW1lLCAyKTtcbiAgICAvLyBsYXN0IG1vZCBmaWxlIGRhdGVcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZG9zRGF0ZSwgMik7XG4gICAgLy8gY3JjLTMyXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGRhdGFJbmZvLmNyYzMyLCA0KTtcbiAgICAvLyBjb21wcmVzc2VkIHNpemVcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZGF0YUluZm8uY29tcHJlc3NlZFNpemUsIDQpO1xuICAgIC8vIHVuY29tcHJlc3NlZCBzaXplXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGRhdGFJbmZvLnVuY29tcHJlc3NlZFNpemUsIDQpO1xuICAgIC8vIGZpbGUgbmFtZSBsZW5ndGhcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZW5jb2RlZEZpbGVOYW1lLmxlbmd0aCwgMik7XG4gICAgLy8gZXh0cmEgZmllbGQgbGVuZ3RoXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGV4dHJhRmllbGRzLmxlbmd0aCwgMik7XG5cblxuICAgIHZhciBmaWxlUmVjb3JkID0gc2lnbmF0dXJlLkxPQ0FMX0ZJTEVfSEVBREVSICsgaGVhZGVyICsgZW5jb2RlZEZpbGVOYW1lICsgZXh0cmFGaWVsZHM7XG5cbiAgICB2YXIgZGlyUmVjb3JkID0gc2lnbmF0dXJlLkNFTlRSQUxfRklMRV9IRUFERVIgK1xuICAgICAgICAvLyB2ZXJzaW9uIG1hZGUgYnkgKDAwOiBET1MpXG4gICAgICAgIGRlY1RvSGV4KHZlcnNpb25NYWRlQnksIDIpICtcbiAgICAgICAgLy8gZmlsZSBoZWFkZXIgKGNvbW1vbiB0byBmaWxlIGFuZCBjZW50cmFsIGRpcmVjdG9yeSlcbiAgICAgICAgaGVhZGVyICtcbiAgICAgICAgLy8gZmlsZSBjb21tZW50IGxlbmd0aFxuICAgICAgICBkZWNUb0hleChlbmNvZGVkQ29tbWVudC5sZW5ndGgsIDIpICtcbiAgICAgICAgLy8gZGlzayBudW1iZXIgc3RhcnRcbiAgICAgICAgXCJcXHgwMFxceDAwXCIgK1xuICAgICAgICAvLyBpbnRlcm5hbCBmaWxlIGF0dHJpYnV0ZXMgVE9ET1xuICAgICAgICBcIlxceDAwXFx4MDBcIiArXG4gICAgICAgIC8vIGV4dGVybmFsIGZpbGUgYXR0cmlidXRlc1xuICAgICAgICBkZWNUb0hleChleHRGaWxlQXR0ciwgNCkgK1xuICAgICAgICAvLyByZWxhdGl2ZSBvZmZzZXQgb2YgbG9jYWwgaGVhZGVyXG4gICAgICAgIGRlY1RvSGV4KG9mZnNldCwgNCkgK1xuICAgICAgICAvLyBmaWxlIG5hbWVcbiAgICAgICAgZW5jb2RlZEZpbGVOYW1lICtcbiAgICAgICAgLy8gZXh0cmEgZmllbGRcbiAgICAgICAgZXh0cmFGaWVsZHMgK1xuICAgICAgICAvLyBmaWxlIGNvbW1lbnRcbiAgICAgICAgZW5jb2RlZENvbW1lbnQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBmaWxlUmVjb3JkOiBmaWxlUmVjb3JkLFxuICAgICAgICBkaXJSZWNvcmQ6IGRpclJlY29yZFxuICAgIH07XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBFT0NEIHJlY29yZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBlbnRyaWVzQ291bnQgdGhlIG51bWJlciBvZiBlbnRyaWVzIGluIHRoZSB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBjZW50cmFsRGlyTGVuZ3RoIHRoZSBsZW5ndGggKGluIGJ5dGVzKSBvZiB0aGUgY2VudHJhbCBkaXIuXG4gKiBAcGFyYW0ge051bWJlcn0gbG9jYWxEaXJMZW5ndGggdGhlIGxlbmd0aCAoaW4gYnl0ZXMpIG9mIHRoZSBsb2NhbCBkaXIuXG4gKiBAcGFyYW0ge1N0cmluZ30gY29tbWVudCB0aGUgemlwIGZpbGUgY29tbWVudCBhcyBhIGJpbmFyeSBzdHJpbmcuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmNvZGVGaWxlTmFtZSB0aGUgZnVuY3Rpb24gdG8gZW5jb2RlIHRoZSBjb21tZW50LlxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgRU9DRCByZWNvcmQuXG4gKi9cbnZhciBnZW5lcmF0ZUNlbnRyYWxEaXJlY3RvcnlFbmQgPSBmdW5jdGlvbiAoZW50cmllc0NvdW50LCBjZW50cmFsRGlyTGVuZ3RoLCBsb2NhbERpckxlbmd0aCwgY29tbWVudCwgZW5jb2RlRmlsZU5hbWUpIHtcbiAgICB2YXIgZGlyRW5kID0gXCJcIjtcbiAgICB2YXIgZW5jb2RlZENvbW1lbnQgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCBlbmNvZGVGaWxlTmFtZShjb21tZW50KSk7XG5cbiAgICAvLyBlbmQgb2YgY2VudHJhbCBkaXIgc2lnbmF0dXJlXG4gICAgZGlyRW5kID0gc2lnbmF0dXJlLkNFTlRSQUxfRElSRUNUT1JZX0VORCArXG4gICAgICAgIC8vIG51bWJlciBvZiB0aGlzIGRpc2tcbiAgICAgICAgXCJcXHgwMFxceDAwXCIgK1xuICAgICAgICAvLyBudW1iZXIgb2YgdGhlIGRpc2sgd2l0aCB0aGUgc3RhcnQgb2YgdGhlIGNlbnRyYWwgZGlyZWN0b3J5XG4gICAgICAgIFwiXFx4MDBcXHgwMFwiICtcbiAgICAgICAgLy8gdG90YWwgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIGNlbnRyYWwgZGlyZWN0b3J5IG9uIHRoaXMgZGlza1xuICAgICAgICBkZWNUb0hleChlbnRyaWVzQ291bnQsIDIpICtcbiAgICAgICAgLy8gdG90YWwgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIGNlbnRyYWwgZGlyZWN0b3J5XG4gICAgICAgIGRlY1RvSGV4KGVudHJpZXNDb3VudCwgMikgK1xuICAgICAgICAvLyBzaXplIG9mIHRoZSBjZW50cmFsIGRpcmVjdG9yeSAgIDQgYnl0ZXNcbiAgICAgICAgZGVjVG9IZXgoY2VudHJhbERpckxlbmd0aCwgNCkgK1xuICAgICAgICAvLyBvZmZzZXQgb2Ygc3RhcnQgb2YgY2VudHJhbCBkaXJlY3Rvcnkgd2l0aCByZXNwZWN0IHRvIHRoZSBzdGFydGluZyBkaXNrIG51bWJlclxuICAgICAgICBkZWNUb0hleChsb2NhbERpckxlbmd0aCwgNCkgK1xuICAgICAgICAvLyAuWklQIGZpbGUgY29tbWVudCBsZW5ndGhcbiAgICAgICAgZGVjVG9IZXgoZW5jb2RlZENvbW1lbnQubGVuZ3RoLCAyKSArXG4gICAgICAgIC8vIC5aSVAgZmlsZSBjb21tZW50XG4gICAgICAgIGVuY29kZWRDb21tZW50O1xuXG4gICAgcmV0dXJuIGRpckVuZDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgZGF0YSBkZXNjcmlwdG9ycyBmb3IgYSBmaWxlIGVudHJ5LlxuICogQHBhcmFtIHtPYmplY3R9IHN0cmVhbUluZm8gdGhlIGhhc2ggZ2VuZXJhdGVkIGJ5IGEgd29ya2VyLCBjb250YWluaW5nIGluZm9ybWF0aW9uXG4gKiBvbiB0aGUgZmlsZSBlbnRyeS5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIGRhdGEgZGVzY3JpcHRvcnMuXG4gKi9cbnZhciBnZW5lcmF0ZURhdGFEZXNjcmlwdG9ycyA9IGZ1bmN0aW9uIChzdHJlYW1JbmZvKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBcIlwiO1xuICAgIGRlc2NyaXB0b3IgPSBzaWduYXR1cmUuREFUQV9ERVNDUklQVE9SICtcbiAgICAgICAgLy8gY3JjLTMyICAgICAgICAgICAgICAgICAgICAgICAgICA0IGJ5dGVzXG4gICAgICAgIGRlY1RvSGV4KHN0cmVhbUluZm9bXCJjcmMzMlwiXSwgNCkgK1xuICAgICAgICAvLyBjb21wcmVzc2VkIHNpemUgICAgICAgICAgICAgICAgIDQgYnl0ZXNcbiAgICAgICAgZGVjVG9IZXgoc3RyZWFtSW5mb1tcImNvbXByZXNzZWRTaXplXCJdLCA0KSArXG4gICAgICAgIC8vIHVuY29tcHJlc3NlZCBzaXplICAgICAgICAgICAgICAgNCBieXRlc1xuICAgICAgICBkZWNUb0hleChzdHJlYW1JbmZvW1widW5jb21wcmVzc2VkU2l6ZVwiXSwgNCk7XG5cbiAgICByZXR1cm4gZGVzY3JpcHRvcjtcbn07XG5cblxuLyoqXG4gKiBBIHdvcmtlciB0byBjb25jYXRlbmF0ZSBvdGhlciB3b3JrZXJzIHRvIGNyZWF0ZSBhIHppcCBmaWxlLlxuICogQHBhcmFtIHtCb29sZWFufSBzdHJlYW1GaWxlcyBgdHJ1ZWAgdG8gc3RyZWFtIHRoZSBjb250ZW50IG9mIHRoZSBmaWxlcyxcbiAqIGBmYWxzZWAgdG8gYWNjdW11bGF0ZSBpdC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb21tZW50IHRoZSBjb21tZW50IHRvIHVzZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGF0Zm9ybSB0aGUgcGxhdGZvcm0gdG8gdXNlLCBcIlVOSVhcIiBvciBcIkRPU1wiLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5jb2RlRmlsZU5hbWUgdGhlIGZ1bmN0aW9uIHRvIGVuY29kZSBmaWxlIG5hbWVzIGFuZCBjb21tZW50cy5cbiAqL1xuZnVuY3Rpb24gWmlwRmlsZVdvcmtlcihzdHJlYW1GaWxlcywgY29tbWVudCwgcGxhdGZvcm0sIGVuY29kZUZpbGVOYW1lKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiWmlwRmlsZVdvcmtlclwiKTtcbiAgICAvLyBUaGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gc28gZmFyLiBUaGlzIGRvZXNuJ3QgY291bnQgYWNjdW11bGF0ZWQgY2h1bmtzLlxuICAgIHRoaXMuYnl0ZXNXcml0dGVuID0gMDtcbiAgICAvLyBUaGUgY29tbWVudCBvZiB0aGUgemlwIGZpbGVcbiAgICB0aGlzLnppcENvbW1lbnQgPSBjb21tZW50O1xuICAgIC8vIFRoZSBwbGF0Zm9ybSBcImdlbmVyYXRpbmdcIiB0aGUgemlwIGZpbGUuXG4gICAgdGhpcy56aXBQbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICAgIC8vIHRoZSBmdW5jdGlvbiB0byBlbmNvZGUgZmlsZSBuYW1lcyBhbmQgY29tbWVudHMuXG4gICAgdGhpcy5lbmNvZGVGaWxlTmFtZSA9IGVuY29kZUZpbGVOYW1lO1xuICAgIC8vIFNob3VsZCB3ZSBzdHJlYW0gdGhlIGNvbnRlbnQgb2YgdGhlIGZpbGVzID9cbiAgICB0aGlzLnN0cmVhbUZpbGVzID0gc3RyZWFtRmlsZXM7XG4gICAgLy8gSWYgYHN0cmVhbUZpbGVzYCBpcyBmYWxzZSwgd2Ugd2lsbCBuZWVkIHRvIGFjY3VtdWxhdGUgdGhlIGNvbnRlbnQgb2YgdGhlXG4gICAgLy8gZmlsZXMgdG8gY2FsY3VsYXRlIHNpemVzIC8gY3JjMzIgKGFuZCB3cml0ZSB0aGVtICpiZWZvcmUqIHRoZSBjb250ZW50KS5cbiAgICAvLyBUaGlzIGJvb2xlYW4gaW5kaWNhdGVzIGlmIHdlIGFyZSBhY2N1bXVsYXRpbmcgY2h1bmtzIChpdCB3aWxsIGNoYW5nZSBhIGxvdFxuICAgIC8vIGR1cmluZyB0aGUgbGlmZXRpbWUgb2YgdGhpcyB3b3JrZXIpLlxuICAgIHRoaXMuYWNjdW11bGF0ZSA9IGZhbHNlO1xuICAgIC8vIFRoZSBidWZmZXIgcmVjZWl2aW5nIGNodW5rcyB3aGVuIGFjY3VtdWxhdGluZyBjb250ZW50LlxuICAgIHRoaXMuY29udGVudEJ1ZmZlciA9IFtdO1xuICAgIC8vIFRoZSBsaXN0IG9mIGdlbmVyYXRlZCBkaXJlY3RvcnkgcmVjb3Jkcy5cbiAgICB0aGlzLmRpclJlY29yZHMgPSBbXTtcbiAgICAvLyBUaGUgb2Zmc2V0IChpbiBieXRlcykgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSB6aXAgZmlsZSBmb3IgdGhlIGN1cnJlbnQgc291cmNlLlxuICAgIHRoaXMuY3VycmVudFNvdXJjZU9mZnNldCA9IDA7XG4gICAgLy8gVGhlIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzIGluIHRoaXMgemlwIGZpbGUuXG4gICAgdGhpcy5lbnRyaWVzQ291bnQgPSAwO1xuICAgIC8vIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGN1cnJlbnRseSBiZWluZyBhZGRlZCwgbnVsbCB3aGVuIGhhbmRsaW5nIHRoZSBlbmQgb2YgdGhlIHppcCBmaWxlLlxuICAgIC8vIFVzZWQgZm9yIHRoZSBlbWl0dGVkIG1ldGFkYXRhLlxuICAgIHRoaXMuY3VycmVudEZpbGUgPSBudWxsO1xuXG5cblxuICAgIHRoaXMuX3NvdXJjZXMgPSBbXTtcbn1cbnV0aWxzLmluaGVyaXRzKFppcEZpbGVXb3JrZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wdXNoXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmspIHtcblxuICAgIHZhciBjdXJyZW50RmlsZVBlcmNlbnQgPSBjaHVuay5tZXRhLnBlcmNlbnQgfHwgMDtcbiAgICB2YXIgZW50cmllc0NvdW50ID0gdGhpcy5lbnRyaWVzQ291bnQ7XG4gICAgdmFyIHJlbWFpbmluZ0ZpbGVzID0gdGhpcy5fc291cmNlcy5sZW5ndGg7XG5cbiAgICBpZih0aGlzLmFjY3VtdWxhdGUpIHtcbiAgICAgICAgdGhpcy5jb250ZW50QnVmZmVyLnB1c2goY2h1bmspO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYnl0ZXNXcml0dGVuICs9IGNodW5rLmRhdGEubGVuZ3RoO1xuXG4gICAgICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICBkYXRhIDogY2h1bmsuZGF0YSxcbiAgICAgICAgICAgIG1ldGEgOiB7XG4gICAgICAgICAgICAgICAgY3VycmVudEZpbGUgOiB0aGlzLmN1cnJlbnRGaWxlLFxuICAgICAgICAgICAgICAgIHBlcmNlbnQgOiBlbnRyaWVzQ291bnQgPyAoY3VycmVudEZpbGVQZXJjZW50ICsgMTAwICogKGVudHJpZXNDb3VudCAtIHJlbWFpbmluZ0ZpbGVzIC0gMSkpIC8gZW50cmllc0NvdW50IDogMTAwXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGhlIHdvcmtlciBzdGFydGVkIGEgbmV3IHNvdXJjZSAoYW4gb3RoZXIgd29ya2VyKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHJlYW1JbmZvIHRoZSBzdHJlYW1JbmZvIG9iamVjdCBmcm9tIHRoZSBuZXcgc291cmNlLlxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5vcGVuZWRTb3VyY2UgPSBmdW5jdGlvbiAoc3RyZWFtSW5mbykge1xuICAgIHRoaXMuY3VycmVudFNvdXJjZU9mZnNldCA9IHRoaXMuYnl0ZXNXcml0dGVuO1xuICAgIHRoaXMuY3VycmVudEZpbGUgPSBzdHJlYW1JbmZvW1wiZmlsZVwiXS5uYW1lO1xuXG4gICAgdmFyIHN0cmVhbWVkQ29udGVudCA9IHRoaXMuc3RyZWFtRmlsZXMgJiYgIXN0cmVhbUluZm9bXCJmaWxlXCJdLmRpcjtcblxuICAgIC8vIGRvbid0IHN0cmVhbSBmb2xkZXJzIChiZWNhdXNlIHRoZXkgZG9uJ3QgaGF2ZSBhbnkgY29udGVudClcbiAgICBpZihzdHJlYW1lZENvbnRlbnQpIHtcbiAgICAgICAgdmFyIHJlY29yZCA9IGdlbmVyYXRlWmlwUGFydHMoc3RyZWFtSW5mbywgc3RyZWFtZWRDb250ZW50LCBmYWxzZSwgdGhpcy5jdXJyZW50U291cmNlT2Zmc2V0LCB0aGlzLnppcFBsYXRmb3JtLCB0aGlzLmVuY29kZUZpbGVOYW1lKTtcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiByZWNvcmQuZmlsZVJlY29yZCxcbiAgICAgICAgICAgIG1ldGEgOiB7cGVyY2VudDowfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSB3aG9sZSBmaWxlIGJlZm9yZSBwdXNoaW5nIGFueXRoaW5nXG4gICAgICAgIHRoaXMuYWNjdW11bGF0ZSA9IHRydWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUaGUgd29ya2VyIGZpbmlzaGVkIGEgc291cmNlIChhbiBvdGhlciB3b3JrZXIpLlxuICogQHBhcmFtIHtPYmplY3R9IHN0cmVhbUluZm8gdGhlIHN0cmVhbUluZm8gb2JqZWN0IGZyb20gdGhlIGZpbmlzaGVkIHNvdXJjZS5cbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUuY2xvc2VkU291cmNlID0gZnVuY3Rpb24gKHN0cmVhbUluZm8pIHtcbiAgICB0aGlzLmFjY3VtdWxhdGUgPSBmYWxzZTtcbiAgICB2YXIgc3RyZWFtZWRDb250ZW50ID0gdGhpcy5zdHJlYW1GaWxlcyAmJiAhc3RyZWFtSW5mb1tcImZpbGVcIl0uZGlyO1xuICAgIHZhciByZWNvcmQgPSBnZW5lcmF0ZVppcFBhcnRzKHN0cmVhbUluZm8sIHN0cmVhbWVkQ29udGVudCwgdHJ1ZSwgdGhpcy5jdXJyZW50U291cmNlT2Zmc2V0LCB0aGlzLnppcFBsYXRmb3JtLCB0aGlzLmVuY29kZUZpbGVOYW1lKTtcblxuICAgIHRoaXMuZGlyUmVjb3Jkcy5wdXNoKHJlY29yZC5kaXJSZWNvcmQpO1xuICAgIGlmKHN0cmVhbWVkQ29udGVudCkge1xuICAgICAgICAvLyBhZnRlciB0aGUgc3RyZWFtZWQgZmlsZSwgd2UgcHV0IGRhdGEgZGVzY3JpcHRvcnNcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiBnZW5lcmF0ZURhdGFEZXNjcmlwdG9ycyhzdHJlYW1JbmZvKSxcbiAgICAgICAgICAgIG1ldGEgOiB7cGVyY2VudDoxMDB9XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZSBjb250ZW50IHdhc24ndCBzdHJlYW1lZCwgd2UgbmVlZCB0byBwdXNoIGV2ZXJ5dGhpbmcgbm93XG4gICAgICAgIC8vIGZpcnN0IHRoZSBmaWxlIHJlY29yZCwgdGhlbiB0aGUgY29udGVudFxuICAgICAgICB0aGlzLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IHJlY29yZC5maWxlUmVjb3JkLFxuICAgICAgICAgICAgbWV0YSA6IHtwZXJjZW50OjB9XG4gICAgICAgIH0pO1xuICAgICAgICB3aGlsZSh0aGlzLmNvbnRlbnRCdWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2godGhpcy5jb250ZW50QnVmZmVyLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuY3VycmVudEZpbGUgPSBudWxsO1xufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuZmx1c2hcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgbG9jYWxEaXJMZW5ndGggPSB0aGlzLmJ5dGVzV3JpdHRlbjtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5kaXJSZWNvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogdGhpcy5kaXJSZWNvcmRzW2ldLFxuICAgICAgICAgICAgbWV0YSA6IHtwZXJjZW50OjEwMH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBjZW50cmFsRGlyTGVuZ3RoID0gdGhpcy5ieXRlc1dyaXR0ZW4gLSBsb2NhbERpckxlbmd0aDtcblxuICAgIHZhciBkaXJFbmQgPSBnZW5lcmF0ZUNlbnRyYWxEaXJlY3RvcnlFbmQodGhpcy5kaXJSZWNvcmRzLmxlbmd0aCwgY2VudHJhbERpckxlbmd0aCwgbG9jYWxEaXJMZW5ndGgsIHRoaXMuemlwQ29tbWVudCwgdGhpcy5lbmNvZGVGaWxlTmFtZSk7XG5cbiAgICB0aGlzLnB1c2goe1xuICAgICAgICBkYXRhIDogZGlyRW5kLFxuICAgICAgICBtZXRhIDoge3BlcmNlbnQ6MTAwfVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBQcmVwYXJlIHRoZSBuZXh0IHNvdXJjZSB0byBiZSByZWFkLlxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5wcmVwYXJlTmV4dFNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnByZXZpb3VzID0gdGhpcy5fc291cmNlcy5zaGlmdCgpO1xuICAgIHRoaXMub3BlbmVkU291cmNlKHRoaXMucHJldmlvdXMuc3RyZWFtSW5mbyk7XG4gICAgaWYgKHRoaXMuaXNQYXVzZWQpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91cy5wYXVzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJldmlvdXMucmVzdW1lKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucmVnaXN0ZXJQcmV2aW91c1xuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5yZWdpc3RlclByZXZpb3VzID0gZnVuY3Rpb24gKHByZXZpb3VzKSB7XG4gICAgdGhpcy5fc291cmNlcy5wdXNoKHByZXZpb3VzKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBwcmV2aW91cy5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHNlbGYucHJvY2Vzc0NodW5rKGNodW5rKTtcbiAgICB9KTtcbiAgICBwcmV2aW91cy5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuY2xvc2VkU291cmNlKHNlbGYucHJldmlvdXMuc3RyZWFtSW5mbyk7XG4gICAgICAgIGlmKHNlbGYuX3NvdXJjZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZWxmLnByZXBhcmVOZXh0U291cmNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmVuZCgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcHJldmlvdXMub24oXCJlcnJvclwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBzZWxmLmVycm9yKGUpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucmVzdW1lXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZighR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucmVzdW1lLmNhbGwodGhpcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5wcmV2aW91cyAmJiB0aGlzLl9zb3VyY2VzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnByZXBhcmVOZXh0U291cmNlKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucHJldmlvdXMgJiYgIXRoaXMuX3NvdXJjZXMubGVuZ3RoICYmICF0aGlzLmdlbmVyYXRlZEVycm9yKSB7XG4gICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmVycm9yXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc291cmNlcyA9IHRoaXMuX3NvdXJjZXM7XG4gICAgaWYoIUdlbmVyaWNXb3JrZXIucHJvdG90eXBlLmVycm9yLmNhbGwodGhpcywgZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc291cmNlc1tpXS5lcnJvcihlKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAvLyB0aGUgYGVycm9yYCBleHBsb2RlZCwgbm90aGluZyB0byBkb1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIubG9ja1xuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5sb2NrID0gZnVuY3Rpb24gKCkge1xuICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLmxvY2suY2FsbCh0aGlzKTtcbiAgICB2YXIgc291cmNlcyA9IHRoaXMuX3NvdXJjZXM7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc291cmNlc1tpXS5sb2NrKCk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBaaXBGaWxlV29ya2VyO1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsIkdlbmVyaWNXb3JrZXIiLCJ1dGY4IiwiY3JjMzIiLCJzaWduYXR1cmUiLCJkZWNUb0hleCIsImRlYyIsImJ5dGVzIiwiaGV4IiwiaSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImdlbmVyYXRlVW5peEV4dGVybmFsRmlsZUF0dHIiLCJ1bml4UGVybWlzc2lvbnMiLCJpc0RpciIsInJlc3VsdCIsImdlbmVyYXRlRG9zRXh0ZXJuYWxGaWxlQXR0ciIsImRvc1Blcm1pc3Npb25zIiwiZ2VuZXJhdGVaaXBQYXJ0cyIsInN0cmVhbUluZm8iLCJzdHJlYW1lZENvbnRlbnQiLCJzdHJlYW1pbmdFbmRlZCIsIm9mZnNldCIsInBsYXRmb3JtIiwiZW5jb2RlRmlsZU5hbWUiLCJmaWxlIiwiY29tcHJlc3Npb24iLCJ1c2VDdXN0b21FbmNvZGluZyIsInV0ZjhlbmNvZGUiLCJlbmNvZGVkRmlsZU5hbWUiLCJ0cmFuc2Zvcm1UbyIsIm5hbWUiLCJ1dGZFbmNvZGVkRmlsZU5hbWUiLCJjb21tZW50IiwiZW5jb2RlZENvbW1lbnQiLCJ1dGZFbmNvZGVkQ29tbWVudCIsInVzZVVURjhGb3JGaWxlTmFtZSIsImxlbmd0aCIsInVzZVVURjhGb3JDb21tZW50IiwiZG9zVGltZSIsImRvc0RhdGUiLCJleHRyYUZpZWxkcyIsInVuaWNvZGVQYXRoRXh0cmFGaWVsZCIsInVuaWNvZGVDb21tZW50RXh0cmFGaWVsZCIsImRpciIsImRhdGUiLCJkYXRhSW5mbyIsImNvbXByZXNzZWRTaXplIiwidW5jb21wcmVzc2VkU2l6ZSIsImJpdGZsYWciLCJleHRGaWxlQXR0ciIsInZlcnNpb25NYWRlQnkiLCJnZXRVVENIb3VycyIsImdldFVUQ01pbnV0ZXMiLCJnZXRVVENTZWNvbmRzIiwiZ2V0VVRDRnVsbFllYXIiLCJnZXRVVENNb250aCIsImdldFVUQ0RhdGUiLCJoZWFkZXIiLCJtYWdpYyIsImZpbGVSZWNvcmQiLCJMT0NBTF9GSUxFX0hFQURFUiIsImRpclJlY29yZCIsIkNFTlRSQUxfRklMRV9IRUFERVIiLCJnZW5lcmF0ZUNlbnRyYWxEaXJlY3RvcnlFbmQiLCJlbnRyaWVzQ291bnQiLCJjZW50cmFsRGlyTGVuZ3RoIiwibG9jYWxEaXJMZW5ndGgiLCJkaXJFbmQiLCJDRU5UUkFMX0RJUkVDVE9SWV9FTkQiLCJnZW5lcmF0ZURhdGFEZXNjcmlwdG9ycyIsImRlc2NyaXB0b3IiLCJEQVRBX0RFU0NSSVBUT1IiLCJaaXBGaWxlV29ya2VyIiwic3RyZWFtRmlsZXMiLCJjYWxsIiwiYnl0ZXNXcml0dGVuIiwiemlwQ29tbWVudCIsInppcFBsYXRmb3JtIiwiYWNjdW11bGF0ZSIsImNvbnRlbnRCdWZmZXIiLCJkaXJSZWNvcmRzIiwiY3VycmVudFNvdXJjZU9mZnNldCIsImN1cnJlbnRGaWxlIiwiX3NvdXJjZXMiLCJpbmhlcml0cyIsInByb3RvdHlwZSIsInB1c2giLCJjaHVuayIsImN1cnJlbnRGaWxlUGVyY2VudCIsIm1ldGEiLCJwZXJjZW50IiwicmVtYWluaW5nRmlsZXMiLCJkYXRhIiwib3BlbmVkU291cmNlIiwicmVjb3JkIiwiY2xvc2VkU291cmNlIiwic2hpZnQiLCJmbHVzaCIsInByZXBhcmVOZXh0U291cmNlIiwicHJldmlvdXMiLCJpc1BhdXNlZCIsInBhdXNlIiwicmVzdW1lIiwicmVnaXN0ZXJQcmV2aW91cyIsInNlbGYiLCJvbiIsInByb2Nlc3NDaHVuayIsImVuZCIsImUiLCJlcnJvciIsImdlbmVyYXRlZEVycm9yIiwic291cmNlcyIsImxvY2siLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/generate/ZipFileWorker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/generate/index.js":
/*!**************************************************!*\
  !*** ./node_modules/jszip/lib/generate/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar compressions = __webpack_require__(/*! ../compressions */ \"(ssr)/./node_modules/jszip/lib/compressions.js\");\nvar ZipFileWorker = __webpack_require__(/*! ./ZipFileWorker */ \"(ssr)/./node_modules/jszip/lib/generate/ZipFileWorker.js\");\n/**\n * Find the compression to use.\n * @param {String} fileCompression the compression defined at the file level, if any.\n * @param {String} zipCompression the compression defined at the load() level.\n * @return {Object} the compression object to use.\n */ var getCompression = function(fileCompression, zipCompression) {\n    var compressionName = fileCompression || zipCompression;\n    var compression = compressions[compressionName];\n    if (!compression) {\n        throw new Error(compressionName + \" is not a valid compression method !\");\n    }\n    return compression;\n};\n/**\n * Create a worker to generate a zip file.\n * @param {JSZip} zip the JSZip instance at the right root level.\n * @param {Object} options to generate the zip file.\n * @param {String} comment the comment to use.\n */ exports.generateWorker = function(zip, options, comment) {\n    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);\n    var entriesCount = 0;\n    try {\n        zip.forEach(function(relativePath, file) {\n            entriesCount++;\n            var compression = getCompression(file.options.compression, options.compression);\n            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};\n            var dir = file.dir, date = file.date;\n            file._compressWorker(compression, compressionOptions).withStreamInfo(\"file\", {\n                name: relativePath,\n                dir: dir,\n                date: date,\n                comment: file.comment || \"\",\n                unixPermissions: file.unixPermissions,\n                dosPermissions: file.dosPermissions\n            }).pipe(zipFileWorker);\n        });\n        zipFileWorker.entriesCount = entriesCount;\n    } catch (e) {\n        zipFileWorker.error(e);\n    }\n    return zipFileWorker;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2dlbmVyYXRlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsZUFBZUMsbUJBQU9BLENBQUMsdUVBQWlCO0FBQzVDLElBQUlDLGdCQUFnQkQsbUJBQU9BLENBQUMsaUZBQWlCO0FBRTdDOzs7OztDQUtDLEdBQ0QsSUFBSUUsaUJBQWlCLFNBQVVDLGVBQWUsRUFBRUMsY0FBYztJQUUxRCxJQUFJQyxrQkFBa0JGLG1CQUFtQkM7SUFDekMsSUFBSUUsY0FBY1AsWUFBWSxDQUFDTSxnQkFBZ0I7SUFDL0MsSUFBSSxDQUFDQyxhQUFhO1FBQ2QsTUFBTSxJQUFJQyxNQUFNRixrQkFBa0I7SUFDdEM7SUFDQSxPQUFPQztBQUNYO0FBRUE7Ozs7O0NBS0MsR0FDREUsc0JBQXNCLEdBQUcsU0FBVUUsR0FBRyxFQUFFQyxPQUFPLEVBQUVDLE9BQU87SUFFcEQsSUFBSUMsZ0JBQWdCLElBQUlaLGNBQWNVLFFBQVFHLFdBQVcsRUFBRUYsU0FBU0QsUUFBUUksUUFBUSxFQUFFSixRQUFRSyxjQUFjO0lBQzVHLElBQUlDLGVBQWU7SUFDbkIsSUFBSTtRQUVBUCxJQUFJUSxPQUFPLENBQUMsU0FBVUMsWUFBWSxFQUFFQyxJQUFJO1lBQ3BDSDtZQUNBLElBQUlYLGNBQWNKLGVBQWVrQixLQUFLVCxPQUFPLENBQUNMLFdBQVcsRUFBRUssUUFBUUwsV0FBVztZQUM5RSxJQUFJZSxxQkFBcUJELEtBQUtULE9BQU8sQ0FBQ1Usa0JBQWtCLElBQUlWLFFBQVFVLGtCQUFrQixJQUFJLENBQUM7WUFDM0YsSUFBSUMsTUFBTUYsS0FBS0UsR0FBRyxFQUFFQyxPQUFPSCxLQUFLRyxJQUFJO1lBRXBDSCxLQUFLSSxlQUFlLENBQUNsQixhQUFhZSxvQkFDN0JJLGNBQWMsQ0FBQyxRQUFRO2dCQUNwQkMsTUFBT1A7Z0JBQ1BHLEtBQU1BO2dCQUNOQyxNQUFPQTtnQkFDUFgsU0FBVVEsS0FBS1IsT0FBTyxJQUFJO2dCQUMxQmUsaUJBQWtCUCxLQUFLTyxlQUFlO2dCQUN0Q0MsZ0JBQWlCUixLQUFLUSxjQUFjO1lBQ3hDLEdBQ0NDLElBQUksQ0FBQ2hCO1FBQ2Q7UUFDQUEsY0FBY0ksWUFBWSxHQUFHQTtJQUNqQyxFQUFFLE9BQU9hLEdBQUc7UUFDUmpCLGNBQWNrQixLQUFLLENBQUNEO0lBQ3hCO0lBRUEsT0FBT2pCO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90c2EtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2dlbmVyYXRlL2luZGV4LmpzPzc1MmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjb21wcmVzc2lvbnMgPSByZXF1aXJlKFwiLi4vY29tcHJlc3Npb25zXCIpO1xudmFyIFppcEZpbGVXb3JrZXIgPSByZXF1aXJlKFwiLi9aaXBGaWxlV29ya2VyXCIpO1xuXG4vKipcbiAqIEZpbmQgdGhlIGNvbXByZXNzaW9uIHRvIHVzZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlQ29tcHJlc3Npb24gdGhlIGNvbXByZXNzaW9uIGRlZmluZWQgYXQgdGhlIGZpbGUgbGV2ZWwsIGlmIGFueS5cbiAqIEBwYXJhbSB7U3RyaW5nfSB6aXBDb21wcmVzc2lvbiB0aGUgY29tcHJlc3Npb24gZGVmaW5lZCBhdCB0aGUgbG9hZCgpIGxldmVsLlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgY29tcHJlc3Npb24gb2JqZWN0IHRvIHVzZS5cbiAqL1xudmFyIGdldENvbXByZXNzaW9uID0gZnVuY3Rpb24gKGZpbGVDb21wcmVzc2lvbiwgemlwQ29tcHJlc3Npb24pIHtcblxuICAgIHZhciBjb21wcmVzc2lvbk5hbWUgPSBmaWxlQ29tcHJlc3Npb24gfHwgemlwQ29tcHJlc3Npb247XG4gICAgdmFyIGNvbXByZXNzaW9uID0gY29tcHJlc3Npb25zW2NvbXByZXNzaW9uTmFtZV07XG4gICAgaWYgKCFjb21wcmVzc2lvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY29tcHJlc3Npb25OYW1lICsgXCIgaXMgbm90IGEgdmFsaWQgY29tcHJlc3Npb24gbWV0aG9kICFcIik7XG4gICAgfVxuICAgIHJldHVybiBjb21wcmVzc2lvbjtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgd29ya2VyIHRvIGdlbmVyYXRlIGEgemlwIGZpbGUuXG4gKiBAcGFyYW0ge0pTWmlwfSB6aXAgdGhlIEpTWmlwIGluc3RhbmNlIGF0IHRoZSByaWdodCByb290IGxldmVsLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdG8gZ2VuZXJhdGUgdGhlIHppcCBmaWxlLlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbW1lbnQgdGhlIGNvbW1lbnQgdG8gdXNlLlxuICovXG5leHBvcnRzLmdlbmVyYXRlV29ya2VyID0gZnVuY3Rpb24gKHppcCwgb3B0aW9ucywgY29tbWVudCkge1xuXG4gICAgdmFyIHppcEZpbGVXb3JrZXIgPSBuZXcgWmlwRmlsZVdvcmtlcihvcHRpb25zLnN0cmVhbUZpbGVzLCBjb21tZW50LCBvcHRpb25zLnBsYXRmb3JtLCBvcHRpb25zLmVuY29kZUZpbGVOYW1lKTtcbiAgICB2YXIgZW50cmllc0NvdW50ID0gMDtcbiAgICB0cnkge1xuXG4gICAgICAgIHppcC5mb3JFYWNoKGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIGZpbGUpIHtcbiAgICAgICAgICAgIGVudHJpZXNDb3VudCsrO1xuICAgICAgICAgICAgdmFyIGNvbXByZXNzaW9uID0gZ2V0Q29tcHJlc3Npb24oZmlsZS5vcHRpb25zLmNvbXByZXNzaW9uLCBvcHRpb25zLmNvbXByZXNzaW9uKTtcbiAgICAgICAgICAgIHZhciBjb21wcmVzc2lvbk9wdGlvbnMgPSBmaWxlLm9wdGlvbnMuY29tcHJlc3Npb25PcHRpb25zIHx8IG9wdGlvbnMuY29tcHJlc3Npb25PcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGRpciA9IGZpbGUuZGlyLCBkYXRlID0gZmlsZS5kYXRlO1xuXG4gICAgICAgICAgICBmaWxlLl9jb21wcmVzc1dvcmtlcihjb21wcmVzc2lvbiwgY29tcHJlc3Npb25PcHRpb25zKVxuICAgICAgICAgICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImZpbGVcIiwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lIDogcmVsYXRpdmVQYXRoLFxuICAgICAgICAgICAgICAgICAgICBkaXIgOiBkaXIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGUgOiBkYXRlLFxuICAgICAgICAgICAgICAgICAgICBjb21tZW50IDogZmlsZS5jb21tZW50IHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIHVuaXhQZXJtaXNzaW9ucyA6IGZpbGUudW5peFBlcm1pc3Npb25zLFxuICAgICAgICAgICAgICAgICAgICBkb3NQZXJtaXNzaW9ucyA6IGZpbGUuZG9zUGVybWlzc2lvbnNcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5waXBlKHppcEZpbGVXb3JrZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgemlwRmlsZVdvcmtlci5lbnRyaWVzQ291bnQgPSBlbnRyaWVzQ291bnQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB6aXBGaWxlV29ya2VyLmVycm9yKGUpO1xuICAgIH1cblxuICAgIHJldHVybiB6aXBGaWxlV29ya2VyO1xufTtcbiJdLCJuYW1lcyI6WyJjb21wcmVzc2lvbnMiLCJyZXF1aXJlIiwiWmlwRmlsZVdvcmtlciIsImdldENvbXByZXNzaW9uIiwiZmlsZUNvbXByZXNzaW9uIiwiemlwQ29tcHJlc3Npb24iLCJjb21wcmVzc2lvbk5hbWUiLCJjb21wcmVzc2lvbiIsIkVycm9yIiwiZXhwb3J0cyIsImdlbmVyYXRlV29ya2VyIiwiemlwIiwib3B0aW9ucyIsImNvbW1lbnQiLCJ6aXBGaWxlV29ya2VyIiwic3RyZWFtRmlsZXMiLCJwbGF0Zm9ybSIsImVuY29kZUZpbGVOYW1lIiwiZW50cmllc0NvdW50IiwiZm9yRWFjaCIsInJlbGF0aXZlUGF0aCIsImZpbGUiLCJjb21wcmVzc2lvbk9wdGlvbnMiLCJkaXIiLCJkYXRlIiwiX2NvbXByZXNzV29ya2VyIiwid2l0aFN0cmVhbUluZm8iLCJuYW1lIiwidW5peFBlcm1pc3Npb25zIiwiZG9zUGVybWlzc2lvbnMiLCJwaXBlIiwiZSIsImVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/generate/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/jszip/lib/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * Representation a of zip file in js\n * @constructor\n */ function JSZip() {\n    // if this constructor is used without `new`, it adds `new` before itself:\n    if (!(this instanceof JSZip)) {\n        return new JSZip();\n    }\n    if (arguments.length) {\n        throw new Error(\"The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.\");\n    }\n    // object containing the files :\n    // {\n    //   \"folder/\" : {...},\n    //   \"folder/data.txt\" : {...}\n    // }\n    // NOTE: we use a null prototype because we do not\n    // want filenames like \"toString\" coming from a zip file\n    // to overwrite methods and attributes in a normal Object.\n    this.files = Object.create(null);\n    this.comment = null;\n    // Where we are in the hierarchy\n    this.root = \"\";\n    this.clone = function() {\n        var newObj = new JSZip();\n        for(var i in this){\n            if (typeof this[i] !== \"function\") {\n                newObj[i] = this[i];\n            }\n        }\n        return newObj;\n    };\n}\nJSZip.prototype = __webpack_require__(/*! ./object */ \"(ssr)/./node_modules/jszip/lib/object.js\");\nJSZip.prototype.loadAsync = __webpack_require__(/*! ./load */ \"(ssr)/./node_modules/jszip/lib/load.js\");\nJSZip.support = __webpack_require__(/*! ./support */ \"(ssr)/./node_modules/jszip/lib/support.js\");\nJSZip.defaults = __webpack_require__(/*! ./defaults */ \"(ssr)/./node_modules/jszip/lib/defaults.js\");\n// TODO find a better way to handle this version,\n// a require('package.json').version doesn't work with webpack, see #327\nJSZip.version = \"3.10.1\";\nJSZip.loadAsync = function(content, options) {\n    return new JSZip().loadAsync(content, options);\n};\nJSZip.external = __webpack_require__(/*! ./external */ \"(ssr)/./node_modules/jszip/lib/external.js\");\nmodule.exports = JSZip;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWI7OztDQUdDLEdBQ0QsU0FBU0E7SUFDTCwwRUFBMEU7SUFDMUUsSUFBRyxDQUFFLEtBQUksWUFBWUEsS0FBSSxHQUFJO1FBQ3pCLE9BQU8sSUFBSUE7SUFDZjtJQUVBLElBQUdDLFVBQVVDLE1BQU0sRUFBRTtRQUNqQixNQUFNLElBQUlDLE1BQU07SUFDcEI7SUFFQSxnQ0FBZ0M7SUFDaEMsSUFBSTtJQUNKLHVCQUF1QjtJQUN2Qiw4QkFBOEI7SUFDOUIsSUFBSTtJQUNKLGtEQUFrRDtJQUNsRCx3REFBd0Q7SUFDeEQsMERBQTBEO0lBQzFELElBQUksQ0FBQ0MsS0FBSyxHQUFHQyxPQUFPQyxNQUFNLENBQUM7SUFFM0IsSUFBSSxDQUFDQyxPQUFPLEdBQUc7SUFFZixnQ0FBZ0M7SUFDaEMsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDWixJQUFJLENBQUNDLEtBQUssR0FBRztRQUNULElBQUlDLFNBQVMsSUFBSVY7UUFDakIsSUFBSyxJQUFJVyxLQUFLLElBQUksQ0FBRTtZQUNoQixJQUFJLE9BQU8sSUFBSSxDQUFDQSxFQUFFLEtBQUssWUFBWTtnQkFDL0JELE1BQU0sQ0FBQ0MsRUFBRSxHQUFHLElBQUksQ0FBQ0EsRUFBRTtZQUN2QjtRQUNKO1FBQ0EsT0FBT0Q7SUFDWDtBQUNKO0FBQ0FWLE1BQU1ZLFNBQVMsR0FBR0MsbUJBQU9BLENBQUMsMERBQVU7QUFDcENiLE1BQU1ZLFNBQVMsQ0FBQ0UsU0FBUyxHQUFHRCxtQkFBT0EsQ0FBQyxzREFBUTtBQUM1Q2IsTUFBTWUsT0FBTyxHQUFHRixtQkFBT0EsQ0FBQyw0REFBVztBQUNuQ2IsTUFBTWdCLFFBQVEsR0FBR0gsbUJBQU9BLENBQUMsOERBQVk7QUFFckMsaURBQWlEO0FBQ2pELHdFQUF3RTtBQUN4RWIsTUFBTWlCLE9BQU8sR0FBRztBQUVoQmpCLE1BQU1jLFNBQVMsR0FBRyxTQUFVSSxPQUFPLEVBQUVDLE9BQU87SUFDeEMsT0FBTyxJQUFJbkIsUUFBUWMsU0FBUyxDQUFDSSxTQUFTQztBQUMxQztBQUVBbkIsTUFBTW9CLFFBQVEsR0FBR1AsbUJBQU9BLENBQUMsOERBQVk7QUFDckNRLE9BQU9DLE9BQU8sR0FBR3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHNhLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9pbmRleC5qcz80ZWY1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIGEgb2YgemlwIGZpbGUgaW4ganNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBKU1ppcCgpIHtcbiAgICAvLyBpZiB0aGlzIGNvbnN0cnVjdG9yIGlzIHVzZWQgd2l0aG91dCBgbmV3YCwgaXQgYWRkcyBgbmV3YCBiZWZvcmUgaXRzZWxmOlxuICAgIGlmKCEodGhpcyBpbnN0YW5jZW9mIEpTWmlwKSkge1xuICAgICAgICByZXR1cm4gbmV3IEpTWmlwKCk7XG4gICAgfVxuXG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY29uc3RydWN0b3Igd2l0aCBwYXJhbWV0ZXJzIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xuICAgIH1cblxuICAgIC8vIG9iamVjdCBjb250YWluaW5nIHRoZSBmaWxlcyA6XG4gICAgLy8ge1xuICAgIC8vICAgXCJmb2xkZXIvXCIgOiB7Li4ufSxcbiAgICAvLyAgIFwiZm9sZGVyL2RhdGEudHh0XCIgOiB7Li4ufVxuICAgIC8vIH1cbiAgICAvLyBOT1RFOiB3ZSB1c2UgYSBudWxsIHByb3RvdHlwZSBiZWNhdXNlIHdlIGRvIG5vdFxuICAgIC8vIHdhbnQgZmlsZW5hbWVzIGxpa2UgXCJ0b1N0cmluZ1wiIGNvbWluZyBmcm9tIGEgemlwIGZpbGVcbiAgICAvLyB0byBvdmVyd3JpdGUgbWV0aG9kcyBhbmQgYXR0cmlidXRlcyBpbiBhIG5vcm1hbCBPYmplY3QuXG4gICAgdGhpcy5maWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICB0aGlzLmNvbW1lbnQgPSBudWxsO1xuXG4gICAgLy8gV2hlcmUgd2UgYXJlIGluIHRoZSBoaWVyYXJjaHlcbiAgICB0aGlzLnJvb3QgPSBcIlwiO1xuICAgIHRoaXMuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5ld09iaiA9IG5ldyBKU1ppcCgpO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpc1tpXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbmV3T2JqW2ldID0gdGhpc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH07XG59XG5KU1ppcC5wcm90b3R5cGUgPSByZXF1aXJlKFwiLi9vYmplY3RcIik7XG5KU1ppcC5wcm90b3R5cGUubG9hZEFzeW5jID0gcmVxdWlyZShcIi4vbG9hZFwiKTtcbkpTWmlwLnN1cHBvcnQgPSByZXF1aXJlKFwiLi9zdXBwb3J0XCIpO1xuSlNaaXAuZGVmYXVsdHMgPSByZXF1aXJlKFwiLi9kZWZhdWx0c1wiKTtcblxuLy8gVE9ETyBmaW5kIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcyB2ZXJzaW9uLFxuLy8gYSByZXF1aXJlKCdwYWNrYWdlLmpzb24nKS52ZXJzaW9uIGRvZXNuJ3Qgd29yayB3aXRoIHdlYnBhY2ssIHNlZSAjMzI3XG5KU1ppcC52ZXJzaW9uID0gXCIzLjEwLjFcIjtcblxuSlNaaXAubG9hZEFzeW5jID0gZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEpTWmlwKCkubG9hZEFzeW5jKGNvbnRlbnQsIG9wdGlvbnMpO1xufTtcblxuSlNaaXAuZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi9leHRlcm5hbFwiKTtcbm1vZHVsZS5leHBvcnRzID0gSlNaaXA7XG4iXSwibmFtZXMiOlsiSlNaaXAiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJFcnJvciIsImZpbGVzIiwiT2JqZWN0IiwiY3JlYXRlIiwiY29tbWVudCIsInJvb3QiLCJjbG9uZSIsIm5ld09iaiIsImkiLCJwcm90b3R5cGUiLCJyZXF1aXJlIiwibG9hZEFzeW5jIiwic3VwcG9ydCIsImRlZmF1bHRzIiwidmVyc2lvbiIsImNvbnRlbnQiLCJvcHRpb25zIiwiZXh0ZXJuYWwiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/load.js":
/*!****************************************!*\
  !*** ./node_modules/jszip/lib/load.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nvar external = __webpack_require__(/*! ./external */ \"(ssr)/./node_modules/jszip/lib/external.js\");\nvar utf8 = __webpack_require__(/*! ./utf8 */ \"(ssr)/./node_modules/jszip/lib/utf8.js\");\nvar ZipEntries = __webpack_require__(/*! ./zipEntries */ \"(ssr)/./node_modules/jszip/lib/zipEntries.js\");\nvar Crc32Probe = __webpack_require__(/*! ./stream/Crc32Probe */ \"(ssr)/./node_modules/jszip/lib/stream/Crc32Probe.js\");\nvar nodejsUtils = __webpack_require__(/*! ./nodejsUtils */ \"(ssr)/./node_modules/jszip/lib/nodejsUtils.js\");\n/**\n * Check the CRC32 of an entry.\n * @param {ZipEntry} zipEntry the zip entry to check.\n * @return {Promise} the result.\n */ function checkEntryCRC32(zipEntry) {\n    return new external.Promise(function(resolve, reject) {\n        var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());\n        worker.on(\"error\", function(e) {\n            reject(e);\n        }).on(\"end\", function() {\n            if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {\n                reject(new Error(\"Corrupted zip : CRC32 mismatch\"));\n            } else {\n                resolve();\n            }\n        }).resume();\n    });\n}\nmodule.exports = function(data, options) {\n    var zip = this;\n    options = utils.extend(options || {}, {\n        base64: false,\n        checkCRC32: false,\n        optimizedBinaryString: false,\n        createFolders: false,\n        decodeFileName: utf8.utf8decode\n    });\n    if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {\n        return external.Promise.reject(new Error(\"JSZip can't accept a stream when loading a zip file.\"));\n    }\n    return utils.prepareContent(\"the loaded zip file\", data, true, options.optimizedBinaryString, options.base64).then(function(data) {\n        var zipEntries = new ZipEntries(options);\n        zipEntries.load(data);\n        return zipEntries;\n    }).then(function checkCRC32(zipEntries) {\n        var promises = [\n            external.Promise.resolve(zipEntries)\n        ];\n        var files = zipEntries.files;\n        if (options.checkCRC32) {\n            for(var i = 0; i < files.length; i++){\n                promises.push(checkEntryCRC32(files[i]));\n            }\n        }\n        return external.Promise.all(promises);\n    }).then(function addFiles(results) {\n        var zipEntries = results.shift();\n        var files = zipEntries.files;\n        for(var i = 0; i < files.length; i++){\n            var input = files[i];\n            var unsafeName = input.fileNameStr;\n            var safeName = utils.resolve(input.fileNameStr);\n            zip.file(safeName, input.decompressed, {\n                binary: true,\n                optimizedBinaryString: true,\n                date: input.date,\n                dir: input.dir,\n                comment: input.fileCommentStr.length ? input.fileCommentStr : null,\n                unixPermissions: input.unixPermissions,\n                dosPermissions: input.dosPermissions,\n                createFolders: options.createFolders\n            });\n            if (!input.dir) {\n                zip.file(safeName).unsafeOriginalName = unsafeName;\n            }\n        }\n        if (zipEntries.zipComment.length) {\n            zip.comment = zipEntries.zipComment;\n        }\n        return zip;\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Z0JBQ3ZCeUIsTUFBTU4sTUFBTU0sSUFBSTtnQkFDaEJDLEtBQUtQLE1BQU1PLEdBQUc7Z0JBQ2RDLFNBQVNSLE1BQU1TLGNBQWMsQ0FBQ2YsTUFBTSxHQUFHTSxNQUFNUyxjQUFjLEdBQUc7Z0JBQzlEQyxpQkFBaUJWLE1BQU1VLGVBQWU7Z0JBQ3RDQyxnQkFBZ0JYLE1BQU1XLGNBQWM7Z0JBQ3BDN0IsZUFBZU4sUUFBUU0sYUFBYTtZQUN4QztZQUNBLElBQUksQ0FBQ2tCLE1BQU1PLEdBQUcsRUFBRTtnQkFDWjlCLElBQUkyQixJQUFJLENBQUNELFVBQVVTLGtCQUFrQixHQUFHWDtZQUM1QztRQUNKO1FBQ0EsSUFBSVosV0FBV3dCLFVBQVUsQ0FBQ25CLE1BQU0sRUFBRTtZQUM5QmpCLElBQUkrQixPQUFPLEdBQUduQixXQUFXd0IsVUFBVTtRQUN2QztRQUVBLE9BQU9wQztJQUNYO0FBQ1IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90c2EtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL2xvYWQuanM/Yzk5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIGV4dGVybmFsID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxcIik7XG52YXIgdXRmOCA9IHJlcXVpcmUoXCIuL3V0ZjhcIik7XG52YXIgWmlwRW50cmllcyA9IHJlcXVpcmUoXCIuL3ppcEVudHJpZXNcIik7XG52YXIgQ3JjMzJQcm9iZSA9IHJlcXVpcmUoXCIuL3N0cmVhbS9DcmMzMlByb2JlXCIpO1xudmFyIG5vZGVqc1V0aWxzID0gcmVxdWlyZShcIi4vbm9kZWpzVXRpbHNcIik7XG5cbi8qKlxuICogQ2hlY2sgdGhlIENSQzMyIG9mIGFuIGVudHJ5LlxuICogQHBhcmFtIHtaaXBFbnRyeX0gemlwRW50cnkgdGhlIHppcCBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm4ge1Byb21pc2V9IHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrRW50cnlDUkMzMih6aXBFbnRyeSkge1xuICAgIHJldHVybiBuZXcgZXh0ZXJuYWwuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciB3b3JrZXIgPSB6aXBFbnRyeS5kZWNvbXByZXNzZWQuZ2V0Q29udGVudFdvcmtlcigpLnBpcGUobmV3IENyYzMyUHJvYmUoKSk7XG4gICAgICAgIHdvcmtlci5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh3b3JrZXIuc3RyZWFtSW5mby5jcmMzMiAhPT0gemlwRW50cnkuZGVjb21wcmVzc2VkLmNyYzMyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwIDogQ1JDMzIgbWlzbWF0Y2hcIikpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlc3VtZSgpO1xuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkYXRhLCBvcHRpb25zKSB7XG4gICAgdmFyIHppcCA9IHRoaXM7XG4gICAgb3B0aW9ucyA9IHV0aWxzLmV4dGVuZChvcHRpb25zIHx8IHt9LCB7XG4gICAgICAgIGJhc2U2NDogZmFsc2UsXG4gICAgICAgIGNoZWNrQ1JDMzI6IGZhbHNlLFxuICAgICAgICBvcHRpbWl6ZWRCaW5hcnlTdHJpbmc6IGZhbHNlLFxuICAgICAgICBjcmVhdGVGb2xkZXJzOiBmYWxzZSxcbiAgICAgICAgZGVjb2RlRmlsZU5hbWU6IHV0ZjgudXRmOGRlY29kZVxuICAgIH0pO1xuXG4gICAgaWYgKG5vZGVqc1V0aWxzLmlzTm9kZSAmJiBub2RlanNVdGlscy5pc1N0cmVhbShkYXRhKSkge1xuICAgICAgICByZXR1cm4gZXh0ZXJuYWwuUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSlNaaXAgY2FuJ3QgYWNjZXB0IGEgc3RyZWFtIHdoZW4gbG9hZGluZyBhIHppcCBmaWxlLlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWxzLnByZXBhcmVDb250ZW50KFwidGhlIGxvYWRlZCB6aXAgZmlsZVwiLCBkYXRhLCB0cnVlLCBvcHRpb25zLm9wdGltaXplZEJpbmFyeVN0cmluZywgb3B0aW9ucy5iYXNlNjQpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgemlwRW50cmllcyA9IG5ldyBaaXBFbnRyaWVzKG9wdGlvbnMpO1xuICAgICAgICAgICAgemlwRW50cmllcy5sb2FkKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHppcEVudHJpZXM7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gY2hlY2tDUkMzMih6aXBFbnRyaWVzKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbZXh0ZXJuYWwuUHJvbWlzZS5yZXNvbHZlKHppcEVudHJpZXMpXTtcbiAgICAgICAgICAgIHZhciBmaWxlcyA9IHppcEVudHJpZXMuZmlsZXM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jaGVja0NSQzMyKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGNoZWNrRW50cnlDUkMzMihmaWxlc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBleHRlcm5hbC5Qcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gYWRkRmlsZXMocmVzdWx0cykge1xuICAgICAgICAgICAgdmFyIHppcEVudHJpZXMgPSByZXN1bHRzLnNoaWZ0KCk7XG4gICAgICAgICAgICB2YXIgZmlsZXMgPSB6aXBFbnRyaWVzLmZpbGVzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IGZpbGVzW2ldO1xuXG4gICAgICAgICAgICAgICAgdmFyIHVuc2FmZU5hbWUgPSBpbnB1dC5maWxlTmFtZVN0cjtcbiAgICAgICAgICAgICAgICB2YXIgc2FmZU5hbWUgPSB1dGlscy5yZXNvbHZlKGlucHV0LmZpbGVOYW1lU3RyKTtcblxuICAgICAgICAgICAgICAgIHppcC5maWxlKHNhZmVOYW1lLCBpbnB1dC5kZWNvbXByZXNzZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgYmluYXJ5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBvcHRpbWl6ZWRCaW5hcnlTdHJpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGU6IGlucHV0LmRhdGUsXG4gICAgICAgICAgICAgICAgICAgIGRpcjogaW5wdXQuZGlyLFxuICAgICAgICAgICAgICAgICAgICBjb21tZW50OiBpbnB1dC5maWxlQ29tbWVudFN0ci5sZW5ndGggPyBpbnB1dC5maWxlQ29tbWVudFN0ciA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHVuaXhQZXJtaXNzaW9uczogaW5wdXQudW5peFBlcm1pc3Npb25zLFxuICAgICAgICAgICAgICAgICAgICBkb3NQZXJtaXNzaW9uczogaW5wdXQuZG9zUGVybWlzc2lvbnMsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUZvbGRlcnM6IG9wdGlvbnMuY3JlYXRlRm9sZGVyc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghaW5wdXQuZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIHppcC5maWxlKHNhZmVOYW1lKS51bnNhZmVPcmlnaW5hbE5hbWUgPSB1bnNhZmVOYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh6aXBFbnRyaWVzLnppcENvbW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgemlwLmNvbW1lbnQgPSB6aXBFbnRyaWVzLnppcENvbW1lbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB6aXA7XG4gICAgICAgIH0pO1xufTtcbiJdLCJuYW1lcyI6WyJ1dGlscyIsInJlcXVpcmUiLCJleHRlcm5hbCIsInV0ZjgiLCJaaXBFbnRyaWVzIiwiQ3JjMzJQcm9iZSIsIm5vZGVqc1V0aWxzIiwiY2hlY2tFbnRyeUNSQzMyIiwiemlwRW50cnkiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIndvcmtlciIsImRlY29tcHJlc3NlZCIsImdldENvbnRlbnRXb3JrZXIiLCJwaXBlIiwib24iLCJlIiwic3RyZWFtSW5mbyIsImNyYzMyIiwiRXJyb3IiLCJyZXN1bWUiLCJtb2R1bGUiLCJleHBvcnRzIiwiZGF0YSIsIm9wdGlvbnMiLCJ6aXAiLCJleHRlbmQiLCJiYXNlNjQiLCJjaGVja0NSQzMyIiwib3B0aW1pemVkQmluYXJ5U3RyaW5nIiwiY3JlYXRlRm9sZGVycyIsImRlY29kZUZpbGVOYW1lIiwidXRmOGRlY29kZSIsImlzTm9kZSIsImlzU3RyZWFtIiwicHJlcGFyZUNvbnRlbnQiLCJ0aGVuIiwiemlwRW50cmllcyIsImxvYWQiLCJwcm9taXNlcyIsImZpbGVzIiwiaSIsImxlbmd0aCIsInB1c2giLCJhbGwiLCJhZGRGaWxlcyIsInJlc3VsdHMiLCJzaGlmdCIsImlucHV0IiwidW5zYWZlTmFtZSIsImZpbGVOYW1lU3RyIiwic2FmZU5hbWUiLCJmaWxlIiwiYmluYXJ5IiwiZGF0ZSIsImRpciIsImNvbW1lbnQiLCJmaWxlQ29tbWVudFN0ciIsInVuaXhQZXJtaXNzaW9ucyIsImRvc1Blcm1pc3Npb25zIiwidW5zYWZlT3JpZ2luYWxOYW1lIiwiemlwQ29tbWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/load.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js":
/*!*******************************************************************!*\
  !*** ./node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nvar GenericWorker = __webpack_require__(/*! ../stream/GenericWorker */ \"(ssr)/./node_modules/jszip/lib/stream/GenericWorker.js\");\n/**\n * A worker that use a nodejs stream as source.\n * @constructor\n * @param {String} filename the name of the file entry for this stream.\n * @param {Readable} stream the nodejs stream.\n */ function NodejsStreamInputAdapter(filename, stream) {\n    GenericWorker.call(this, \"Nodejs stream input adapter for \" + filename);\n    this._upstreamEnded = false;\n    this._bindStream(stream);\n}\nutils.inherits(NodejsStreamInputAdapter, GenericWorker);\n/**\n * Prepare the stream and bind the callbacks on it.\n * Do this ASAP on node 0.10 ! A lazy binding doesn't always work.\n * @param {Stream} stream the nodejs stream to use.\n */ NodejsStreamInputAdapter.prototype._bindStream = function(stream) {\n    var self = this;\n    this._stream = stream;\n    stream.pause();\n    stream.on(\"data\", function(chunk) {\n        self.push({\n            data: chunk,\n            meta: {\n                percent: 0\n            }\n        });\n    }).on(\"error\", function(e) {\n        if (self.isPaused) {\n            this.generatedError = e;\n        } else {\n            self.error(e);\n        }\n    }).on(\"end\", function() {\n        if (self.isPaused) {\n            self._upstreamEnded = true;\n        } else {\n            self.end();\n        }\n    });\n};\nNodejsStreamInputAdapter.prototype.pause = function() {\n    if (!GenericWorker.prototype.pause.call(this)) {\n        return false;\n    }\n    this._stream.pause();\n    return true;\n};\nNodejsStreamInputAdapter.prototype.resume = function() {\n    if (!GenericWorker.prototype.resume.call(this)) {\n        return false;\n    }\n    if (this._upstreamEnded) {\n        this.end();\n    } else {\n        this._stream.resume();\n    }\n    return true;\n};\nmodule.exports = NodejsStreamInputAdapter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL25vZGVqcy9Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQyx5REFBVTtBQUM5QixJQUFJQyxnQkFBZ0JELG1CQUFPQSxDQUFDLHVGQUF5QjtBQUVyRDs7Ozs7Q0FLQyxHQUNELFNBQVNFLHlCQUF5QkMsUUFBUSxFQUFFQyxNQUFNO0lBQzlDSCxjQUFjSSxJQUFJLENBQUMsSUFBSSxFQUFFLHFDQUFxQ0Y7SUFDOUQsSUFBSSxDQUFDRyxjQUFjLEdBQUc7SUFDdEIsSUFBSSxDQUFDQyxXQUFXLENBQUNIO0FBQ3JCO0FBRUFMLE1BQU1TLFFBQVEsQ0FBQ04sMEJBQTBCRDtBQUV6Qzs7OztDQUlDLEdBQ0RDLHlCQUF5Qk8sU0FBUyxDQUFDRixXQUFXLEdBQUcsU0FBVUgsTUFBTTtJQUM3RCxJQUFJTSxPQUFPLElBQUk7SUFDZixJQUFJLENBQUNDLE9BQU8sR0FBR1A7SUFDZkEsT0FBT1EsS0FBSztJQUNaUixPQUNLUyxFQUFFLENBQUMsUUFBUSxTQUFVQyxLQUFLO1FBQ3ZCSixLQUFLSyxJQUFJLENBQUM7WUFDTkMsTUFBTUY7WUFDTkcsTUFBTztnQkFDSEMsU0FBVTtZQUNkO1FBQ0o7SUFDSixHQUNDTCxFQUFFLENBQUMsU0FBUyxTQUFVTSxDQUFDO1FBQ3BCLElBQUdULEtBQUtVLFFBQVEsRUFBRTtZQUNkLElBQUksQ0FBQ0MsY0FBYyxHQUFHRjtRQUMxQixPQUFPO1lBQ0hULEtBQUtZLEtBQUssQ0FBQ0g7UUFDZjtJQUNKLEdBQ0NOLEVBQUUsQ0FBQyxPQUFPO1FBQ1AsSUFBR0gsS0FBS1UsUUFBUSxFQUFFO1lBQ2RWLEtBQUtKLGNBQWMsR0FBRztRQUMxQixPQUFPO1lBQ0hJLEtBQUthLEdBQUc7UUFDWjtJQUNKO0FBQ1I7QUFDQXJCLHlCQUF5Qk8sU0FBUyxDQUFDRyxLQUFLLEdBQUc7SUFDdkMsSUFBRyxDQUFDWCxjQUFjUSxTQUFTLENBQUNHLEtBQUssQ0FBQ1AsSUFBSSxDQUFDLElBQUksR0FBRztRQUMxQyxPQUFPO0lBQ1g7SUFDQSxJQUFJLENBQUNNLE9BQU8sQ0FBQ0MsS0FBSztJQUNsQixPQUFPO0FBQ1g7QUFDQVYseUJBQXlCTyxTQUFTLENBQUNlLE1BQU0sR0FBRztJQUN4QyxJQUFHLENBQUN2QixjQUFjUSxTQUFTLENBQUNlLE1BQU0sQ0FBQ25CLElBQUksQ0FBQyxJQUFJLEdBQUc7UUFDM0MsT0FBTztJQUNYO0lBRUEsSUFBRyxJQUFJLENBQUNDLGNBQWMsRUFBRTtRQUNwQixJQUFJLENBQUNpQixHQUFHO0lBQ1osT0FBTztRQUNILElBQUksQ0FBQ1osT0FBTyxDQUFDYSxNQUFNO0lBQ3ZCO0lBRUEsT0FBTztBQUNYO0FBRUFDLE9BQU9DLE9BQU8sR0FBR3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHNhLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9ub2RlanMvTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyLmpzPzgxNzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZShcIi4uL3N0cmVhbS9HZW5lcmljV29ya2VyXCIpO1xuXG4vKipcbiAqIEEgd29ya2VyIHRoYXQgdXNlIGEgbm9kZWpzIHN0cmVhbSBhcyBzb3VyY2UuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZSBlbnRyeSBmb3IgdGhpcyBzdHJlYW0uXG4gKiBAcGFyYW0ge1JlYWRhYmxlfSBzdHJlYW0gdGhlIG5vZGVqcyBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlcihmaWxlbmFtZSwgc3RyZWFtKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiTm9kZWpzIHN0cmVhbSBpbnB1dCBhZGFwdGVyIGZvciBcIiArIGZpbGVuYW1lKTtcbiAgICB0aGlzLl91cHN0cmVhbUVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYmluZFN0cmVhbShzdHJlYW0pO1xufVxuXG51dGlscy5pbmhlcml0cyhOb2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIFByZXBhcmUgdGhlIHN0cmVhbSBhbmQgYmluZCB0aGUgY2FsbGJhY2tzIG9uIGl0LlxuICogRG8gdGhpcyBBU0FQIG9uIG5vZGUgMC4xMCAhIEEgbGF6eSBiaW5kaW5nIGRvZXNuJ3QgYWx3YXlzIHdvcmsuXG4gKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtIHRoZSBub2RlanMgc3RyZWFtIHRvIHVzZS5cbiAqL1xuTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyLnByb3RvdHlwZS5fYmluZFN0cmVhbSA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIHN0cmVhbVxuICAgICAgICAub24oXCJkYXRhXCIsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgICAgc2VsZi5wdXNoKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjaHVuayxcbiAgICAgICAgICAgICAgICBtZXRhIDoge1xuICAgICAgICAgICAgICAgICAgICBwZXJjZW50IDogMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAub24oXCJlcnJvclwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYoc2VsZi5pc1BhdXNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVkRXJyb3IgPSBlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYoc2VsZi5pc1BhdXNlZCkge1xuICAgICAgICAgICAgICAgIHNlbGYuX3Vwc3RyZWFtRW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbn07XG5Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKCFHZW5lcmljV29ya2VyLnByb3RvdHlwZS5wYXVzZS5jYWxsKHRoaXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5fc3RyZWFtLnBhdXNlKCk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoIUdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnJlc3VtZS5jYWxsKHRoaXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZih0aGlzLl91cHN0cmVhbUVuZGVkKSB7XG4gICAgICAgIHRoaXMuZW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlanNTdHJlYW1JbnB1dEFkYXB0ZXI7XG4iXSwibmFtZXMiOlsidXRpbHMiLCJyZXF1aXJlIiwiR2VuZXJpY1dvcmtlciIsIk5vZGVqc1N0cmVhbUlucHV0QWRhcHRlciIsImZpbGVuYW1lIiwic3RyZWFtIiwiY2FsbCIsIl91cHN0cmVhbUVuZGVkIiwiX2JpbmRTdHJlYW0iLCJpbmhlcml0cyIsInByb3RvdHlwZSIsInNlbGYiLCJfc3RyZWFtIiwicGF1c2UiLCJvbiIsImNodW5rIiwicHVzaCIsImRhdGEiLCJtZXRhIiwicGVyY2VudCIsImUiLCJpc1BhdXNlZCIsImdlbmVyYXRlZEVycm9yIiwiZXJyb3IiLCJlbmQiLCJyZXN1bWUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js":
/*!********************************************************************!*\
  !*** ./node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar Readable = (__webpack_require__(/*! readable-stream */ \"(ssr)/./node_modules/readable-stream/readable.js\").Readable);\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nutils.inherits(NodejsStreamOutputAdapter, Readable);\n/**\n* A nodejs stream using a worker as source.\n* @see the SourceWrapper in http://nodejs.org/api/stream.html\n* @constructor\n* @param {StreamHelper} helper the helper wrapping the worker\n* @param {Object} options the nodejs stream options\n* @param {Function} updateCb the update callback.\n*/ function NodejsStreamOutputAdapter(helper, options, updateCb) {\n    Readable.call(this, options);\n    this._helper = helper;\n    var self = this;\n    helper.on(\"data\", function(data, meta) {\n        if (!self.push(data)) {\n            self._helper.pause();\n        }\n        if (updateCb) {\n            updateCb(meta);\n        }\n    }).on(\"error\", function(e) {\n        self.emit(\"error\", e);\n    }).on(\"end\", function() {\n        self.push(null);\n    });\n}\nNodejsStreamOutputAdapter.prototype._read = function() {\n    this._helper.resume();\n};\nmodule.exports = NodejsStreamOutputAdapter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL25vZGVqcy9Ob2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsV0FBV0MseUdBQW1DO0FBRWxELElBQUlDLFFBQVFELG1CQUFPQSxDQUFDLHlEQUFVO0FBQzlCQyxNQUFNQyxRQUFRLENBQUNDLDJCQUEyQko7QUFFMUM7Ozs7Ozs7QUFPQSxHQUNBLFNBQVNJLDBCQUEwQkMsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLFFBQVE7SUFDeERQLFNBQVNRLElBQUksQ0FBQyxJQUFJLEVBQUVGO0lBQ3BCLElBQUksQ0FBQ0csT0FBTyxHQUFHSjtJQUVmLElBQUlLLE9BQU8sSUFBSTtJQUNmTCxPQUFPTSxFQUFFLENBQUMsUUFBUSxTQUFVQyxJQUFJLEVBQUVDLElBQUk7UUFDbEMsSUFBSSxDQUFDSCxLQUFLSSxJQUFJLENBQUNGLE9BQU87WUFDbEJGLEtBQUtELE9BQU8sQ0FBQ00sS0FBSztRQUN0QjtRQUNBLElBQUdSLFVBQVU7WUFDVEEsU0FBU007UUFDYjtJQUNKLEdBQ0tGLEVBQUUsQ0FBQyxTQUFTLFNBQVNLLENBQUM7UUFDbkJOLEtBQUtPLElBQUksQ0FBQyxTQUFTRDtJQUN2QixHQUNDTCxFQUFFLENBQUMsT0FBTztRQUNQRCxLQUFLSSxJQUFJLENBQUM7SUFDZDtBQUNSO0FBR0FWLDBCQUEwQmMsU0FBUyxDQUFDQyxLQUFLLEdBQUc7SUFDeEMsSUFBSSxDQUFDVixPQUFPLENBQUNXLE1BQU07QUFDdkI7QUFFQUMsT0FBT0MsT0FBTyxHQUFHbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90c2EtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL25vZGVqcy9Ob2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyLmpzPzk4MDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoXCJyZWFkYWJsZS1zdHJlYW1cIikuUmVhZGFibGU7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnV0aWxzLmluaGVyaXRzKE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIsIFJlYWRhYmxlKTtcblxuLyoqXG4qIEEgbm9kZWpzIHN0cmVhbSB1c2luZyBhIHdvcmtlciBhcyBzb3VyY2UuXG4qIEBzZWUgdGhlIFNvdXJjZVdyYXBwZXIgaW4gaHR0cDovL25vZGVqcy5vcmcvYXBpL3N0cmVhbS5odG1sXG4qIEBjb25zdHJ1Y3RvclxuKiBAcGFyYW0ge1N0cmVhbUhlbHBlcn0gaGVscGVyIHRoZSBoZWxwZXIgd3JhcHBpbmcgdGhlIHdvcmtlclxuKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgbm9kZWpzIHN0cmVhbSBvcHRpb25zXG4qIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZUNiIHRoZSB1cGRhdGUgY2FsbGJhY2suXG4qL1xuZnVuY3Rpb24gTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcihoZWxwZXIsIG9wdGlvbnMsIHVwZGF0ZUNiKSB7XG4gICAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB0aGlzLl9oZWxwZXIgPSBoZWxwZXI7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaGVscGVyLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoZGF0YSwgbWV0YSkge1xuICAgICAgICBpZiAoIXNlbGYucHVzaChkYXRhKSkge1xuICAgICAgICAgICAgc2VsZi5faGVscGVyLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodXBkYXRlQ2IpIHtcbiAgICAgICAgICAgIHVwZGF0ZUNiKG1ldGEpO1xuICAgICAgICB9XG4gICAgfSlcbiAgICAgICAgLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLnB1c2gobnVsbCk7XG4gICAgICAgIH0pO1xufVxuXG5cbk5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5faGVscGVyLnJlc3VtZSgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyO1xuIl0sIm5hbWVzIjpbIlJlYWRhYmxlIiwicmVxdWlyZSIsInV0aWxzIiwiaW5oZXJpdHMiLCJOb2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyIiwiaGVscGVyIiwib3B0aW9ucyIsInVwZGF0ZUNiIiwiY2FsbCIsIl9oZWxwZXIiLCJzZWxmIiwib24iLCJkYXRhIiwibWV0YSIsInB1c2giLCJwYXVzZSIsImUiLCJlbWl0IiwicHJvdG90eXBlIiwiX3JlYWQiLCJyZXN1bWUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/nodejsUtils.js":
/*!***********************************************!*\
  !*** ./node_modules/jszip/lib/nodejsUtils.js ***!
  \***********************************************/
/***/ ((module) => {

eval("\nmodule.exports = {\n    /**\n     * True if this is running in Nodejs, will be undefined in a browser.\n     * In a browser, browserify won't include this file and the whole module\n     * will be resolved an empty object.\n     */ isNode: typeof Buffer !== \"undefined\",\n    /**\n     * Create a new nodejs Buffer from an existing content.\n     * @param {Object} data the data to pass to the constructor.\n     * @param {String} encoding the encoding to use.\n     * @return {Buffer} a new Buffer.\n     */ newBufferFrom: function(data, encoding) {\n        if (Buffer.from && Buffer.from !== Uint8Array.from) {\n            return Buffer.from(data, encoding);\n        } else {\n            if (typeof data === \"number\") {\n                // Safeguard for old Node.js versions. On newer versions,\n                // Buffer.from(number) / Buffer(number, encoding) already throw.\n                throw new Error('The \"data\" argument must not be a number');\n            }\n            return new Buffer(data, encoding);\n        }\n    },\n    /**\n     * Create a new nodejs Buffer with the specified size.\n     * @param {Integer} size the size of the buffer.\n     * @return {Buffer} a new Buffer.\n     */ allocBuffer: function(size) {\n        if (Buffer.alloc) {\n            return Buffer.alloc(size);\n        } else {\n            var buf = new Buffer(size);\n            buf.fill(0);\n            return buf;\n        }\n    },\n    /**\n     * Find out if an object is a Buffer.\n     * @param {Object} b the object to test.\n     * @return {Boolean} true if the object is a Buffer, false otherwise.\n     */ isBuffer: function(b) {\n        return Buffer.isBuffer(b);\n    },\n    isStream: function(obj) {\n        return obj && typeof obj.on === \"function\" && typeof obj.pause === \"function\" && typeof obj.resume === \"function\";\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL25vZGVqc1V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLE9BQU9DLE9BQU8sR0FBRztJQUNiOzs7O0tBSUMsR0FDREMsUUFBUyxPQUFPQyxXQUFXO0lBQzNCOzs7OztLQUtDLEdBQ0RDLGVBQWUsU0FBU0MsSUFBSSxFQUFFQyxRQUFRO1FBQ2xDLElBQUlILE9BQU9JLElBQUksSUFBSUosT0FBT0ksSUFBSSxLQUFLQyxXQUFXRCxJQUFJLEVBQUU7WUFDaEQsT0FBT0osT0FBT0ksSUFBSSxDQUFDRixNQUFNQztRQUM3QixPQUFPO1lBQ0gsSUFBSSxPQUFPRCxTQUFTLFVBQVU7Z0JBQzFCLHlEQUF5RDtnQkFDekQsZ0VBQWdFO2dCQUNoRSxNQUFNLElBQUlJLE1BQU07WUFDcEI7WUFDQSxPQUFPLElBQUlOLE9BQU9FLE1BQU1DO1FBQzVCO0lBQ0o7SUFDQTs7OztLQUlDLEdBQ0RJLGFBQWEsU0FBVUMsSUFBSTtRQUN2QixJQUFJUixPQUFPUyxLQUFLLEVBQUU7WUFDZCxPQUFPVCxPQUFPUyxLQUFLLENBQUNEO1FBQ3hCLE9BQU87WUFDSCxJQUFJRSxNQUFNLElBQUlWLE9BQU9RO1lBQ3JCRSxJQUFJQyxJQUFJLENBQUM7WUFDVCxPQUFPRDtRQUNYO0lBQ0o7SUFDQTs7OztLQUlDLEdBQ0RFLFVBQVcsU0FBU0MsQ0FBQztRQUNqQixPQUFPYixPQUFPWSxRQUFRLENBQUNDO0lBQzNCO0lBRUFDLFVBQVcsU0FBVUMsR0FBRztRQUNwQixPQUFPQSxPQUNILE9BQU9BLElBQUlDLEVBQUUsS0FBSyxjQUNsQixPQUFPRCxJQUFJRSxLQUFLLEtBQUssY0FDckIsT0FBT0YsSUFBSUcsTUFBTSxLQUFLO0lBQzlCO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90c2EtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL25vZGVqc1V0aWxzLmpzPzRmNzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhpcyBpcyBydW5uaW5nIGluIE5vZGVqcywgd2lsbCBiZSB1bmRlZmluZWQgaW4gYSBicm93c2VyLlxuICAgICAqIEluIGEgYnJvd3NlciwgYnJvd3NlcmlmeSB3b24ndCBpbmNsdWRlIHRoaXMgZmlsZSBhbmQgdGhlIHdob2xlIG1vZHVsZVxuICAgICAqIHdpbGwgYmUgcmVzb2x2ZWQgYW4gZW1wdHkgb2JqZWN0LlxuICAgICAqL1xuICAgIGlzTm9kZSA6IHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIsXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IG5vZGVqcyBCdWZmZXIgZnJvbSBhbiBleGlzdGluZyBjb250ZW50LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIHRoZSBkYXRhIHRvIHBhc3MgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBlbmNvZGluZyB0aGUgZW5jb2RpbmcgdG8gdXNlLlxuICAgICAqIEByZXR1cm4ge0J1ZmZlcn0gYSBuZXcgQnVmZmVyLlxuICAgICAqL1xuICAgIG5ld0J1ZmZlckZyb206IGZ1bmN0aW9uKGRhdGEsIGVuY29kaW5nKSB7XG4gICAgICAgIGlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuZnJvbSAhPT0gVWludDhBcnJheS5mcm9tKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oZGF0YSwgZW5jb2RpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgLy8gU2FmZWd1YXJkIGZvciBvbGQgTm9kZS5qcyB2ZXJzaW9ucy4gT24gbmV3ZXIgdmVyc2lvbnMsXG4gICAgICAgICAgICAgICAgLy8gQnVmZmVyLmZyb20obnVtYmVyKSAvIEJ1ZmZlcihudW1iZXIsIGVuY29kaW5nKSBhbHJlYWR5IHRocm93LlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBcXFwiZGF0YVxcXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihkYXRhLCBlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBub2RlanMgQnVmZmVyIHdpdGggdGhlIHNwZWNpZmllZCBzaXplLlxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gc2l6ZSB0aGUgc2l6ZSBvZiB0aGUgYnVmZmVyLlxuICAgICAqIEByZXR1cm4ge0J1ZmZlcn0gYSBuZXcgQnVmZmVyLlxuICAgICAqL1xuICAgIGFsbG9jQnVmZmVyOiBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICBpZiAoQnVmZmVyLmFsbG9jKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKHNpemUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gICAgICAgICAgICBidWYuZmlsbCgwKTtcbiAgICAgICAgICAgIHJldHVybiBidWY7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEZpbmQgb3V0IGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYiB0aGUgb2JqZWN0IHRvIHRlc3QuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgQnVmZmVyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNCdWZmZXIgOiBmdW5jdGlvbihiKXtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihiKTtcbiAgICB9LFxuXG4gICAgaXNTdHJlYW0gOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiZcbiAgICAgICAgICAgIHR5cGVvZiBvYmoub24gPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgdHlwZW9mIG9iai5wYXVzZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICB0eXBlb2Ygb2JqLnJlc3VtZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH1cbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImlzTm9kZSIsIkJ1ZmZlciIsIm5ld0J1ZmZlckZyb20iLCJkYXRhIiwiZW5jb2RpbmciLCJmcm9tIiwiVWludDhBcnJheSIsIkVycm9yIiwiYWxsb2NCdWZmZXIiLCJzaXplIiwiYWxsb2MiLCJidWYiLCJmaWxsIiwiaXNCdWZmZXIiLCJiIiwiaXNTdHJlYW0iLCJvYmoiLCJvbiIsInBhdXNlIiwicmVzdW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/nodejsUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/object.js":
/*!******************************************!*\
  !*** ./node_modules/jszip/lib/object.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utf8 = __webpack_require__(/*! ./utf8 */ \"(ssr)/./node_modules/jszip/lib/utf8.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nvar GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ \"(ssr)/./node_modules/jszip/lib/stream/GenericWorker.js\");\nvar StreamHelper = __webpack_require__(/*! ./stream/StreamHelper */ \"(ssr)/./node_modules/jszip/lib/stream/StreamHelper.js\");\nvar defaults = __webpack_require__(/*! ./defaults */ \"(ssr)/./node_modules/jszip/lib/defaults.js\");\nvar CompressedObject = __webpack_require__(/*! ./compressedObject */ \"(ssr)/./node_modules/jszip/lib/compressedObject.js\");\nvar ZipObject = __webpack_require__(/*! ./zipObject */ \"(ssr)/./node_modules/jszip/lib/zipObject.js\");\nvar generate = __webpack_require__(/*! ./generate */ \"(ssr)/./node_modules/jszip/lib/generate/index.js\");\nvar nodejsUtils = __webpack_require__(/*! ./nodejsUtils */ \"(ssr)/./node_modules/jszip/lib/nodejsUtils.js\");\nvar NodejsStreamInputAdapter = __webpack_require__(/*! ./nodejs/NodejsStreamInputAdapter */ \"(ssr)/./node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js\");\n/**\n * Add a file in the current folder.\n * @private\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file\n * @param {Object} originalOptions the options of the file\n * @return {Object} the new file.\n */ var fileAdd = function(name, data, originalOptions) {\n    // be sure sub folders exist\n    var dataType = utils.getTypeOf(data), parent;\n    /*\n     * Correct options.\n     */ var o = utils.extend(originalOptions || {}, defaults);\n    o.date = o.date || new Date();\n    if (o.compression !== null) {\n        o.compression = o.compression.toUpperCase();\n    }\n    if (typeof o.unixPermissions === \"string\") {\n        o.unixPermissions = parseInt(o.unixPermissions, 8);\n    }\n    // UNX_IFDIR  0040000 see zipinfo.c\n    if (o.unixPermissions && o.unixPermissions & 0x4000) {\n        o.dir = true;\n    }\n    // Bit 4    Directory\n    if (o.dosPermissions && o.dosPermissions & 0x0010) {\n        o.dir = true;\n    }\n    if (o.dir) {\n        name = forceTrailingSlash(name);\n    }\n    if (o.createFolders && (parent = parentFolder(name))) {\n        folderAdd.call(this, parent, true);\n    }\n    var isUnicodeString = dataType === \"string\" && o.binary === false && o.base64 === false;\n    if (!originalOptions || typeof originalOptions.binary === \"undefined\") {\n        o.binary = !isUnicodeString;\n    }\n    var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;\n    if (isCompressedEmpty || o.dir || !data || data.length === 0) {\n        o.base64 = false;\n        o.binary = true;\n        data = \"\";\n        o.compression = \"STORE\";\n        dataType = \"string\";\n    }\n    /*\n     * Convert content to fit.\n     */ var zipObjectContent = null;\n    if (data instanceof CompressedObject || data instanceof GenericWorker) {\n        zipObjectContent = data;\n    } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {\n        zipObjectContent = new NodejsStreamInputAdapter(name, data);\n    } else {\n        zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);\n    }\n    var object = new ZipObject(name, zipObjectContent, o);\n    this.files[name] = object;\n/*\n    TODO: we can't throw an exception because we have async promises\n    (we can have a promise of a Date() for example) but returning a\n    promise is useless because file(name, data) returns the JSZip\n    object for chaining. Should we break that to allow the user\n    to catch the error ?\n\n    return external.Promise.resolve(zipObjectContent)\n    .then(function () {\n        return object;\n    });\n    */ };\n/**\n * Find the parent folder of the path.\n * @private\n * @param {string} path the path to use\n * @return {string} the parent folder, or \"\"\n */ var parentFolder = function(path) {\n    if (path.slice(-1) === \"/\") {\n        path = path.substring(0, path.length - 1);\n    }\n    var lastSlash = path.lastIndexOf(\"/\");\n    return lastSlash > 0 ? path.substring(0, lastSlash) : \"\";\n};\n/**\n * Returns the path with a slash at the end.\n * @private\n * @param {String} path the path to check.\n * @return {String} the path with a trailing slash.\n */ var forceTrailingSlash = function(path) {\n    // Check the name ends with a /\n    if (path.slice(-1) !== \"/\") {\n        path += \"/\"; // IE doesn't like substr(-1)\n    }\n    return path;\n};\n/**\n * Add a (sub) folder in the current folder.\n * @private\n * @param {string} name the folder's name\n * @param {boolean=} [createFolders] If true, automatically create sub\n *  folders. Defaults to false.\n * @return {Object} the new folder.\n */ var folderAdd = function(name, createFolders) {\n    createFolders = typeof createFolders !== \"undefined\" ? createFolders : defaults.createFolders;\n    name = forceTrailingSlash(name);\n    // Does this folder already exist?\n    if (!this.files[name]) {\n        fileAdd.call(this, name, null, {\n            dir: true,\n            createFolders: createFolders\n        });\n    }\n    return this.files[name];\n};\n/**\n* Cross-window, cross-Node-context regular expression detection\n* @param  {Object}  object Anything\n* @return {Boolean}        true if the object is a regular expression,\n* false otherwise\n*/ function isRegExp(object) {\n    return Object.prototype.toString.call(object) === \"[object RegExp]\";\n}\n// return the actual prototype of JSZip\nvar out = {\n    /**\n     * @see loadAsync\n     */ load: function() {\n        throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n    },\n    /**\n     * Call a callback function for each entry at this folder level.\n     * @param {Function} cb the callback function:\n     * function (relativePath, file) {...}\n     * It takes 2 arguments : the relative path and the file.\n     */ forEach: function(cb) {\n        var filename, relativePath, file;\n        // ignore warning about unwanted properties because this.files is a null prototype object\n        /* eslint-disable-next-line guard-for-in */ for(filename in this.files){\n            file = this.files[filename];\n            relativePath = filename.slice(this.root.length, filename.length);\n            if (relativePath && filename.slice(0, this.root.length) === this.root) {\n                cb(relativePath, file); // TODO reverse the parameters ? need to be clean AND consistent with the filter search fn...\n            }\n        }\n    },\n    /**\n     * Filter nested files/folders with the specified function.\n     * @param {Function} search the predicate to use :\n     * function (relativePath, file) {...}\n     * It takes 2 arguments : the relative path and the file.\n     * @return {Array} An array of matching elements.\n     */ filter: function(search) {\n        var result = [];\n        this.forEach(function(relativePath, entry) {\n            if (search(relativePath, entry)) {\n                result.push(entry);\n            }\n        });\n        return result;\n    },\n    /**\n     * Add a file to the zip file, or search a file.\n     * @param   {string|RegExp} name The name of the file to add (if data is defined),\n     * the name of the file to find (if no data) or a regex to match files.\n     * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded\n     * @param   {Object} o     File options\n     * @return  {JSZip|Object|Array} this JSZip object (when adding a file),\n     * a file (when searching by string) or an array of files (when searching by regex).\n     */ file: function(name, data, o) {\n        if (arguments.length === 1) {\n            if (isRegExp(name)) {\n                var regexp = name;\n                return this.filter(function(relativePath, file) {\n                    return !file.dir && regexp.test(relativePath);\n                });\n            } else {\n                var obj = this.files[this.root + name];\n                if (obj && !obj.dir) {\n                    return obj;\n                } else {\n                    return null;\n                }\n            }\n        } else {\n            name = this.root + name;\n            fileAdd.call(this, name, data, o);\n        }\n        return this;\n    },\n    /**\n     * Add a directory to the zip file, or search.\n     * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.\n     * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.\n     */ folder: function(arg) {\n        if (!arg) {\n            return this;\n        }\n        if (isRegExp(arg)) {\n            return this.filter(function(relativePath, file) {\n                return file.dir && arg.test(relativePath);\n            });\n        }\n        // else, name is a new folder\n        var name = this.root + arg;\n        var newFolder = folderAdd.call(this, name);\n        // Allow chaining by returning a new object with this folder as the root\n        var ret = this.clone();\n        ret.root = newFolder.name;\n        return ret;\n    },\n    /**\n     * Delete a file, or a directory and all sub-files, from the zip\n     * @param {string} name the name of the file to delete\n     * @return {JSZip} this JSZip object\n     */ remove: function(name) {\n        name = this.root + name;\n        var file = this.files[name];\n        if (!file) {\n            // Look for any folders\n            if (name.slice(-1) !== \"/\") {\n                name += \"/\";\n            }\n            file = this.files[name];\n        }\n        if (file && !file.dir) {\n            // file\n            delete this.files[name];\n        } else {\n            // maybe a folder, delete recursively\n            var kids = this.filter(function(relativePath, file) {\n                return file.name.slice(0, name.length) === name;\n            });\n            for(var i = 0; i < kids.length; i++){\n                delete this.files[kids[i].name];\n            }\n        }\n        return this;\n    },\n    /**\n     * @deprecated This method has been removed in JSZip 3.0, please check the upgrade guide.\n     */ generate: function() {\n        throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n    },\n    /**\n     * Generate the complete zip file as an internal stream.\n     * @param {Object} options the options to generate the zip file :\n     * - compression, \"STORE\" by default.\n     * - type, \"base64\" by default. Values are : string, base64, uint8array, arraybuffer, blob.\n     * @return {StreamHelper} the streamed zip file.\n     */ generateInternalStream: function(options) {\n        var worker, opts = {};\n        try {\n            opts = utils.extend(options || {}, {\n                streamFiles: false,\n                compression: \"STORE\",\n                compressionOptions: null,\n                type: \"\",\n                platform: \"DOS\",\n                comment: null,\n                mimeType: \"application/zip\",\n                encodeFileName: utf8.utf8encode\n            });\n            opts.type = opts.type.toLowerCase();\n            opts.compression = opts.compression.toUpperCase();\n            // \"binarystring\" is preferred but the internals use \"string\".\n            if (opts.type === \"binarystring\") {\n                opts.type = \"string\";\n            }\n            if (!opts.type) {\n                throw new Error(\"No output type specified.\");\n            }\n            utils.checkSupport(opts.type);\n            // accept nodejs `process.platform`\n            if (opts.platform === \"darwin\" || opts.platform === \"freebsd\" || opts.platform === \"linux\" || opts.platform === \"sunos\") {\n                opts.platform = \"UNIX\";\n            }\n            if (opts.platform === \"win32\") {\n                opts.platform = \"DOS\";\n            }\n            var comment = opts.comment || this.comment || \"\";\n            worker = generate.generateWorker(this, opts, comment);\n        } catch (e) {\n            worker = new GenericWorker(\"error\");\n            worker.error(e);\n        }\n        return new StreamHelper(worker, opts.type || \"string\", opts.mimeType);\n    },\n    /**\n     * Generate the complete zip file asynchronously.\n     * @see generateInternalStream\n     */ generateAsync: function(options, onUpdate) {\n        return this.generateInternalStream(options).accumulate(onUpdate);\n    },\n    /**\n     * Generate the complete zip file asynchronously.\n     * @see generateInternalStream\n     */ generateNodeStream: function(options, onUpdate) {\n        options = options || {};\n        if (!options.type) {\n            options.type = \"nodebuffer\";\n        }\n        return this.generateInternalStream(options).toNodejsStream(onUpdate);\n    }\n};\nmodule.exports = out;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL29iamVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLE9BQU9DLG1CQUFPQSxDQUFDLHNEQUFRO0FBQzNCLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDLHdEQUFTO0FBQzdCLElBQUlFLGdCQUFnQkYsbUJBQU9BLENBQUMsc0ZBQXdCO0FBQ3BELElBQUlHLGVBQWVILG1CQUFPQSxDQUFDLG9GQUF1QjtBQUNsRCxJQUFJSSxXQUFXSixtQkFBT0EsQ0FBQyw4REFBWTtBQUNuQyxJQUFJSyxtQkFBbUJMLG1CQUFPQSxDQUFDLDhFQUFvQjtBQUNuRCxJQUFJTSxZQUFZTixtQkFBT0EsQ0FBQyxnRUFBYTtBQUNyQyxJQUFJTyxXQUFXUCxtQkFBT0EsQ0FBQyxvRUFBWTtBQUNuQyxJQUFJUSxjQUFjUixtQkFBT0EsQ0FBQyxvRUFBZTtBQUN6QyxJQUFJUywyQkFBMkJULG1CQUFPQSxDQUFDLDRHQUFtQztBQUcxRTs7Ozs7OztDQU9DLEdBQ0QsSUFBSVUsVUFBVSxTQUFTQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsZUFBZTtJQUM5Qyw0QkFBNEI7SUFDNUIsSUFBSUMsV0FBV2IsTUFBTWMsU0FBUyxDQUFDSCxPQUMzQkk7SUFHSjs7S0FFQyxHQUVELElBQUlDLElBQUloQixNQUFNaUIsTUFBTSxDQUFDTCxtQkFBbUIsQ0FBQyxHQUFHVDtJQUM1Q2EsRUFBRUUsSUFBSSxHQUFHRixFQUFFRSxJQUFJLElBQUksSUFBSUM7SUFDdkIsSUFBSUgsRUFBRUksV0FBVyxLQUFLLE1BQU07UUFDeEJKLEVBQUVJLFdBQVcsR0FBR0osRUFBRUksV0FBVyxDQUFDQyxXQUFXO0lBQzdDO0lBRUEsSUFBSSxPQUFPTCxFQUFFTSxlQUFlLEtBQUssVUFBVTtRQUN2Q04sRUFBRU0sZUFBZSxHQUFHQyxTQUFTUCxFQUFFTSxlQUFlLEVBQUU7SUFDcEQ7SUFFQSxtQ0FBbUM7SUFDbkMsSUFBSU4sRUFBRU0sZUFBZSxJQUFLTixFQUFF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QUNBLFFBQVFLLElBQUksRUFBRTtZQUNmTCxRQUFRSyxJQUFJLEdBQUc7UUFDbkI7UUFDQSxPQUFPLElBQUksQ0FBQ04sc0JBQXNCLENBQUNDLFNBQVNvQixjQUFjLENBQUNIO0lBQy9EO0FBQ0o7QUFDQUksT0FBT0MsT0FBTyxHQUFHakQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90c2EtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL29iamVjdC5qcz9kYTRhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIHV0ZjggPSByZXF1aXJlKFwiLi91dGY4XCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoXCIuL3N0cmVhbS9HZW5lcmljV29ya2VyXCIpO1xudmFyIFN0cmVhbUhlbHBlciA9IHJlcXVpcmUoXCIuL3N0cmVhbS9TdHJlYW1IZWxwZXJcIik7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKFwiLi9kZWZhdWx0c1wiKTtcbnZhciBDb21wcmVzc2VkT2JqZWN0ID0gcmVxdWlyZShcIi4vY29tcHJlc3NlZE9iamVjdFwiKTtcbnZhciBaaXBPYmplY3QgPSByZXF1aXJlKFwiLi96aXBPYmplY3RcIik7XG52YXIgZ2VuZXJhdGUgPSByZXF1aXJlKFwiLi9nZW5lcmF0ZVwiKTtcbnZhciBub2RlanNVdGlscyA9IHJlcXVpcmUoXCIuL25vZGVqc1V0aWxzXCIpO1xudmFyIE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlciA9IHJlcXVpcmUoXCIuL25vZGVqcy9Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXJcIik7XG5cblxuLyoqXG4gKiBBZGQgYSBmaWxlIGluIHRoZSBjdXJyZW50IGZvbGRlci5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZVxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGRhdGEgb2YgdGhlIGZpbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcmlnaW5hbE9wdGlvbnMgdGhlIG9wdGlvbnMgb2YgdGhlIGZpbGVcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIG5ldyBmaWxlLlxuICovXG52YXIgZmlsZUFkZCA9IGZ1bmN0aW9uKG5hbWUsIGRhdGEsIG9yaWdpbmFsT3B0aW9ucykge1xuICAgIC8vIGJlIHN1cmUgc3ViIGZvbGRlcnMgZXhpc3RcbiAgICB2YXIgZGF0YVR5cGUgPSB1dGlscy5nZXRUeXBlT2YoZGF0YSksXG4gICAgICAgIHBhcmVudDtcblxuXG4gICAgLypcbiAgICAgKiBDb3JyZWN0IG9wdGlvbnMuXG4gICAgICovXG5cbiAgICB2YXIgbyA9IHV0aWxzLmV4dGVuZChvcmlnaW5hbE9wdGlvbnMgfHwge30sIGRlZmF1bHRzKTtcbiAgICBvLmRhdGUgPSBvLmRhdGUgfHwgbmV3IERhdGUoKTtcbiAgICBpZiAoby5jb21wcmVzc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICBvLmNvbXByZXNzaW9uID0gby5jb21wcmVzc2lvbi50b1VwcGVyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygby51bml4UGVybWlzc2lvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgby51bml4UGVybWlzc2lvbnMgPSBwYXJzZUludChvLnVuaXhQZXJtaXNzaW9ucywgOCk7XG4gICAgfVxuXG4gICAgLy8gVU5YX0lGRElSICAwMDQwMDAwIHNlZSB6aXBpbmZvLmNcbiAgICBpZiAoby51bml4UGVybWlzc2lvbnMgJiYgKG8udW5peFBlcm1pc3Npb25zICYgMHg0MDAwKSkge1xuICAgICAgICBvLmRpciA9IHRydWU7XG4gICAgfVxuICAgIC8vIEJpdCA0ICAgIERpcmVjdG9yeVxuICAgIGlmIChvLmRvc1Blcm1pc3Npb25zICYmIChvLmRvc1Blcm1pc3Npb25zICYgMHgwMDEwKSkge1xuICAgICAgICBvLmRpciA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG8uZGlyKSB7XG4gICAgICAgIG5hbWUgPSBmb3JjZVRyYWlsaW5nU2xhc2gobmFtZSk7XG4gICAgfVxuICAgIGlmIChvLmNyZWF0ZUZvbGRlcnMgJiYgKHBhcmVudCA9IHBhcmVudEZvbGRlcihuYW1lKSkpIHtcbiAgICAgICAgZm9sZGVyQWRkLmNhbGwodGhpcywgcGFyZW50LCB0cnVlKTtcbiAgICB9XG5cbiAgICB2YXIgaXNVbmljb2RlU3RyaW5nID0gZGF0YVR5cGUgPT09IFwic3RyaW5nXCIgJiYgby5iaW5hcnkgPT09IGZhbHNlICYmIG8uYmFzZTY0ID09PSBmYWxzZTtcbiAgICBpZiAoIW9yaWdpbmFsT3B0aW9ucyB8fCB0eXBlb2Ygb3JpZ2luYWxPcHRpb25zLmJpbmFyeSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBvLmJpbmFyeSA9ICFpc1VuaWNvZGVTdHJpbmc7XG4gICAgfVxuXG5cbiAgICB2YXIgaXNDb21wcmVzc2VkRW1wdHkgPSAoZGF0YSBpbnN0YW5jZW9mIENvbXByZXNzZWRPYmplY3QpICYmIGRhdGEudW5jb21wcmVzc2VkU2l6ZSA9PT0gMDtcblxuICAgIGlmIChpc0NvbXByZXNzZWRFbXB0eSB8fCBvLmRpciB8fCAhZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBvLmJhc2U2NCA9IGZhbHNlO1xuICAgICAgICBvLmJpbmFyeSA9IHRydWU7XG4gICAgICAgIGRhdGEgPSBcIlwiO1xuICAgICAgICBvLmNvbXByZXNzaW9uID0gXCJTVE9SRVwiO1xuICAgICAgICBkYXRhVHlwZSA9IFwic3RyaW5nXCI7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb252ZXJ0IGNvbnRlbnQgdG8gZml0LlxuICAgICAqL1xuXG4gICAgdmFyIHppcE9iamVjdENvbnRlbnQgPSBudWxsO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQ29tcHJlc3NlZE9iamVjdCB8fCBkYXRhIGluc3RhbmNlb2YgR2VuZXJpY1dvcmtlcikge1xuICAgICAgICB6aXBPYmplY3RDb250ZW50ID0gZGF0YTtcbiAgICB9IGVsc2UgaWYgKG5vZGVqc1V0aWxzLmlzTm9kZSAmJiBub2RlanNVdGlscy5pc1N0cmVhbShkYXRhKSkge1xuICAgICAgICB6aXBPYmplY3RDb250ZW50ID0gbmV3IE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlcihuYW1lLCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB6aXBPYmplY3RDb250ZW50ID0gdXRpbHMucHJlcGFyZUNvbnRlbnQobmFtZSwgZGF0YSwgby5iaW5hcnksIG8ub3B0aW1pemVkQmluYXJ5U3RyaW5nLCBvLmJhc2U2NCk7XG4gICAgfVxuXG4gICAgdmFyIG9iamVjdCA9IG5ldyBaaXBPYmplY3QobmFtZSwgemlwT2JqZWN0Q29udGVudCwgbyk7XG4gICAgdGhpcy5maWxlc1tuYW1lXSA9IG9iamVjdDtcbiAgICAvKlxuICAgIFRPRE86IHdlIGNhbid0IHRocm93IGFuIGV4Y2VwdGlvbiBiZWNhdXNlIHdlIGhhdmUgYXN5bmMgcHJvbWlzZXNcbiAgICAod2UgY2FuIGhhdmUgYSBwcm9taXNlIG9mIGEgRGF0ZSgpIGZvciBleGFtcGxlKSBidXQgcmV0dXJuaW5nIGFcbiAgICBwcm9taXNlIGlzIHVzZWxlc3MgYmVjYXVzZSBmaWxlKG5hbWUsIGRhdGEpIHJldHVybnMgdGhlIEpTWmlwXG4gICAgb2JqZWN0IGZvciBjaGFpbmluZy4gU2hvdWxkIHdlIGJyZWFrIHRoYXQgdG8gYWxsb3cgdGhlIHVzZXJcbiAgICB0byBjYXRjaCB0aGUgZXJyb3IgP1xuXG4gICAgcmV0dXJuIGV4dGVybmFsLlByb21pc2UucmVzb2x2ZSh6aXBPYmplY3RDb250ZW50KVxuICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9KTtcbiAgICAqL1xufTtcblxuLyoqXG4gKiBGaW5kIHRoZSBwYXJlbnQgZm9sZGVyIG9mIHRoZSBwYXRoLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHRoZSBwYXRoIHRvIHVzZVxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgcGFyZW50IGZvbGRlciwgb3IgXCJcIlxuICovXG52YXIgcGFyZW50Rm9sZGVyID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBpZiAocGF0aC5zbGljZSgtMSkgPT09IFwiL1wiKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBwYXRoLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICB2YXIgbGFzdFNsYXNoID0gcGF0aC5sYXN0SW5kZXhPZihcIi9cIik7XG4gICAgcmV0dXJuIChsYXN0U2xhc2ggPiAwKSA/IHBhdGguc3Vic3RyaW5nKDAsIGxhc3RTbGFzaCkgOiBcIlwiO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXRoIHdpdGggYSBzbGFzaCBhdCB0aGUgZW5kLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgcGF0aCB3aXRoIGEgdHJhaWxpbmcgc2xhc2guXG4gKi9cbnZhciBmb3JjZVRyYWlsaW5nU2xhc2ggPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgLy8gQ2hlY2sgdGhlIG5hbWUgZW5kcyB3aXRoIGEgL1xuICAgIGlmIChwYXRoLnNsaWNlKC0xKSAhPT0gXCIvXCIpIHtcbiAgICAgICAgcGF0aCArPSBcIi9cIjsgLy8gSUUgZG9lc24ndCBsaWtlIHN1YnN0cigtMSlcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59O1xuXG4vKipcbiAqIEFkZCBhIChzdWIpIGZvbGRlciBpbiB0aGUgY3VycmVudCBmb2xkZXIuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIGZvbGRlcidzIG5hbWVcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IFtjcmVhdGVGb2xkZXJzXSBJZiB0cnVlLCBhdXRvbWF0aWNhbGx5IGNyZWF0ZSBzdWJcbiAqICBmb2xkZXJzLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIG5ldyBmb2xkZXIuXG4gKi9cbnZhciBmb2xkZXJBZGQgPSBmdW5jdGlvbihuYW1lLCBjcmVhdGVGb2xkZXJzKSB7XG4gICAgY3JlYXRlRm9sZGVycyA9ICh0eXBlb2YgY3JlYXRlRm9sZGVycyAhPT0gXCJ1bmRlZmluZWRcIikgPyBjcmVhdGVGb2xkZXJzIDogZGVmYXVsdHMuY3JlYXRlRm9sZGVycztcblxuICAgIG5hbWUgPSBmb3JjZVRyYWlsaW5nU2xhc2gobmFtZSk7XG5cbiAgICAvLyBEb2VzIHRoaXMgZm9sZGVyIGFscmVhZHkgZXhpc3Q/XG4gICAgaWYgKCF0aGlzLmZpbGVzW25hbWVdKSB7XG4gICAgICAgIGZpbGVBZGQuY2FsbCh0aGlzLCBuYW1lLCBudWxsLCB7XG4gICAgICAgICAgICBkaXI6IHRydWUsXG4gICAgICAgICAgICBjcmVhdGVGb2xkZXJzOiBjcmVhdGVGb2xkZXJzXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maWxlc1tuYW1lXTtcbn07XG5cbi8qKlxuKiBDcm9zcy13aW5kb3csIGNyb3NzLU5vZGUtY29udGV4dCByZWd1bGFyIGV4cHJlc3Npb24gZGV0ZWN0aW9uXG4qIEBwYXJhbSAge09iamVjdH0gIG9iamVjdCBBbnl0aGluZ1xuKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgcmVndWxhciBleHByZXNzaW9uLFxuKiBmYWxzZSBvdGhlcndpc2VcbiovXG5mdW5jdGlvbiBpc1JlZ0V4cChvYmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09IFwiW29iamVjdCBSZWdFeHBdXCI7XG59XG5cbi8vIHJldHVybiB0aGUgYWN0dWFsIHByb3RvdHlwZSBvZiBKU1ppcFxudmFyIG91dCA9IHtcbiAgICAvKipcbiAgICAgKiBAc2VlIGxvYWRBc3luY1xuICAgICAqL1xuICAgIGxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG1ldGhvZCBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlwiKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBDYWxsIGEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggZW50cnkgYXQgdGhpcyBmb2xkZXIgbGV2ZWwuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uOlxuICAgICAqIGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIGZpbGUpIHsuLi59XG4gICAgICogSXQgdGFrZXMgMiBhcmd1bWVudHMgOiB0aGUgcmVsYXRpdmUgcGF0aCBhbmQgdGhlIGZpbGUuXG4gICAgICovXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgdmFyIGZpbGVuYW1lLCByZWxhdGl2ZVBhdGgsIGZpbGU7XG4gICAgICAgIC8vIGlnbm9yZSB3YXJuaW5nIGFib3V0IHVud2FudGVkIHByb3BlcnRpZXMgYmVjYXVzZSB0aGlzLmZpbGVzIGlzIGEgbnVsbCBwcm90b3R5cGUgb2JqZWN0XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW4gKi9cbiAgICAgICAgZm9yIChmaWxlbmFtZSBpbiB0aGlzLmZpbGVzKSB7XG4gICAgICAgICAgICBmaWxlID0gdGhpcy5maWxlc1tmaWxlbmFtZV07XG4gICAgICAgICAgICByZWxhdGl2ZVBhdGggPSBmaWxlbmFtZS5zbGljZSh0aGlzLnJvb3QubGVuZ3RoLCBmaWxlbmFtZS5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHJlbGF0aXZlUGF0aCAmJiBmaWxlbmFtZS5zbGljZSgwLCB0aGlzLnJvb3QubGVuZ3RoKSA9PT0gdGhpcy5yb290KSB7IC8vIHRoZSBmaWxlIGlzIGluIHRoZSBjdXJyZW50IHJvb3RcbiAgICAgICAgICAgICAgICBjYihyZWxhdGl2ZVBhdGgsIGZpbGUpOyAvLyBUT0RPIHJldmVyc2UgdGhlIHBhcmFtZXRlcnMgPyBuZWVkIHRvIGJlIGNsZWFuIEFORCBjb25zaXN0ZW50IHdpdGggdGhlIGZpbHRlciBzZWFyY2ggZm4uLi5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgbmVzdGVkIGZpbGVzL2ZvbGRlcnMgd2l0aCB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNlYXJjaCB0aGUgcHJlZGljYXRlIHRvIHVzZSA6XG4gICAgICogZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgZmlsZSkgey4uLn1cbiAgICAgKiBJdCB0YWtlcyAyIGFyZ3VtZW50cyA6IHRoZSByZWxhdGl2ZSBwYXRoIGFuZCB0aGUgZmlsZS5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgbWF0Y2hpbmcgZWxlbWVudHMuXG4gICAgICovXG4gICAgZmlsdGVyOiBmdW5jdGlvbihzZWFyY2gpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgZW50cnkpIHtcbiAgICAgICAgICAgIGlmIChzZWFyY2gocmVsYXRpdmVQYXRoLCBlbnRyeSkpIHsgLy8gdGhlIGZpbGUgbWF0Y2hlcyB0aGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbnRyeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGZpbGUgdG8gdGhlIHppcCBmaWxlLCBvciBzZWFyY2ggYSBmaWxlLlxuICAgICAqIEBwYXJhbSAgIHtzdHJpbmd8UmVnRXhwfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBmaWxlIHRvIGFkZCAoaWYgZGF0YSBpcyBkZWZpbmVkKSxcbiAgICAgKiB0aGUgbmFtZSBvZiB0aGUgZmlsZSB0byBmaW5kIChpZiBubyBkYXRhKSBvciBhIHJlZ2V4IHRvIG1hdGNoIGZpbGVzLlxuICAgICAqIEBwYXJhbSAgIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgIFRoZSBmaWxlIGRhdGEsIGVpdGhlciByYXcgb3IgYmFzZTY0IGVuY29kZWRcbiAgICAgKiBAcGFyYW0gICB7T2JqZWN0fSBvICAgICBGaWxlIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuICB7SlNaaXB8T2JqZWN0fEFycmF5fSB0aGlzIEpTWmlwIG9iamVjdCAod2hlbiBhZGRpbmcgYSBmaWxlKSxcbiAgICAgKiBhIGZpbGUgKHdoZW4gc2VhcmNoaW5nIGJ5IHN0cmluZykgb3IgYW4gYXJyYXkgb2YgZmlsZXMgKHdoZW4gc2VhcmNoaW5nIGJ5IHJlZ2V4KS5cbiAgICAgKi9cbiAgICBmaWxlOiBmdW5jdGlvbihuYW1lLCBkYXRhLCBvKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoaXNSZWdFeHAobmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVnZXhwID0gbmFtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24ocmVsYXRpdmVQYXRoLCBmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhZmlsZS5kaXIgJiYgcmVnZXhwLnRlc3QocmVsYXRpdmVQYXRoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyB0ZXh0XG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IHRoaXMuZmlsZXNbdGhpcy5yb290ICsgbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKG9iaiAmJiAhb2JqLmRpcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gbW9yZSB0aGFuIG9uZSBhcmd1bWVudCA6IHdlIGhhdmUgZGF0YSAhXG4gICAgICAgICAgICBuYW1lID0gdGhpcy5yb290ICsgbmFtZTtcbiAgICAgICAgICAgIGZpbGVBZGQuY2FsbCh0aGlzLCBuYW1lLCBkYXRhLCBvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgZGlyZWN0b3J5IHRvIHRoZSB6aXAgZmlsZSwgb3Igc2VhcmNoLlxuICAgICAqIEBwYXJhbSAgIHtTdHJpbmd8UmVnRXhwfSBhcmcgVGhlIG5hbWUgb2YgdGhlIGRpcmVjdG9yeSB0byBhZGQsIG9yIGEgcmVnZXggdG8gc2VhcmNoIGZvbGRlcnMuXG4gICAgICogQHJldHVybiAge0pTWmlwfSBhbiBvYmplY3Qgd2l0aCB0aGUgbmV3IGRpcmVjdG9yeSBhcyB0aGUgcm9vdCwgb3IgYW4gYXJyYXkgY29udGFpbmluZyBtYXRjaGluZyBmb2xkZXJzLlxuICAgICAqL1xuICAgIGZvbGRlcjogZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIGlmICghYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1JlZ0V4cChhcmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24ocmVsYXRpdmVQYXRoLCBmaWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGUuZGlyICYmIGFyZy50ZXN0KHJlbGF0aXZlUGF0aCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVsc2UsIG5hbWUgaXMgYSBuZXcgZm9sZGVyXG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5yb290ICsgYXJnO1xuICAgICAgICB2YXIgbmV3Rm9sZGVyID0gZm9sZGVyQWRkLmNhbGwodGhpcywgbmFtZSk7XG5cbiAgICAgICAgLy8gQWxsb3cgY2hhaW5pbmcgYnkgcmV0dXJuaW5nIGEgbmV3IG9iamVjdCB3aXRoIHRoaXMgZm9sZGVyIGFzIHRoZSByb290XG4gICAgICAgIHZhciByZXQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHJldC5yb290ID0gbmV3Rm9sZGVyLm5hbWU7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIGZpbGUsIG9yIGEgZGlyZWN0b3J5IGFuZCBhbGwgc3ViLWZpbGVzLCBmcm9tIHRoZSB6aXBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZSB0byBkZWxldGVcbiAgICAgKiBAcmV0dXJuIHtKU1ppcH0gdGhpcyBKU1ppcCBvYmplY3RcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgbmFtZSA9IHRoaXMucm9vdCArIG5hbWU7XG4gICAgICAgIHZhciBmaWxlID0gdGhpcy5maWxlc1tuYW1lXTtcbiAgICAgICAgaWYgKCFmaWxlKSB7XG4gICAgICAgICAgICAvLyBMb29rIGZvciBhbnkgZm9sZGVyc1xuICAgICAgICAgICAgaWYgKG5hbWUuc2xpY2UoLTEpICE9PSBcIi9cIikge1xuICAgICAgICAgICAgICAgIG5hbWUgKz0gXCIvXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWxlID0gdGhpcy5maWxlc1tuYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWxlICYmICFmaWxlLmRpcikge1xuICAgICAgICAgICAgLy8gZmlsZVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmlsZXNbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBtYXliZSBhIGZvbGRlciwgZGVsZXRlIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICB2YXIga2lkcyA9IHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHJlbGF0aXZlUGF0aCwgZmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLm5hbWUuc2xpY2UoMCwgbmFtZS5sZW5ndGgpID09PSBuYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5maWxlc1traWRzW2ldLm5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFRoaXMgbWV0aG9kIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXG4gICAgICovXG4gICAgZ2VuZXJhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG1ldGhvZCBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlwiKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIGNvbXBsZXRlIHppcCBmaWxlIGFzIGFuIGludGVybmFsIHN0cmVhbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byBnZW5lcmF0ZSB0aGUgemlwIGZpbGUgOlxuICAgICAqIC0gY29tcHJlc3Npb24sIFwiU1RPUkVcIiBieSBkZWZhdWx0LlxuICAgICAqIC0gdHlwZSwgXCJiYXNlNjRcIiBieSBkZWZhdWx0LiBWYWx1ZXMgYXJlIDogc3RyaW5nLCBiYXNlNjQsIHVpbnQ4YXJyYXksIGFycmF5YnVmZmVyLCBibG9iLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbUhlbHBlcn0gdGhlIHN0cmVhbWVkIHppcCBmaWxlLlxuICAgICAqL1xuICAgIGdlbmVyYXRlSW50ZXJuYWxTdHJlYW06IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHdvcmtlciwgb3B0cyA9IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgb3B0cyA9IHV0aWxzLmV4dGVuZChvcHRpb25zIHx8IHt9LCB7XG4gICAgICAgICAgICAgICAgc3RyZWFtRmlsZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uOiBcIlNUT1JFXCIsXG4gICAgICAgICAgICAgICAgY29tcHJlc3Npb25PcHRpb25zIDogbnVsbCxcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlwiLFxuICAgICAgICAgICAgICAgIHBsYXRmb3JtOiBcIkRPU1wiLFxuICAgICAgICAgICAgICAgIGNvbW1lbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgbWltZVR5cGU6IFwiYXBwbGljYXRpb24vemlwXCIsXG4gICAgICAgICAgICAgICAgZW5jb2RlRmlsZU5hbWU6IHV0ZjgudXRmOGVuY29kZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG9wdHMudHlwZSA9IG9wdHMudHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgb3B0cy5jb21wcmVzc2lvbiA9IG9wdHMuY29tcHJlc3Npb24udG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgICAgLy8gXCJiaW5hcnlzdHJpbmdcIiBpcyBwcmVmZXJyZWQgYnV0IHRoZSBpbnRlcm5hbHMgdXNlIFwic3RyaW5nXCIuXG4gICAgICAgICAgICBpZihvcHRzLnR5cGUgPT09IFwiYmluYXJ5c3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBvcHRzLnR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW9wdHMudHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG91dHB1dCB0eXBlIHNwZWNpZmllZC5cIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHV0aWxzLmNoZWNrU3VwcG9ydChvcHRzLnR5cGUpO1xuXG4gICAgICAgICAgICAvLyBhY2NlcHQgbm9kZWpzIGBwcm9jZXNzLnBsYXRmb3JtYFxuICAgICAgICAgICAgaWYoXG4gICAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9PT0gXCJkYXJ3aW5cIiB8fFxuICAgICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPT09IFwiZnJlZWJzZFwiIHx8XG4gICAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9PT0gXCJsaW51eFwiIHx8XG4gICAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9PT0gXCJzdW5vc1wiXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBvcHRzLnBsYXRmb3JtID0gXCJVTklYXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9IFwiRE9TXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjb21tZW50ID0gb3B0cy5jb21tZW50IHx8IHRoaXMuY29tbWVudCB8fCBcIlwiO1xuICAgICAgICAgICAgd29ya2VyID0gZ2VuZXJhdGUuZ2VuZXJhdGVXb3JrZXIodGhpcywgb3B0cywgY29tbWVudCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHdvcmtlciA9IG5ldyBHZW5lcmljV29ya2VyKFwiZXJyb3JcIik7XG4gICAgICAgICAgICB3b3JrZXIuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1IZWxwZXIod29ya2VyLCBvcHRzLnR5cGUgfHwgXCJzdHJpbmdcIiwgb3B0cy5taW1lVHlwZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgY29tcGxldGUgemlwIGZpbGUgYXN5bmNocm9ub3VzbHkuXG4gICAgICogQHNlZSBnZW5lcmF0ZUludGVybmFsU3RyZWFtXG4gICAgICovXG4gICAgZ2VuZXJhdGVBc3luYzogZnVuY3Rpb24ob3B0aW9ucywgb25VcGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbShvcHRpb25zKS5hY2N1bXVsYXRlKG9uVXBkYXRlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRoZSBjb21wbGV0ZSB6aXAgZmlsZSBhc3luY2hyb25vdXNseS5cbiAgICAgKiBAc2VlIGdlbmVyYXRlSW50ZXJuYWxTdHJlYW1cbiAgICAgKi9cbiAgICBnZW5lcmF0ZU5vZGVTdHJlYW06IGZ1bmN0aW9uKG9wdGlvbnMsIG9uVXBkYXRlKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBpZiAoIW9wdGlvbnMudHlwZSkge1xuICAgICAgICAgICAgb3B0aW9ucy50eXBlID0gXCJub2RlYnVmZmVyXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbShvcHRpb25zKS50b05vZGVqc1N0cmVhbShvblVwZGF0ZSk7XG4gICAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gb3V0O1xuIl0sIm5hbWVzIjpbInV0ZjgiLCJyZXF1aXJlIiwidXRpbHMiLCJHZW5lcmljV29ya2VyIiwiU3RyZWFtSGVscGVyIiwiZGVmYXVsdHMiLCJDb21wcmVzc2VkT2JqZWN0IiwiWmlwT2JqZWN0IiwiZ2VuZXJhdGUiLCJub2RlanNVdGlscyIsIk5vZGVqc1N0cmVhbUlucHV0QWRhcHRlciIsImZpbGVBZGQiLCJuYW1lIiwiZGF0YSIsIm9yaWdpbmFsT3B0aW9ucyIsImRhdGFUeXBlIiwiZ2V0VHlwZU9mIiwicGFyZW50IiwibyIsImV4dGVuZCIsImRhdGUiLCJEYXRlIiwiY29tcHJlc3Npb24iLCJ0b1VwcGVyQ2FzZSIsInVuaXhQZXJtaXNzaW9ucyIsInBhcnNlSW50IiwiZGlyIiwiZG9zUGVybWlzc2lvbnMiLCJmb3JjZVRyYWlsaW5nU2xhc2giLCJjcmVhdGVGb2xkZXJzIiwicGFyZW50Rm9sZGVyIiwiZm9sZGVyQWRkIiwiY2FsbCIsImlzVW5pY29kZVN0cmluZyIsImJpbmFyeSIsImJhc2U2NCIsImlzQ29tcHJlc3NlZEVtcHR5IiwidW5jb21wcmVzc2VkU2l6ZSIsImxlbmd0aCIsInppcE9iamVjdENvbnRlbnQiLCJpc05vZGUiLCJpc1N0cmVhbSIsInByZXBhcmVDb250ZW50Iiwib3B0aW1pemVkQmluYXJ5U3RyaW5nIiwib2JqZWN0IiwiZmlsZXMiLCJwYXRoIiwic2xpY2UiLCJzdWJzdHJpbmciLCJsYXN0U2xhc2giLCJsYXN0SW5kZXhPZiIsImlzUmVnRXhwIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJvdXQiLCJsb2FkIiwiRXJyb3IiLCJmb3JFYWNoIiwiY2IiLCJmaWxlbmFtZSIsInJlbGF0aXZlUGF0aCIsImZpbGUiLCJyb290IiwiZmlsdGVyIiwic2VhcmNoIiwicmVzdWx0IiwiZW50cnkiLCJwdXNoIiwiYXJndW1lbnRzIiwicmVnZXhwIiwidGVzdCIsIm9iaiIsImZvbGRlciIsImFyZyIsIm5ld0ZvbGRlciIsInJldCIsImNsb25lIiwicmVtb3ZlIiwia2lkcyIsImkiLCJnZW5lcmF0ZUludGVybmFsU3RyZWFtIiwib3B0aW9ucyIsIndvcmtlciIsIm9wdHMiLCJzdHJlYW1GaWxlcyIsImNvbXByZXNzaW9uT3B0aW9ucyIsInR5cGUiLCJwbGF0Zm9ybSIsImNvbW1lbnQiLCJtaW1lVHlwZSIsImVuY29kZUZpbGVOYW1lIiwidXRmOGVuY29kZSIsInRvTG93ZXJDYXNlIiwiY2hlY2tTdXBwb3J0IiwiZ2VuZXJhdGVXb3JrZXIiLCJlIiwiZXJyb3IiLCJnZW5lcmF0ZUFzeW5jIiwib25VcGRhdGUiLCJhY2N1bXVsYXRlIiwiZ2VuZXJhdGVOb2RlU3RyZWFtIiwidG9Ob2RlanNTdHJlYW0iLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/object.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/reader/ArrayReader.js":
/*!******************************************************!*\
  !*** ./node_modules/jszip/lib/reader/ArrayReader.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar DataReader = __webpack_require__(/*! ./DataReader */ \"(ssr)/./node_modules/jszip/lib/reader/DataReader.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nfunction ArrayReader(data) {\n    DataReader.call(this, data);\n    for(var i = 0; i < this.data.length; i++){\n        data[i] = data[i] & 0xFF;\n    }\n}\nutils.inherits(ArrayReader, DataReader);\n/**\n * @see DataReader.byteAt\n */ ArrayReader.prototype.byteAt = function(i) {\n    return this.data[this.zero + i];\n};\n/**\n * @see DataReader.lastIndexOfSignature\n */ ArrayReader.prototype.lastIndexOfSignature = function(sig) {\n    var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);\n    for(var i = this.length - 4; i >= 0; --i){\n        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {\n            return i - this.zero;\n        }\n    }\n    return -1;\n};\n/**\n * @see DataReader.readAndCheckSignature\n */ ArrayReader.prototype.readAndCheckSignature = function(sig) {\n    var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3), data = this.readData(4);\n    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];\n};\n/**\n * @see DataReader.readData\n */ ArrayReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    if (size === 0) {\n        return [];\n    }\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = ArrayReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9BcnJheVJlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGFBQWFDLG1CQUFPQSxDQUFDLHlFQUFjO0FBQ3ZDLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDLHlEQUFVO0FBRTlCLFNBQVNFLFlBQVlDLElBQUk7SUFDckJKLFdBQVdLLElBQUksQ0FBQyxJQUFJLEVBQUVEO0lBQ3RCLElBQUksSUFBSUUsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ0YsSUFBSSxDQUFDRyxNQUFNLEVBQUVELElBQUs7UUFDdENGLElBQUksQ0FBQ0UsRUFBRSxHQUFHRixJQUFJLENBQUNFLEVBQUUsR0FBRztJQUN4QjtBQUNKO0FBQ0FKLE1BQU1NLFFBQVEsQ0FBQ0wsYUFBYUg7QUFDNUI7O0NBRUMsR0FDREcsWUFBWU0sU0FBUyxDQUFDQyxNQUFNLEdBQUcsU0FBU0osQ0FBQztJQUNyQyxPQUFPLElBQUksQ0FBQ0YsSUFBSSxDQUFDLElBQUksQ0FBQ08sSUFBSSxHQUFHTCxFQUFFO0FBQ25DO0FBQ0E7O0NBRUMsR0FDREgsWUFBWU0sU0FBUyxDQUFDRyxvQkFBb0IsR0FBRyxTQUFTQyxHQUFHO0lBQ3JELElBQUlDLE9BQU9ELElBQUlFLFVBQVUsQ0FBQyxJQUN0QkMsT0FBT0gsSUFBSUUsVUFBVSxDQUFDLElBQ3RCRSxPQUFPSixJQUFJRSxVQUFVLENBQUMsSUFDdEJHLE9BQU9MLElBQUlFLFVBQVUsQ0FBQztJQUMxQixJQUFLLElBQUlULElBQUksSUFBSSxDQUFDQyxNQUFNLEdBQUcsR0FBR0QsS0FBSyxHQUFHLEVBQUVBLEVBQUc7UUFDdkMsSUFBSSxJQUFJLENBQUNGLElBQUksQ0FBQ0UsRUFBRSxLQUFLUSxRQUFRLElBQUksQ0FBQ1YsSUFBSSxDQUFDRSxJQUFJLEVBQUUsS0FBS1UsUUFBUSxJQUFJLENBQUNaLElBQUksQ0FBQ0UsSUFBSSxFQUFFLEtBQUtXLFFBQVEsSUFBSSxDQUFDYixJQUFJLENBQUNFLElBQUksRUFBRSxLQUFLWSxNQUFNO1lBQzlHLE9BQU9aLElBQUksSUFBSSxDQUFDSyxJQUFJO1FBQ3hCO0lBQ0o7SUFFQSxPQUFPLENBQUM7QUFDWjtBQUNBOztDQUVDLEdBQ0RSLFlBQVlNLFNBQVMsQ0FBQ1UscUJBQXFCLEdBQUcsU0FBVU4sR0FBRztJQUN2RCxJQUFJQyxPQUFPRCxJQUFJRSxVQUFVLENBQUMsSUFDdEJDLE9BQU9ILElBQUlFLFVBQVUsQ0FBQyxJQUN0QkUsT0FBT0osSUFBSUUsVUFBVSxDQUFDLElBQ3RCRyxPQUFPTCxJQUFJRSxVQUFVLENBQUMsSUFDdEJYLE9BQU8sSUFBSSxDQUFDZ0IsUUFBUSxDQUFDO0lBQ3pCLE9BQU9OLFNBQVNWLElBQUksQ0FBQyxFQUFFLElBQUlZLFNBQVNaLElBQUksQ0FBQyxFQUFFLElBQUlhLFNBQVNiLElBQUksQ0FBQyxFQUFFLElBQUljLFNBQVNkLElBQUksQ0FBQyxFQUFFO0FBQ3ZGO0FBQ0E7O0NBRUMsR0FDREQsWUFBWU0sU0FBUyxDQUFDVyxRQUFRLEdBQUcsU0FBU0MsSUFBSTtJQUMxQyxJQUFJLENBQUNDLFdBQVcsQ0FBQ0Q7SUFDakIsSUFBR0EsU0FBUyxHQUFHO1FBQ1gsT0FBTyxFQUFFO0lBQ2I7SUFDQSxJQUFJRSxTQUFTLElBQUksQ0FBQ25CLElBQUksQ0FBQ29CLEtBQUssQ0FBQyxJQUFJLENBQUNiLElBQUksR0FBRyxJQUFJLENBQUNjLEtBQUssRUFBRSxJQUFJLENBQUNkLElBQUksR0FBRyxJQUFJLENBQUNjLEtBQUssR0FBR0o7SUFDOUUsSUFBSSxDQUFDSSxLQUFLLElBQUlKO0lBQ2QsT0FBT0U7QUFDWDtBQUNBRyxPQUFPQyxPQUFPLEdBQUd4QiIsInNvdXJjZXMiOlsid2VicGFjazovL3RzYS1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL0FycmF5UmVhZGVyLmpzP2YzZjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRGF0YVJlYWRlciA9IHJlcXVpcmUoXCIuL0RhdGFSZWFkZXJcIik7XG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5cbmZ1bmN0aW9uIEFycmF5UmVhZGVyKGRhdGEpIHtcbiAgICBEYXRhUmVhZGVyLmNhbGwodGhpcywgZGF0YSk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBkYXRhW2ldID0gZGF0YVtpXSAmIDB4RkY7XG4gICAgfVxufVxudXRpbHMuaW5oZXJpdHMoQXJyYXlSZWFkZXIsIERhdGFSZWFkZXIpO1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIuYnl0ZUF0XG4gKi9cbkFycmF5UmVhZGVyLnByb3RvdHlwZS5ieXRlQXQgPSBmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVt0aGlzLnplcm8gKyBpXTtcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5sYXN0SW5kZXhPZlNpZ25hdHVyZVxuICovXG5BcnJheVJlYWRlci5wcm90b3R5cGUubGFzdEluZGV4T2ZTaWduYXR1cmUgPSBmdW5jdGlvbihzaWcpIHtcbiAgICB2YXIgc2lnMCA9IHNpZy5jaGFyQ29kZUF0KDApLFxuICAgICAgICBzaWcxID0gc2lnLmNoYXJDb2RlQXQoMSksXG4gICAgICAgIHNpZzIgPSBzaWcuY2hhckNvZGVBdCgyKSxcbiAgICAgICAgc2lnMyA9IHNpZy5jaGFyQ29kZUF0KDMpO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDQ7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFbaV0gPT09IHNpZzAgJiYgdGhpcy5kYXRhW2kgKyAxXSA9PT0gc2lnMSAmJiB0aGlzLmRhdGFbaSArIDJdID09PSBzaWcyICYmIHRoaXMuZGF0YVtpICsgM10gPT09IHNpZzMpIHtcbiAgICAgICAgICAgIHJldHVybiBpIC0gdGhpcy56ZXJvO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xufTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLnJlYWRBbmRDaGVja1NpZ25hdHVyZVxuICovXG5BcnJheVJlYWRlci5wcm90b3R5cGUucmVhZEFuZENoZWNrU2lnbmF0dXJlID0gZnVuY3Rpb24gKHNpZykge1xuICAgIHZhciBzaWcwID0gc2lnLmNoYXJDb2RlQXQoMCksXG4gICAgICAgIHNpZzEgPSBzaWcuY2hhckNvZGVBdCgxKSxcbiAgICAgICAgc2lnMiA9IHNpZy5jaGFyQ29kZUF0KDIpLFxuICAgICAgICBzaWczID0gc2lnLmNoYXJDb2RlQXQoMyksXG4gICAgICAgIGRhdGEgPSB0aGlzLnJlYWREYXRhKDQpO1xuICAgIHJldHVybiBzaWcwID09PSBkYXRhWzBdICYmIHNpZzEgPT09IGRhdGFbMV0gJiYgc2lnMiA9PT0gZGF0YVsyXSAmJiBzaWczID09PSBkYXRhWzNdO1xufTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLnJlYWREYXRhXG4gKi9cbkFycmF5UmVhZGVyLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgIGlmKHNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMuemVybyArIHRoaXMuaW5kZXgsIHRoaXMuemVybyArIHRoaXMuaW5kZXggKyBzaXplKTtcbiAgICB0aGlzLmluZGV4ICs9IHNpemU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5UmVhZGVyO1xuIl0sIm5hbWVzIjpbIkRhdGFSZWFkZXIiLCJyZXF1aXJlIiwidXRpbHMiLCJBcnJheVJlYWRlciIsImRhdGEiLCJjYWxsIiwiaSIsImxlbmd0aCIsImluaGVyaXRzIiwicHJvdG90eXBlIiwiYnl0ZUF0IiwiemVybyIsImxhc3RJbmRleE9mU2lnbmF0dXJlIiwic2lnIiwic2lnMCIsImNoYXJDb2RlQXQiLCJzaWcxIiwic2lnMiIsInNpZzMiLCJyZWFkQW5kQ2hlY2tTaWduYXR1cmUiLCJyZWFkRGF0YSIsInNpemUiLCJjaGVja09mZnNldCIsInJlc3VsdCIsInNsaWNlIiwiaW5kZXgiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/reader/ArrayReader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/reader/DataReader.js":
/*!*****************************************************!*\
  !*** ./node_modules/jszip/lib/reader/DataReader.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nfunction DataReader(data) {\n    this.data = data; // type : see implementation\n    this.length = data.length;\n    this.index = 0;\n    this.zero = 0;\n}\nDataReader.prototype = {\n    /**\n     * Check that the offset will not go too far.\n     * @param {string} offset the additional offset to check.\n     * @throws {Error} an Error if the offset is out of bounds.\n     */ checkOffset: function(offset) {\n        this.checkIndex(this.index + offset);\n    },\n    /**\n     * Check that the specified index will not be too far.\n     * @param {string} newIndex the index to check.\n     * @throws {Error} an Error if the index is out of bounds.\n     */ checkIndex: function(newIndex) {\n        if (this.length < this.zero + newIndex || newIndex < 0) {\n            throw new Error(\"End of data reached (data length = \" + this.length + \", asked index = \" + newIndex + \"). Corrupted zip ?\");\n        }\n    },\n    /**\n     * Change the index.\n     * @param {number} newIndex The new index.\n     * @throws {Error} if the new index is out of the data.\n     */ setIndex: function(newIndex) {\n        this.checkIndex(newIndex);\n        this.index = newIndex;\n    },\n    /**\n     * Skip the next n bytes.\n     * @param {number} n the number of bytes to skip.\n     * @throws {Error} if the new index is out of the data.\n     */ skip: function(n) {\n        this.setIndex(this.index + n);\n    },\n    /**\n     * Get the byte at the specified index.\n     * @param {number} i the index to use.\n     * @return {number} a byte.\n     */ byteAt: function() {\n    // see implementations\n    },\n    /**\n     * Get the next number with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {number} the corresponding number.\n     */ readInt: function(size) {\n        var result = 0, i;\n        this.checkOffset(size);\n        for(i = this.index + size - 1; i >= this.index; i--){\n            result = (result << 8) + this.byteAt(i);\n        }\n        this.index += size;\n        return result;\n    },\n    /**\n     * Get the next string with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {string} the corresponding string.\n     */ readString: function(size) {\n        return utils.transformTo(\"string\", this.readData(size));\n    },\n    /**\n     * Get raw data without conversion, <size> bytes.\n     * @param {number} size the number of bytes to read.\n     * @return {Object} the raw data, implementation specific.\n     */ readData: function() {\n    // see implementations\n    },\n    /**\n     * Find the last occurrence of a zip signature (4 bytes).\n     * @param {string} sig the signature to find.\n     * @return {number} the index of the last occurrence, -1 if not found.\n     */ lastIndexOfSignature: function() {\n    // see implementations\n    },\n    /**\n     * Read the signature (4 bytes) at the current position and compare it with sig.\n     * @param {string} sig the expected signature\n     * @return {boolean} true if the signature matches, false otherwise.\n     */ readAndCheckSignature: function() {\n    // see implementations\n    },\n    /**\n     * Get the next date.\n     * @return {Date} the date.\n     */ readDate: function() {\n        var dostime = this.readInt(4);\n        return new Date(Date.UTC((dostime >> 25 & 0x7f) + 1980, (dostime >> 21 & 0x0f) - 1, dostime >> 16 & 0x1f, dostime >> 11 & 0x1f, dostime >> 5 & 0x3f, (dostime & 0x1f) << 1)); // second\n    }\n};\nmodule.exports = DataReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9EYXRhUmVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUMseURBQVU7QUFFOUIsU0FBU0MsV0FBV0MsSUFBSTtJQUNwQixJQUFJLENBQUNBLElBQUksR0FBR0EsTUFBTSw0QkFBNEI7SUFDOUMsSUFBSSxDQUFDQyxNQUFNLEdBQUdELEtBQUtDLE1BQU07SUFDekIsSUFBSSxDQUFDQyxLQUFLLEdBQUc7SUFDYixJQUFJLENBQUNDLElBQUksR0FBRztBQUNoQjtBQUNBSixXQUFXSyxTQUFTLEdBQUc7SUFDbkI7Ozs7S0FJQyxHQUNEQyxhQUFhLFNBQVNDLE1BQU07UUFDeEIsSUFBSSxDQUFDQyxVQUFVLENBQUMsSUFBSSxDQUFDTCxLQUFLLEdBQUdJO0lBQ2pDO0lBQ0E7Ozs7S0FJQyxHQUNEQyxZQUFZLFNBQVNDLFFBQVE7UUFDekIsSUFBSSxJQUFJLENBQUNQLE1BQU0sR0FBRyxJQUFJLENBQUNFLElBQUksR0FBR0ssWUFBWUEsV0FBVyxHQUFHO1lBQ3BELE1BQU0sSUFBSUMsTUFBTSx3Q0FBd0MsSUFBSSxDQUFDUixNQUFNLEdBQUcscUJBQXNCTyxXQUFZO1FBQzVHO0lBQ0o7SUFDQTs7OztLQUlDLEdBQ0RFLFVBQVUsU0FBU0YsUUFBUTtRQUN2QixJQUFJLENBQUNELFVBQVUsQ0FBQ0M7UUFDaEIsSUFBSSxDQUFDTixLQUFLLEdBQUdNO0lBQ2pCO0lBQ0E7Ozs7S0FJQyxHQUNERyxNQUFNLFNBQVNDLENBQUM7UUFDWixJQUFJLENBQUNGLFFBQVEsQ0FBQyxJQUFJLENBQUNSLEtBQUssR0FBR1U7SUFDL0I7SUFDQTs7OztLQUlDLEdBQ0RDLFFBQVE7SUFDSixzQkFBc0I7SUFDMUI7SUFDQTs7OztLQUlDLEdBQ0RDLFNBQVMsU0FBU0MsSUFBSTtRQUNsQixJQUFJQyxTQUFTLEdBQ1RDO1FBQ0osSUFBSSxDQUFDWixXQUFXLENBQUNVO1FBQ2pCLElBQUtFLElBQUksSUFBSSxDQUFDZixLQUFLLEdBQUdhLE9BQU8sR0FBR0UsS0FBSyxJQUFJLENBQUNmLEtBQUssRUFBRWUsSUFBSztZQUNsREQsU0FBUyxDQUFDQSxVQUFVLEtBQUssSUFBSSxDQUFDSCxNQUFNLENBQUNJO1FBQ3pDO1FBQ0EsSUFBSSxDQUFDZixLQUFLLElBQUlhO1FBQ2QsT0FBT0M7SUFDWDtJQUNBOzs7O0tBSUMsR0FDREUsWUFBWSxTQUFTSCxJQUFJO1FBQ3JCLE9BQU9sQixNQUFNc0IsV0FBVyxDQUFDLFVBQVUsSUFBSSxDQUFDQyxRQUFRLENBQUNMO0lBQ3JEO0lBQ0E7Ozs7S0FJQyxHQUNESyxVQUFVO0lBQ04sc0JBQXNCO0lBQzFCO0lBQ0E7Ozs7S0FJQyxHQUNEQyxzQkFBc0I7SUFDbEIsc0JBQXNCO0lBQzFCO0lBQ0E7Ozs7S0FJQyxHQUNEQyx1QkFBdUI7SUFDbkIsc0JBQXNCO0lBQzFCO0lBQ0E7OztLQUdDLEdBQ0RDLFVBQVU7UUFDTixJQUFJQyxVQUFVLElBQUksQ0FBQ1YsT0FBTyxDQUFDO1FBQzNCLE9BQU8sSUFBSVcsS0FBS0EsS0FBS0MsR0FBRyxDQUNwQixDQUFDLFdBQVksS0FBTSxJQUFHLElBQUssTUFDM0IsQ0FBQyxXQUFZLEtBQU0sSUFBRyxJQUFLLEdBQzNCLFdBQVksS0FBTSxNQUNsQixXQUFZLEtBQU0sTUFDbEIsV0FBWSxJQUFLLE1BQ2pCLENBQUNGLFVBQVUsSUFBRyxLQUFNLEtBQUssU0FBUztJQUMxQztBQUNKO0FBQ0FHLE9BQU9DLE9BQU8sR0FBRzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHNhLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvRGF0YVJlYWRlci5qcz9jYmVlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuXG5mdW5jdGlvbiBEYXRhUmVhZGVyKGRhdGEpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhOyAvLyB0eXBlIDogc2VlIGltcGxlbWVudGF0aW9uXG4gICAgdGhpcy5sZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB0aGlzLnplcm8gPSAwO1xufVxuRGF0YVJlYWRlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCB0aGUgb2Zmc2V0IHdpbGwgbm90IGdvIHRvbyBmYXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9mZnNldCB0aGUgYWRkaXRpb25hbCBvZmZzZXQgdG8gY2hlY2suXG4gICAgICogQHRocm93cyB7RXJyb3J9IGFuIEVycm9yIGlmIHRoZSBvZmZzZXQgaXMgb3V0IG9mIGJvdW5kcy5cbiAgICAgKi9cbiAgICBjaGVja09mZnNldDogZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tJbmRleCh0aGlzLmluZGV4ICsgb2Zmc2V0KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgdGhlIHNwZWNpZmllZCBpbmRleCB3aWxsIG5vdCBiZSB0b28gZmFyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdJbmRleCB0aGUgaW5kZXggdG8gY2hlY2suXG4gICAgICogQHRocm93cyB7RXJyb3J9IGFuIEVycm9yIGlmIHRoZSBpbmRleCBpcyBvdXQgb2YgYm91bmRzLlxuICAgICAqL1xuICAgIGNoZWNrSW5kZXg6IGZ1bmN0aW9uKG5ld0luZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA8IHRoaXMuemVybyArIG5ld0luZGV4IHx8IG5ld0luZGV4IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5kIG9mIGRhdGEgcmVhY2hlZCAoZGF0YSBsZW5ndGggPSBcIiArIHRoaXMubGVuZ3RoICsgXCIsIGFza2VkIGluZGV4ID0gXCIgKyAobmV3SW5kZXgpICsgXCIpLiBDb3JydXB0ZWQgemlwID9cIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoYW5nZSB0aGUgaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld0luZGV4IFRoZSBuZXcgaW5kZXguXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBuZXcgaW5kZXggaXMgb3V0IG9mIHRoZSBkYXRhLlxuICAgICAqL1xuICAgIHNldEluZGV4OiBmdW5jdGlvbihuZXdJbmRleCkge1xuICAgICAgICB0aGlzLmNoZWNrSW5kZXgobmV3SW5kZXgpO1xuICAgICAgICB0aGlzLmluZGV4ID0gbmV3SW5kZXg7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTa2lwIHRoZSBuZXh0IG4gYnl0ZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gdGhlIG51bWJlciBvZiBieXRlcyB0byBza2lwLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgbmV3IGluZGV4IGlzIG91dCBvZiB0aGUgZGF0YS5cbiAgICAgKi9cbiAgICBza2lwOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHRoaXMuc2V0SW5kZXgodGhpcy5pbmRleCArIG4pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBieXRlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGkgdGhlIGluZGV4IHRvIHVzZS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IGEgYnl0ZS5cbiAgICAgKi9cbiAgICBieXRlQXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBzZWUgaW1wbGVtZW50YXRpb25zXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgbnVtYmVyIHdpdGggYSBnaXZlbiBieXRlIHNpemUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIGNvcnJlc3BvbmRpbmcgbnVtYmVyLlxuICAgICAqL1xuICAgIHJlYWRJbnQ6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IDAsXG4gICAgICAgICAgICBpO1xuICAgICAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgICAgICBmb3IgKGkgPSB0aGlzLmluZGV4ICsgc2l6ZSAtIDE7IGkgPj0gdGhpcy5pbmRleDsgaS0tKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAocmVzdWx0IDw8IDgpICsgdGhpcy5ieXRlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IHN0cmluZyB3aXRoIGEgZ2l2ZW4gYnl0ZSBzaXplLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBjb3JyZXNwb25kaW5nIHN0cmluZy5cbiAgICAgKi9cbiAgICByZWFkU3RyaW5nOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIHJldHVybiB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB0aGlzLnJlYWREYXRhKHNpemUpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCByYXcgZGF0YSB3aXRob3V0IGNvbnZlcnNpb24sIDxzaXplPiBieXRlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgcmF3IGRhdGEsIGltcGxlbWVudGF0aW9uIHNwZWNpZmljLlxuICAgICAqL1xuICAgIHJlYWREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gc2VlIGltcGxlbWVudGF0aW9uc1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIGEgemlwIHNpZ25hdHVyZSAoNCBieXRlcykuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNpZyB0aGUgc2lnbmF0dXJlIHRvIGZpbmQuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgb2NjdXJyZW5jZSwgLTEgaWYgbm90IGZvdW5kLlxuICAgICAqL1xuICAgIGxhc3RJbmRleE9mU2lnbmF0dXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gc2VlIGltcGxlbWVudGF0aW9uc1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgc2lnbmF0dXJlICg0IGJ5dGVzKSBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiBhbmQgY29tcGFyZSBpdCB3aXRoIHNpZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2lnIHRoZSBleHBlY3RlZCBzaWduYXR1cmVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBzaWduYXR1cmUgbWF0Y2hlcywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHJlYWRBbmRDaGVja1NpZ25hdHVyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHNlZSBpbXBsZW1lbnRhdGlvbnNcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmV4dCBkYXRlLlxuICAgICAqIEByZXR1cm4ge0RhdGV9IHRoZSBkYXRlLlxuICAgICAqL1xuICAgIHJlYWREYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRvc3RpbWUgPSB0aGlzLnJlYWRJbnQoNCk7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyhcbiAgICAgICAgICAgICgoZG9zdGltZSA+PiAyNSkgJiAweDdmKSArIDE5ODAsIC8vIHllYXJcbiAgICAgICAgICAgICgoZG9zdGltZSA+PiAyMSkgJiAweDBmKSAtIDEsIC8vIG1vbnRoXG4gICAgICAgICAgICAoZG9zdGltZSA+PiAxNikgJiAweDFmLCAvLyBkYXlcbiAgICAgICAgICAgIChkb3N0aW1lID4+IDExKSAmIDB4MWYsIC8vIGhvdXJcbiAgICAgICAgICAgIChkb3N0aW1lID4+IDUpICYgMHgzZiwgLy8gbWludXRlXG4gICAgICAgICAgICAoZG9zdGltZSAmIDB4MWYpIDw8IDEpKTsgLy8gc2Vjb25kXG4gICAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gRGF0YVJlYWRlcjtcbiJdLCJuYW1lcyI6WyJ1dGlscyIsInJlcXVpcmUiLCJEYXRhUmVhZGVyIiwiZGF0YSIsImxlbmd0aCIsImluZGV4IiwiemVybyIsInByb3RvdHlwZSIsImNoZWNrT2Zmc2V0Iiwib2Zmc2V0IiwiY2hlY2tJbmRleCIsIm5ld0luZGV4IiwiRXJyb3IiLCJzZXRJbmRleCIsInNraXAiLCJuIiwiYnl0ZUF0IiwicmVhZEludCIsInNpemUiLCJyZXN1bHQiLCJpIiwicmVhZFN0cmluZyIsInRyYW5zZm9ybVRvIiwicmVhZERhdGEiLCJsYXN0SW5kZXhPZlNpZ25hdHVyZSIsInJlYWRBbmRDaGVja1NpZ25hdHVyZSIsInJlYWREYXRlIiwiZG9zdGltZSIsIkRhdGUiLCJVVEMiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/reader/DataReader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/reader/NodeBufferReader.js":
/*!***********************************************************!*\
  !*** ./node_modules/jszip/lib/reader/NodeBufferReader.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar Uint8ArrayReader = __webpack_require__(/*! ./Uint8ArrayReader */ \"(ssr)/./node_modules/jszip/lib/reader/Uint8ArrayReader.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nfunction NodeBufferReader(data) {\n    Uint8ArrayReader.call(this, data);\n}\nutils.inherits(NodeBufferReader, Uint8ArrayReader);\n/**\n * @see DataReader.readData\n */ NodeBufferReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = NodeBufferReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9Ob2RlQnVmZmVyUmVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsbUJBQW1CQyxtQkFBT0EsQ0FBQyxxRkFBb0I7QUFDbkQsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUMseURBQVU7QUFFOUIsU0FBU0UsaUJBQWlCQyxJQUFJO0lBQzFCSixpQkFBaUJLLElBQUksQ0FBQyxJQUFJLEVBQUVEO0FBQ2hDO0FBQ0FGLE1BQU1JLFFBQVEsQ0FBQ0gsa0JBQWtCSDtBQUVqQzs7Q0FFQyxHQUNERyxpQkFBaUJJLFNBQVMsQ0FBQ0MsUUFBUSxHQUFHLFNBQVNDLElBQUk7SUFDL0MsSUFBSSxDQUFDQyxXQUFXLENBQUNEO0lBQ2pCLElBQUlFLFNBQVMsSUFBSSxDQUFDUCxJQUFJLENBQUNRLEtBQUssQ0FBQyxJQUFJLENBQUNDLElBQUksR0FBRyxJQUFJLENBQUNDLEtBQUssRUFBRSxJQUFJLENBQUNELElBQUksR0FBRyxJQUFJLENBQUNDLEtBQUssR0FBR0w7SUFDOUUsSUFBSSxDQUFDSyxLQUFLLElBQUlMO0lBQ2QsT0FBT0U7QUFDWDtBQUNBSSxPQUFPQyxPQUFPLEdBQUdiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHNhLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvTm9kZUJ1ZmZlclJlYWRlci5qcz81MzY1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIFVpbnQ4QXJyYXlSZWFkZXIgPSByZXF1aXJlKFwiLi9VaW50OEFycmF5UmVhZGVyXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuXG5mdW5jdGlvbiBOb2RlQnVmZmVyUmVhZGVyKGRhdGEpIHtcbiAgICBVaW50OEFycmF5UmVhZGVyLmNhbGwodGhpcywgZGF0YSk7XG59XG51dGlscy5pbmhlcml0cyhOb2RlQnVmZmVyUmVhZGVyLCBVaW50OEFycmF5UmVhZGVyKTtcblxuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIucmVhZERhdGFcbiAqL1xuTm9kZUJ1ZmZlclJlYWRlci5wcm90b3R5cGUucmVhZERhdGEgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdGhpcy5jaGVja09mZnNldChzaXplKTtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMuemVybyArIHRoaXMuaW5kZXgsIHRoaXMuemVybyArIHRoaXMuaW5kZXggKyBzaXplKTtcbiAgICB0aGlzLmluZGV4ICs9IHNpemU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVCdWZmZXJSZWFkZXI7XG4iXSwibmFtZXMiOlsiVWludDhBcnJheVJlYWRlciIsInJlcXVpcmUiLCJ1dGlscyIsIk5vZGVCdWZmZXJSZWFkZXIiLCJkYXRhIiwiY2FsbCIsImluaGVyaXRzIiwicHJvdG90eXBlIiwicmVhZERhdGEiLCJzaXplIiwiY2hlY2tPZmZzZXQiLCJyZXN1bHQiLCJzbGljZSIsInplcm8iLCJpbmRleCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/reader/NodeBufferReader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/reader/StringReader.js":
/*!*******************************************************!*\
  !*** ./node_modules/jszip/lib/reader/StringReader.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar DataReader = __webpack_require__(/*! ./DataReader */ \"(ssr)/./node_modules/jszip/lib/reader/DataReader.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nfunction StringReader(data) {\n    DataReader.call(this, data);\n}\nutils.inherits(StringReader, DataReader);\n/**\n * @see DataReader.byteAt\n */ StringReader.prototype.byteAt = function(i) {\n    return this.data.charCodeAt(this.zero + i);\n};\n/**\n * @see DataReader.lastIndexOfSignature\n */ StringReader.prototype.lastIndexOfSignature = function(sig) {\n    return this.data.lastIndexOf(sig) - this.zero;\n};\n/**\n * @see DataReader.readAndCheckSignature\n */ StringReader.prototype.readAndCheckSignature = function(sig) {\n    var data = this.readData(4);\n    return sig === data;\n};\n/**\n * @see DataReader.readData\n */ StringReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    // this will work because the constructor applied the \"& 0xff\" mask.\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = StringReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9TdHJpbmdSZWFkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxhQUFhQyxtQkFBT0EsQ0FBQyx5RUFBYztBQUN2QyxJQUFJQyxRQUFRRCxtQkFBT0EsQ0FBQyx5REFBVTtBQUU5QixTQUFTRSxhQUFhQyxJQUFJO0lBQ3RCSixXQUFXSyxJQUFJLENBQUMsSUFBSSxFQUFFRDtBQUMxQjtBQUNBRixNQUFNSSxRQUFRLENBQUNILGNBQWNIO0FBQzdCOztDQUVDLEdBQ0RHLGFBQWFJLFNBQVMsQ0FBQ0MsTUFBTSxHQUFHLFNBQVNDLENBQUM7SUFDdEMsT0FBTyxJQUFJLENBQUNMLElBQUksQ0FBQ00sVUFBVSxDQUFDLElBQUksQ0FBQ0MsSUFBSSxHQUFHRjtBQUM1QztBQUNBOztDQUVDLEdBQ0ROLGFBQWFJLFNBQVMsQ0FBQ0ssb0JBQW9CLEdBQUcsU0FBU0MsR0FBRztJQUN0RCxPQUFPLElBQUksQ0FBQ1QsSUFBSSxDQUFDVSxXQUFXLENBQUNELE9BQU8sSUFBSSxDQUFDRixJQUFJO0FBQ2pEO0FBQ0E7O0NBRUMsR0FDRFIsYUFBYUksU0FBUyxDQUFDUSxxQkFBcUIsR0FBRyxTQUFVRixHQUFHO0lBQ3hELElBQUlULE9BQU8sSUFBSSxDQUFDWSxRQUFRLENBQUM7SUFDekIsT0FBT0gsUUFBUVQ7QUFDbkI7QUFDQTs7Q0FFQyxHQUNERCxhQUFhSSxTQUFTLENBQUNTLFFBQVEsR0FBRyxTQUFTQyxJQUFJO0lBQzNDLElBQUksQ0FBQ0MsV0FBVyxDQUFDRDtJQUNqQixvRUFBb0U7SUFDcEUsSUFBSUUsU0FBUyxJQUFJLENBQUNmLElBQUksQ0FBQ2dCLEtBQUssQ0FBQyxJQUFJLENBQUNULElBQUksR0FBRyxJQUFJLENBQUNVLEtBQUssRUFBRSxJQUFJLENBQUNWLElBQUksR0FBRyxJQUFJLENBQUNVLEtBQUssR0FBR0o7SUFDOUUsSUFBSSxDQUFDSSxLQUFLLElBQUlKO0lBQ2QsT0FBT0U7QUFDWDtBQUNBRyxPQUFPQyxPQUFPLEdBQUdwQiIsInNvdXJjZXMiOlsid2VicGFjazovL3RzYS1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL1N0cmluZ1JlYWRlci5qcz80MDBiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIERhdGFSZWFkZXIgPSByZXF1aXJlKFwiLi9EYXRhUmVhZGVyXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuXG5mdW5jdGlvbiBTdHJpbmdSZWFkZXIoZGF0YSkge1xuICAgIERhdGFSZWFkZXIuY2FsbCh0aGlzLCBkYXRhKTtcbn1cbnV0aWxzLmluaGVyaXRzKFN0cmluZ1JlYWRlciwgRGF0YVJlYWRlcik7XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5ieXRlQXRcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5ieXRlQXQgPSBmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMuemVybyArIGkpO1xufTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLmxhc3RJbmRleE9mU2lnbmF0dXJlXG4gKi9cblN0cmluZ1JlYWRlci5wcm90b3R5cGUubGFzdEluZGV4T2ZTaWduYXR1cmUgPSBmdW5jdGlvbihzaWcpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmxhc3RJbmRleE9mKHNpZykgLSB0aGlzLnplcm87XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIucmVhZEFuZENoZWNrU2lnbmF0dXJlXG4gKi9cblN0cmluZ1JlYWRlci5wcm90b3R5cGUucmVhZEFuZENoZWNrU2lnbmF0dXJlID0gZnVuY3Rpb24gKHNpZykge1xuICAgIHZhciBkYXRhID0gdGhpcy5yZWFkRGF0YSg0KTtcbiAgICByZXR1cm4gc2lnID09PSBkYXRhO1xufTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLnJlYWREYXRhXG4gKi9cblN0cmluZ1JlYWRlci5wcm90b3R5cGUucmVhZERhdGEgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdGhpcy5jaGVja09mZnNldChzaXplKTtcbiAgICAvLyB0aGlzIHdpbGwgd29yayBiZWNhdXNlIHRoZSBjb25zdHJ1Y3RvciBhcHBsaWVkIHRoZSBcIiYgMHhmZlwiIG1hc2suXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBTdHJpbmdSZWFkZXI7XG4iXSwibmFtZXMiOlsiRGF0YVJlYWRlciIsInJlcXVpcmUiLCJ1dGlscyIsIlN0cmluZ1JlYWRlciIsImRhdGEiLCJjYWxsIiwiaW5oZXJpdHMiLCJwcm90b3R5cGUiLCJieXRlQXQiLCJpIiwiY2hhckNvZGVBdCIsInplcm8iLCJsYXN0SW5kZXhPZlNpZ25hdHVyZSIsInNpZyIsImxhc3RJbmRleE9mIiwicmVhZEFuZENoZWNrU2lnbmF0dXJlIiwicmVhZERhdGEiLCJzaXplIiwiY2hlY2tPZmZzZXQiLCJyZXN1bHQiLCJzbGljZSIsImluZGV4IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/reader/StringReader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/reader/Uint8ArrayReader.js":
/*!***********************************************************!*\
  !*** ./node_modules/jszip/lib/reader/Uint8ArrayReader.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar ArrayReader = __webpack_require__(/*! ./ArrayReader */ \"(ssr)/./node_modules/jszip/lib/reader/ArrayReader.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nfunction Uint8ArrayReader(data) {\n    ArrayReader.call(this, data);\n}\nutils.inherits(Uint8ArrayReader, ArrayReader);\n/**\n * @see DataReader.readData\n */ Uint8ArrayReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    if (size === 0) {\n        // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].\n        return new Uint8Array(0);\n    }\n    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = Uint8ArrayReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9VaW50OEFycmF5UmVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsY0FBY0MsbUJBQU9BLENBQUMsMkVBQWU7QUFDekMsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUMseURBQVU7QUFFOUIsU0FBU0UsaUJBQWlCQyxJQUFJO0lBQzFCSixZQUFZSyxJQUFJLENBQUMsSUFBSSxFQUFFRDtBQUMzQjtBQUNBRixNQUFNSSxRQUFRLENBQUNILGtCQUFrQkg7QUFDakM7O0NBRUMsR0FDREcsaUJBQWlCSSxTQUFTLENBQUNDLFFBQVEsR0FBRyxTQUFTQyxJQUFJO0lBQy9DLElBQUksQ0FBQ0MsV0FBVyxDQUFDRDtJQUNqQixJQUFHQSxTQUFTLEdBQUc7UUFDWCxpRkFBaUY7UUFDakYsT0FBTyxJQUFJRSxXQUFXO0lBQzFCO0lBQ0EsSUFBSUMsU0FBUyxJQUFJLENBQUNSLElBQUksQ0FBQ1MsUUFBUSxDQUFDLElBQUksQ0FBQ0MsSUFBSSxHQUFHLElBQUksQ0FBQ0MsS0FBSyxFQUFFLElBQUksQ0FBQ0QsSUFBSSxHQUFHLElBQUksQ0FBQ0MsS0FBSyxHQUFHTjtJQUNqRixJQUFJLENBQUNNLEtBQUssSUFBSU47SUFDZCxPQUFPRztBQUNYO0FBQ0FJLE9BQU9DLE9BQU8sR0FBR2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90c2EtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9VaW50OEFycmF5UmVhZGVyLmpzPzU0OTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQXJyYXlSZWFkZXIgPSByZXF1aXJlKFwiLi9BcnJheVJlYWRlclwiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcblxuZnVuY3Rpb24gVWludDhBcnJheVJlYWRlcihkYXRhKSB7XG4gICAgQXJyYXlSZWFkZXIuY2FsbCh0aGlzLCBkYXRhKTtcbn1cbnV0aWxzLmluaGVyaXRzKFVpbnQ4QXJyYXlSZWFkZXIsIEFycmF5UmVhZGVyKTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLnJlYWREYXRhXG4gKi9cblVpbnQ4QXJyYXlSZWFkZXIucHJvdG90eXBlLnJlYWREYXRhID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHRoaXMuY2hlY2tPZmZzZXQoc2l6ZSk7XG4gICAgaWYoc2l6ZSA9PT0gMCkge1xuICAgICAgICAvLyBpbiBJRTEwLCB3aGVuIHVzaW5nIHN1YmFycmF5KGlkeCwgaWR4KSwgd2UgZ2V0IHRoZSBhcnJheSBbMHgwMF0gaW5zdGVhZCBvZiBbXS5cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5kYXRhLnN1YmFycmF5KHRoaXMuemVybyArIHRoaXMuaW5kZXgsIHRoaXMuemVybyArIHRoaXMuaW5kZXggKyBzaXplKTtcbiAgICB0aGlzLmluZGV4ICs9IHNpemU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFVpbnQ4QXJyYXlSZWFkZXI7XG4iXSwibmFtZXMiOlsiQXJyYXlSZWFkZXIiLCJyZXF1aXJlIiwidXRpbHMiLCJVaW50OEFycmF5UmVhZGVyIiwiZGF0YSIsImNhbGwiLCJpbmhlcml0cyIsInByb3RvdHlwZSIsInJlYWREYXRhIiwic2l6ZSIsImNoZWNrT2Zmc2V0IiwiVWludDhBcnJheSIsInJlc3VsdCIsInN1YmFycmF5IiwiemVybyIsImluZGV4IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/reader/Uint8ArrayReader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/reader/readerFor.js":
/*!****************************************************!*\
  !*** ./node_modules/jszip/lib/reader/readerFor.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nvar support = __webpack_require__(/*! ../support */ \"(ssr)/./node_modules/jszip/lib/support.js\");\nvar ArrayReader = __webpack_require__(/*! ./ArrayReader */ \"(ssr)/./node_modules/jszip/lib/reader/ArrayReader.js\");\nvar StringReader = __webpack_require__(/*! ./StringReader */ \"(ssr)/./node_modules/jszip/lib/reader/StringReader.js\");\nvar NodeBufferReader = __webpack_require__(/*! ./NodeBufferReader */ \"(ssr)/./node_modules/jszip/lib/reader/NodeBufferReader.js\");\nvar Uint8ArrayReader = __webpack_require__(/*! ./Uint8ArrayReader */ \"(ssr)/./node_modules/jszip/lib/reader/Uint8ArrayReader.js\");\n/**\n * Create a reader adapted to the data.\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data to read.\n * @return {DataReader} the data reader.\n */ module.exports = function(data) {\n    var type = utils.getTypeOf(data);\n    utils.checkSupport(type);\n    if (type === \"string\" && !support.uint8array) {\n        return new StringReader(data);\n    }\n    if (type === \"nodebuffer\") {\n        return new NodeBufferReader(data);\n    }\n    if (support.uint8array) {\n        return new Uint8ArrayReader(utils.transformTo(\"uint8array\", data));\n    }\n    return new ArrayReader(utils.transformTo(\"array\", data));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9yZWFkZXJGb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQyx5REFBVTtBQUM5QixJQUFJQyxVQUFVRCxtQkFBT0EsQ0FBQyw2REFBWTtBQUNsQyxJQUFJRSxjQUFjRixtQkFBT0EsQ0FBQywyRUFBZTtBQUN6QyxJQUFJRyxlQUFlSCxtQkFBT0EsQ0FBQyw2RUFBZ0I7QUFDM0MsSUFBSUksbUJBQW1CSixtQkFBT0EsQ0FBQyxxRkFBb0I7QUFDbkQsSUFBSUssbUJBQW1CTCxtQkFBT0EsQ0FBQyxxRkFBb0I7QUFFbkQ7Ozs7Q0FJQyxHQUNETSxPQUFPQyxPQUFPLEdBQUcsU0FBVUMsSUFBSTtJQUMzQixJQUFJQyxPQUFPVixNQUFNVyxTQUFTLENBQUNGO0lBQzNCVCxNQUFNWSxZQUFZLENBQUNGO0lBQ25CLElBQUlBLFNBQVMsWUFBWSxDQUFDUixRQUFRVyxVQUFVLEVBQUU7UUFDMUMsT0FBTyxJQUFJVCxhQUFhSztJQUM1QjtJQUNBLElBQUlDLFNBQVMsY0FBYztRQUN2QixPQUFPLElBQUlMLGlCQUFpQkk7SUFDaEM7SUFDQSxJQUFJUCxRQUFRVyxVQUFVLEVBQUU7UUFDcEIsT0FBTyxJQUFJUCxpQkFBaUJOLE1BQU1jLFdBQVcsQ0FBQyxjQUFjTDtJQUNoRTtJQUNBLE9BQU8sSUFBSU4sWUFBWUgsTUFBTWMsV0FBVyxDQUFDLFNBQVNMO0FBQ3REIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHNhLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvcmVhZGVyRm9yLmpzPzk1YzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBzdXBwb3J0ID0gcmVxdWlyZShcIi4uL3N1cHBvcnRcIik7XG52YXIgQXJyYXlSZWFkZXIgPSByZXF1aXJlKFwiLi9BcnJheVJlYWRlclwiKTtcbnZhciBTdHJpbmdSZWFkZXIgPSByZXF1aXJlKFwiLi9TdHJpbmdSZWFkZXJcIik7XG52YXIgTm9kZUJ1ZmZlclJlYWRlciA9IHJlcXVpcmUoXCIuL05vZGVCdWZmZXJSZWFkZXJcIik7XG52YXIgVWludDhBcnJheVJlYWRlciA9IHJlcXVpcmUoXCIuL1VpbnQ4QXJyYXlSZWFkZXJcIik7XG5cbi8qKlxuICogQ3JlYXRlIGEgcmVhZGVyIGFkYXB0ZWQgdG8gdGhlIGRhdGEuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gZGF0YSB0aGUgZGF0YSB0byByZWFkLlxuICogQHJldHVybiB7RGF0YVJlYWRlcn0gdGhlIGRhdGEgcmVhZGVyLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHR5cGUgPSB1dGlscy5nZXRUeXBlT2YoZGF0YSk7XG4gICAgdXRpbHMuY2hlY2tTdXBwb3J0KHR5cGUpO1xuICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiICYmICFzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdSZWFkZXIoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcIm5vZGVidWZmZXJcIikge1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVCdWZmZXJSZWFkZXIoZGF0YSk7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5UmVhZGVyKHV0aWxzLnRyYW5zZm9ybVRvKFwidWludDhhcnJheVwiLCBkYXRhKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQXJyYXlSZWFkZXIodXRpbHMudHJhbnNmb3JtVG8oXCJhcnJheVwiLCBkYXRhKSk7XG59O1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsInN1cHBvcnQiLCJBcnJheVJlYWRlciIsIlN0cmluZ1JlYWRlciIsIk5vZGVCdWZmZXJSZWFkZXIiLCJVaW50OEFycmF5UmVhZGVyIiwibW9kdWxlIiwiZXhwb3J0cyIsImRhdGEiLCJ0eXBlIiwiZ2V0VHlwZU9mIiwiY2hlY2tTdXBwb3J0IiwidWludDhhcnJheSIsInRyYW5zZm9ybVRvIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/reader/readerFor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/signature.js":
/*!*********************************************!*\
  !*** ./node_modules/jszip/lib/signature.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nexports.LOCAL_FILE_HEADER = \"PK\\x03\\x04\";\nexports.CENTRAL_FILE_HEADER = \"PK\\x01\\x02\";\nexports.CENTRAL_DIRECTORY_END = \"PK\\x05\\x06\";\nexports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = \"PK\\x06\\x07\";\nexports.ZIP64_CENTRAL_DIRECTORY_END = \"PK\\x06\\x06\";\nexports.DATA_DESCRIPTOR = \"PK\\x07\\b\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3NpZ25hdHVyZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSx5QkFBeUIsR0FBRztBQUM1QkEsMkJBQTJCLEdBQUc7QUFDOUJBLDZCQUE2QixHQUFHO0FBQ2hDQSx1Q0FBdUMsR0FBRztBQUMxQ0EsbUNBQW1DLEdBQUc7QUFDdENBLHVCQUF1QixHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHNhLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zaWduYXR1cmUuanM/MDJjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuTE9DQUxfRklMRV9IRUFERVIgPSBcIlBLXFx4MDNcXHgwNFwiO1xuZXhwb3J0cy5DRU5UUkFMX0ZJTEVfSEVBREVSID0gXCJQS1xceDAxXFx4MDJcIjtcbmV4cG9ydHMuQ0VOVFJBTF9ESVJFQ1RPUllfRU5EID0gXCJQS1xceDA1XFx4MDZcIjtcbmV4cG9ydHMuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfTE9DQVRPUiA9IFwiUEtcXHgwNlxceDA3XCI7XG5leHBvcnRzLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCA9IFwiUEtcXHgwNlxceDA2XCI7XG5leHBvcnRzLkRBVEFfREVTQ1JJUFRPUiA9IFwiUEtcXHgwN1xceDA4XCI7XG4iXSwibmFtZXMiOlsiZXhwb3J0cyIsIkxPQ0FMX0ZJTEVfSEVBREVSIiwiQ0VOVFJBTF9GSUxFX0hFQURFUiIsIkNFTlRSQUxfRElSRUNUT1JZX0VORCIsIlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0xPQ0FUT1IiLCJaSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQiLCJEQVRBX0RFU0NSSVBUT1IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/signature.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/stream/ConvertWorker.js":
/*!********************************************************!*\
  !*** ./node_modules/jszip/lib/stream/ConvertWorker.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar GenericWorker = __webpack_require__(/*! ./GenericWorker */ \"(ssr)/./node_modules/jszip/lib/stream/GenericWorker.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\n/**\n * A worker which convert chunks to a specified type.\n * @constructor\n * @param {String} destType the destination type.\n */ function ConvertWorker(destType) {\n    GenericWorker.call(this, \"ConvertWorker to \" + destType);\n    this.destType = destType;\n}\nutils.inherits(ConvertWorker, GenericWorker);\n/**\n * @see GenericWorker.processChunk\n */ ConvertWorker.prototype.processChunk = function(chunk) {\n    this.push({\n        data: utils.transformTo(this.destType, chunk.data),\n        meta: chunk.meta\n    });\n};\nmodule.exports = ConvertWorker;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9Db252ZXJ0V29ya2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsZ0JBQWdCQyxtQkFBT0EsQ0FBQywrRUFBaUI7QUFDN0MsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUMseURBQVU7QUFFOUI7Ozs7Q0FJQyxHQUNELFNBQVNFLGNBQWNDLFFBQVE7SUFDM0JKLGNBQWNLLElBQUksQ0FBQyxJQUFJLEVBQUUsc0JBQXNCRDtJQUMvQyxJQUFJLENBQUNBLFFBQVEsR0FBR0E7QUFDcEI7QUFDQUYsTUFBTUksUUFBUSxDQUFDSCxlQUFlSDtBQUU5Qjs7Q0FFQyxHQUNERyxjQUFjSSxTQUFTLENBQUNDLFlBQVksR0FBRyxTQUFVQyxLQUFLO0lBQ2xELElBQUksQ0FBQ0MsSUFBSSxDQUFDO1FBQ05DLE1BQU9ULE1BQU1VLFdBQVcsQ0FBQyxJQUFJLENBQUNSLFFBQVEsRUFBRUssTUFBTUUsSUFBSTtRQUNsREUsTUFBT0osTUFBTUksSUFBSTtJQUNyQjtBQUNKO0FBQ0FDLE9BQU9DLE9BQU8sR0FBR1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90c2EtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9Db252ZXJ0V29ya2VyLmpzPzBhYzUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZShcIi4vR2VuZXJpY1dvcmtlclwiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcblxuLyoqXG4gKiBBIHdvcmtlciB3aGljaCBjb252ZXJ0IGNodW5rcyB0byBhIHNwZWNpZmllZCB0eXBlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVzdFR5cGUgdGhlIGRlc3RpbmF0aW9uIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIENvbnZlcnRXb3JrZXIoZGVzdFR5cGUpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJDb252ZXJ0V29ya2VyIHRvIFwiICsgZGVzdFR5cGUpO1xuICAgIHRoaXMuZGVzdFR5cGUgPSBkZXN0VHlwZTtcbn1cbnV0aWxzLmluaGVyaXRzKENvbnZlcnRXb3JrZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuQ29udmVydFdvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgdGhpcy5wdXNoKHtcbiAgICAgICAgZGF0YSA6IHV0aWxzLnRyYW5zZm9ybVRvKHRoaXMuZGVzdFR5cGUsIGNodW5rLmRhdGEpLFxuICAgICAgICBtZXRhIDogY2h1bmsubWV0YVxuICAgIH0pO1xufTtcbm1vZHVsZS5leHBvcnRzID0gQ29udmVydFdvcmtlcjtcbiJdLCJuYW1lcyI6WyJHZW5lcmljV29ya2VyIiwicmVxdWlyZSIsInV0aWxzIiwiQ29udmVydFdvcmtlciIsImRlc3RUeXBlIiwiY2FsbCIsImluaGVyaXRzIiwicHJvdG90eXBlIiwicHJvY2Vzc0NodW5rIiwiY2h1bmsiLCJwdXNoIiwiZGF0YSIsInRyYW5zZm9ybVRvIiwibWV0YSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/stream/ConvertWorker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/stream/Crc32Probe.js":
/*!*****************************************************!*\
  !*** ./node_modules/jszip/lib/stream/Crc32Probe.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar GenericWorker = __webpack_require__(/*! ./GenericWorker */ \"(ssr)/./node_modules/jszip/lib/stream/GenericWorker.js\");\nvar crc32 = __webpack_require__(/*! ../crc32 */ \"(ssr)/./node_modules/jszip/lib/crc32.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\n/**\n * A worker which calculate the crc32 of the data flowing through.\n * @constructor\n */ function Crc32Probe() {\n    GenericWorker.call(this, \"Crc32Probe\");\n    this.withStreamInfo(\"crc32\", 0);\n}\nutils.inherits(Crc32Probe, GenericWorker);\n/**\n * @see GenericWorker.processChunk\n */ Crc32Probe.prototype.processChunk = function(chunk) {\n    this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);\n    this.push(chunk);\n};\nmodule.exports = Crc32Probe;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9DcmMzMlByb2JlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsZ0JBQWdCQyxtQkFBT0EsQ0FBQywrRUFBaUI7QUFDN0MsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUMseURBQVU7QUFDOUIsSUFBSUUsUUFBUUYsbUJBQU9BLENBQUMseURBQVU7QUFFOUI7OztDQUdDLEdBQ0QsU0FBU0c7SUFDTEosY0FBY0ssSUFBSSxDQUFDLElBQUksRUFBRTtJQUN6QixJQUFJLENBQUNDLGNBQWMsQ0FBQyxTQUFTO0FBQ2pDO0FBQ0FILE1BQU1JLFFBQVEsQ0FBQ0gsWUFBWUo7QUFFM0I7O0NBRUMsR0FDREksV0FBV0ksU0FBUyxDQUFDQyxZQUFZLEdBQUcsU0FBVUMsS0FBSztJQUMvQyxJQUFJLENBQUNDLFVBQVUsQ0FBQ1QsS0FBSyxHQUFHQSxNQUFNUSxNQUFNRSxJQUFJLEVBQUUsSUFBSSxDQUFDRCxVQUFVLENBQUNULEtBQUssSUFBSTtJQUNuRSxJQUFJLENBQUNXLElBQUksQ0FBQ0g7QUFDZDtBQUNBSSxPQUFPQyxPQUFPLEdBQUdYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHNhLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vQ3JjMzJQcm9iZS5qcz8yMTg5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoXCIuL0dlbmVyaWNXb3JrZXJcIik7XG52YXIgY3JjMzIgPSByZXF1aXJlKFwiLi4vY3JjMzJcIik7XG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5cbi8qKlxuICogQSB3b3JrZXIgd2hpY2ggY2FsY3VsYXRlIHRoZSBjcmMzMiBvZiB0aGUgZGF0YSBmbG93aW5nIHRocm91Z2guXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ3JjMzJQcm9iZSgpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJDcmMzMlByb2JlXCIpO1xuICAgIHRoaXMud2l0aFN0cmVhbUluZm8oXCJjcmMzMlwiLCAwKTtcbn1cbnV0aWxzLmluaGVyaXRzKENyYzMyUHJvYmUsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuQ3JjMzJQcm9iZS5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgdGhpcy5zdHJlYW1JbmZvLmNyYzMyID0gY3JjMzIoY2h1bmsuZGF0YSwgdGhpcy5zdHJlYW1JbmZvLmNyYzMyIHx8IDApO1xuICAgIHRoaXMucHVzaChjaHVuayk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBDcmMzMlByb2JlO1xuIl0sIm5hbWVzIjpbIkdlbmVyaWNXb3JrZXIiLCJyZXF1aXJlIiwiY3JjMzIiLCJ1dGlscyIsIkNyYzMyUHJvYmUiLCJjYWxsIiwid2l0aFN0cmVhbUluZm8iLCJpbmhlcml0cyIsInByb3RvdHlwZSIsInByb2Nlc3NDaHVuayIsImNodW5rIiwic3RyZWFtSW5mbyIsImRhdGEiLCJwdXNoIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/stream/Crc32Probe.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/stream/DataLengthProbe.js":
/*!**********************************************************!*\
  !*** ./node_modules/jszip/lib/stream/DataLengthProbe.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nvar GenericWorker = __webpack_require__(/*! ./GenericWorker */ \"(ssr)/./node_modules/jszip/lib/stream/GenericWorker.js\");\n/**\n * A worker which calculate the total length of the data flowing through.\n * @constructor\n * @param {String} propName the name used to expose the length\n */ function DataLengthProbe(propName) {\n    GenericWorker.call(this, \"DataLengthProbe for \" + propName);\n    this.propName = propName;\n    this.withStreamInfo(propName, 0);\n}\nutils.inherits(DataLengthProbe, GenericWorker);\n/**\n * @see GenericWorker.processChunk\n */ DataLengthProbe.prototype.processChunk = function(chunk) {\n    if (chunk) {\n        var length = this.streamInfo[this.propName] || 0;\n        this.streamInfo[this.propName] = length + chunk.data.length;\n    }\n    GenericWorker.prototype.processChunk.call(this, chunk);\n};\nmodule.exports = DataLengthProbe;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9EYXRhTGVuZ3RoUHJvYmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQyx5REFBVTtBQUM5QixJQUFJQyxnQkFBZ0JELG1CQUFPQSxDQUFDLCtFQUFpQjtBQUU3Qzs7OztDQUlDLEdBQ0QsU0FBU0UsZ0JBQWdCQyxRQUFRO0lBQzdCRixjQUFjRyxJQUFJLENBQUMsSUFBSSxFQUFFLHlCQUF5QkQ7SUFDbEQsSUFBSSxDQUFDQSxRQUFRLEdBQUdBO0lBQ2hCLElBQUksQ0FBQ0UsY0FBYyxDQUFDRixVQUFVO0FBQ2xDO0FBQ0FKLE1BQU1PLFFBQVEsQ0FBQ0osaUJBQWlCRDtBQUVoQzs7Q0FFQyxHQUNEQyxnQkFBZ0JLLFNBQVMsQ0FBQ0MsWUFBWSxHQUFHLFNBQVVDLEtBQUs7SUFDcEQsSUFBR0EsT0FBTztRQUNOLElBQUlDLFNBQVMsSUFBSSxDQUFDQyxVQUFVLENBQUMsSUFBSSxDQUFDUixRQUFRLENBQUMsSUFBSTtRQUMvQyxJQUFJLENBQUNRLFVBQVUsQ0FBQyxJQUFJLENBQUNSLFFBQVEsQ0FBQyxHQUFHTyxTQUFTRCxNQUFNRyxJQUFJLENBQUNGLE1BQU07SUFDL0Q7SUFDQVQsY0FBY00sU0FBUyxDQUFDQyxZQUFZLENBQUNKLElBQUksQ0FBQyxJQUFJLEVBQUVLO0FBQ3BEO0FBQ0FJLE9BQU9DLE9BQU8sR0FBR1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90c2EtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9EYXRhTGVuZ3RoUHJvYmUuanM/MDk5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKFwiLi9HZW5lcmljV29ya2VyXCIpO1xuXG4vKipcbiAqIEEgd29ya2VyIHdoaWNoIGNhbGN1bGF0ZSB0aGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBkYXRhIGZsb3dpbmcgdGhyb3VnaC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lIHRoZSBuYW1lIHVzZWQgdG8gZXhwb3NlIHRoZSBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gRGF0YUxlbmd0aFByb2JlKHByb3BOYW1lKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiRGF0YUxlbmd0aFByb2JlIGZvciBcIiArIHByb3BOYW1lKTtcbiAgICB0aGlzLnByb3BOYW1lID0gcHJvcE5hbWU7XG4gICAgdGhpcy53aXRoU3RyZWFtSW5mbyhwcm9wTmFtZSwgMCk7XG59XG51dGlscy5pbmhlcml0cyhEYXRhTGVuZ3RoUHJvYmUsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuRGF0YUxlbmd0aFByb2JlLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBpZihjaHVuaykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5zdHJlYW1JbmZvW3RoaXMucHJvcE5hbWVdIHx8IDA7XG4gICAgICAgIHRoaXMuc3RyZWFtSW5mb1t0aGlzLnByb3BOYW1lXSA9IGxlbmd0aCArIGNodW5rLmRhdGEubGVuZ3RoO1xuICAgIH1cbiAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsuY2FsbCh0aGlzLCBjaHVuayk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBEYXRhTGVuZ3RoUHJvYmU7XG5cbiJdLCJuYW1lcyI6WyJ1dGlscyIsInJlcXVpcmUiLCJHZW5lcmljV29ya2VyIiwiRGF0YUxlbmd0aFByb2JlIiwicHJvcE5hbWUiLCJjYWxsIiwid2l0aFN0cmVhbUluZm8iLCJpbmhlcml0cyIsInByb3RvdHlwZSIsInByb2Nlc3NDaHVuayIsImNodW5rIiwibGVuZ3RoIiwic3RyZWFtSW5mbyIsImRhdGEiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/stream/DataLengthProbe.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/stream/DataWorker.js":
/*!*****************************************************!*\
  !*** ./node_modules/jszip/lib/stream/DataWorker.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nvar GenericWorker = __webpack_require__(/*! ./GenericWorker */ \"(ssr)/./node_modules/jszip/lib/stream/GenericWorker.js\");\n// the size of the generated chunks\n// TODO expose this as a public variable\nvar DEFAULT_BLOCK_SIZE = 16 * 1024;\n/**\n * A worker that reads a content and emits chunks.\n * @constructor\n * @param {Promise} dataP the promise of the data to split\n */ function DataWorker(dataP) {\n    GenericWorker.call(this, \"DataWorker\");\n    var self = this;\n    this.dataIsReady = false;\n    this.index = 0;\n    this.max = 0;\n    this.data = null;\n    this.type = \"\";\n    this._tickScheduled = false;\n    dataP.then(function(data) {\n        self.dataIsReady = true;\n        self.data = data;\n        self.max = data && data.length || 0;\n        self.type = utils.getTypeOf(data);\n        if (!self.isPaused) {\n            self._tickAndRepeat();\n        }\n    }, function(e) {\n        self.error(e);\n    });\n}\nutils.inherits(DataWorker, GenericWorker);\n/**\n * @see GenericWorker.cleanUp\n */ DataWorker.prototype.cleanUp = function() {\n    GenericWorker.prototype.cleanUp.call(this);\n    this.data = null;\n};\n/**\n * @see GenericWorker.resume\n */ DataWorker.prototype.resume = function() {\n    if (!GenericWorker.prototype.resume.call(this)) {\n        return false;\n    }\n    if (!this._tickScheduled && this.dataIsReady) {\n        this._tickScheduled = true;\n        utils.delay(this._tickAndRepeat, [], this);\n    }\n    return true;\n};\n/**\n * Trigger a tick a schedule an other call to this function.\n */ DataWorker.prototype._tickAndRepeat = function() {\n    this._tickScheduled = false;\n    if (this.isPaused || this.isFinished) {\n        return;\n    }\n    this._tick();\n    if (!this.isFinished) {\n        utils.delay(this._tickAndRepeat, [], this);\n        this._tickScheduled = true;\n    }\n};\n/**\n * Read and push a chunk.\n */ DataWorker.prototype._tick = function() {\n    if (this.isPaused || this.isFinished) {\n        return false;\n    }\n    var size = DEFAULT_BLOCK_SIZE;\n    var data = null, nextIndex = Math.min(this.max, this.index + size);\n    if (this.index >= this.max) {\n        // EOF\n        return this.end();\n    } else {\n        switch(this.type){\n            case \"string\":\n                data = this.data.substring(this.index, nextIndex);\n                break;\n            case \"uint8array\":\n                data = this.data.subarray(this.index, nextIndex);\n                break;\n            case \"array\":\n            case \"nodebuffer\":\n                data = this.data.slice(this.index, nextIndex);\n                break;\n        }\n        this.index = nextIndex;\n        return this.push({\n            data: data,\n            meta: {\n                percent: this.max ? this.index / this.max * 100 : 0\n            }\n        });\n    }\n};\nmodule.exports = DataWorker;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9EYXRhV29ya2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUMseURBQVU7QUFDOUIsSUFBSUMsZ0JBQWdCRCxtQkFBT0EsQ0FBQywrRUFBaUI7QUFFN0MsbUNBQW1DO0FBQ25DLHdDQUF3QztBQUN4QyxJQUFJRSxxQkFBcUIsS0FBSztBQUU5Qjs7OztDQUlDLEdBQ0QsU0FBU0MsV0FBV0MsS0FBSztJQUNyQkgsY0FBY0ksSUFBSSxDQUFDLElBQUksRUFBRTtJQUN6QixJQUFJQyxPQUFPLElBQUk7SUFDZixJQUFJLENBQUNDLFdBQVcsR0FBRztJQUNuQixJQUFJLENBQUNDLEtBQUssR0FBRztJQUNiLElBQUksQ0FBQ0MsR0FBRyxHQUFHO0lBQ1gsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDWixJQUFJLENBQUNDLElBQUksR0FBRztJQUVaLElBQUksQ0FBQ0MsY0FBYyxHQUFHO0lBRXRCUixNQUFNUyxJQUFJLENBQUMsU0FBVUgsSUFBSTtRQUNyQkosS0FBS0MsV0FBVyxHQUFHO1FBQ25CRCxLQUFLSSxJQUFJLEdBQUdBO1FBQ1pKLEtBQUtHLEdBQUcsR0FBR0MsUUFBUUEsS0FBS0ksTUFBTSxJQUFJO1FBQ2xDUixLQUFLSyxJQUFJLEdBQUdaLE1BQU1nQixTQUFTLENBQUNMO1FBQzVCLElBQUcsQ0FBQ0osS0FBS1UsUUFBUSxFQUFFO1lBQ2ZWLEtBQUtXLGNBQWM7UUFDdkI7SUFDSixHQUFHLFNBQVVDLENBQUM7UUFDVlosS0FBS2EsS0FBSyxDQUFDRDtJQUNmO0FBQ0o7QUFFQW5CLE1BQU1xQixRQUFRLENBQUNqQixZQUFZRjtBQUUzQjs7Q0FFQyxHQUNERSxXQUFXa0IsU0FBUyxDQUFDQyxPQUFPLEdBQUc7SUFDM0JyQixjQUFjb0IsU0FBUyxDQUFDQyxPQUFPLENBQUNqQixJQUFJLENBQUMsSUFBSTtJQUN6QyxJQUFJLENBQUNLLElBQUksR0FBRztBQUNoQjtBQUVBOztDQUVDLEdBQ0RQLFdBQVdrQixTQUFTLENBQUNFLE1BQU0sR0FBRztJQUMxQixJQUFHLENBQUN0QixjQUFjb0IsU0FBUyxDQUFDRSxNQUFNLENBQUNsQixJQUFJLENBQUMsSUFBSSxHQUFHO1FBQzNDLE9BQU87SUFDWDtJQUVBLElBQUksQ0FBQyxJQUFJLENBQUNPLGNBQWMsSUFBSSxJQUFJLENBQUNMLFdBQVcsRUFBRTtRQUMxQyxJQUFJLENBQUNLLGNBQWMsR0FBRztRQUN0QmIsTUFBTXlCLEtBQUssQ0FBQyxJQUFJLENBQUNQLGNBQWMsRUFBRSxFQUFFLEVBQUUsSUFBSTtJQUM3QztJQUNBLE9BQU87QUFDWDtBQUVBOztDQUVDLEdBQ0RkLFdBQVdrQixTQUFTLENBQUNKLGNBQWMsR0FBRztJQUNsQyxJQUFJLENBQUNMLGNBQWMsR0FBRztJQUN0QixJQUFHLElBQUksQ0FBQ0ksUUFBUSxJQUFJLElBQUksQ0FBQ1MsVUFBVSxFQUFFO1FBQ2pDO0lBQ0o7SUFDQSxJQUFJLENBQUNDLEtBQUs7SUFDVixJQUFHLENBQUMsSUFBSSxDQUFDRCxVQUFVLEVBQUU7UUFDakIxQixNQUFNeUIsS0FBSyxDQUFDLElBQUksQ0FBQ1AsY0FBYyxFQUFFLEVBQUUsRUFBRSxJQUFJO1FBQ3pDLElBQUksQ0FBQ0wsY0FBYyxHQUFHO0lBQzFCO0FBQ0o7QUFFQTs7Q0FFQyxHQUNEVCxXQUFXa0IsU0FBUyxDQUFDSyxLQUFLLEdBQUc7SUFFekIsSUFBRyxJQUFJLENBQUNWLFFBQVEsSUFBSSxJQUFJLENBQUNTLFVBQVUsRUFBRTtRQUNqQyxPQUFPO0lBQ1g7SUFFQSxJQUFJRSxPQUFPekI7SUFDWCxJQUFJUSxPQUFPLE1BQU1rQixZQUFZQyxLQUFLQyxHQUFHLENBQUMsSUFBSSxDQUFDckIsR0FBRyxFQUFFLElBQUksQ0FBQ0QsS0FBSyxHQUFHbUI7SUFDN0QsSUFBSSxJQUFJLENBQUNuQixLQUFLLElBQUksSUFBSSxDQUFDQyxHQUFHLEVBQUU7UUFDeEIsTUFBTTtRQUNOLE9BQU8sSUFBSSxDQUFDc0IsR0FBRztJQUNuQixPQUFPO1FBQ0gsT0FBTyxJQUFJLENBQUNwQixJQUFJO1lBQ2hCLEtBQUs7Z0JBQ0RELE9BQU8sSUFBSSxDQUFDQSxJQUFJLENBQUNzQixTQUFTLENBQUMsSUFBSSxDQUFDeEIsS0FBSyxFQUFFb0I7Z0JBQ3ZDO1lBQ0osS0FBSztnQkFDRGxCLE9BQU8sSUFBSSxDQUFDQSxJQUFJLENBQUN1QixRQUFRLENBQUMsSUFBSSxDQUFDekIsS0FBSyxFQUFFb0I7Z0JBQ3RDO1lBQ0osS0FBSztZQUNMLEtBQUs7Z0JBQ0RsQixPQUFPLElBQUksQ0FBQ0EsSUFBSSxDQUFDd0IsS0FBSyxDQUFDLElBQUksQ0FBQzFCLEtBQUssRUFBRW9CO2dCQUNuQztRQUNKO1FBQ0EsSUFBSSxDQUFDcEIsS0FBSyxHQUFHb0I7UUFDYixPQUFPLElBQUksQ0FBQ08sSUFBSSxDQUFDO1lBQ2J6QixNQUFPQTtZQUNQMEIsTUFBTztnQkFDSEMsU0FBVSxJQUFJLENBQUM1QixHQUFHLEdBQUcsSUFBSSxDQUFDRCxLQUFLLEdBQUcsSUFBSSxDQUFDQyxHQUFHLEdBQUcsTUFBTTtZQUN2RDtRQUNKO0lBQ0o7QUFDSjtBQUVBNkIsT0FBT0MsT0FBTyxHQUFHcEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90c2EtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9EYXRhV29ya2VyLmpzPzQ2YTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZShcIi4vR2VuZXJpY1dvcmtlclwiKTtcblxuLy8gdGhlIHNpemUgb2YgdGhlIGdlbmVyYXRlZCBjaHVua3Ncbi8vIFRPRE8gZXhwb3NlIHRoaXMgYXMgYSBwdWJsaWMgdmFyaWFibGVcbnZhciBERUZBVUxUX0JMT0NLX1NJWkUgPSAxNiAqIDEwMjQ7XG5cbi8qKlxuICogQSB3b3JrZXIgdGhhdCByZWFkcyBhIGNvbnRlbnQgYW5kIGVtaXRzIGNodW5rcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtQcm9taXNlfSBkYXRhUCB0aGUgcHJvbWlzZSBvZiB0aGUgZGF0YSB0byBzcGxpdFxuICovXG5mdW5jdGlvbiBEYXRhV29ya2VyKGRhdGFQKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwiRGF0YVdvcmtlclwiKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5kYXRhSXNSZWFkeSA9IGZhbHNlO1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIHRoaXMubWF4ID0gMDtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgIHRoaXMudHlwZSA9IFwiXCI7XG5cbiAgICB0aGlzLl90aWNrU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgICBkYXRhUC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHNlbGYuZGF0YUlzUmVhZHkgPSB0cnVlO1xuICAgICAgICBzZWxmLmRhdGEgPSBkYXRhO1xuICAgICAgICBzZWxmLm1heCA9IGRhdGEgJiYgZGF0YS5sZW5ndGggfHwgMDtcbiAgICAgICAgc2VsZi50eXBlID0gdXRpbHMuZ2V0VHlwZU9mKGRhdGEpO1xuICAgICAgICBpZighc2VsZi5pc1BhdXNlZCkge1xuICAgICAgICAgICAgc2VsZi5fdGlja0FuZFJlcGVhdCgpO1xuICAgICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgc2VsZi5lcnJvcihlKTtcbiAgICB9KTtcbn1cblxudXRpbHMuaW5oZXJpdHMoRGF0YVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmNsZWFuVXBcbiAqL1xuRGF0YVdvcmtlci5wcm90b3R5cGUuY2xlYW5VcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5jbGVhblVwLmNhbGwodGhpcyk7XG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnJlc3VtZVxuICovXG5EYXRhV29ya2VyLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoIUdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnJlc3VtZS5jYWxsKHRoaXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3RpY2tTY2hlZHVsZWQgJiYgdGhpcy5kYXRhSXNSZWFkeSkge1xuICAgICAgICB0aGlzLl90aWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgdXRpbHMuZGVsYXkodGhpcy5fdGlja0FuZFJlcGVhdCwgW10sIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogVHJpZ2dlciBhIHRpY2sgYSBzY2hlZHVsZSBhbiBvdGhlciBjYWxsIHRvIHRoaXMgZnVuY3Rpb24uXG4gKi9cbkRhdGFXb3JrZXIucHJvdG90eXBlLl90aWNrQW5kUmVwZWF0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdGlja1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIGlmKHRoaXMuaXNQYXVzZWQgfHwgdGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdGljaygpO1xuICAgIGlmKCF0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgdXRpbHMuZGVsYXkodGhpcy5fdGlja0FuZFJlcGVhdCwgW10sIHRoaXMpO1xuICAgICAgICB0aGlzLl90aWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlYWQgYW5kIHB1c2ggYSBjaHVuay5cbiAqL1xuRGF0YVdvcmtlci5wcm90b3R5cGUuX3RpY2sgPSBmdW5jdGlvbigpIHtcblxuICAgIGlmKHRoaXMuaXNQYXVzZWQgfHwgdGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc2l6ZSA9IERFRkFVTFRfQkxPQ0tfU0laRTtcbiAgICB2YXIgZGF0YSA9IG51bGwsIG5leHRJbmRleCA9IE1hdGgubWluKHRoaXMubWF4LCB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgaWYgKHRoaXMuaW5kZXggPj0gdGhpcy5tYXgpIHtcbiAgICAgICAgLy8gRU9GXG4gICAgICAgIHJldHVybiB0aGlzLmVuZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCh0aGlzLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgZGF0YSA9IHRoaXMuZGF0YS5zdWJzdHJpbmcodGhpcy5pbmRleCwgbmV4dEluZGV4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidWludDhhcnJheVwiOlxuICAgICAgICAgICAgZGF0YSA9IHRoaXMuZGF0YS5zdWJhcnJheSh0aGlzLmluZGV4LCBuZXh0SW5kZXgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICBjYXNlIFwibm9kZWJ1ZmZlclwiOlxuICAgICAgICAgICAgZGF0YSA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLmluZGV4LCBuZXh0SW5kZXgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogZGF0YSxcbiAgICAgICAgICAgIG1ldGEgOiB7XG4gICAgICAgICAgICAgICAgcGVyY2VudCA6IHRoaXMubWF4ID8gdGhpcy5pbmRleCAvIHRoaXMubWF4ICogMTAwIDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFXb3JrZXI7XG4iXSwibmFtZXMiOlsidXRpbHMiLCJyZXF1aXJlIiwiR2VuZXJpY1dvcmtlciIsIkRFRkFVTFRfQkxPQ0tfU0laRSIsIkRhdGFXb3JrZXIiLCJkYXRhUCIsImNhbGwiLCJzZWxmIiwiZGF0YUlzUmVhZHkiLCJpbmRleCIsIm1heCIsImRhdGEiLCJ0eXBlIiwiX3RpY2tTY2hlZHVsZWQiLCJ0aGVuIiwibGVuZ3RoIiwiZ2V0VHlwZU9mIiwiaXNQYXVzZWQiLCJfdGlja0FuZFJlcGVhdCIsImUiLCJlcnJvciIsImluaGVyaXRzIiwicHJvdG90eXBlIiwiY2xlYW5VcCIsInJlc3VtZSIsImRlbGF5IiwiaXNGaW5pc2hlZCIsIl90aWNrIiwic2l6ZSIsIm5leHRJbmRleCIsIk1hdGgiLCJtaW4iLCJlbmQiLCJzdWJzdHJpbmciLCJzdWJhcnJheSIsInNsaWNlIiwicHVzaCIsIm1ldGEiLCJwZXJjZW50IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/stream/DataWorker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/stream/GenericWorker.js":
/*!********************************************************!*\
  !*** ./node_modules/jszip/lib/stream/GenericWorker.js ***!
  \********************************************************/
/***/ ((module) => {

eval("\n/**\n * A worker that does nothing but passing chunks to the next one. This is like\n * a nodejs stream but with some differences. On the good side :\n * - it works on IE 6-9 without any issue / polyfill\n * - it weights less than the full dependencies bundled with browserify\n * - it forwards errors (no need to declare an error handler EVERYWHERE)\n *\n * A chunk is an object with 2 attributes : `meta` and `data`. The former is an\n * object containing anything (`percent` for example), see each worker for more\n * details. The latter is the real data (String, Uint8Array, etc).\n *\n * @constructor\n * @param {String} name the name of the stream (mainly used for debugging purposes)\n */ function GenericWorker(name) {\n    // the name of the worker\n    this.name = name || \"default\";\n    // an object containing metadata about the workers chain\n    this.streamInfo = {};\n    // an error which happened when the worker was paused\n    this.generatedError = null;\n    // an object containing metadata to be merged by this worker into the general metadata\n    this.extraStreamInfo = {};\n    // true if the stream is paused (and should not do anything), false otherwise\n    this.isPaused = true;\n    // true if the stream is finished (and should not do anything), false otherwise\n    this.isFinished = false;\n    // true if the stream is locked to prevent further structure updates (pipe), false otherwise\n    this.isLocked = false;\n    // the event listeners\n    this._listeners = {\n        \"data\": [],\n        \"end\": [],\n        \"error\": []\n    };\n    // the previous worker, if any\n    this.previous = null;\n}\nGenericWorker.prototype = {\n    /**\n     * Push a chunk to the next workers.\n     * @param {Object} chunk the chunk to push\n     */ push: function(chunk) {\n        this.emit(\"data\", chunk);\n    },\n    /**\n     * End the stream.\n     * @return {Boolean} true if this call ended the worker, false otherwise.\n     */ end: function() {\n        if (this.isFinished) {\n            return false;\n        }\n        this.flush();\n        try {\n            this.emit(\"end\");\n            this.cleanUp();\n            this.isFinished = true;\n        } catch (e) {\n            this.emit(\"error\", e);\n        }\n        return true;\n    },\n    /**\n     * End the stream with an error.\n     * @param {Error} e the error which caused the premature end.\n     * @return {Boolean} true if this call ended the worker with an error, false otherwise.\n     */ error: function(e) {\n        if (this.isFinished) {\n            return false;\n        }\n        if (this.isPaused) {\n            this.generatedError = e;\n        } else {\n            this.isFinished = true;\n            this.emit(\"error\", e);\n            // in the workers chain exploded in the middle of the chain,\n            // the error event will go downward but we also need to notify\n            // workers upward that there has been an error.\n            if (this.previous) {\n                this.previous.error(e);\n            }\n            this.cleanUp();\n        }\n        return true;\n    },\n    /**\n     * Add a callback on an event.\n     * @param {String} name the name of the event (data, end, error)\n     * @param {Function} listener the function to call when the event is triggered\n     * @return {GenericWorker} the current object for chainability\n     */ on: function(name, listener) {\n        this._listeners[name].push(listener);\n        return this;\n    },\n    /**\n     * Clean any references when a worker is ending.\n     */ cleanUp: function() {\n        this.streamInfo = this.generatedError = this.extraStreamInfo = null;\n        this._listeners = [];\n    },\n    /**\n     * Trigger an event. This will call registered callback with the provided arg.\n     * @param {String} name the name of the event (data, end, error)\n     * @param {Object} arg the argument to call the callback with.\n     */ emit: function(name, arg) {\n        if (this._listeners[name]) {\n            for(var i = 0; i < this._listeners[name].length; i++){\n                this._listeners[name][i].call(this, arg);\n            }\n        }\n    },\n    /**\n     * Chain a worker with an other.\n     * @param {Worker} next the worker receiving events from the current one.\n     * @return {worker} the next worker for chainability\n     */ pipe: function(next) {\n        return next.registerPrevious(this);\n    },\n    /**\n     * Same as `pipe` in the other direction.\n     * Using an API with `pipe(next)` is very easy.\n     * Implementing the API with the point of view of the next one registering\n     * a source is easier, see the ZipFileWorker.\n     * @param {Worker} previous the previous worker, sending events to this one\n     * @return {Worker} the current worker for chainability\n     */ registerPrevious: function(previous) {\n        if (this.isLocked) {\n            throw new Error(\"The stream '\" + this + \"' has already been used.\");\n        }\n        // sharing the streamInfo...\n        this.streamInfo = previous.streamInfo;\n        // ... and adding our own bits\n        this.mergeStreamInfo();\n        this.previous = previous;\n        var self = this;\n        previous.on(\"data\", function(chunk) {\n            self.processChunk(chunk);\n        });\n        previous.on(\"end\", function() {\n            self.end();\n        });\n        previous.on(\"error\", function(e) {\n            self.error(e);\n        });\n        return this;\n    },\n    /**\n     * Pause the stream so it doesn't send events anymore.\n     * @return {Boolean} true if this call paused the worker, false otherwise.\n     */ pause: function() {\n        if (this.isPaused || this.isFinished) {\n            return false;\n        }\n        this.isPaused = true;\n        if (this.previous) {\n            this.previous.pause();\n        }\n        return true;\n    },\n    /**\n     * Resume a paused stream.\n     * @return {Boolean} true if this call resumed the worker, false otherwise.\n     */ resume: function() {\n        if (!this.isPaused || this.isFinished) {\n            return false;\n        }\n        this.isPaused = false;\n        // if true, the worker tried to resume but failed\n        var withError = false;\n        if (this.generatedError) {\n            this.error(this.generatedError);\n            withError = true;\n        }\n        if (this.previous) {\n            this.previous.resume();\n        }\n        return !withError;\n    },\n    /**\n     * Flush any remaining bytes as the stream is ending.\n     */ flush: function() {},\n    /**\n     * Process a chunk. This is usually the method overridden.\n     * @param {Object} chunk the chunk to process.\n     */ processChunk: function(chunk) {\n        this.push(chunk);\n    },\n    /**\n     * Add a key/value to be added in the workers chain streamInfo once activated.\n     * @param {String} key the key to use\n     * @param {Object} value the associated value\n     * @return {Worker} the current worker for chainability\n     */ withStreamInfo: function(key, value) {\n        this.extraStreamInfo[key] = value;\n        this.mergeStreamInfo();\n        return this;\n    },\n    /**\n     * Merge this worker's streamInfo into the chain's streamInfo.\n     */ mergeStreamInfo: function() {\n        for(var key in this.extraStreamInfo){\n            if (!Object.prototype.hasOwnProperty.call(this.extraStreamInfo, key)) {\n                continue;\n            }\n            this.streamInfo[key] = this.extraStreamInfo[key];\n        }\n    },\n    /**\n     * Lock the stream to prevent further updates on the workers chain.\n     * After calling this method, all calls to pipe will fail.\n     */ lock: function() {\n        if (this.isLocked) {\n            throw new Error(\"The stream '\" + this + \"' has already been used.\");\n        }\n        this.isLocked = true;\n        if (this.previous) {\n            this.previous.lock();\n        }\n    },\n    /**\n     *\n     * Pretty print the workers chain.\n     */ toString: function() {\n        var me = \"Worker \" + this.name;\n        if (this.previous) {\n            return this.previous + \" -> \" + me;\n        } else {\n            return me;\n        }\n    }\n};\nmodule.exports = GenericWorker;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9HZW5lcmljV29ya2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWI7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNELFNBQVNBLGNBQWNDLElBQUk7SUFDdkIseUJBQXlCO0lBQ3pCLElBQUksQ0FBQ0EsSUFBSSxHQUFHQSxRQUFRO0lBQ3BCLHdEQUF3RDtJQUN4RCxJQUFJLENBQUNDLFVBQVUsR0FBRyxDQUFDO0lBQ25CLHFEQUFxRDtJQUNyRCxJQUFJLENBQUNDLGNBQWMsR0FBRztJQUN0QixzRkFBc0Y7SUFDdEYsSUFBSSxDQUFDQyxlQUFlLEdBQUcsQ0FBQztJQUN4Qiw2RUFBNkU7SUFDN0UsSUFBSSxDQUFDQyxRQUFRLEdBQUc7SUFDaEIsK0VBQStFO0lBQy9FLElBQUksQ0FBQ0MsVUFBVSxHQUFHO0lBQ2xCLDRGQUE0RjtJQUM1RixJQUFJLENBQUNDLFFBQVEsR0FBRztJQUNoQixzQkFBc0I7SUFDdEIsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDZCxRQUFPLEVBQUU7UUFDVCxPQUFNLEVBQUU7UUFDUixTQUFRLEVBQUU7SUFDZDtJQUNBLDhCQUE4QjtJQUM5QixJQUFJLENBQUNDLFFBQVEsR0FBRztBQUNwQjtBQUVBVCxjQUFjVSxTQUFTLEdBQUc7SUFDdEI7OztLQUdDLEdBQ0RDLE1BQU8sU0FBVUMsS0FBSztRQUNsQixJQUFJLENBQUNDLElBQUksQ0FBQyxRQUFRRDtJQUN0QjtJQUNBOzs7S0FHQyxHQUNERSxLQUFNO1FBQ0YsSUFBSSxJQUFJLENBQUNSLFVBQVUsRUFBRTtZQUNqQixPQUFPO1FBQ1g7UUFFQSxJQUFJLENBQUNTLEtBQUs7UUFDVixJQUFJO1lBQ0EsSUFBSSxDQUFDRixJQUFJLENBQUM7WUFDVixJQUFJLENBQUNHLE9BQU87WUFDWixJQUFJLENBQUNWLFVBQVUsR0FBRztRQUN0QixFQUFFLE9BQU9XLEdBQUc7WUFDUixJQUFJLENBQUNKLElBQUksQ0FBQyxTQUFTSTtRQUN2QjtR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QUFZLElBQUksQ0FBQ3pDLElBQUk7UUFDOUIsSUFBSSxJQUFJLENBQUNRLFFBQVEsRUFBRTtZQUNmLE9BQU8sSUFBSSxDQUFDQSxRQUFRLEdBQUcsU0FBU2lDO1FBQ3BDLE9BQU87WUFDSCxPQUFPQTtRQUNYO0lBQ0o7QUFDSjtBQUVBQyxPQUFPQyxPQUFPLEdBQUc1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3RzYS1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL0dlbmVyaWNXb3JrZXIuanM/ZWZiMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBBIHdvcmtlciB0aGF0IGRvZXMgbm90aGluZyBidXQgcGFzc2luZyBjaHVua3MgdG8gdGhlIG5leHQgb25lLiBUaGlzIGlzIGxpa2VcbiAqIGEgbm9kZWpzIHN0cmVhbSBidXQgd2l0aCBzb21lIGRpZmZlcmVuY2VzLiBPbiB0aGUgZ29vZCBzaWRlIDpcbiAqIC0gaXQgd29ya3Mgb24gSUUgNi05IHdpdGhvdXQgYW55IGlzc3VlIC8gcG9seWZpbGxcbiAqIC0gaXQgd2VpZ2h0cyBsZXNzIHRoYW4gdGhlIGZ1bGwgZGVwZW5kZW5jaWVzIGJ1bmRsZWQgd2l0aCBicm93c2VyaWZ5XG4gKiAtIGl0IGZvcndhcmRzIGVycm9ycyAobm8gbmVlZCB0byBkZWNsYXJlIGFuIGVycm9yIGhhbmRsZXIgRVZFUllXSEVSRSlcbiAqXG4gKiBBIGNodW5rIGlzIGFuIG9iamVjdCB3aXRoIDIgYXR0cmlidXRlcyA6IGBtZXRhYCBhbmQgYGRhdGFgLiBUaGUgZm9ybWVyIGlzIGFuXG4gKiBvYmplY3QgY29udGFpbmluZyBhbnl0aGluZyAoYHBlcmNlbnRgIGZvciBleGFtcGxlKSwgc2VlIGVhY2ggd29ya2VyIGZvciBtb3JlXG4gKiBkZXRhaWxzLiBUaGUgbGF0dGVyIGlzIHRoZSByZWFsIGRhdGEgKFN0cmluZywgVWludDhBcnJheSwgZXRjKS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBzdHJlYW0gKG1haW5seSB1c2VkIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMpXG4gKi9cbmZ1bmN0aW9uIEdlbmVyaWNXb3JrZXIobmFtZSkge1xuICAgIC8vIHRoZSBuYW1lIG9mIHRoZSB3b3JrZXJcbiAgICB0aGlzLm5hbWUgPSBuYW1lIHx8IFwiZGVmYXVsdFwiO1xuICAgIC8vIGFuIG9iamVjdCBjb250YWluaW5nIG1ldGFkYXRhIGFib3V0IHRoZSB3b3JrZXJzIGNoYWluXG4gICAgdGhpcy5zdHJlYW1JbmZvID0ge307XG4gICAgLy8gYW4gZXJyb3Igd2hpY2ggaGFwcGVuZWQgd2hlbiB0aGUgd29ya2VyIHdhcyBwYXVzZWRcbiAgICB0aGlzLmdlbmVyYXRlZEVycm9yID0gbnVsbDtcbiAgICAvLyBhbiBvYmplY3QgY29udGFpbmluZyBtZXRhZGF0YSB0byBiZSBtZXJnZWQgYnkgdGhpcyB3b3JrZXIgaW50byB0aGUgZ2VuZXJhbCBtZXRhZGF0YVxuICAgIHRoaXMuZXh0cmFTdHJlYW1JbmZvID0ge307XG4gICAgLy8gdHJ1ZSBpZiB0aGUgc3RyZWFtIGlzIHBhdXNlZCAoYW5kIHNob3VsZCBub3QgZG8gYW55dGhpbmcpLCBmYWxzZSBvdGhlcndpc2VcbiAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZTtcbiAgICAvLyB0cnVlIGlmIHRoZSBzdHJlYW0gaXMgZmluaXNoZWQgKGFuZCBzaG91bGQgbm90IGRvIGFueXRoaW5nKSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgdGhpcy5pc0ZpbmlzaGVkID0gZmFsc2U7XG4gICAgLy8gdHJ1ZSBpZiB0aGUgc3RyZWFtIGlzIGxvY2tlZCB0byBwcmV2ZW50IGZ1cnRoZXIgc3RydWN0dXJlIHVwZGF0ZXMgKHBpcGUpLCBmYWxzZSBvdGhlcndpc2VcbiAgICB0aGlzLmlzTG9ja2VkID0gZmFsc2U7XG4gICAgLy8gdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHtcbiAgICAgICAgXCJkYXRhXCI6W10sXG4gICAgICAgIFwiZW5kXCI6W10sXG4gICAgICAgIFwiZXJyb3JcIjpbXVxuICAgIH07XG4gICAgLy8gdGhlIHByZXZpb3VzIHdvcmtlciwgaWYgYW55XG4gICAgdGhpcy5wcmV2aW91cyA9IG51bGw7XG59XG5cbkdlbmVyaWNXb3JrZXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIFB1c2ggYSBjaHVuayB0byB0aGUgbmV4dCB3b3JrZXJzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaHVuayB0aGUgY2h1bmsgdG8gcHVzaFxuICAgICAqL1xuICAgIHB1c2ggOiBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiZGF0YVwiLCBjaHVuayk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFbmQgdGhlIHN0cmVhbS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoaXMgY2FsbCBlbmRlZCB0aGUgd29ya2VyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZW5kIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlbmRcIik7XG4gICAgICAgICAgICB0aGlzLmNsZWFuVXAoKTtcbiAgICAgICAgICAgIHRoaXMuaXNGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRW5kIHRoZSBzdHJlYW0gd2l0aCBhbiBlcnJvci5cbiAgICAgKiBAcGFyYW0ge0Vycm9yfSBlIHRoZSBlcnJvciB3aGljaCBjYXVzZWQgdGhlIHByZW1hdHVyZSBlbmQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGNhbGwgZW5kZWQgdGhlIHdvcmtlciB3aXRoIGFuIGVycm9yLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZXJyb3IgOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlZEVycm9yID0gZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXNGaW5pc2hlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGUpO1xuXG4gICAgICAgICAgICAvLyBpbiB0aGUgd29ya2VycyBjaGFpbiBleHBsb2RlZCBpbiB0aGUgbWlkZGxlIG9mIHRoZSBjaGFpbixcbiAgICAgICAgICAgIC8vIHRoZSBlcnJvciBldmVudCB3aWxsIGdvIGRvd253YXJkIGJ1dCB3ZSBhbHNvIG5lZWQgdG8gbm90aWZ5XG4gICAgICAgICAgICAvLyB3b3JrZXJzIHVwd2FyZCB0aGF0IHRoZXJlIGhhcyBiZWVuIGFuIGVycm9yLlxuICAgICAgICAgICAgaWYodGhpcy5wcmV2aW91cykge1xuICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXMuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY2xlYW5VcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQWRkIGEgY2FsbGJhY2sgb24gYW4gZXZlbnQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGV2ZW50IChkYXRhLCBlbmQsIGVycm9yKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIHRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZFxuICAgICAqIEByZXR1cm4ge0dlbmVyaWNXb3JrZXJ9IHRoZSBjdXJyZW50IG9iamVjdCBmb3IgY2hhaW5hYmlsaXR5XG4gICAgICovXG4gICAgb24gOiBmdW5jdGlvbiAobmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzW25hbWVdLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENsZWFuIGFueSByZWZlcmVuY2VzIHdoZW4gYSB3b3JrZXIgaXMgZW5kaW5nLlxuICAgICAqL1xuICAgIGNsZWFuVXAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtSW5mbyA9IHRoaXMuZ2VuZXJhdGVkRXJyb3IgPSB0aGlzLmV4dHJhU3RyZWFtSW5mbyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVHJpZ2dlciBhbiBldmVudC4gVGhpcyB3aWxsIGNhbGwgcmVnaXN0ZXJlZCBjYWxsYmFjayB3aXRoIHRoZSBwcm92aWRlZCBhcmcuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGV2ZW50IChkYXRhLCBlbmQsIGVycm9yKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmcgdGhlIGFyZ3VtZW50IHRvIGNhbGwgdGhlIGNhbGxiYWNrIHdpdGguXG4gICAgICovXG4gICAgZW1pdCA6IGZ1bmN0aW9uIChuYW1lLCBhcmcpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xpc3RlbmVyc1tuYW1lXSkge1xuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2xpc3RlbmVyc1tuYW1lXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1tuYW1lXVtpXS5jYWxsKHRoaXMsIGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoYWluIGEgd29ya2VyIHdpdGggYW4gb3RoZXIuXG4gICAgICogQHBhcmFtIHtXb3JrZXJ9IG5leHQgdGhlIHdvcmtlciByZWNlaXZpbmcgZXZlbnRzIGZyb20gdGhlIGN1cnJlbnQgb25lLlxuICAgICAqIEByZXR1cm4ge3dvcmtlcn0gdGhlIG5leHQgd29ya2VyIGZvciBjaGFpbmFiaWxpdHlcbiAgICAgKi9cbiAgICBwaXBlIDogZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgICAgcmV0dXJuIG5leHQucmVnaXN0ZXJQcmV2aW91cyh0aGlzKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNhbWUgYXMgYHBpcGVgIGluIHRoZSBvdGhlciBkaXJlY3Rpb24uXG4gICAgICogVXNpbmcgYW4gQVBJIHdpdGggYHBpcGUobmV4dClgIGlzIHZlcnkgZWFzeS5cbiAgICAgKiBJbXBsZW1lbnRpbmcgdGhlIEFQSSB3aXRoIHRoZSBwb2ludCBvZiB2aWV3IG9mIHRoZSBuZXh0IG9uZSByZWdpc3RlcmluZ1xuICAgICAqIGEgc291cmNlIGlzIGVhc2llciwgc2VlIHRoZSBaaXBGaWxlV29ya2VyLlxuICAgICAqIEBwYXJhbSB7V29ya2VyfSBwcmV2aW91cyB0aGUgcHJldmlvdXMgd29ya2VyLCBzZW5kaW5nIGV2ZW50cyB0byB0aGlzIG9uZVxuICAgICAqIEByZXR1cm4ge1dvcmtlcn0gdGhlIGN1cnJlbnQgd29ya2VyIGZvciBjaGFpbmFiaWxpdHlcbiAgICAgKi9cbiAgICByZWdpc3RlclByZXZpb3VzIDogZnVuY3Rpb24gKHByZXZpb3VzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTG9ja2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3RyZWFtICdcIiArIHRoaXMgKyBcIicgaGFzIGFscmVhZHkgYmVlbiB1c2VkLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNoYXJpbmcgdGhlIHN0cmVhbUluZm8uLi5cbiAgICAgICAgdGhpcy5zdHJlYW1JbmZvID0gcHJldmlvdXMuc3RyZWFtSW5mbztcbiAgICAgICAgLy8gLi4uIGFuZCBhZGRpbmcgb3VyIG93biBiaXRzXG4gICAgICAgIHRoaXMubWVyZ2VTdHJlYW1JbmZvKCk7XG4gICAgICAgIHRoaXMucHJldmlvdXMgPSAgcHJldmlvdXM7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcHJldmlvdXMub24oXCJkYXRhXCIsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgICAgc2VsZi5wcm9jZXNzQ2h1bmsoY2h1bmspO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJldmlvdXMub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5lbmQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByZXZpb3VzLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHNlbGYuZXJyb3IoZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFBhdXNlIHRoZSBzdHJlYW0gc28gaXQgZG9lc24ndCBzZW5kIGV2ZW50cyBhbnltb3JlLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhpcyBjYWxsIHBhdXNlZCB0aGUgd29ya2VyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcGF1c2UgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmKHRoaXMuaXNQYXVzZWQgfHwgdGhpcy5pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XG5cbiAgICAgICAgaWYodGhpcy5wcmV2aW91cykge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91cy5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVzdW1lIGEgcGF1c2VkIHN0cmVhbS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoaXMgY2FsbCByZXN1bWVkIHRoZSB3b3JrZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICByZXN1bWUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmKCF0aGlzLmlzUGF1c2VkIHx8IHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNQYXVzZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBpZiB0cnVlLCB0aGUgd29ya2VyIHRyaWVkIHRvIHJlc3VtZSBidXQgZmFpbGVkXG4gICAgICAgIHZhciB3aXRoRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgaWYodGhpcy5nZW5lcmF0ZWRFcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lcnJvcih0aGlzLmdlbmVyYXRlZEVycm9yKTtcbiAgICAgICAgICAgIHdpdGhFcnJvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5wcmV2aW91cykge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91cy5yZXN1bWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhd2l0aEVycm9yO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRmx1c2ggYW55IHJlbWFpbmluZyBieXRlcyBhcyB0aGUgc3RyZWFtIGlzIGVuZGluZy5cbiAgICAgKi9cbiAgICBmbHVzaCA6IGZ1bmN0aW9uICgpIHt9LFxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgYSBjaHVuay4gVGhpcyBpcyB1c3VhbGx5IHRoZSBtZXRob2Qgb3ZlcnJpZGRlbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2h1bmsgdGhlIGNodW5rIHRvIHByb2Nlc3MuXG4gICAgICovXG4gICAgcHJvY2Vzc0NodW5rIDogZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFkZCBhIGtleS92YWx1ZSB0byBiZSBhZGRlZCBpbiB0aGUgd29ya2VycyBjaGFpbiBzdHJlYW1JbmZvIG9uY2UgYWN0aXZhdGVkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgdGhlIGtleSB0byB1c2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgdGhlIGFzc29jaWF0ZWQgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtXb3JrZXJ9IHRoZSBjdXJyZW50IHdvcmtlciBmb3IgY2hhaW5hYmlsaXR5XG4gICAgICovXG4gICAgd2l0aFN0cmVhbUluZm8gOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmV4dHJhU3RyZWFtSW5mb1trZXldID0gdmFsdWU7XG4gICAgICAgIHRoaXMubWVyZ2VTdHJlYW1JbmZvKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogTWVyZ2UgdGhpcyB3b3JrZXIncyBzdHJlYW1JbmZvIGludG8gdGhlIGNoYWluJ3Mgc3RyZWFtSW5mby5cbiAgICAgKi9cbiAgICBtZXJnZVN0cmVhbUluZm8gOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvcih2YXIga2V5IGluIHRoaXMuZXh0cmFTdHJlYW1JbmZvKSB7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmV4dHJhU3RyZWFtSW5mbywga2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdHJlYW1JbmZvW2tleV0gPSB0aGlzLmV4dHJhU3RyZWFtSW5mb1trZXldO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExvY2sgdGhlIHN0cmVhbSB0byBwcmV2ZW50IGZ1cnRoZXIgdXBkYXRlcyBvbiB0aGUgd29ya2VycyBjaGFpbi5cbiAgICAgKiBBZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kLCBhbGwgY2FsbHMgdG8gcGlwZSB3aWxsIGZhaWwuXG4gICAgICovXG4gICAgbG9jazogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0cmVhbSAnXCIgKyB0aGlzICsgXCInIGhhcyBhbHJlYWR5IGJlZW4gdXNlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0xvY2tlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzLmxvY2soKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFByZXR0eSBwcmludCB0aGUgd29ya2VycyBjaGFpbi5cbiAgICAgKi9cbiAgICB0b1N0cmluZyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1lID0gXCJXb3JrZXIgXCIgKyB0aGlzLm5hbWU7XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91cyArIFwiIC0+IFwiICsgbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdlbmVyaWNXb3JrZXI7XG4iXSwibmFtZXMiOlsiR2VuZXJpY1dvcmtlciIsIm5hbWUiLCJzdHJlYW1JbmZvIiwiZ2VuZXJhdGVkRXJyb3IiLCJleHRyYVN0cmVhbUluZm8iLCJpc1BhdXNlZCIsImlzRmluaXNoZWQiLCJpc0xvY2tlZCIsIl9saXN0ZW5lcnMiLCJwcmV2aW91cyIsInByb3RvdHlwZSIsInB1c2giLCJjaHVuayIsImVtaXQiLCJlbmQiLCJmbHVzaCIsImNsZWFuVXAiLCJlIiwiZXJyb3IiLCJvbiIsImxpc3RlbmVyIiwiYXJnIiwiaSIsImxlbmd0aCIsImNhbGwiLCJwaXBlIiwibmV4dCIsInJlZ2lzdGVyUHJldmlvdXMiLCJFcnJvciIsIm1lcmdlU3RyZWFtSW5mbyIsInNlbGYiLCJwcm9jZXNzQ2h1bmsiLCJwYXVzZSIsInJlc3VtZSIsIndpdGhFcnJvciIsIndpdGhTdHJlYW1JbmZvIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJoYXNPd25Qcm9wZXJ0eSIsImxvY2siLCJ0b1N0cmluZyIsIm1lIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/stream/GenericWorker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/stream/StreamHelper.js":
/*!*******************************************************!*\
  !*** ./node_modules/jszip/lib/stream/StreamHelper.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nvar ConvertWorker = __webpack_require__(/*! ./ConvertWorker */ \"(ssr)/./node_modules/jszip/lib/stream/ConvertWorker.js\");\nvar GenericWorker = __webpack_require__(/*! ./GenericWorker */ \"(ssr)/./node_modules/jszip/lib/stream/GenericWorker.js\");\nvar base64 = __webpack_require__(/*! ../base64 */ \"(ssr)/./node_modules/jszip/lib/base64.js\");\nvar support = __webpack_require__(/*! ../support */ \"(ssr)/./node_modules/jszip/lib/support.js\");\nvar external = __webpack_require__(/*! ../external */ \"(ssr)/./node_modules/jszip/lib/external.js\");\nvar NodejsStreamOutputAdapter = null;\nif (support.nodestream) {\n    try {\n        NodejsStreamOutputAdapter = __webpack_require__(/*! ../nodejs/NodejsStreamOutputAdapter */ \"(ssr)/./node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js\");\n    } catch (e) {\n    // ignore\n    }\n}\n/**\n * Apply the final transformation of the data. If the user wants a Blob for\n * example, it's easier to work with an U8intArray and finally do the\n * ArrayBuffer/Blob conversion.\n * @param {String} type the name of the final type\n * @param {String|Uint8Array|Buffer} content the content to transform\n * @param {String} mimeType the mime type of the content, if applicable.\n * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.\n */ function transformZipOutput(type, content, mimeType) {\n    switch(type){\n        case \"blob\":\n            return utils.newBlob(utils.transformTo(\"arraybuffer\", content), mimeType);\n        case \"base64\":\n            return base64.encode(content);\n        default:\n            return utils.transformTo(type, content);\n    }\n}\n/**\n * Concatenate an array of data of the given type.\n * @param {String} type the type of the data in the given array.\n * @param {Array} dataArray the array containing the data chunks to concatenate\n * @return {String|Uint8Array|Buffer} the concatenated data\n * @throws Error if the asked type is unsupported\n */ function concat(type, dataArray) {\n    var i, index = 0, res = null, totalLength = 0;\n    for(i = 0; i < dataArray.length; i++){\n        totalLength += dataArray[i].length;\n    }\n    switch(type){\n        case \"string\":\n            return dataArray.join(\"\");\n        case \"array\":\n            return Array.prototype.concat.apply([], dataArray);\n        case \"uint8array\":\n            res = new Uint8Array(totalLength);\n            for(i = 0; i < dataArray.length; i++){\n                res.set(dataArray[i], index);\n                index += dataArray[i].length;\n            }\n            return res;\n        case \"nodebuffer\":\n            return Buffer.concat(dataArray);\n        default:\n            throw new Error(\"concat : unsupported type '\" + type + \"'\");\n    }\n}\n/**\n * Listen a StreamHelper, accumulate its content and concatenate it into a\n * complete block.\n * @param {StreamHelper} helper the helper to use.\n * @param {Function} updateCallback a callback called on each update. Called\n * with one arg :\n * - the metadata linked to the update received.\n * @return Promise the promise for the accumulation.\n */ function accumulate(helper, updateCallback) {\n    return new external.Promise(function(resolve, reject) {\n        var dataArray = [];\n        var chunkType = helper._internalType, resultType = helper._outputType, mimeType = helper._mimeType;\n        helper.on(\"data\", function(data, meta) {\n            dataArray.push(data);\n            if (updateCallback) {\n                updateCallback(meta);\n            }\n        }).on(\"error\", function(err) {\n            dataArray = [];\n            reject(err);\n        }).on(\"end\", function() {\n            try {\n                var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);\n                resolve(result);\n            } catch (e) {\n                reject(e);\n            }\n            dataArray = [];\n        }).resume();\n    });\n}\n/**\n * An helper to easily use workers outside of JSZip.\n * @constructor\n * @param {Worker} worker the worker to wrap\n * @param {String} outputType the type of data expected by the use\n * @param {String} mimeType the mime type of the content, if applicable.\n */ function StreamHelper(worker, outputType, mimeType) {\n    var internalType = outputType;\n    switch(outputType){\n        case \"blob\":\n        case \"arraybuffer\":\n            internalType = \"uint8array\";\n            break;\n        case \"base64\":\n            internalType = \"string\";\n            break;\n    }\n    try {\n        // the type used internally\n        this._internalType = internalType;\n        // the type used to output results\n        this._outputType = outputType;\n        // the mime type\n        this._mimeType = mimeType;\n        utils.checkSupport(internalType);\n        this._worker = worker.pipe(new ConvertWorker(internalType));\n        // the last workers can be rewired without issues but we need to\n        // prevent any updates on previous workers.\n        worker.lock();\n    } catch (e) {\n        this._worker = new GenericWorker(\"error\");\n        this._worker.error(e);\n    }\n}\nStreamHelper.prototype = {\n    /**\n     * Listen a StreamHelper, accumulate its content and concatenate it into a\n     * complete block.\n     * @param {Function} updateCb the update callback.\n     * @return Promise the promise for the accumulation.\n     */ accumulate: function(updateCb) {\n        return accumulate(this, updateCb);\n    },\n    /**\n     * Add a listener on an event triggered on a stream.\n     * @param {String} evt the name of the event\n     * @param {Function} fn the listener\n     * @return {StreamHelper} the current helper.\n     */ on: function(evt, fn) {\n        var self = this;\n        if (evt === \"data\") {\n            this._worker.on(evt, function(chunk) {\n                fn.call(self, chunk.data, chunk.meta);\n            });\n        } else {\n            this._worker.on(evt, function() {\n                utils.delay(fn, arguments, self);\n            });\n        }\n        return this;\n    },\n    /**\n     * Resume the flow of chunks.\n     * @return {StreamHelper} the current helper.\n     */ resume: function() {\n        utils.delay(this._worker.resume, [], this._worker);\n        return this;\n    },\n    /**\n     * Pause the flow of chunks.\n     * @return {StreamHelper} the current helper.\n     */ pause: function() {\n        this._worker.pause();\n        return this;\n    },\n    /**\n     * Return a nodejs stream for this helper.\n     * @param {Function} updateCb the update callback.\n     * @return {NodejsStreamOutputAdapter} the nodejs stream.\n     */ toNodejsStream: function(updateCb) {\n        utils.checkSupport(\"nodestream\");\n        if (this._outputType !== \"nodebuffer\") {\n            // an object stream containing blob/arraybuffer/uint8array/string\n            // is strange and I don't know if it would be useful.\n            // I you find this comment and have a good usecase, please open a\n            // bug report !\n            throw new Error(this._outputType + \" is not supported by this method\");\n        }\n        return new NodejsStreamOutputAdapter(this, {\n            objectMode: this._outputType !== \"nodebuffer\"\n        }, updateCb);\n    }\n};\nmodule.exports = StreamHelper;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9TdHJlYW1IZWxwZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQyx5REFBVTtBQUM5QixJQUFJQyxnQkFBZ0JELG1CQUFPQSxDQUFDLCtFQUFpQjtBQUM3QyxJQUFJRSxnQkFBZ0JGLG1CQUFPQSxDQUFDLCtFQUFpQjtBQUM3QyxJQUFJRyxTQUFTSCxtQkFBT0EsQ0FBQywyREFBVztBQUNoQyxJQUFJSSxVQUFVSixtQkFBT0EsQ0FBQyw2REFBWTtBQUNsQyxJQUFJSyxXQUFXTCxtQkFBT0EsQ0FBQywrREFBYTtBQUVwQyxJQUFJTSw0QkFBNEI7QUFDaEMsSUFBSUYsUUFBUUcsVUFBVSxFQUFFO0lBQ3BCLElBQUk7UUFDQUQsNEJBQTRCTixtQkFBT0EsQ0FBQywrR0FBcUM7SUFDN0UsRUFBRSxPQUFNUSxHQUFHO0lBQ1AsU0FBUztJQUNiO0FBQ0o7QUFFQTs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNDLG1CQUFtQkMsSUFBSSxFQUFFQyxPQUFPLEVBQUVDLFFBQVE7SUFDL0MsT0FBT0Y7UUFDUCxLQUFLO1lBQ0QsT0FBT1gsTUFBTWMsT0FBTyxDQUFDZCxNQUFNZSxXQUFXLENBQUMsZUFBZUgsVUFBVUM7UUFDcEUsS0FBSztZQUNELE9BQU9ULE9BQU9ZLE1BQU0sQ0FBQ0o7UUFDekI7WUFDSSxPQUFPWixNQUFNZSxXQUFXLENBQUNKLE1BQU1DO0lBQ25DO0FBQ0o7QUFFQTs7Ozs7O0NBTUMsR0FDRCxTQUFTSyxPQUFRTixJQUFJLEVBQUVPLFNBQVM7SUFDNUIsSUFBSUMsR0FBR0MsUUFBUSxHQUFHQyxNQUFNLE1BQU1DLGNBQWM7SUFDNUMsSUFBSUgsSUFBSSxHQUFHQSxJQUFJRCxVQUFVSyxNQUFNLEVBQUVKLElBQUs7UUFDbENHLGVBQWVKLFNBQVMsQ0FBQ0MsRUFBRSxDQUFDSSxNQUFNO0lBQ3RDO0lBQ0EsT0FBT1o7UUFDUCxLQUFLO1lBQ0QsT0FBT08s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T0FBTztZQUNILElBQUksQ0FBQ1UsT0FBTyxDQUFDWixFQUFFLENBQUNpQixLQUFLO2dCQUNqQjVELE1BQU1pRSxLQUFLLENBQUNKLElBQUlLLFdBQVdKO1lBQy9CO1FBQ0o7UUFDQSxPQUFPLElBQUk7SUFDZjtJQUNBOzs7S0FHQyxHQUNEYixRQUFTO1FBQ0xqRCxNQUFNaUUsS0FBSyxDQUFDLElBQUksQ0FBQ1YsT0FBTyxDQUFDTixNQUFNLEVBQUUsRUFBRSxFQUFFLElBQUksQ0FBQ00sT0FBTztRQUNqRCxPQUFPLElBQUk7SUFDZjtJQUNBOzs7S0FHQyxHQUNEWSxPQUFRO1FBQ0osSUFBSSxDQUFDWixPQUFPLENBQUNZLEtBQUs7UUFDbEIsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7OztLQUlDLEdBQ0RDLGdCQUFpQixTQUFVVCxRQUFRO1FBQy9CM0QsTUFBTXNELFlBQVksQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQ2IsV0FBVyxLQUFLLGNBQWM7WUFDbkMsaUVBQWlFO1lBQ2pFLHFEQUFxRDtZQUNyRCxpRUFBaUU7WUFDakUsZUFBZTtZQUNmLE1BQU0sSUFBSVYsTUFBTSxJQUFJLENBQUNVLFdBQVcsR0FBRztRQUN2QztRQUVBLE9BQU8sSUFBSWxDLDBCQUEwQixJQUFJLEVBQUU7WUFDdkM4RCxZQUFhLElBQUksQ0FBQzVCLFdBQVcsS0FBSztRQUN0QyxHQUFHa0I7SUFDUDtBQUNKO0FBR0FXLE9BQU9DLE9BQU8sR0FBR3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHNhLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vU3RyZWFtSGVscGVyLmpzPzIxZTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBDb252ZXJ0V29ya2VyID0gcmVxdWlyZShcIi4vQ29udmVydFdvcmtlclwiKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZShcIi4vR2VuZXJpY1dvcmtlclwiKTtcbnZhciBiYXNlNjQgPSByZXF1aXJlKFwiLi4vYmFzZTY0XCIpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKFwiLi4vc3VwcG9ydFwiKTtcbnZhciBleHRlcm5hbCA9IHJlcXVpcmUoXCIuLi9leHRlcm5hbFwiKTtcblxudmFyIE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIgPSBudWxsO1xuaWYgKHN1cHBvcnQubm9kZXN0cmVhbSkge1xuICAgIHRyeSB7XG4gICAgICAgIE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIgPSByZXF1aXJlKFwiLi4vbm9kZWpzL05vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXJcIik7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAgIC8vIGlnbm9yZVxuICAgIH1cbn1cblxuLyoqXG4gKiBBcHBseSB0aGUgZmluYWwgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGRhdGEuIElmIHRoZSB1c2VyIHdhbnRzIGEgQmxvYiBmb3JcbiAqIGV4YW1wbGUsIGl0J3MgZWFzaWVyIHRvIHdvcmsgd2l0aCBhbiBVOGludEFycmF5IGFuZCBmaW5hbGx5IGRvIHRoZVxuICogQXJyYXlCdWZmZXIvQmxvYiBjb252ZXJzaW9uLlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIG5hbWUgb2YgdGhlIGZpbmFsIHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfFVpbnQ4QXJyYXl8QnVmZmVyfSBjb250ZW50IHRoZSBjb250ZW50IHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWVUeXBlIHRoZSBtaW1lIHR5cGUgb2YgdGhlIGNvbnRlbnQsIGlmIGFwcGxpY2FibGUuXG4gKiBAcmV0dXJuIHtTdHJpbmd8VWludDhBcnJheXxBcnJheUJ1ZmZlcnxCdWZmZXJ8QmxvYn0gdGhlIGNvbnRlbnQgaW4gdGhlIHJpZ2h0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtWmlwT3V0cHV0KHR5cGUsIGNvbnRlbnQsIG1pbWVUeXBlKSB7XG4gICAgc3dpdGNoKHR5cGUpIHtcbiAgICBjYXNlIFwiYmxvYlwiIDpcbiAgICAgICAgcmV0dXJuIHV0aWxzLm5ld0Jsb2IodXRpbHMudHJhbnNmb3JtVG8oXCJhcnJheWJ1ZmZlclwiLCBjb250ZW50KSwgbWltZVR5cGUpO1xuICAgIGNhc2UgXCJiYXNlNjRcIiA6XG4gICAgICAgIHJldHVybiBiYXNlNjQuZW5jb2RlKGNvbnRlbnQpO1xuICAgIGRlZmF1bHQgOlxuICAgICAgICByZXR1cm4gdXRpbHMudHJhbnNmb3JtVG8odHlwZSwgY29udGVudCk7XG4gICAgfVxufVxuXG4vKipcbiAqIENvbmNhdGVuYXRlIGFuIGFycmF5IG9mIGRhdGEgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgdHlwZSBvZiB0aGUgZGF0YSBpbiB0aGUgZ2l2ZW4gYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhQXJyYXkgdGhlIGFycmF5IGNvbnRhaW5pbmcgdGhlIGRhdGEgY2h1bmtzIHRvIGNvbmNhdGVuYXRlXG4gKiBAcmV0dXJuIHtTdHJpbmd8VWludDhBcnJheXxCdWZmZXJ9IHRoZSBjb25jYXRlbmF0ZWQgZGF0YVxuICogQHRocm93cyBFcnJvciBpZiB0aGUgYXNrZWQgdHlwZSBpcyB1bnN1cHBvcnRlZFxuICovXG5mdW5jdGlvbiBjb25jYXQgKHR5cGUsIGRhdGFBcnJheSkge1xuICAgIHZhciBpLCBpbmRleCA9IDAsIHJlcyA9IG51bGwsIHRvdGFsTGVuZ3RoID0gMDtcbiAgICBmb3IoaSA9IDA7IGkgPCBkYXRhQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG90YWxMZW5ndGggKz0gZGF0YUFycmF5W2ldLmxlbmd0aDtcbiAgICB9XG4gICAgc3dpdGNoKHR5cGUpIHtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIHJldHVybiBkYXRhQXJyYXkuam9pbihcIlwiKTtcbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGRhdGFBcnJheSk7XG4gICAgY2FzZSBcInVpbnQ4YXJyYXlcIjpcbiAgICAgICAgcmVzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBkYXRhQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlcy5zZXQoZGF0YUFycmF5W2ldLCBpbmRleCk7XG4gICAgICAgICAgICBpbmRleCArPSBkYXRhQXJyYXlbaV0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgY2FzZSBcIm5vZGVidWZmZXJcIjpcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoZGF0YUFycmF5KTtcbiAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb25jYXQgOiB1bnN1cHBvcnRlZCB0eXBlICdcIiAgKyB0eXBlICsgXCInXCIpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBMaXN0ZW4gYSBTdHJlYW1IZWxwZXIsIGFjY3VtdWxhdGUgaXRzIGNvbnRlbnQgYW5kIGNvbmNhdGVuYXRlIGl0IGludG8gYVxuICogY29tcGxldGUgYmxvY2suXG4gKiBAcGFyYW0ge1N0cmVhbUhlbHBlcn0gaGVscGVyIHRoZSBoZWxwZXIgdG8gdXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlQ2FsbGJhY2sgYSBjYWxsYmFjayBjYWxsZWQgb24gZWFjaCB1cGRhdGUuIENhbGxlZFxuICogd2l0aCBvbmUgYXJnIDpcbiAqIC0gdGhlIG1ldGFkYXRhIGxpbmtlZCB0byB0aGUgdXBkYXRlIHJlY2VpdmVkLlxuICogQHJldHVybiBQcm9taXNlIHRoZSBwcm9taXNlIGZvciB0aGUgYWNjdW11bGF0aW9uLlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlKGhlbHBlciwgdXBkYXRlQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gbmV3IGV4dGVybmFsLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICAgIHZhciBkYXRhQXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIGNodW5rVHlwZSA9IGhlbHBlci5faW50ZXJuYWxUeXBlLFxuICAgICAgICAgICAgcmVzdWx0VHlwZSA9IGhlbHBlci5fb3V0cHV0VHlwZSxcbiAgICAgICAgICAgIG1pbWVUeXBlID0gaGVscGVyLl9taW1lVHlwZTtcbiAgICAgICAgaGVscGVyXG4gICAgICAgICAgICAub24oXCJkYXRhXCIsIGZ1bmN0aW9uIChkYXRhLCBtZXRhKSB7XG4gICAgICAgICAgICAgICAgZGF0YUFycmF5LnB1c2goZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYodXBkYXRlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ2FsbGJhY2sobWV0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihcImVycm9yXCIsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIGRhdGFBcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihcImVuZFwiLCBmdW5jdGlvbiAoKXtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJhbnNmb3JtWmlwT3V0cHV0KHJlc3VsdFR5cGUsIGNvbmNhdChjaHVua1R5cGUsIGRhdGFBcnJheSksIG1pbWVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhQXJyYXkgPSBbXTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVzdW1lKCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQW4gaGVscGVyIHRvIGVhc2lseSB1c2Ugd29ya2VycyBvdXRzaWRlIG9mIEpTWmlwLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1dvcmtlcn0gd29ya2VyIHRoZSB3b3JrZXIgdG8gd3JhcFxuICogQHBhcmFtIHtTdHJpbmd9IG91dHB1dFR5cGUgdGhlIHR5cGUgb2YgZGF0YSBleHBlY3RlZCBieSB0aGUgdXNlXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZVR5cGUgdGhlIG1pbWUgdHlwZSBvZiB0aGUgY29udGVudCwgaWYgYXBwbGljYWJsZS5cbiAqL1xuZnVuY3Rpb24gU3RyZWFtSGVscGVyKHdvcmtlciwgb3V0cHV0VHlwZSwgbWltZVR5cGUpIHtcbiAgICB2YXIgaW50ZXJuYWxUeXBlID0gb3V0cHV0VHlwZTtcbiAgICBzd2l0Y2gob3V0cHV0VHlwZSkge1xuICAgIGNhc2UgXCJibG9iXCI6XG4gICAgY2FzZSBcImFycmF5YnVmZmVyXCI6XG4gICAgICAgIGludGVybmFsVHlwZSA9IFwidWludDhhcnJheVwiO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIFwiYmFzZTY0XCI6XG4gICAgICAgIGludGVybmFsVHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIC8vIHRoZSB0eXBlIHVzZWQgaW50ZXJuYWxseVxuICAgICAgICB0aGlzLl9pbnRlcm5hbFR5cGUgPSBpbnRlcm5hbFR5cGU7XG4gICAgICAgIC8vIHRoZSB0eXBlIHVzZWQgdG8gb3V0cHV0IHJlc3VsdHNcbiAgICAgICAgdGhpcy5fb3V0cHV0VHlwZSA9IG91dHB1dFR5cGU7XG4gICAgICAgIC8vIHRoZSBtaW1lIHR5cGVcbiAgICAgICAgdGhpcy5fbWltZVR5cGUgPSBtaW1lVHlwZTtcbiAgICAgICAgdXRpbHMuY2hlY2tTdXBwb3J0KGludGVybmFsVHlwZSk7XG4gICAgICAgIHRoaXMuX3dvcmtlciA9IHdvcmtlci5waXBlKG5ldyBDb252ZXJ0V29ya2VyKGludGVybmFsVHlwZSkpO1xuICAgICAgICAvLyB0aGUgbGFzdCB3b3JrZXJzIGNhbiBiZSByZXdpcmVkIHdpdGhvdXQgaXNzdWVzIGJ1dCB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIHByZXZlbnQgYW55IHVwZGF0ZXMgb24gcHJldmlvdXMgd29ya2Vycy5cbiAgICAgICAgd29ya2VyLmxvY2soKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgdGhpcy5fd29ya2VyID0gbmV3IEdlbmVyaWNXb3JrZXIoXCJlcnJvclwiKTtcbiAgICAgICAgdGhpcy5fd29ya2VyLmVycm9yKGUpO1xuICAgIH1cbn1cblxuU3RyZWFtSGVscGVyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBMaXN0ZW4gYSBTdHJlYW1IZWxwZXIsIGFjY3VtdWxhdGUgaXRzIGNvbnRlbnQgYW5kIGNvbmNhdGVuYXRlIGl0IGludG8gYVxuICAgICAqIGNvbXBsZXRlIGJsb2NrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZUNiIHRoZSB1cGRhdGUgY2FsbGJhY2suXG4gICAgICogQHJldHVybiBQcm9taXNlIHRoZSBwcm9taXNlIGZvciB0aGUgYWNjdW11bGF0aW9uLlxuICAgICAqL1xuICAgIGFjY3VtdWxhdGUgOiBmdW5jdGlvbiAodXBkYXRlQ2IpIHtcbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdGUodGhpcywgdXBkYXRlQ2IpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQWRkIGEgbGlzdGVuZXIgb24gYW4gZXZlbnQgdHJpZ2dlcmVkIG9uIGEgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldnQgdGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gdGhlIGxpc3RlbmVyXG4gICAgICogQHJldHVybiB7U3RyZWFtSGVscGVyfSB0aGUgY3VycmVudCBoZWxwZXIuXG4gICAgICovXG4gICAgb24gOiBmdW5jdGlvbiAoZXZ0LCBmbikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYoZXZ0ID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgdGhpcy5fd29ya2VyLm9uKGV2dCwgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgZm4uY2FsbChzZWxmLCBjaHVuay5kYXRhLCBjaHVuay5tZXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fd29ya2VyLm9uKGV2dCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHV0aWxzLmRlbGF5KGZuLCBhcmd1bWVudHMsIHNlbGYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXN1bWUgdGhlIGZsb3cgb2YgY2h1bmtzLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbUhlbHBlcn0gdGhlIGN1cnJlbnQgaGVscGVyLlxuICAgICAqL1xuICAgIHJlc3VtZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbHMuZGVsYXkodGhpcy5fd29ya2VyLnJlc3VtZSwgW10sIHRoaXMuX3dvcmtlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUGF1c2UgdGhlIGZsb3cgb2YgY2h1bmtzLlxuICAgICAqIEByZXR1cm4ge1N0cmVhbUhlbHBlcn0gdGhlIGN1cnJlbnQgaGVscGVyLlxuICAgICAqL1xuICAgIHBhdXNlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl93b3JrZXIucGF1c2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBub2RlanMgc3RyZWFtIGZvciB0aGlzIGhlbHBlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVDYiB0aGUgdXBkYXRlIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm4ge05vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXJ9IHRoZSBub2RlanMgc3RyZWFtLlxuICAgICAqL1xuICAgIHRvTm9kZWpzU3RyZWFtIDogZnVuY3Rpb24gKHVwZGF0ZUNiKSB7XG4gICAgICAgIHV0aWxzLmNoZWNrU3VwcG9ydChcIm5vZGVzdHJlYW1cIik7XG4gICAgICAgIGlmICh0aGlzLl9vdXRwdXRUeXBlICE9PSBcIm5vZGVidWZmZXJcIikge1xuICAgICAgICAgICAgLy8gYW4gb2JqZWN0IHN0cmVhbSBjb250YWluaW5nIGJsb2IvYXJyYXlidWZmZXIvdWludDhhcnJheS9zdHJpbmdcbiAgICAgICAgICAgIC8vIGlzIHN0cmFuZ2UgYW5kIEkgZG9uJ3Qga25vdyBpZiBpdCB3b3VsZCBiZSB1c2VmdWwuXG4gICAgICAgICAgICAvLyBJIHlvdSBmaW5kIHRoaXMgY29tbWVudCBhbmQgaGF2ZSBhIGdvb2QgdXNlY2FzZSwgcGxlYXNlIG9wZW4gYVxuICAgICAgICAgICAgLy8gYnVnIHJlcG9ydCAhXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5fb3V0cHV0VHlwZSArIFwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBtZXRob2RcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIodGhpcywge1xuICAgICAgICAgICAgb2JqZWN0TW9kZSA6IHRoaXMuX291dHB1dFR5cGUgIT09IFwibm9kZWJ1ZmZlclwiXG4gICAgICAgIH0sIHVwZGF0ZUNiKTtcbiAgICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtSGVscGVyO1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsIkNvbnZlcnRXb3JrZXIiLCJHZW5lcmljV29ya2VyIiwiYmFzZTY0Iiwic3VwcG9ydCIsImV4dGVybmFsIiwiTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlciIsIm5vZGVzdHJlYW0iLCJlIiwidHJhbnNmb3JtWmlwT3V0cHV0IiwidHlwZSIsImNvbnRlbnQiLCJtaW1lVHlwZSIsIm5ld0Jsb2IiLCJ0cmFuc2Zvcm1UbyIsImVuY29kZSIsImNvbmNhdCIsImRhdGFBcnJheSIsImkiLCJpbmRleCIsInJlcyIsInRvdGFsTGVuZ3RoIiwibGVuZ3RoIiwiam9pbiIsIkFycmF5IiwicHJvdG90eXBlIiwiYXBwbHkiLCJVaW50OEFycmF5Iiwic2V0IiwiQnVmZmVyIiwiRXJyb3IiLCJhY2N1bXVsYXRlIiwiaGVscGVyIiwidXBkYXRlQ2FsbGJhY2siLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImNodW5rVHlwZSIsIl9pbnRlcm5hbFR5cGUiLCJyZXN1bHRUeXBlIiwiX291dHB1dFR5cGUiLCJfbWltZVR5cGUiLCJvbiIsImRhdGEiLCJtZXRhIiwicHVzaCIsImVyciIsInJlc3VsdCIsInJlc3VtZSIsIlN0cmVhbUhlbHBlciIsIndvcmtlciIsIm91dHB1dFR5cGUiLCJpbnRlcm5hbFR5cGUiLCJjaGVja1N1cHBvcnQiLCJfd29ya2VyIiwicGlwZSIsImxvY2siLCJlcnJvciIsInVwZGF0ZUNiIiwiZXZ0IiwiZm4iLCJzZWxmIiwiY2h1bmsiLCJjYWxsIiwiZGVsYXkiLCJhcmd1bWVudHMiLCJwYXVzZSIsInRvTm9kZWpzU3RyZWFtIiwib2JqZWN0TW9kZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/stream/StreamHelper.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/support.js":
/*!*******************************************!*\
  !*** ./node_modules/jszip/lib/support.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nexports.base64 = true;\nexports.array = true;\nexports.string = true;\nexports.arraybuffer = typeof ArrayBuffer !== \"undefined\" && typeof Uint8Array !== \"undefined\";\nexports.nodebuffer = typeof Buffer !== \"undefined\";\n// contains true if JSZip can read/generate Uint8Array, false otherwise.\nexports.uint8array = typeof Uint8Array !== \"undefined\";\nif (typeof ArrayBuffer === \"undefined\") {\n    exports.blob = false;\n} else {\n    var buffer = new ArrayBuffer(0);\n    try {\n        exports.blob = new Blob([\n            buffer\n        ], {\n            type: \"application/zip\"\n        }).size === 0;\n    } catch (e) {\n        try {\n            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;\n            var builder = new Builder();\n            builder.append(buffer);\n            exports.blob = builder.getBlob(\"application/zip\").size === 0;\n        } catch (e) {\n            exports.blob = false;\n        }\n    }\n}\ntry {\n    exports.nodestream = !!(__webpack_require__(/*! readable-stream */ \"(ssr)/./node_modules/readable-stream/readable.js\").Readable);\n} catch (e) {\n    exports.nodestream = false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3N1cHBvcnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsY0FBYyxHQUFHO0FBQ2pCQSxhQUFhLEdBQUc7QUFDaEJBLGNBQWMsR0FBRztBQUNqQkEsbUJBQW1CLEdBQUcsT0FBT0ssZ0JBQWdCLGVBQWUsT0FBT0MsZUFBZTtBQUNsRk4sa0JBQWtCLEdBQUcsT0FBT1EsV0FBVztBQUN2Qyx3RUFBd0U7QUFDeEVSLGtCQUFrQixHQUFHLE9BQU9NLGVBQWU7QUFFM0MsSUFBSSxPQUFPRCxnQkFBZ0IsYUFBYTtJQUNwQ0wsWUFBWSxHQUFHO0FBQ25CLE9BQ0s7SUFDRCxJQUFJVyxTQUFTLElBQUlOLFlBQVk7SUFDN0IsSUFBSTtRQUNBTCxZQUFZLEdBQUcsSUFBSVksS0FBSztZQUFDRDtTQUFPLEVBQUU7WUFDOUJFLE1BQU07UUFDVixHQUFHQyxJQUFJLEtBQUs7SUFDaEIsRUFDQSxPQUFPQyxHQUFHO1FBQ04sSUFBSTtZQUNBLElBQUlDLFVBQVVDLEtBQUtDLFdBQVcsSUFBSUQsS0FBS0UsaUJBQWlCLElBQUlGLEtBQUtHLGNBQWMsSUFBSUgsS0FBS0ksYUFBYTtZQUNyRyxJQUFJQyxVQUFVLElBQUlOO1lBQ2xCTSxRQUFRQyxNQUFNLENBQUNaO1lBQ2ZYLFlBQVksR0FBR3NCLFFBQVFFLE9BQU8sQ0FBQyxtQkFBbUJWLElBQUksS0FBSztRQUMvRCxFQUNBLE9BQU9DLEdBQUc7WUFDTmYsWUFBWSxHQUFHO1FBQ25CO0lBQ0o7QUFDSjtBQUVBLElBQUk7SUFDQUEsa0JBQWtCLEdBQUcsQ0FBQyxDQUFDMEIseUdBQW1DO0FBQzlELEVBQUUsT0FBTVgsR0FBRztJQUNQZixrQkFBa0IsR0FBRztBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL3RzYS1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3VwcG9ydC5qcz8xY2JlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLmJhc2U2NCA9IHRydWU7XG5leHBvcnRzLmFycmF5ID0gdHJ1ZTtcbmV4cG9ydHMuc3RyaW5nID0gdHJ1ZTtcbmV4cG9ydHMuYXJyYXlidWZmZXIgPSB0eXBlb2YgQXJyYXlCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCI7XG5leHBvcnRzLm5vZGVidWZmZXIgPSB0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiO1xuLy8gY29udGFpbnMgdHJ1ZSBpZiBKU1ppcCBjYW4gcmVhZC9nZW5lcmF0ZSBVaW50OEFycmF5LCBmYWxzZSBvdGhlcndpc2UuXG5leHBvcnRzLnVpbnQ4YXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIjtcblxuaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGV4cG9ydHMuYmxvYiA9IGZhbHNlO1xufVxuZWxzZSB7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICB0cnkge1xuICAgICAgICBleHBvcnRzLmJsb2IgPSBuZXcgQmxvYihbYnVmZmVyXSwge1xuICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi96aXBcIlxuICAgICAgICB9KS5zaXplID09PSAwO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIEJ1aWxkZXIgPSBzZWxmLkJsb2JCdWlsZGVyIHx8IHNlbGYuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgc2VsZi5Nb3pCbG9iQnVpbGRlciB8fCBzZWxmLk1TQmxvYkJ1aWxkZXI7XG4gICAgICAgICAgICB2YXIgYnVpbGRlciA9IG5ldyBCdWlsZGVyKCk7XG4gICAgICAgICAgICBidWlsZGVyLmFwcGVuZChidWZmZXIpO1xuICAgICAgICAgICAgZXhwb3J0cy5ibG9iID0gYnVpbGRlci5nZXRCbG9iKFwiYXBwbGljYXRpb24vemlwXCIpLnNpemUgPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuYmxvYiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG50cnkge1xuICAgIGV4cG9ydHMubm9kZXN0cmVhbSA9ICEhcmVxdWlyZShcInJlYWRhYmxlLXN0cmVhbVwiKS5SZWFkYWJsZTtcbn0gY2F0Y2goZSkge1xuICAgIGV4cG9ydHMubm9kZXN0cmVhbSA9IGZhbHNlO1xufVxuIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJiYXNlNjQiLCJhcnJheSIsInN0cmluZyIsImFycmF5YnVmZmVyIiwiQXJyYXlCdWZmZXIiLCJVaW50OEFycmF5Iiwibm9kZWJ1ZmZlciIsIkJ1ZmZlciIsInVpbnQ4YXJyYXkiLCJibG9iIiwiYnVmZmVyIiwiQmxvYiIsInR5cGUiLCJzaXplIiwiZSIsIkJ1aWxkZXIiLCJzZWxmIiwiQmxvYkJ1aWxkZXIiLCJXZWJLaXRCbG9iQnVpbGRlciIsIk1vekJsb2JCdWlsZGVyIiwiTVNCbG9iQnVpbGRlciIsImJ1aWxkZXIiLCJhcHBlbmQiLCJnZXRCbG9iIiwibm9kZXN0cmVhbSIsInJlcXVpcmUiLCJSZWFkYWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/support.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/utf8.js":
/*!****************************************!*\
  !*** ./node_modules/jszip/lib/utf8.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nvar support = __webpack_require__(/*! ./support */ \"(ssr)/./node_modules/jszip/lib/support.js\");\nvar nodejsUtils = __webpack_require__(/*! ./nodejsUtils */ \"(ssr)/./node_modules/jszip/lib/nodejsUtils.js\");\nvar GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ \"(ssr)/./node_modules/jszip/lib/stream/GenericWorker.js\");\n/**\n * The following functions come from pako, from pako/lib/utils/strings\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */ // Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new Array(256);\nfor(var i = 0; i < 256; i++){\n    _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n// convert string to array (typed, when possible)\nvar string2buf = function(str) {\n    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n    // count binary size\n    for(m_pos = 0; m_pos < str_len; m_pos++){\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n            c2 = str.charCodeAt(m_pos + 1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n    }\n    // allocate buffer\n    if (support.uint8array) {\n        buf = new Uint8Array(buf_len);\n    } else {\n        buf = new Array(buf_len);\n    }\n    // convert\n    for(i = 0, m_pos = 0; i < buf_len; m_pos++){\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n            c2 = str.charCodeAt(m_pos + 1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        if (c < 0x80) {\n            /* one byte */ buf[i++] = c;\n        } else if (c < 0x800) {\n            /* two bytes */ buf[i++] = 0xC0 | c >>> 6;\n            buf[i++] = 0x80 | c & 0x3f;\n        } else if (c < 0x10000) {\n            /* three bytes */ buf[i++] = 0xE0 | c >>> 12;\n            buf[i++] = 0x80 | c >>> 6 & 0x3f;\n            buf[i++] = 0x80 | c & 0x3f;\n        } else {\n            /* four bytes */ buf[i++] = 0xf0 | c >>> 18;\n            buf[i++] = 0x80 | c >>> 12 & 0x3f;\n            buf[i++] = 0x80 | c >>> 6 & 0x3f;\n            buf[i++] = 0x80 | c & 0x3f;\n        }\n    }\n    return buf;\n};\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nvar utf8border = function(buf, max) {\n    var pos;\n    max = max || buf.length;\n    if (max > buf.length) {\n        max = buf.length;\n    }\n    // go back from last position, until start of sequence found\n    pos = max - 1;\n    while(pos >= 0 && (buf[pos] & 0xC0) === 0x80){\n        pos--;\n    }\n    // Fuckup - very small and broken sequence,\n    // return max, because we should return something anyway.\n    if (pos < 0) {\n        return max;\n    }\n    // If we came to start of buffer - that means vuffer is too small,\n    // return max too.\n    if (pos === 0) {\n        return max;\n    }\n    return pos + _utf8len[buf[pos]] > max ? pos : max;\n};\n// convert array to string\nvar buf2string = function(buf) {\n    var i, out, c, c_len;\n    var len = buf.length;\n    // Reserve max possible length (2 words per char)\n    // NB: by unknown reasons, Array is significantly faster for\n    //     String.fromCharCode.apply than Uint16Array.\n    var utf16buf = new Array(len * 2);\n    for(out = 0, i = 0; i < len;){\n        c = buf[i++];\n        // quick process ascii\n        if (c < 0x80) {\n            utf16buf[out++] = c;\n            continue;\n        }\n        c_len = _utf8len[c];\n        // skip 5 & 6 byte codes\n        if (c_len > 4) {\n            utf16buf[out++] = 0xfffd;\n            i += c_len - 1;\n            continue;\n        }\n        // apply mask on first byte\n        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n        // join the rest\n        while(c_len > 1 && i < len){\n            c = c << 6 | buf[i++] & 0x3f;\n            c_len--;\n        }\n        // terminated by end of string?\n        if (c_len > 1) {\n            utf16buf[out++] = 0xfffd;\n            continue;\n        }\n        if (c < 0x10000) {\n            utf16buf[out++] = c;\n        } else {\n            c -= 0x10000;\n            utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;\n            utf16buf[out++] = 0xdc00 | c & 0x3ff;\n        }\n    }\n    // shrinkBuf(utf16buf, out)\n    if (utf16buf.length !== out) {\n        if (utf16buf.subarray) {\n            utf16buf = utf16buf.subarray(0, out);\n        } else {\n            utf16buf.length = out;\n        }\n    }\n    // return String.fromCharCode.apply(null, utf16buf);\n    return utils.applyFromCharCode(utf16buf);\n};\n// That's all for the pako functions.\n/**\n * Transform a javascript string into an array (typed if possible) of bytes,\n * UTF-8 encoded.\n * @param {String} str the string to encode\n * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.\n */ exports.utf8encode = function utf8encode(str) {\n    if (support.nodebuffer) {\n        return nodejsUtils.newBufferFrom(str, \"utf-8\");\n    }\n    return string2buf(str);\n};\n/**\n * Transform a bytes array (or a representation) representing an UTF-8 encoded\n * string into a javascript string.\n * @param {Array|Uint8Array|Buffer} buf the data de decode\n * @return {String} the decoded string.\n */ exports.utf8decode = function utf8decode(buf) {\n    if (support.nodebuffer) {\n        return utils.transformTo(\"nodebuffer\", buf).toString(\"utf-8\");\n    }\n    buf = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", buf);\n    return buf2string(buf);\n};\n/**\n * A worker to decode utf8 encoded binary chunks into string chunks.\n * @constructor\n */ function Utf8DecodeWorker() {\n    GenericWorker.call(this, \"utf-8 decode\");\n    // the last bytes if a chunk didn't end with a complete codepoint.\n    this.leftOver = null;\n}\nutils.inherits(Utf8DecodeWorker, GenericWorker);\n/**\n * @see GenericWorker.processChunk\n */ Utf8DecodeWorker.prototype.processChunk = function(chunk) {\n    var data = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", chunk.data);\n    // 1st step, re-use what's left of the previous chunk\n    if (this.leftOver && this.leftOver.length) {\n        if (support.uint8array) {\n            var previousData = data;\n            data = new Uint8Array(previousData.length + this.leftOver.length);\n            data.set(this.leftOver, 0);\n            data.set(previousData, this.leftOver.length);\n        } else {\n            data = this.leftOver.concat(data);\n        }\n        this.leftOver = null;\n    }\n    var nextBoundary = utf8border(data);\n    var usableData = data;\n    if (nextBoundary !== data.length) {\n        if (support.uint8array) {\n            usableData = data.subarray(0, nextBoundary);\n            this.leftOver = data.subarray(nextBoundary, data.length);\n        } else {\n            usableData = data.slice(0, nextBoundary);\n            this.leftOver = data.slice(nextBoundary, data.length);\n        }\n    }\n    this.push({\n        data: exports.utf8decode(usableData),\n        meta: chunk.meta\n    });\n};\n/**\n * @see GenericWorker.flush\n */ Utf8DecodeWorker.prototype.flush = function() {\n    if (this.leftOver && this.leftOver.length) {\n        this.push({\n            data: exports.utf8decode(this.leftOver),\n            meta: {}\n        });\n        this.leftOver = null;\n    }\n};\nexports.Utf8DecodeWorker = Utf8DecodeWorker;\n/**\n * A worker to endcode string chunks into utf8 encoded binary chunks.\n * @constructor\n */ function Utf8EncodeWorker() {\n    GenericWorker.call(this, \"utf-8 encode\");\n}\nutils.inherits(Utf8EncodeWorker, GenericWorker);\n/**\n * @see GenericWorker.processChunk\n */ Utf8EncodeWorker.prototype.processChunk = function(chunk) {\n    this.push({\n        data: exports.utf8encode(chunk.data),\n        meta: chunk.meta\n    });\n};\nexports.Utf8EncodeWorker = Utf8EncodeWorker;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3V0ZjguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQyx3REFBUztBQUM3QixJQUFJQyxVQUFVRCxtQkFBT0EsQ0FBQyw0REFBVztBQUNqQyxJQUFJRSxjQUFjRixtQkFBT0EsQ0FBQyxvRUFBZTtBQUN6QyxJQUFJRyxnQkFBZ0JILG1CQUFPQSxDQUFDLHNGQUF3QjtBQUVwRDs7O0NBR0MsR0FFRCxpRUFBaUU7QUFDakUsb0ZBQW9GO0FBQ3BGLDZDQUE2QztBQUM3QyxJQUFJSSxXQUFXLElBQUlDLE1BQU07QUFDekIsSUFBSyxJQUFJQyxJQUFFLEdBQUdBLElBQUUsS0FBS0EsSUFBSztJQUN0QkYsUUFBUSxDQUFDRSxFQUFFLEdBQUlBLEtBQUssTUFBTSxJQUFJQSxLQUFLLE1BQU0sSUFBSUEsS0FBSyxNQUFNLElBQUlBLEtBQUssTUFBTSxJQUFJQSxLQUFLLE1BQU0sSUFBSTtBQUM5RjtBQUNBRixRQUFRLENBQUMsSUFBSSxHQUFDQSxRQUFRLENBQUMsSUFBSSxHQUFDLEdBQUcseUJBQXlCO0FBRXhELGlEQUFpRDtBQUNqRCxJQUFJRyxhQUFhLFNBQVVDLEdBQUc7SUFDMUIsSUFBSUMsS0FBS0MsR0FBR0MsSUFBSUMsT0FBT04sR0FBR08sVUFBVUwsSUFBSU0sTUFBTSxFQUFFQyxVQUFVO0lBRTFELG9CQUFvQjtJQUNwQixJQUFLSCxRQUFRLEdBQUdBLFFBQVFDLFNBQVNELFFBQVM7UUFDdENGLElBQUlGLElBQUlRLFVBQVUsQ0FBQ0o7UUFDbkIsSUFBSSxDQUFDRixJQUFJLE1BQUssTUFBTyxVQUFXRSxRQUFNLElBQUlDLFNBQVU7WUFDaERGLEtBQUtILElBQUlRLFVBQVUsQ0FBQ0osUUFBTTtZQUMxQixJQUFJLENBQUNELEtBQUssTUFBSyxNQUFPLFFBQVE7Z0JBQzFCRCxJQUFJLFVBQVcsS0FBSyxVQUFXLEVBQUMsSUFBTUMsQ0FBQUEsS0FBSyxNQUFLO2dCQUNo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LElBQUksQ0FBQztRQUNOUCxNQUFPZCxRQUFRQyxVQUFVLENBQUNZLE1BQU1DLElBQUk7UUFDcENRLE1BQU9ULE1BQU1TLElBQUk7SUFDckI7QUFDSjtBQUNBdEIsd0JBQXdCLEdBQUd3QiIsInNvdXJjZXMiOlsid2VicGFjazovL3RzYS1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvdXRmOC5qcz8xMzc4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBzdXBwb3J0ID0gcmVxdWlyZShcIi4vc3VwcG9ydFwiKTtcbnZhciBub2RlanNVdGlscyA9IHJlcXVpcmUoXCIuL25vZGVqc1V0aWxzXCIpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKFwiLi9zdHJlYW0vR2VuZXJpY1dvcmtlclwiKTtcblxuLyoqXG4gKiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBjb21lIGZyb20gcGFrbywgZnJvbSBwYWtvL2xpYi91dGlscy9zdHJpbmdzXG4gKiByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UsIHNlZSBwYWtvIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGFrby9cbiAqL1xuXG4vLyBUYWJsZSB3aXRoIHV0ZjggbGVuZ3RocyAoY2FsY3VsYXRlZCBieSBmaXJzdCBieXRlIG9mIHNlcXVlbmNlKVxuLy8gTm90ZSwgdGhhdCA1ICYgNi1ieXRlIHZhbHVlcyBhbmQgc29tZSA0LWJ5dGUgdmFsdWVzIGNhbiBub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlMsXG4vLyBiZWNhdXNlIG1heCBwb3NzaWJsZSBjb2RlcG9pbnQgaXMgMHgxMGZmZmZcbnZhciBfdXRmOGxlbiA9IG5ldyBBcnJheSgyNTYpO1xuZm9yICh2YXIgaT0wOyBpPDI1NjsgaSsrKSB7XG4gICAgX3V0ZjhsZW5baV0gPSAoaSA+PSAyNTIgPyA2IDogaSA+PSAyNDggPyA1IDogaSA+PSAyNDAgPyA0IDogaSA+PSAyMjQgPyAzIDogaSA+PSAxOTIgPyAyIDogMSk7XG59XG5fdXRmOGxlblsyNTRdPV91dGY4bGVuWzI1NF09MTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydFxuXG4vLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG52YXIgc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB2YXIgYnVmLCBjLCBjMiwgbV9wb3MsIGksIHN0cl9sZW4gPSBzdHIubGVuZ3RoLCBidWZfbGVuID0gMDtcblxuICAgIC8vIGNvdW50IGJpbmFyeSBzaXplXG4gICAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykge1xuICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgICAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zKzEgPCBzdHJfbGVuKSkge1xuICAgICAgICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcysxKTtcbiAgICAgICAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgICAgICAgICBtX3BvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJ1Zl9sZW4gKz0gYyA8IDB4ODAgPyAxIDogYyA8IDB4ODAwID8gMiA6IGMgPCAweDEwMDAwID8gMyA6IDQ7XG4gICAgfVxuXG4gICAgLy8gYWxsb2NhdGUgYnVmZmVyXG4gICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICBidWYgPSBuZXcgVWludDhBcnJheShidWZfbGVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBidWYgPSBuZXcgQXJyYXkoYnVmX2xlbik7XG4gICAgfVxuXG4gICAgLy8gY29udmVydFxuICAgIGZvciAoaT0wLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7XG4gICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MrMSA8IHN0cl9sZW4pKSB7XG4gICAgICAgICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKzEpO1xuICAgICAgICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICAgICAgICAgIG1fcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICAvKiBvbmUgYnl0ZSAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSBjO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgLyogdHdvIGJ5dGVzICovXG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4QzAgfCAoYyA+Pj4gNik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICAvKiB0aHJlZSBieXRlcyAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSAweEUwIHwgKGMgPj4+IDEyKTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLyogZm91ciBieXRlcyAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSAweGYwIHwgKGMgPj4+IDE4KTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiAxMiAmIDB4M2YpO1xuICAgICAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xufTtcblxuLy8gQ2FsY3VsYXRlIG1heCBwb3NzaWJsZSBwb3NpdGlvbiBpbiB1dGY4IGJ1ZmZlcixcbi8vIHRoYXQgd2lsbCBub3QgYnJlYWsgc2VxdWVuY2UuIElmIHRoYXQncyBub3QgcG9zc2libGVcbi8vIC0gKHZlcnkgc21hbGwgbGltaXRzKSByZXR1cm4gbWF4IHNpemUgYXMgaXMuXG4vL1xuLy8gYnVmW10gLSB1dGY4IGJ5dGVzIGFycmF5XG4vLyBtYXggICAtIGxlbmd0aCBsaW1pdCAobWFuZGF0b3J5KTtcbnZhciB1dGY4Ym9yZGVyID0gZnVuY3Rpb24oYnVmLCBtYXgpIHtcbiAgICB2YXIgcG9zO1xuXG4gICAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gICAgaWYgKG1heCA+IGJ1Zi5sZW5ndGgpIHsgbWF4ID0gYnVmLmxlbmd0aDsgfVxuXG4gICAgLy8gZ28gYmFjayBmcm9tIGxhc3QgcG9zaXRpb24sIHVudGlsIHN0YXJ0IG9mIHNlcXVlbmNlIGZvdW5kXG4gICAgcG9zID0gbWF4LTE7XG4gICAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDB4QzApID09PSAweDgwKSB7IHBvcy0tOyB9XG5cbiAgICAvLyBGdWNrdXAgLSB2ZXJ5IHNtYWxsIGFuZCBicm9rZW4gc2VxdWVuY2UsXG4gICAgLy8gcmV0dXJuIG1heCwgYmVjYXVzZSB3ZSBzaG91bGQgcmV0dXJuIHNvbWV0aGluZyBhbnl3YXkuXG4gICAgaWYgKHBvcyA8IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gICAgLy8gSWYgd2UgY2FtZSB0byBzdGFydCBvZiBidWZmZXIgLSB0aGF0IG1lYW5zIHZ1ZmZlciBpcyB0b28gc21hbGwsXG4gICAgLy8gcmV0dXJuIG1heCB0b28uXG4gICAgaWYgKHBvcyA9PT0gMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgICByZXR1cm4gKHBvcyArIF91dGY4bGVuW2J1Zltwb3NdXSA+IG1heCkgPyBwb3MgOiBtYXg7XG59O1xuXG4vLyBjb252ZXJ0IGFycmF5IHRvIHN0cmluZ1xudmFyIGJ1ZjJzdHJpbmcgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgdmFyIGksIG91dCwgYywgY19sZW47XG4gICAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7XG5cbiAgICAvLyBSZXNlcnZlIG1heCBwb3NzaWJsZSBsZW5ndGggKDIgd29yZHMgcGVyIGNoYXIpXG4gICAgLy8gTkI6IGJ5IHVua25vd24gcmVhc29ucywgQXJyYXkgaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgZm9yXG4gICAgLy8gICAgIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkgdGhhbiBVaW50MTZBcnJheS5cbiAgICB2YXIgdXRmMTZidWYgPSBuZXcgQXJyYXkobGVuKjIpO1xuXG4gICAgZm9yIChvdXQ9MCwgaT0wOyBpPGxlbjspIHtcbiAgICAgICAgYyA9IGJ1ZltpKytdO1xuICAgICAgICAvLyBxdWljayBwcm9jZXNzIGFzY2lpXG4gICAgICAgIGlmIChjIDwgMHg4MCkgeyB1dGYxNmJ1ZltvdXQrK10gPSBjOyBjb250aW51ZTsgfVxuXG4gICAgICAgIGNfbGVuID0gX3V0ZjhsZW5bY107XG4gICAgICAgIC8vIHNraXAgNSAmIDYgYnl0ZSBjb2Rlc1xuICAgICAgICBpZiAoY19sZW4gPiA0KSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgaSArPSBjX2xlbi0xOyBjb250aW51ZTsgfVxuXG4gICAgICAgIC8vIGFwcGx5IG1hc2sgb24gZmlyc3QgYnl0ZVxuICAgICAgICBjICY9IGNfbGVuID09PSAyID8gMHgxZiA6IGNfbGVuID09PSAzID8gMHgwZiA6IDB4MDc7XG4gICAgICAgIC8vIGpvaW4gdGhlIHJlc3RcbiAgICAgICAgd2hpbGUgKGNfbGVuID4gMSAmJiBpIDwgbGVuKSB7XG4gICAgICAgICAgICBjID0gKGMgPDwgNikgfCAoYnVmW2krK10gJiAweDNmKTtcbiAgICAgICAgICAgIGNfbGVuLS07XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0ZXJtaW5hdGVkIGJ5IGVuZCBvZiBzdHJpbmc/XG4gICAgICAgIGlmIChjX2xlbiA+IDEpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBjb250aW51ZTsgfVxuXG4gICAgICAgIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gYztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGMgLT0gMHgxMDAwMDtcbiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZDgwMCB8ICgoYyA+PiAxMCkgJiAweDNmZik7XG4gICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGRjMDAgfCAoYyAmIDB4M2ZmKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNocmlua0J1Zih1dGYxNmJ1Ziwgb3V0KVxuICAgIGlmICh1dGYxNmJ1Zi5sZW5ndGggIT09IG91dCkge1xuICAgICAgICBpZih1dGYxNmJ1Zi5zdWJhcnJheSkge1xuICAgICAgICAgICAgdXRmMTZidWYgPSB1dGYxNmJ1Zi5zdWJhcnJheSgwLCBvdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXRmMTZidWYubGVuZ3RoID0gb3V0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdXRmMTZidWYpO1xuICAgIHJldHVybiB1dGlscy5hcHBseUZyb21DaGFyQ29kZSh1dGYxNmJ1Zik7XG59O1xuXG5cbi8vIFRoYXQncyBhbGwgZm9yIHRoZSBwYWtvIGZ1bmN0aW9ucy5cblxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIGphdmFzY3JpcHQgc3RyaW5nIGludG8gYW4gYXJyYXkgKHR5cGVkIGlmIHBvc3NpYmxlKSBvZiBieXRlcyxcbiAqIFVURi04IGVuY29kZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gZW5jb2RlXG4gKiBAcmV0dXJuIHtBcnJheXxVaW50OEFycmF5fEJ1ZmZlcn0gdGhlIFVURi04IGVuY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnRzLnV0ZjhlbmNvZGUgPSBmdW5jdGlvbiB1dGY4ZW5jb2RlKHN0cikge1xuICAgIGlmIChzdXBwb3J0Lm5vZGVidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVqc1V0aWxzLm5ld0J1ZmZlckZyb20oc3RyLCBcInV0Zi04XCIpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmcyYnVmKHN0cik7XG59O1xuXG5cbi8qKlxuICogVHJhbnNmb3JtIGEgYnl0ZXMgYXJyYXkgKG9yIGEgcmVwcmVzZW50YXRpb24pIHJlcHJlc2VudGluZyBhbiBVVEYtOCBlbmNvZGVkXG4gKiBzdHJpbmcgaW50byBhIGphdmFzY3JpcHQgc3RyaW5nLlxuICogQHBhcmFtIHtBcnJheXxVaW50OEFycmF5fEJ1ZmZlcn0gYnVmIHRoZSBkYXRhIGRlIGRlY29kZVxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgZGVjb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydHMudXRmOGRlY29kZSA9IGZ1bmN0aW9uIHV0ZjhkZWNvZGUoYnVmKSB7XG4gICAgaWYgKHN1cHBvcnQubm9kZWJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gdXRpbHMudHJhbnNmb3JtVG8oXCJub2RlYnVmZmVyXCIsIGJ1ZikudG9TdHJpbmcoXCJ1dGYtOFwiKTtcbiAgICB9XG5cbiAgICBidWYgPSB1dGlscy50cmFuc2Zvcm1UbyhzdXBwb3J0LnVpbnQ4YXJyYXkgPyBcInVpbnQ4YXJyYXlcIiA6IFwiYXJyYXlcIiwgYnVmKTtcblxuICAgIHJldHVybiBidWYyc3RyaW5nKGJ1Zik7XG59O1xuXG4vKipcbiAqIEEgd29ya2VyIHRvIGRlY29kZSB1dGY4IGVuY29kZWQgYmluYXJ5IGNodW5rcyBpbnRvIHN0cmluZyBjaHVua3MuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVXRmOERlY29kZVdvcmtlcigpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJ1dGYtOCBkZWNvZGVcIik7XG4gICAgLy8gdGhlIGxhc3QgYnl0ZXMgaWYgYSBjaHVuayBkaWRuJ3QgZW5kIHdpdGggYSBjb21wbGV0ZSBjb2RlcG9pbnQuXG4gICAgdGhpcy5sZWZ0T3ZlciA9IG51bGw7XG59XG51dGlscy5pbmhlcml0cyhVdGY4RGVjb2RlV29ya2VyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHJvY2Vzc0NodW5rXG4gKi9cblV0ZjhEZWNvZGVXb3JrZXIucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuXG4gICAgdmFyIGRhdGEgPSB1dGlscy50cmFuc2Zvcm1UbyhzdXBwb3J0LnVpbnQ4YXJyYXkgPyBcInVpbnQ4YXJyYXlcIiA6IFwiYXJyYXlcIiwgY2h1bmsuZGF0YSk7XG5cbiAgICAvLyAxc3Qgc3RlcCwgcmUtdXNlIHdoYXQncyBsZWZ0IG9mIHRoZSBwcmV2aW91cyBjaHVua1xuICAgIGlmICh0aGlzLmxlZnRPdmVyICYmIHRoaXMubGVmdE92ZXIubGVuZ3RoKSB7XG4gICAgICAgIGlmKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzRGF0YSA9IGRhdGE7XG4gICAgICAgICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkocHJldmlvdXNEYXRhLmxlbmd0aCArIHRoaXMubGVmdE92ZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIGRhdGEuc2V0KHRoaXMubGVmdE92ZXIsIDApO1xuICAgICAgICAgICAgZGF0YS5zZXQocHJldmlvdXNEYXRhLCB0aGlzLmxlZnRPdmVyLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5sZWZ0T3Zlci5jb25jYXQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZWZ0T3ZlciA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG5leHRCb3VuZGFyeSA9IHV0Zjhib3JkZXIoZGF0YSk7XG4gICAgdmFyIHVzYWJsZURhdGEgPSBkYXRhO1xuICAgIGlmIChuZXh0Qm91bmRhcnkgIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgICAgIHVzYWJsZURhdGEgPSBkYXRhLnN1YmFycmF5KDAsIG5leHRCb3VuZGFyeSk7XG4gICAgICAgICAgICB0aGlzLmxlZnRPdmVyID0gZGF0YS5zdWJhcnJheShuZXh0Qm91bmRhcnksIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVzYWJsZURhdGEgPSBkYXRhLnNsaWNlKDAsIG5leHRCb3VuZGFyeSk7XG4gICAgICAgICAgICB0aGlzLmxlZnRPdmVyID0gZGF0YS5zbGljZShuZXh0Qm91bmRhcnksIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucHVzaCh7XG4gICAgICAgIGRhdGEgOiBleHBvcnRzLnV0ZjhkZWNvZGUodXNhYmxlRGF0YSksXG4gICAgICAgIG1ldGEgOiBjaHVuay5tZXRhXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5mbHVzaFxuICovXG5VdGY4RGVjb2RlV29ya2VyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZih0aGlzLmxlZnRPdmVyICYmIHRoaXMubGVmdE92ZXIubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogZXhwb3J0cy51dGY4ZGVjb2RlKHRoaXMubGVmdE92ZXIpLFxuICAgICAgICAgICAgbWV0YSA6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxlZnRPdmVyID0gbnVsbDtcbiAgICB9XG59O1xuZXhwb3J0cy5VdGY4RGVjb2RlV29ya2VyID0gVXRmOERlY29kZVdvcmtlcjtcblxuLyoqXG4gKiBBIHdvcmtlciB0byBlbmRjb2RlIHN0cmluZyBjaHVua3MgaW50byB1dGY4IGVuY29kZWQgYmluYXJ5IGNodW5rcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBVdGY4RW5jb2RlV29ya2VyKCkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcInV0Zi04IGVuY29kZVwiKTtcbn1cbnV0aWxzLmluaGVyaXRzKFV0ZjhFbmNvZGVXb3JrZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuVXRmOEVuY29kZVdvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgdGhpcy5wdXNoKHtcbiAgICAgICAgZGF0YSA6IGV4cG9ydHMudXRmOGVuY29kZShjaHVuay5kYXRhKSxcbiAgICAgICAgbWV0YSA6IGNodW5rLm1ldGFcbiAgICB9KTtcbn07XG5leHBvcnRzLlV0ZjhFbmNvZGVXb3JrZXIgPSBVdGY4RW5jb2RlV29ya2VyO1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsInN1cHBvcnQiLCJub2RlanNVdGlscyIsIkdlbmVyaWNXb3JrZXIiLCJfdXRmOGxlbiIsIkFycmF5IiwiaSIsInN0cmluZzJidWYiLCJzdHIiLCJidWYiLCJjIiwiYzIiLCJtX3BvcyIsInN0cl9sZW4iLCJsZW5ndGgiLCJidWZfbGVuIiwiY2hhckNvZGVBdCIsInVpbnQ4YXJyYXkiLCJVaW50OEFycmF5IiwidXRmOGJvcmRlciIsIm1heCIsInBvcyIsImJ1ZjJzdHJpbmciLCJvdXQiLCJjX2xlbiIsImxlbiIsInV0ZjE2YnVmIiwic3ViYXJyYXkiLCJhcHBseUZyb21DaGFyQ29kZSIsImV4cG9ydHMiLCJ1dGY4ZW5jb2RlIiwibm9kZWJ1ZmZlciIsIm5ld0J1ZmZlckZyb20iLCJ1dGY4ZGVjb2RlIiwidHJhbnNmb3JtVG8iLCJ0b1N0cmluZyIsIlV0ZjhEZWNvZGVXb3JrZXIiLCJjYWxsIiwibGVmdE92ZXIiLCJpbmhlcml0cyIsInByb3RvdHlwZSIsInByb2Nlc3NDaHVuayIsImNodW5rIiwiZGF0YSIsInByZXZpb3VzRGF0YSIsInNldCIsImNvbmNhdCIsIm5leHRCb3VuZGFyeSIsInVzYWJsZURhdGEiLCJzbGljZSIsInB1c2giLCJtZXRhIiwiZmx1c2giLCJVdGY4RW5jb2RlV29ya2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/utf8.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/jszip/lib/utils.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar support = __webpack_require__(/*! ./support */ \"(ssr)/./node_modules/jszip/lib/support.js\");\nvar base64 = __webpack_require__(/*! ./base64 */ \"(ssr)/./node_modules/jszip/lib/base64.js\");\nvar nodejsUtils = __webpack_require__(/*! ./nodejsUtils */ \"(ssr)/./node_modules/jszip/lib/nodejsUtils.js\");\nvar external = __webpack_require__(/*! ./external */ \"(ssr)/./node_modules/jszip/lib/external.js\");\n__webpack_require__(/*! setimmediate */ \"(ssr)/./node_modules/next/dist/compiled/setimmediate/setImmediate.js\");\n/**\n * Convert a string that pass as a \"binary string\": it should represent a byte\n * array but may have > 255 char codes. Be sure to take only the first byte\n * and returns the byte array.\n * @param {String} str the string to transform.\n * @return {Array|Uint8Array} the string in a binary format.\n */ function string2binary(str) {\n    var result = null;\n    if (support.uint8array) {\n        result = new Uint8Array(str.length);\n    } else {\n        result = new Array(str.length);\n    }\n    return stringToArrayLike(str, result);\n}\n/**\n * Create a new blob with the given content and the given type.\n * @param {String|ArrayBuffer} part the content to put in the blob. DO NOT use\n * an Uint8Array because the stock browser of android 4 won't accept it (it\n * will be silently converted to a string, \"[object Uint8Array]\").\n *\n * Use only ONE part to build the blob to avoid a memory leak in IE11 / Edge:\n * when a large amount of Array is used to create the Blob, the amount of\n * memory consumed is nearly 100 times the original data amount.\n *\n * @param {String} type the mime type of the blob.\n * @return {Blob} the created blob.\n */ exports.newBlob = function(part, type) {\n    exports.checkSupport(\"blob\");\n    try {\n        // Blob constructor\n        return new Blob([\n            part\n        ], {\n            type: type\n        });\n    } catch (e) {\n        try {\n            // deprecated, browser only, old way\n            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;\n            var builder = new Builder();\n            builder.append(part);\n            return builder.getBlob(type);\n        } catch (e) {\n            // well, fuck ?!\n            throw new Error(\"Bug : can't construct the Blob.\");\n        }\n    }\n};\n/**\n * The identity function.\n * @param {Object} input the input.\n * @return {Object} the same input.\n */ function identity(input) {\n    return input;\n}\n/**\n * Fill in an array with a string.\n * @param {String} str the string to use.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.\n */ function stringToArrayLike(str, array) {\n    for(var i = 0; i < str.length; ++i){\n        array[i] = str.charCodeAt(i) & 0xFF;\n    }\n    return array;\n}\n/**\n * An helper for the function arrayLikeToString.\n * This contains static information and functions that\n * can be optimized by the browser JIT compiler.\n */ var arrayToStringHelper = {\n    /**\n     * Transform an array of int into a string, chunk by chunk.\n     * See the performances notes on arrayLikeToString.\n     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n     * @param {String} type the type of the array.\n     * @param {Integer} chunk the chunk size.\n     * @return {String} the resulting string.\n     * @throws Error if the chunk is too big for the stack.\n     */ stringifyByChunk: function(array, type, chunk) {\n        var result = [], k = 0, len = array.length;\n        // shortcut\n        if (len <= chunk) {\n            return String.fromCharCode.apply(null, array);\n        }\n        while(k < len){\n            if (type === \"array\" || type === \"nodebuffer\") {\n                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));\n            } else {\n                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));\n            }\n            k += chunk;\n        }\n        return result.join(\"\");\n    },\n    /**\n     * Call String.fromCharCode on every item in the array.\n     * This is the naive implementation, which generate A LOT of intermediate string.\n     * This should be used when everything else fail.\n     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n     * @return {String} the result.\n     */ stringifyByChar: function(array) {\n        var resultStr = \"\";\n        for(var i = 0; i < array.length; i++){\n            resultStr += String.fromCharCode(array[i]);\n        }\n        return resultStr;\n    },\n    applyCanBeUsed: {\n        /**\n         * true if the browser accepts to use String.fromCharCode on Uint8Array\n         */ uint8array: function() {\n            try {\n                return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;\n            } catch (e) {\n                return false;\n            }\n        }(),\n        /**\n         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.\n         */ nodebuffer: function() {\n            try {\n                return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;\n            } catch (e) {\n                return false;\n            }\n        }()\n    }\n};\n/**\n * Transform an array-like object to a string.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n * @return {String} the result.\n */ function arrayLikeToString(array) {\n    // Performances notes :\n    // --------------------\n    // String.fromCharCode.apply(null, array) is the fastest, see\n    // see http://jsperf.com/converting-a-uint8array-to-a-string/2\n    // but the stack is limited (and we can get huge arrays !).\n    //\n    // result += String.fromCharCode(array[i]); generate too many strings !\n    //\n    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2\n    // TODO : we now have workers that split the work. Do we still need that ?\n    var chunk = 65536, type = exports.getTypeOf(array), canUseApply = true;\n    if (type === \"uint8array\") {\n        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;\n    } else if (type === \"nodebuffer\") {\n        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;\n    }\n    if (canUseApply) {\n        while(chunk > 1){\n            try {\n                return arrayToStringHelper.stringifyByChunk(array, type, chunk);\n            } catch (e) {\n                chunk = Math.floor(chunk / 2);\n            }\n        }\n    }\n    // no apply or chunk error : slow and painful algorithm\n    // default browser on android 4.*\n    return arrayToStringHelper.stringifyByChar(array);\n}\nexports.applyFromCharCode = arrayLikeToString;\n/**\n * Copy the data from an array-like to an other array-like.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.\n */ function arrayLikeToArrayLike(arrayFrom, arrayTo) {\n    for(var i = 0; i < arrayFrom.length; i++){\n        arrayTo[i] = arrayFrom[i];\n    }\n    return arrayTo;\n}\n// a matrix containing functions to transform everything into everything.\nvar transform = {};\n// string to ?\ntransform[\"string\"] = {\n    \"string\": identity,\n    \"array\": function(input) {\n        return stringToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return transform[\"string\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return stringToArrayLike(input, new Uint8Array(input.length));\n    },\n    \"nodebuffer\": function(input) {\n        return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));\n    }\n};\n// array to ?\ntransform[\"array\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": identity,\n    \"arraybuffer\": function(input) {\n        return new Uint8Array(input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return new Uint8Array(input);\n    },\n    \"nodebuffer\": function(input) {\n        return nodejsUtils.newBufferFrom(input);\n    }\n};\n// arraybuffer to ?\ntransform[\"arraybuffer\"] = {\n    \"string\": function(input) {\n        return arrayLikeToString(new Uint8Array(input));\n    },\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));\n    },\n    \"arraybuffer\": identity,\n    \"uint8array\": function(input) {\n        return new Uint8Array(input);\n    },\n    \"nodebuffer\": function(input) {\n        return nodejsUtils.newBufferFrom(new Uint8Array(input));\n    }\n};\n// uint8array to ?\ntransform[\"uint8array\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return input.buffer;\n    },\n    \"uint8array\": identity,\n    \"nodebuffer\": function(input) {\n        return nodejsUtils.newBufferFrom(input);\n    }\n};\n// nodebuffer to ?\ntransform[\"nodebuffer\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return transform[\"nodebuffer\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return arrayLikeToArrayLike(input, new Uint8Array(input.length));\n    },\n    \"nodebuffer\": identity\n};\n/**\n * Transform an input into any type.\n * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.\n * If no output type is specified, the unmodified input will be returned.\n * @param {String} outputType the output type.\n * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.\n * @throws {Error} an Error if the browser doesn't support the requested output type.\n */ exports.transformTo = function(outputType, input) {\n    if (!input) {\n        // undefined, null, etc\n        // an empty string won't harm.\n        input = \"\";\n    }\n    if (!outputType) {\n        return input;\n    }\n    exports.checkSupport(outputType);\n    var inputType = exports.getTypeOf(input);\n    var result = transform[inputType][outputType](input);\n    return result;\n};\n/**\n * Resolve all relative path components, \".\" and \"..\", in a path. If these relative components\n * traverse above the root then the resulting path will only contain the final path component.\n *\n * All empty components, e.g. \"//\", are removed.\n * @param {string} path A path with / or \\ separators\n * @returns {string} The path with all relative path components resolved.\n */ exports.resolve = function(path) {\n    var parts = path.split(\"/\");\n    var result = [];\n    for(var index = 0; index < parts.length; index++){\n        var part = parts[index];\n        // Allow the first and last component to be empty for trailing slashes.\n        if (part === \".\" || part === \"\" && index !== 0 && index !== parts.length - 1) {\n            continue;\n        } else if (part === \"..\") {\n            result.pop();\n        } else {\n            result.push(part);\n        }\n    }\n    return result.join(\"/\");\n};\n/**\n * Return the type of the input.\n * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.\n * @param {Object} input the input to identify.\n * @return {String} the (lowercase) type of the input.\n */ exports.getTypeOf = function(input) {\n    if (typeof input === \"string\") {\n        return \"string\";\n    }\n    if (Object.prototype.toString.call(input) === \"[object Array]\") {\n        return \"array\";\n    }\n    if (support.nodebuffer && nodejsUtils.isBuffer(input)) {\n        return \"nodebuffer\";\n    }\n    if (support.uint8array && input instanceof Uint8Array) {\n        return \"uint8array\";\n    }\n    if (support.arraybuffer && input instanceof ArrayBuffer) {\n        return \"arraybuffer\";\n    }\n};\n/**\n * Throw an exception if the type is not supported.\n * @param {String} type the type to check.\n * @throws {Error} an Error if the browser doesn't support the requested type.\n */ exports.checkSupport = function(type) {\n    var supported = support[type.toLowerCase()];\n    if (!supported) {\n        throw new Error(type + \" is not supported by this platform\");\n    }\n};\nexports.MAX_VALUE_16BITS = 65535;\nexports.MAX_VALUE_32BITS = -1; // well, \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\" is parsed as -1\n/**\n * Prettify a string read as binary.\n * @param {string} str the string to prettify.\n * @return {string} a pretty string.\n */ exports.pretty = function(str) {\n    var res = \"\", code, i;\n    for(i = 0; i < (str || \"\").length; i++){\n        code = str.charCodeAt(i);\n        res += \"\\\\x\" + (code < 16 ? \"0\" : \"\") + code.toString(16).toUpperCase();\n    }\n    return res;\n};\n/**\n * Defer the call of a function.\n * @param {Function} callback the function to call asynchronously.\n * @param {Array} args the arguments to give to the callback.\n */ exports.delay = function(callback, args, self1) {\n    setImmediate(function() {\n        callback.apply(self1 || null, args || []);\n    });\n};\n/**\n * Extends a prototype with an other, without calling a constructor with\n * side effects. Inspired by nodejs' `utils.inherits`\n * @param {Function} ctor the constructor to augment\n * @param {Function} superCtor the parent constructor to use\n */ exports.inherits = function(ctor, superCtor) {\n    var Obj = function() {};\n    Obj.prototype = superCtor.prototype;\n    ctor.prototype = new Obj();\n};\n/**\n * Merge the objects passed as parameters into a new one.\n * @private\n * @param {...Object} var_args All objects to merge.\n * @return {Object} a new object with the data of the others.\n */ exports.extend = function() {\n    var result = {}, i, attr;\n    for(i = 0; i < arguments.length; i++){\n        for(attr in arguments[i]){\n            if (Object.prototype.hasOwnProperty.call(arguments[i], attr) && typeof result[attr] === \"undefined\") {\n                result[attr] = arguments[i][attr];\n            }\n        }\n    }\n    return result;\n};\n/**\n * Transform arbitrary content into a Promise.\n * @param {String} name a name for the content being processed.\n * @param {Object} inputData the content to process.\n * @param {Boolean} isBinary true if the content is not an unicode string\n * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.\n * @param {Boolean} isBase64 true if the string content is encoded with base64.\n * @return {Promise} a promise in a format usable by JSZip.\n */ exports.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {\n    // if inputData is already a promise, this flatten it.\n    var promise = external.Promise.resolve(inputData).then(function(data) {\n        var isBlob = support.blob && (data instanceof Blob || [\n            \"[object File]\",\n            \"[object Blob]\"\n        ].indexOf(Object.prototype.toString.call(data)) !== -1);\n        if (isBlob && typeof FileReader !== \"undefined\") {\n            return new external.Promise(function(resolve, reject) {\n                var reader = new FileReader();\n                reader.onload = function(e) {\n                    resolve(e.target.result);\n                };\n                reader.onerror = function(e) {\n                    reject(e.target.error);\n                };\n                reader.readAsArrayBuffer(data);\n            });\n        } else {\n            return data;\n        }\n    });\n    return promise.then(function(data) {\n        var dataType = exports.getTypeOf(data);\n        if (!dataType) {\n            return external.Promise.reject(new Error(\"Can't read the data of '\" + name + \"'. Is it \" + \"in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?\"));\n        }\n        // special case : it's way easier to work with Uint8Array than with ArrayBuffer\n        if (dataType === \"arraybuffer\") {\n            data = exports.transformTo(\"uint8array\", data);\n        } else if (dataType === \"string\") {\n            if (isBase64) {\n                data = base64.decode(data);\n            } else if (isBinary) {\n                // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask\n                if (isOptimizedBinaryString !== true) {\n                    // this is a string, not in a base64 format.\n                    // Be sure that this is a correct \"binary string\"\n                    data = string2binary(data);\n                }\n            }\n        }\n        return data;\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsVUFBVUMsbUJBQU9BLENBQUMsNERBQVc7QUFDakMsSUFBSUMsU0FBU0QsbUJBQU9BLENBQUMsMERBQVU7QUFDL0IsSUFBSUUsY0FBY0YsbUJBQU9BLENBQUMsb0VBQWU7QUFDekMsSUFBSUcsV0FBV0gsbUJBQU9BLENBQUMsOERBQVk7QUFDbkNBLG1CQUFPQSxDQUFDLDBGQUFjO0FBR3RCOzs7Ozs7Q0FNQyxHQUNELFNBQVNJLGNBQWNDLEdBQUc7SUFDdEIsSUFBSUMsU0FBUztJQUNiLElBQUlQLFFBQVFRLFVBQVUsRUFBRTtRQUNwQkQsU0FBUyxJQUFJRSxXQUFXSCxJQUFJSSxNQUFNO0lBQ3RDLE9BQU87UUFDSEgsU0FBUyxJQUFJSSxNQUFNTCxJQUFJSSxNQUFNO0lBQ2pDO0lBQ0EsT0FBT0Usa0JBQWtCTixLQUFLQztBQUNsQztBQUVBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNETSxlQUFlLEdBQUcsU0FBU0UsSUFBSSxFQUFFQyxJQUFJO0lBQ2pDSCxRQUFRSSxZQUFZLENBQUM7SUFFckIsSUFBSTtRQUNBLG1CQUFtQjtRQUNuQixPQUFPLElBQUlDLEtBQUs7WUFBQ0g7U0FBSyxFQUFFO1lBQ3BCQyxNQUFNQTtRQUNWO0lBQ0osRUFDQSxPQUFPRyxHQUFHO1FBRU4sSUFBSTtZQUNBLG9DQUFvQztZQUNwQyxJQUFJQyxVQUFVQyxLQUFLQyxXQUFXLElBQUlELEtBQUtFLGlCQUFpQixJQUFJRixLQUFLRyxjQUFjLElBQUlILEtBQUtJLGFBQWE7WUFDckcsSUFBSUMsVUFBVSxJQUFJTjtZQUNsQk0sUUFBUUMsTUFBTSxDQUFDWjtZQUNmLE9BQU9XLFFBQVFFLE9BQU8sQ0FBQ1o7UUFDM0IsRUFDQSxPQUFPRyxHQUFHO1lBRU4sZ0JBQWdCO1lBQ2hCLE1BQU0sSUFBSVUsTUFBTTtRQUNwQjtJQUNKO0FBR0o7QUFDQTs7OztDQUlDLEdBQ0QsU0FB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RyxlQUFlLGFBQWE7WUFDN0MsT0FBTyxJQUFJL0csU0FBU3lHLE9BQU8sQ0FBQyxTQUFVeEMsT0FBTyxFQUFFK0MsTUFBTTtnQkFDakQsSUFBSUMsU0FBUyxJQUFJRjtnQkFFakJFLE9BQU9DLE1BQU0sR0FBRyxTQUFTbkcsQ0FBQztvQkFDdEJrRCxRQUFRbEQsRUFBRW9HLE1BQU0sQ0FBQ2hILE1BQU07Z0JBQzNCO2dCQUNBOEcsT0FBT0csT0FBTyxHQUFHLFNBQVNyRyxDQUFDO29CQUN2QmlHLE9BQU9qRyxFQUFFb0csTUFBTSxDQUFDRSxLQUFLO2dCQUN6QjtnQkFDQUosT0FBT0ssaUJBQWlCLENBQUNYO1lBQzdCO1FBQ0osT0FBTztZQUNILE9BQU9BO1FBQ1g7SUFDSjtJQUVBLE9BQU9ILFFBQVFFLElBQUksQ0FBQyxTQUFTQyxJQUFJO1FBQzdCLElBQUlZLFdBQVc5RyxRQUFRMEMsU0FBUyxDQUFDd0Q7UUFFakMsSUFBSSxDQUFDWSxVQUFVO1lBQ1gsT0FBT3ZILFNBQVN5RyxPQUFPLENBQUNPLE1BQU0sQ0FDMUIsSUFBSXZGLE1BQU0sNkJBQTZCMEUsT0FBTyxjQUNwQztRQUVsQjtRQUNBLCtFQUErRTtRQUMvRSxJQUFJb0IsYUFBYSxlQUFlO1lBQzVCWixPQUFPbEcsUUFBUXFELFdBQVcsQ0FBQyxjQUFjNkM7UUFDN0MsT0FBTyxJQUFJWSxhQUFhLFVBQVU7WUFDOUIsSUFBSWhCLFVBQVU7Z0JBQ1ZJLE9BQU83RyxPQUFPMEgsTUFBTSxDQUFDYjtZQUN6QixPQUNLLElBQUlOLFVBQVU7Z0JBQ2YsZ0dBQWdHO2dCQUNoRyxJQUFJQyw0QkFBNEIsTUFBTTtvQkFDbEMsNENBQTRDO29CQUM1QyxpREFBaUQ7b0JBQ2pESyxPQUFPMUcsY0FBYzBHO2dCQUN6QjtZQUNKO1FBQ0o7UUFDQSxPQUFPQTtJQUNYO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90c2EtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3V0aWxzLmpzPzNkOTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzdXBwb3J0ID0gcmVxdWlyZShcIi4vc3VwcG9ydFwiKTtcbnZhciBiYXNlNjQgPSByZXF1aXJlKFwiLi9iYXNlNjRcIik7XG52YXIgbm9kZWpzVXRpbHMgPSByZXF1aXJlKFwiLi9ub2RlanNVdGlsc1wiKTtcbnZhciBleHRlcm5hbCA9IHJlcXVpcmUoXCIuL2V4dGVybmFsXCIpO1xucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcblxuXG4vKipcbiAqIENvbnZlcnQgYSBzdHJpbmcgdGhhdCBwYXNzIGFzIGEgXCJiaW5hcnkgc3RyaW5nXCI6IGl0IHNob3VsZCByZXByZXNlbnQgYSBieXRlXG4gKiBhcnJheSBidXQgbWF5IGhhdmUgPiAyNTUgY2hhciBjb2Rlcy4gQmUgc3VyZSB0byB0YWtlIG9ubHkgdGhlIGZpcnN0IGJ5dGVcbiAqIGFuZCByZXR1cm5zIHRoZSBieXRlIGFycmF5LlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHRyYW5zZm9ybS5cbiAqIEByZXR1cm4ge0FycmF5fFVpbnQ4QXJyYXl9IHRoZSBzdHJpbmcgaW4gYSBiaW5hcnkgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBzdHJpbmcyYmluYXJ5KHN0cikge1xuICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gbmV3IEFycmF5KHN0ci5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nVG9BcnJheUxpa2Uoc3RyLCByZXN1bHQpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBibG9iIHdpdGggdGhlIGdpdmVuIGNvbnRlbnQgYW5kIHRoZSBnaXZlbiB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ9IHBhcnQgdGhlIGNvbnRlbnQgdG8gcHV0IGluIHRoZSBibG9iLiBETyBOT1QgdXNlXG4gKiBhbiBVaW50OEFycmF5IGJlY2F1c2UgdGhlIHN0b2NrIGJyb3dzZXIgb2YgYW5kcm9pZCA0IHdvbid0IGFjY2VwdCBpdCAoaXRcbiAqIHdpbGwgYmUgc2lsZW50bHkgY29udmVydGVkIHRvIGEgc3RyaW5nLCBcIltvYmplY3QgVWludDhBcnJheV1cIikuXG4gKlxuICogVXNlIG9ubHkgT05FIHBhcnQgdG8gYnVpbGQgdGhlIGJsb2IgdG8gYXZvaWQgYSBtZW1vcnkgbGVhayBpbiBJRTExIC8gRWRnZTpcbiAqIHdoZW4gYSBsYXJnZSBhbW91bnQgb2YgQXJyYXkgaXMgdXNlZCB0byBjcmVhdGUgdGhlIEJsb2IsIHRoZSBhbW91bnQgb2ZcbiAqIG1lbW9yeSBjb25zdW1lZCBpcyBuZWFybHkgMTAwIHRpbWVzIHRoZSBvcmlnaW5hbCBkYXRhIGFtb3VudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgbWltZSB0eXBlIG9mIHRoZSBibG9iLlxuICogQHJldHVybiB7QmxvYn0gdGhlIGNyZWF0ZWQgYmxvYi5cbiAqL1xuZXhwb3J0cy5uZXdCbG9iID0gZnVuY3Rpb24ocGFydCwgdHlwZSkge1xuICAgIGV4cG9ydHMuY2hlY2tTdXBwb3J0KFwiYmxvYlwiKTtcblxuICAgIHRyeSB7XG4gICAgICAgIC8vIEJsb2IgY29uc3RydWN0b3JcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9iKFtwYXJ0XSwge1xuICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gZGVwcmVjYXRlZCwgYnJvd3NlciBvbmx5LCBvbGQgd2F5XG4gICAgICAgICAgICB2YXIgQnVpbGRlciA9IHNlbGYuQmxvYkJ1aWxkZXIgfHwgc2VsZi5XZWJLaXRCbG9iQnVpbGRlciB8fCBzZWxmLk1vekJsb2JCdWlsZGVyIHx8IHNlbGYuTVNCbG9iQnVpbGRlcjtcbiAgICAgICAgICAgIHZhciBidWlsZGVyID0gbmV3IEJ1aWxkZXIoKTtcbiAgICAgICAgICAgIGJ1aWxkZXIuYXBwZW5kKHBhcnQpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZ2V0QmxvYih0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuXG4gICAgICAgICAgICAvLyB3ZWxsLCBmdWNrID8hXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWcgOiBjYW4ndCBjb25zdHJ1Y3QgdGhlIEJsb2IuXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn07XG4vKipcbiAqIFRoZSBpZGVudGl0eSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCB0aGUgaW5wdXQuXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBzYW1lIGlucHV0LlxuICovXG5mdW5jdGlvbiBpZGVudGl0eShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dDtcbn1cblxuLyoqXG4gKiBGaWxsIGluIGFuIGFycmF5IHdpdGggYSBzdHJpbmcuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gdXNlLlxuICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gYXJyYXkgdGhlIGFycmF5IHRvIGZpbGwgaW4gKHdpbGwgYmUgbXV0YXRlZCkuXG4gKiBAcmV0dXJuIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gdGhlIHVwZGF0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXlMaWtlKHN0ciwgYXJyYXkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgICBhcnJheVtpXSA9IHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRjtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEFuIGhlbHBlciBmb3IgdGhlIGZ1bmN0aW9uIGFycmF5TGlrZVRvU3RyaW5nLlxuICogVGhpcyBjb250YWlucyBzdGF0aWMgaW5mb3JtYXRpb24gYW5kIGZ1bmN0aW9ucyB0aGF0XG4gKiBjYW4gYmUgb3B0aW1pemVkIGJ5IHRoZSBicm93c2VyIEpJVCBjb21waWxlci5cbiAqL1xudmFyIGFycmF5VG9TdHJpbmdIZWxwZXIgPSB7XG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIGFuIGFycmF5IG9mIGludCBpbnRvIGEgc3RyaW5nLCBjaHVuayBieSBjaHVuay5cbiAgICAgKiBTZWUgdGhlIHBlcmZvcm1hbmNlcyBub3RlcyBvbiBhcnJheUxpa2VUb1N0cmluZy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheSB0aGUgYXJyYXkgdG8gdHJhbnNmb3JtLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIG9mIHRoZSBhcnJheS5cbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGNodW5rIHRoZSBjaHVuayBzaXplLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHJlc3VsdGluZyBzdHJpbmcuXG4gICAgICogQHRocm93cyBFcnJvciBpZiB0aGUgY2h1bmsgaXMgdG9vIGJpZyBmb3IgdGhlIHN0YWNrLlxuICAgICAqL1xuICAgIHN0cmluZ2lmeUJ5Q2h1bms6IGZ1bmN0aW9uKGFycmF5LCB0eXBlLCBjaHVuaykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW10sIGsgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIC8vIHNob3J0Y3V0XG4gICAgICAgIGlmIChsZW4gPD0gY2h1bmspIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoayA8IGxlbikge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiYXJyYXlcIiB8fCB0eXBlID09PSBcIm5vZGVidWZmZXJcIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyYXkuc2xpY2UoaywgTWF0aC5taW4oayArIGNodW5rLCBsZW4pKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhcnJheS5zdWJhcnJheShrLCBNYXRoLm1pbihrICsgY2h1bmssIGxlbikpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrICs9IGNodW5rO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIlwiKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENhbGwgU3RyaW5nLmZyb21DaGFyQ29kZSBvbiBldmVyeSBpdGVtIGluIHRoZSBhcnJheS5cbiAgICAgKiBUaGlzIGlzIHRoZSBuYWl2ZSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggZ2VuZXJhdGUgQSBMT1Qgb2YgaW50ZXJtZWRpYXRlIHN0cmluZy5cbiAgICAgKiBUaGlzIHNob3VsZCBiZSB1c2VkIHdoZW4gZXZlcnl0aGluZyBlbHNlIGZhaWwuXG4gICAgICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gYXJyYXkgdGhlIGFycmF5IHRvIHRyYW5zZm9ybS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSByZXN1bHQuXG4gICAgICovXG4gICAgc3RyaW5naWZ5QnlDaGFyOiBmdW5jdGlvbihhcnJheSl7XG4gICAgICAgIHZhciByZXN1bHRTdHIgPSBcIlwiO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFycmF5W2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0U3RyO1xuICAgIH0sXG4gICAgYXBwbHlDYW5CZVVzZWQgOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cnVlIGlmIHRoZSBicm93c2VyIGFjY2VwdHMgdG8gdXNlIFN0cmluZy5mcm9tQ2hhckNvZGUgb24gVWludDhBcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgdWludDhhcnJheSA6IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdXBwb3J0LnVpbnQ4YXJyYXkgJiYgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSkubGVuZ3RoID09PSAxO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRydWUgaWYgdGhlIGJyb3dzZXIgYWNjZXB0cyB0byB1c2UgU3RyaW5nLmZyb21DaGFyQ29kZSBvbiBub2RlanMgQnVmZmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgbm9kZWJ1ZmZlciA6IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdXBwb3J0Lm5vZGVidWZmZXIgJiYgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBub2RlanNVdGlscy5hbGxvY0J1ZmZlcigxKSkubGVuZ3RoID09PSAxO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKVxuICAgIH1cbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgc3RyaW5nLlxuICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gYXJyYXkgdGhlIGFycmF5IHRvIHRyYW5zZm9ybS5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlVG9TdHJpbmcoYXJyYXkpIHtcbiAgICAvLyBQZXJmb3JtYW5jZXMgbm90ZXMgOlxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhcnJheSkgaXMgdGhlIGZhc3Rlc3QsIHNlZVxuICAgIC8vIHNlZSBodHRwOi8vanNwZXJmLmNvbS9jb252ZXJ0aW5nLWEtdWludDhhcnJheS10by1hLXN0cmluZy8yXG4gICAgLy8gYnV0IHRoZSBzdGFjayBpcyBsaW1pdGVkIChhbmQgd2UgY2FuIGdldCBodWdlIGFycmF5cyAhKS5cbiAgICAvL1xuICAgIC8vIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFycmF5W2ldKTsgZ2VuZXJhdGUgdG9vIG1hbnkgc3RyaW5ncyAhXG4gICAgLy9cbiAgICAvLyBUaGlzIGNvZGUgaXMgaW5zcGlyZWQgYnkgaHR0cDovL2pzcGVyZi5jb20vYXJyYXlidWZmZXItdG8tc3RyaW5nLWFwcGx5LXBlcmZvcm1hbmNlLzJcbiAgICAvLyBUT0RPIDogd2Ugbm93IGhhdmUgd29ya2VycyB0aGF0IHNwbGl0IHRoZSB3b3JrLiBEbyB3ZSBzdGlsbCBuZWVkIHRoYXQgP1xuICAgIHZhciBjaHVuayA9IDY1NTM2LFxuICAgICAgICB0eXBlID0gZXhwb3J0cy5nZXRUeXBlT2YoYXJyYXkpLFxuICAgICAgICBjYW5Vc2VBcHBseSA9IHRydWU7XG4gICAgaWYgKHR5cGUgPT09IFwidWludDhhcnJheVwiKSB7XG4gICAgICAgIGNhblVzZUFwcGx5ID0gYXJyYXlUb1N0cmluZ0hlbHBlci5hcHBseUNhbkJlVXNlZC51aW50OGFycmF5O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJub2RlYnVmZmVyXCIpIHtcbiAgICAgICAgY2FuVXNlQXBwbHkgPSBhcnJheVRvU3RyaW5nSGVscGVyLmFwcGx5Q2FuQmVVc2VkLm5vZGVidWZmZXI7XG4gICAgfVxuXG4gICAgaWYgKGNhblVzZUFwcGx5KSB7XG4gICAgICAgIHdoaWxlIChjaHVuayA+IDEpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5VG9TdHJpbmdIZWxwZXIuc3RyaW5naWZ5QnlDaHVuayhhcnJheSwgdHlwZSwgY2h1bmspO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNodW5rID0gTWF0aC5mbG9vcihjaHVuayAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gbm8gYXBwbHkgb3IgY2h1bmsgZXJyb3IgOiBzbG93IGFuZCBwYWluZnVsIGFsZ29yaXRobVxuICAgIC8vIGRlZmF1bHQgYnJvd3NlciBvbiBhbmRyb2lkIDQuKlxuICAgIHJldHVybiBhcnJheVRvU3RyaW5nSGVscGVyLnN0cmluZ2lmeUJ5Q2hhcihhcnJheSk7XG59XG5cbmV4cG9ydHMuYXBwbHlGcm9tQ2hhckNvZGUgPSBhcnJheUxpa2VUb1N0cmluZztcblxuXG4vKipcbiAqIENvcHkgdGhlIGRhdGEgZnJvbSBhbiBhcnJheS1saWtlIHRvIGFuIG90aGVyIGFycmF5LWxpa2UuXG4gKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheUZyb20gdGhlIG9yaWdpbiBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5VG8gdGhlIGRlc3RpbmF0aW9uIGFycmF5IHdoaWNoIHdpbGwgYmUgbXV0YXRlZC5cbiAqIEByZXR1cm4ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSB0aGUgdXBkYXRlZCBkZXN0aW5hdGlvbiBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlVG9BcnJheUxpa2UoYXJyYXlGcm9tLCBhcnJheVRvKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheUZyb20ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyYXlUb1tpXSA9IGFycmF5RnJvbVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5VG87XG59XG5cbi8vIGEgbWF0cml4IGNvbnRhaW5pbmcgZnVuY3Rpb25zIHRvIHRyYW5zZm9ybSBldmVyeXRoaW5nIGludG8gZXZlcnl0aGluZy5cbnZhciB0cmFuc2Zvcm0gPSB7fTtcblxuLy8gc3RyaW5nIHRvID9cbnRyYW5zZm9ybVtcInN0cmluZ1wiXSA9IHtcbiAgICBcInN0cmluZ1wiOiBpZGVudGl0eSxcbiAgICBcImFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdUb0FycmF5TGlrZShpbnB1dCwgbmV3IEFycmF5KGlucHV0Lmxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJhcnJheWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtW1wic3RyaW5nXCJdW1widWludDhhcnJheVwiXShpbnB1dCkuYnVmZmVyO1xuICAgIH0sXG4gICAgXCJ1aW50OGFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdUb0FycmF5TGlrZShpbnB1dCwgbmV3IFVpbnQ4QXJyYXkoaW5wdXQubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcIm5vZGVidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1RvQXJyYXlMaWtlKGlucHV0LCBub2RlanNVdGlscy5hbGxvY0J1ZmZlcihpbnB1dC5sZW5ndGgpKTtcbiAgICB9XG59O1xuXG4vLyBhcnJheSB0byA/XG50cmFuc2Zvcm1bXCJhcnJheVwiXSA9IHtcbiAgICBcInN0cmluZ1wiOiBhcnJheUxpa2VUb1N0cmluZyxcbiAgICBcImFycmF5XCI6IGlkZW50aXR5LFxuICAgIFwiYXJyYXlidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChuZXcgVWludDhBcnJheShpbnB1dCkpLmJ1ZmZlcjtcbiAgICB9LFxuICAgIFwidWludDhhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xuICAgIH0sXG4gICAgXCJub2RlYnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBub2RlanNVdGlscy5uZXdCdWZmZXJGcm9tKGlucHV0KTtcbiAgICB9XG59O1xuXG4vLyBhcnJheWJ1ZmZlciB0byA/XG50cmFuc2Zvcm1bXCJhcnJheWJ1ZmZlclwiXSA9IHtcbiAgICBcInN0cmluZ1wiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gYXJyYXlMaWtlVG9TdHJpbmcobmV3IFVpbnQ4QXJyYXkoaW5wdXQpKTtcbiAgICB9LFxuICAgIFwiYXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXlMaWtlKG5ldyBVaW50OEFycmF5KGlucHV0KSwgbmV3IEFycmF5KGlucHV0LmJ5dGVMZW5ndGgpKTtcbiAgICB9LFxuICAgIFwiYXJyYXlidWZmZXJcIjogaWRlbnRpdHksXG4gICAgXCJ1aW50OGFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShpbnB1dCk7XG4gICAgfSxcbiAgICBcIm5vZGVidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVqc1V0aWxzLm5ld0J1ZmZlckZyb20obmV3IFVpbnQ4QXJyYXkoaW5wdXQpKTtcbiAgICB9XG59O1xuXG4vLyB1aW50OGFycmF5IHRvID9cbnRyYW5zZm9ybVtcInVpbnQ4YXJyYXlcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogYXJyYXlMaWtlVG9TdHJpbmcsXG4gICAgXCJhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gYXJyYXlMaWtlVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwiYXJyYXlidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LmJ1ZmZlcjtcbiAgICB9LFxuICAgIFwidWludDhhcnJheVwiOiBpZGVudGl0eSxcbiAgICBcIm5vZGVidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVqc1V0aWxzLm5ld0J1ZmZlckZyb20oaW5wdXQpO1xuICAgIH1cbn07XG5cbi8vIG5vZGVidWZmZXIgdG8gP1xudHJhbnNmb3JtW1wibm9kZWJ1ZmZlclwiXSA9IHtcbiAgICBcInN0cmluZ1wiOiBhcnJheUxpa2VUb1N0cmluZyxcbiAgICBcImFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb0FycmF5TGlrZShpbnB1dCwgbmV3IEFycmF5KGlucHV0Lmxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJhcnJheWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtW1wibm9kZWJ1ZmZlclwiXVtcInVpbnQ4YXJyYXlcIl0oaW5wdXQpLmJ1ZmZlcjtcbiAgICB9LFxuICAgIFwidWludDhhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gYXJyYXlMaWtlVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBVaW50OEFycmF5KGlucHV0Lmxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJub2RlYnVmZmVyXCI6IGlkZW50aXR5XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBpbnB1dCBpbnRvIGFueSB0eXBlLlxuICogVGhlIHN1cHBvcnRlZCBvdXRwdXQgdHlwZSBhcmUgOiBzdHJpbmcsIGFycmF5LCB1aW50OGFycmF5LCBhcnJheWJ1ZmZlciwgbm9kZWJ1ZmZlci5cbiAqIElmIG5vIG91dHB1dCB0eXBlIGlzIHNwZWNpZmllZCwgdGhlIHVubW9kaWZpZWQgaW5wdXQgd2lsbCBiZSByZXR1cm5lZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvdXRwdXRUeXBlIHRoZSBvdXRwdXQgdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBpbnB1dCB0aGUgaW5wdXQgdG8gY29udmVydC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBhbiBFcnJvciBpZiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhlIHJlcXVlc3RlZCBvdXRwdXQgdHlwZS5cbiAqL1xuZXhwb3J0cy50cmFuc2Zvcm1UbyA9IGZ1bmN0aW9uKG91dHB1dFR5cGUsIGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgICAvLyB1bmRlZmluZWQsIG51bGwsIGV0Y1xuICAgICAgICAvLyBhbiBlbXB0eSBzdHJpbmcgd29uJ3QgaGFybS5cbiAgICAgICAgaW5wdXQgPSBcIlwiO1xuICAgIH1cbiAgICBpZiAoIW91dHB1dFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICBleHBvcnRzLmNoZWNrU3VwcG9ydChvdXRwdXRUeXBlKTtcbiAgICB2YXIgaW5wdXRUeXBlID0gZXhwb3J0cy5nZXRUeXBlT2YoaW5wdXQpO1xuICAgIHZhciByZXN1bHQgPSB0cmFuc2Zvcm1baW5wdXRUeXBlXVtvdXRwdXRUeXBlXShpbnB1dCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUmVzb2x2ZSBhbGwgcmVsYXRpdmUgcGF0aCBjb21wb25lbnRzLCBcIi5cIiBhbmQgXCIuLlwiLCBpbiBhIHBhdGguIElmIHRoZXNlIHJlbGF0aXZlIGNvbXBvbmVudHNcbiAqIHRyYXZlcnNlIGFib3ZlIHRoZSByb290IHRoZW4gdGhlIHJlc3VsdGluZyBwYXRoIHdpbGwgb25seSBjb250YWluIHRoZSBmaW5hbCBwYXRoIGNvbXBvbmVudC5cbiAqXG4gKiBBbGwgZW1wdHkgY29tcG9uZW50cywgZS5nLiBcIi8vXCIsIGFyZSByZW1vdmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggQSBwYXRoIHdpdGggLyBvciBcXCBzZXBhcmF0b3JzXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgcGF0aCB3aXRoIGFsbCByZWxhdGl2ZSBwYXRoIGNvbXBvbmVudHMgcmVzb2x2ZWQuXG4gKi9cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHBhcnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2luZGV4XTtcbiAgICAgICAgLy8gQWxsb3cgdGhlIGZpcnN0IGFuZCBsYXN0IGNvbXBvbmVudCB0byBiZSBlbXB0eSBmb3IgdHJhaWxpbmcgc2xhc2hlcy5cbiAgICAgICAgaWYgKHBhcnQgPT09IFwiLlwiIHx8IChwYXJ0ID09PSBcIlwiICYmIGluZGV4ICE9PSAwICYmIGluZGV4ICE9PSBwYXJ0cy5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gXCIuLlwiKSB7XG4gICAgICAgICAgICByZXN1bHQucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIvXCIpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHR5cGUgb2YgdGhlIGlucHV0LlxuICogVGhlIHR5cGUgd2lsbCBiZSBpbiBhIGZvcm1hdCB2YWxpZCBmb3IgSlNaaXAudXRpbHMudHJhbnNmb3JtVG8gOiBzdHJpbmcsIGFycmF5LCB1aW50OGFycmF5LCBhcnJheWJ1ZmZlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCB0aGUgaW5wdXQgdG8gaWRlbnRpZnkuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSAobG93ZXJjYXNlKSB0eXBlIG9mIHRoZSBpbnB1dC5cbiAqL1xuZXhwb3J0cy5nZXRUeXBlT2YgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnQubm9kZWJ1ZmZlciAmJiBub2RlanNVdGlscy5pc0J1ZmZlcihpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIFwibm9kZWJ1ZmZlclwiO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydC51aW50OGFycmF5ICYmIGlucHV0IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICByZXR1cm4gXCJ1aW50OGFycmF5XCI7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0LmFycmF5YnVmZmVyICYmIGlucHV0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFwiYXJyYXlidWZmZXJcIjtcbiAgICB9XG59O1xuXG4vKipcbiAqIFRocm93IGFuIGV4Y2VwdGlvbiBpZiB0aGUgdHlwZSBpcyBub3Qgc3VwcG9ydGVkLlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgdG8gY2hlY2suXG4gKiBAdGhyb3dzIHtFcnJvcn0gYW4gRXJyb3IgaWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSByZXF1ZXN0ZWQgdHlwZS5cbiAqL1xuZXhwb3J0cy5jaGVja1N1cHBvcnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgdmFyIHN1cHBvcnRlZCA9IHN1cHBvcnRbdHlwZS50b0xvd2VyQ2FzZSgpXTtcbiAgICBpZiAoIXN1cHBvcnRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodHlwZSArIFwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBwbGF0Zm9ybVwiKTtcbiAgICB9XG59O1xuXG5leHBvcnRzLk1BWF9WQUxVRV8xNkJJVFMgPSA2NTUzNTtcbmV4cG9ydHMuTUFYX1ZBTFVFXzMyQklUUyA9IC0xOyAvLyB3ZWxsLCBcIlxceEZGXFx4RkZcXHhGRlxceEZGXFx4RkZcXHhGRlxceEZGXFx4RkZcIiBpcyBwYXJzZWQgYXMgLTFcblxuLyoqXG4gKiBQcmV0dGlmeSBhIHN0cmluZyByZWFkIGFzIGJpbmFyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byBwcmV0dGlmeS5cbiAqIEByZXR1cm4ge3N0cmluZ30gYSBwcmV0dHkgc3RyaW5nLlxuICovXG5leHBvcnRzLnByZXR0eSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHZhciByZXMgPSBcIlwiLFxuICAgICAgICBjb2RlLCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCAoc3RyIHx8IFwiXCIpLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgcmVzICs9IFwiXFxcXHhcIiArIChjb2RlIDwgMTYgPyBcIjBcIiA6IFwiXCIpICsgY29kZS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8qKlxuICogRGVmZXIgdGhlIGNhbGwgb2YgYSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRoZSBmdW5jdGlvbiB0byBjYWxsIGFzeW5jaHJvbm91c2x5LlxuICogQHBhcmFtIHtBcnJheX0gYXJncyB0aGUgYXJndW1lbnRzIHRvIGdpdmUgdG8gdGhlIGNhbGxiYWNrLlxuICovXG5leHBvcnRzLmRlbGF5ID0gZnVuY3Rpb24oY2FsbGJhY2ssIGFyZ3MsIHNlbGYpIHtcbiAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjay5hcHBseShzZWxmIHx8IG51bGwsIGFyZ3MgfHwgW10pO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBFeHRlbmRzIGEgcHJvdG90eXBlIHdpdGggYW4gb3RoZXIsIHdpdGhvdXQgY2FsbGluZyBhIGNvbnN0cnVjdG9yIHdpdGhcbiAqIHNpZGUgZWZmZWN0cy4gSW5zcGlyZWQgYnkgbm9kZWpzJyBgdXRpbHMuaW5oZXJpdHNgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdG9yIHRoZSBjb25zdHJ1Y3RvciB0byBhdWdtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdXBlckN0b3IgdGhlIHBhcmVudCBjb25zdHJ1Y3RvciB0byB1c2VcbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IGZ1bmN0aW9uIChjdG9yLCBzdXBlckN0b3IpIHtcbiAgICB2YXIgT2JqID0gZnVuY3Rpb24oKSB7fTtcbiAgICBPYmoucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZTtcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBPYmooKTtcbn07XG5cbi8qKlxuICogTWVyZ2UgdGhlIG9iamVjdHMgcGFzc2VkIGFzIHBhcmFtZXRlcnMgaW50byBhIG5ldyBvbmUuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsuLi5PYmplY3R9IHZhcl9hcmdzIEFsbCBvYmplY3RzIHRvIG1lcmdlLlxuICogQHJldHVybiB7T2JqZWN0fSBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgZGF0YSBvZiB0aGUgb3RoZXJzLlxuICovXG5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXN1bHQgPSB7fSwgaSwgYXR0cjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IC8vIGFyZ3VtZW50cyBpcyBub3QgZW51bWVyYWJsZSBpbiBzb21lIGJyb3dzZXJzXG4gICAgICAgIGZvciAoYXR0ciBpbiBhcmd1bWVudHNbaV0pIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXJndW1lbnRzW2ldLCBhdHRyKSAmJiB0eXBlb2YgcmVzdWx0W2F0dHJdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2F0dHJdID0gYXJndW1lbnRzW2ldW2F0dHJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhcmJpdHJhcnkgY29udGVudCBpbnRvIGEgUHJvbWlzZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGEgbmFtZSBmb3IgdGhlIGNvbnRlbnQgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YSB0aGUgY29udGVudCB0byBwcm9jZXNzLlxuICogQHBhcmFtIHtCb29sZWFufSBpc0JpbmFyeSB0cnVlIGlmIHRoZSBjb250ZW50IGlzIG5vdCBhbiB1bmljb2RlIHN0cmluZ1xuICogQHBhcmFtIHtCb29sZWFufSBpc09wdGltaXplZEJpbmFyeVN0cmluZyB0cnVlIGlmIHRoZSBzdHJpbmcgY29udGVudCBvbmx5IGhhcyBvbmUgYnl0ZSBwZXIgY2hhcmFjdGVyLlxuICogQHBhcmFtIHtCb29sZWFufSBpc0Jhc2U2NCB0cnVlIGlmIHRoZSBzdHJpbmcgY29udGVudCBpcyBlbmNvZGVkIHdpdGggYmFzZTY0LlxuICogQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIGluIGEgZm9ybWF0IHVzYWJsZSBieSBKU1ppcC5cbiAqL1xuZXhwb3J0cy5wcmVwYXJlQ29udGVudCA9IGZ1bmN0aW9uKG5hbWUsIGlucHV0RGF0YSwgaXNCaW5hcnksIGlzT3B0aW1pemVkQmluYXJ5U3RyaW5nLCBpc0Jhc2U2NCkge1xuXG4gICAgLy8gaWYgaW5wdXREYXRhIGlzIGFscmVhZHkgYSBwcm9taXNlLCB0aGlzIGZsYXR0ZW4gaXQuXG4gICAgdmFyIHByb21pc2UgPSBleHRlcm5hbC5Qcm9taXNlLnJlc29sdmUoaW5wdXREYXRhKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcblxuXG4gICAgICAgIHZhciBpc0Jsb2IgPSBzdXBwb3J0LmJsb2IgJiYgKGRhdGEgaW5zdGFuY2VvZiBCbG9iIHx8IFtcIltvYmplY3QgRmlsZV1cIiwgXCJbb2JqZWN0IEJsb2JdXCJdLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpKSAhPT0gLTEpO1xuXG4gICAgICAgIGlmIChpc0Jsb2IgJiYgdHlwZW9mIEZpbGVSZWFkZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZXh0ZXJuYWwuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICAgICAgICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGUudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUudGFyZ2V0LmVycm9yKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgZGF0YVR5cGUgPSBleHBvcnRzLmdldFR5cGVPZihkYXRhKTtcblxuICAgICAgICBpZiAoIWRhdGFUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0ZXJuYWwuUHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgICAgICAgbmV3IEVycm9yKFwiQ2FuJ3QgcmVhZCB0aGUgZGF0YSBvZiAnXCIgKyBuYW1lICsgXCInLiBJcyBpdCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW4gYSBzdXBwb3J0ZWQgSmF2YVNjcmlwdCB0eXBlIChTdHJpbmcsIEJsb2IsIEFycmF5QnVmZmVyLCBldGMpID9cIilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIDogaXQncyB3YXkgZWFzaWVyIHRvIHdvcmsgd2l0aCBVaW50OEFycmF5IHRoYW4gd2l0aCBBcnJheUJ1ZmZlclxuICAgICAgICBpZiAoZGF0YVR5cGUgPT09IFwiYXJyYXlidWZmZXJcIikge1xuICAgICAgICAgICAgZGF0YSA9IGV4cG9ydHMudHJhbnNmb3JtVG8oXCJ1aW50OGFycmF5XCIsIGRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGFUeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoaXNCYXNlNjQpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gYmFzZTY0LmRlY29kZShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQmluYXJ5KSB7XG4gICAgICAgICAgICAgICAgLy8gb3B0aW1pemVkQmluYXJ5U3RyaW5nID09PSB0cnVlIG1lYW5zIHRoYXQgdGhlIGZpbGUgaGFzIGFscmVhZHkgYmVlbiBmaWx0ZXJlZCB3aXRoIGEgMHhGRiBtYXNrXG4gICAgICAgICAgICAgICAgaWYgKGlzT3B0aW1pemVkQmluYXJ5U3RyaW5nICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBzdHJpbmcsIG5vdCBpbiBhIGJhc2U2NCBmb3JtYXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIEJlIHN1cmUgdGhhdCB0aGlzIGlzIGEgY29ycmVjdCBcImJpbmFyeSBzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gc3RyaW5nMmJpbmFyeShkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSk7XG59O1xuIl0sIm5hbWVzIjpbInN1cHBvcnQiLCJyZXF1aXJlIiwiYmFzZTY0Iiwibm9kZWpzVXRpbHMiLCJleHRlcm5hbCIsInN0cmluZzJiaW5hcnkiLCJzdHIiLCJyZXN1bHQiLCJ1aW50OGFycmF5IiwiVWludDhBcnJheSIsImxlbmd0aCIsIkFycmF5Iiwic3RyaW5nVG9BcnJheUxpa2UiLCJleHBvcnRzIiwibmV3QmxvYiIsInBhcnQiLCJ0eXBlIiwiY2hlY2tTdXBwb3J0IiwiQmxvYiIsImUiLCJCdWlsZGVyIiwic2VsZiIsIkJsb2JCdWlsZGVyIiwiV2ViS2l0QmxvYkJ1aWxkZXIiLCJNb3pCbG9iQnVpbGRlciIsIk1TQmxvYkJ1aWxkZXIiLCJidWlsZGVyIiwiYXBwZW5kIiwiZ2V0QmxvYiIsIkVycm9yIiwiaWRlbnRpdHkiLCJpbnB1dCIsImFycmF5IiwiaSIsImNoYXJDb2RlQXQiLCJhcnJheVRvU3RyaW5nSGVscGVyIiwic3RyaW5naWZ5QnlDaHVuayIsImNodW5rIiwiayIsImxlbiIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImFwcGx5IiwicHVzaCIsInNsaWNlIiwiTWF0aCIsIm1pbiIsInN1YmFycmF5Iiwiam9pbiIsInN0cmluZ2lmeUJ5Q2hhciIsInJlc3VsdFN0ciIsImFwcGx5Q2FuQmVVc2VkIiwibm9kZWJ1ZmZlciIsImFsbG9jQnVmZmVyIiwiYXJyYXlMaWtlVG9TdHJpbmciLCJnZXRUeXBlT2YiLCJjYW5Vc2VBcHBseSIsImZsb29yIiwiYXBwbHlGcm9tQ2hhckNvZGUiLCJhcnJheUxpa2VUb0FycmF5TGlrZSIsImFycmF5RnJvbSIsImFycmF5VG8iLCJ0cmFuc2Zvcm0iLCJidWZmZXIiLCJuZXdCdWZmZXJGcm9tIiwiYnl0ZUxlbmd0aCIsInRyYW5zZm9ybVRvIiwib3V0cHV0VHlwZSIsImlucHV0VHlwZSIsInJlc29sdmUiLCJwYXRoIiwicGFydHMiLCJzcGxpdCIsImluZGV4IiwicG9wIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiaXNCdWZmZXIiLCJhcnJheWJ1ZmZlciIsIkFycmF5QnVmZmVyIiwic3VwcG9ydGVkIiwidG9Mb3dlckNhc2UiLCJNQVhfVkFMVUVfMTZCSVRTIiwiTUFYX1ZBTFVFXzMyQklUUyIsInByZXR0eSIsInJlcyIsImNvZGUiLCJ0b1VwcGVyQ2FzZSIsImRlbGF5IiwiY2FsbGJhY2siLCJhcmdzIiwic2V0SW1tZWRpYXRlIiwiaW5oZXJpdHMiLCJjdG9yIiwic3VwZXJDdG9yIiwiT2JqIiwiZXh0ZW5kIiwiYXR0ciIsImFyZ3VtZW50cyIsImhhc093blByb3BlcnR5IiwicHJlcGFyZUNvbnRlbnQiLCJuYW1lIiwiaW5wdXREYXRhIiwiaXNCaW5hcnkiLCJpc09wdGltaXplZEJpbmFyeVN0cmluZyIsImlzQmFzZTY0IiwicHJvbWlzZSIsIlByb21pc2UiLCJ0aGVuIiwiZGF0YSIsImlzQmxvYiIsImJsb2IiLCJpbmRleE9mIiwiRmlsZVJlYWRlciIsInJlamVjdCIsInJlYWRlciIsIm9ubG9hZCIsInRhcmdldCIsIm9uZXJyb3IiLCJlcnJvciIsInJlYWRBc0FycmF5QnVmZmVyIiwiZGF0YVR5cGUiLCJkZWNvZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/zipEntries.js":
/*!**********************************************!*\
  !*** ./node_modules/jszip/lib/zipEntries.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar readerFor = __webpack_require__(/*! ./reader/readerFor */ \"(ssr)/./node_modules/jszip/lib/reader/readerFor.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nvar sig = __webpack_require__(/*! ./signature */ \"(ssr)/./node_modules/jszip/lib/signature.js\");\nvar ZipEntry = __webpack_require__(/*! ./zipEntry */ \"(ssr)/./node_modules/jszip/lib/zipEntry.js\");\nvar support = __webpack_require__(/*! ./support */ \"(ssr)/./node_modules/jszip/lib/support.js\");\n//  class ZipEntries {{{\n/**\n * All the entries in the zip file.\n * @constructor\n * @param {Object} loadOptions Options for loading the stream.\n */ function ZipEntries(loadOptions) {\n    this.files = [];\n    this.loadOptions = loadOptions;\n}\nZipEntries.prototype = {\n    /**\n     * Check that the reader is on the specified signature.\n     * @param {string} expectedSignature the expected signature.\n     * @throws {Error} if it is an other signature.\n     */ checkSignature: function(expectedSignature) {\n        if (!this.reader.readAndCheckSignature(expectedSignature)) {\n            this.reader.index -= 4;\n            var signature = this.reader.readString(4);\n            throw new Error(\"Corrupted zip or bug: unexpected signature \" + \"(\" + utils.pretty(signature) + \", expected \" + utils.pretty(expectedSignature) + \")\");\n        }\n    },\n    /**\n     * Check if the given signature is at the given index.\n     * @param {number} askedIndex the index to check.\n     * @param {string} expectedSignature the signature to expect.\n     * @return {boolean} true if the signature is here, false otherwise.\n     */ isSignature: function(askedIndex, expectedSignature) {\n        var currentIndex = this.reader.index;\n        this.reader.setIndex(askedIndex);\n        var signature = this.reader.readString(4);\n        var result = signature === expectedSignature;\n        this.reader.setIndex(currentIndex);\n        return result;\n    },\n    /**\n     * Read the end of the central directory.\n     */ readBlockEndOfCentral: function() {\n        this.diskNumber = this.reader.readInt(2);\n        this.diskWithCentralDirStart = this.reader.readInt(2);\n        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);\n        this.centralDirRecords = this.reader.readInt(2);\n        this.centralDirSize = this.reader.readInt(4);\n        this.centralDirOffset = this.reader.readInt(4);\n        this.zipCommentLength = this.reader.readInt(2);\n        // warning : the encoding depends of the system locale\n        // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.\n        // On a windows machine, this field is encoded with the localized windows code page.\n        var zipComment = this.reader.readData(this.zipCommentLength);\n        var decodeParamType = support.uint8array ? \"uint8array\" : \"array\";\n        // To get consistent behavior with the generation part, we will assume that\n        // this is utf8 encoded unless specified otherwise.\n        var decodeContent = utils.transformTo(decodeParamType, zipComment);\n        this.zipComment = this.loadOptions.decodeFileName(decodeContent);\n    },\n    /**\n     * Read the end of the Zip 64 central directory.\n     * Not merged with the method readEndOfCentral :\n     * The end of central can coexist with its Zip64 brother,\n     * I don't want to read the wrong number of bytes !\n     */ readBlockZip64EndOfCentral: function() {\n        this.zip64EndOfCentralSize = this.reader.readInt(8);\n        this.reader.skip(4);\n        // this.versionMadeBy = this.reader.readString(2);\n        // this.versionNeeded = this.reader.readInt(2);\n        this.diskNumber = this.reader.readInt(4);\n        this.diskWithCentralDirStart = this.reader.readInt(4);\n        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);\n        this.centralDirRecords = this.reader.readInt(8);\n        this.centralDirSize = this.reader.readInt(8);\n        this.centralDirOffset = this.reader.readInt(8);\n        this.zip64ExtensibleData = {};\n        var extraDataSize = this.zip64EndOfCentralSize - 44, index = 0, extraFieldId, extraFieldLength, extraFieldValue;\n        while(index < extraDataSize){\n            extraFieldId = this.reader.readInt(2);\n            extraFieldLength = this.reader.readInt(4);\n            extraFieldValue = this.reader.readData(extraFieldLength);\n            this.zip64ExtensibleData[extraFieldId] = {\n                id: extraFieldId,\n                length: extraFieldLength,\n                value: extraFieldValue\n            };\n        }\n    },\n    /**\n     * Read the end of the Zip 64 central directory locator.\n     */ readBlockZip64EndOfCentralLocator: function() {\n        this.diskWithZip64CentralDirStart = this.reader.readInt(4);\n        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);\n        this.disksCount = this.reader.readInt(4);\n        if (this.disksCount > 1) {\n            throw new Error(\"Multi-volumes zip are not supported\");\n        }\n    },\n    /**\n     * Read the local files, based on the offset read in the central part.\n     */ readLocalFiles: function() {\n        var i, file;\n        for(i = 0; i < this.files.length; i++){\n            file = this.files[i];\n            this.reader.setIndex(file.localHeaderOffset);\n            this.checkSignature(sig.LOCAL_FILE_HEADER);\n            file.readLocalPart(this.reader);\n            file.handleUTF8();\n            file.processAttributes();\n        }\n    },\n    /**\n     * Read the central directory.\n     */ readCentralDir: function() {\n        var file;\n        this.reader.setIndex(this.centralDirOffset);\n        while(this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)){\n            file = new ZipEntry({\n                zip64: this.zip64\n            }, this.loadOptions);\n            file.readCentralPart(this.reader);\n            this.files.push(file);\n        }\n        if (this.centralDirRecords !== this.files.length) {\n            if (this.centralDirRecords !== 0 && this.files.length === 0) {\n                // We expected some records but couldn't find ANY.\n                // This is really suspicious, as if something went wrong.\n                throw new Error(\"Corrupted zip or bug: expected \" + this.centralDirRecords + \" records in central dir, got \" + this.files.length);\n            } else {\n            // We found some records but not all.\n            // Something is wrong but we got something for the user: no error here.\n            // console.warn(\"expected\", this.centralDirRecords, \"records in central dir, got\", this.files.length);\n            }\n        }\n    },\n    /**\n     * Read the end of central directory.\n     */ readEndOfCentral: function() {\n        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);\n        if (offset < 0) {\n            // Check if the content is a truncated zip or complete garbage.\n            // A \"LOCAL_FILE_HEADER\" is not required at the beginning (auto\n            // extractible zip for example) but it can give a good hint.\n            // If an ajax request was used without responseType, we will also\n            // get unreadable data.\n            var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);\n            if (isGarbage) {\n                throw new Error(\"Can't find end of central directory : is this a zip file ? \" + \"If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html\");\n            } else {\n                throw new Error(\"Corrupted zip: can't find end of central directory\");\n            }\n        }\n        this.reader.setIndex(offset);\n        var endOfCentralDirOffset = offset;\n        this.checkSignature(sig.CENTRAL_DIRECTORY_END);\n        this.readBlockEndOfCentral();\n        /* extract from the zip spec :\n            4)  If one of the fields in the end of central directory\n                record is too small to hold required data, the field\n                should be set to -1 (0xFFFF or 0xFFFFFFFF) and the\n                ZIP64 format record should be created.\n            5)  The end of central directory record and the\n                Zip64 end of central directory locator record must\n                reside on the same disk when splitting or spanning\n                an archive.\n         */ if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {\n            this.zip64 = true;\n            /*\n            Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from\n            the zip file can fit into a 32bits integer. This cannot be solved : JavaScript represents\n            all numbers as 64-bit double precision IEEE 754 floating point numbers.\n            So, we have 53bits for integers and bitwise operations treat everything as 32bits.\n            see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators\n            and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5\n            */ // should look for a zip64 EOCD locator\n            offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n            if (offset < 0) {\n                throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory locator\");\n            }\n            this.reader.setIndex(offset);\n            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n            this.readBlockZip64EndOfCentralLocator();\n            // now the zip64 EOCD record\n            if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {\n                // console.warn(\"ZIP64 end of central directory not where expected.\");\n                this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);\n                if (this.relativeOffsetEndOfZip64CentralDir < 0) {\n                    throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory\");\n                }\n            }\n            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);\n            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);\n            this.readBlockZip64EndOfCentral();\n        }\n        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;\n        if (this.zip64) {\n            expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator\n            expectedEndOfCentralDirOffset += 12 /* should not include the leading 12 bytes */  + this.zip64EndOfCentralSize;\n        }\n        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;\n        if (extraBytes > 0) {\n            // console.warn(extraBytes, \"extra bytes at beginning or within zipfile\");\n            if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {\n            // The offsets seem wrong, but we have something at the specified offset.\n            // So we keep it.\n            } else {\n                // the offset is wrong, update the \"zero\" of the reader\n                // this happens if data has been prepended (crx files for example)\n                this.reader.zero = extraBytes;\n            }\n        } else if (extraBytes < 0) {\n            throw new Error(\"Corrupted zip: missing \" + Math.abs(extraBytes) + \" bytes.\");\n        }\n    },\n    prepareReader: function(data) {\n        this.reader = readerFor(data);\n    },\n    /**\n     * Read a zip file and create ZipEntries.\n     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.\n     */ load: function(data) {\n        this.prepareReader(data);\n        this.readEndOfCentral();\n        this.readCentralDir();\n        this.readLocalFiles();\n    }\n};\n// }}} end of ZipEntries\nmodule.exports = ZipEntries;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3ppcEVudHJpZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxZQUFZQyxtQkFBT0EsQ0FBQyw4RUFBb0I7QUFDNUMsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUMsd0RBQVM7QUFDN0IsSUFBSUUsTUFBTUYsbUJBQU9BLENBQUMsZ0VBQWE7QUFDL0IsSUFBSUcsV0FBV0gsbUJBQU9BLENBQUMsOERBQVk7QUFDbkMsSUFBSUksVUFBVUosbUJBQU9BLENBQUMsNERBQVc7QUFDakMsd0JBQXdCO0FBQ3hCOzs7O0NBSUMsR0FDRCxTQUFTSyxXQUFXQyxXQUFXO0lBQzNCLElBQUksQ0FBQ0MsS0FBSyxHQUFHLEVBQUU7SUFDZixJQUFJLENBQUNELFdBQVcsR0FBR0E7QUFDdkI7QUFDQUQsV0FBV0csU0FBUyxHQUFHO0lBQ25COzs7O0tBSUMsR0FDREMsZ0JBQWdCLFNBQVNDLGlCQUFpQjtRQUN0QyxJQUFJLENBQUMsSUFBSSxDQUFDQyxNQUFNLENBQUNDLHFCQUFxQixDQUFDRixvQkFBb0I7WUFDdkQsSUFBSSxDQUFDQyxNQUFNLENBQUNFLEtBQUssSUFBSTtZQUNyQixJQUFJQyxZQUFZLElBQUksQ0FBQ0gsTUFBTSxDQUFDSSxVQUFVLENBQUM7WUFDdkMsTUFBTSxJQUFJQyxNQUFNLGdEQUFnRCxNQUFNZixNQUFNZ0IsTUFBTSxDQUFDSCxhQUFhLGdCQUFnQmIsTUFBTWdCLE1BQU0sQ0FBQ1AscUJBQXFCO1FBQ3RKO0lBQ0o7SUFDQTs7Ozs7S0FLQyxHQUNEUSxhQUFhLFNBQVNDLFVBQVUsRUFBRVQsaUJBQWlCO1FBQy9DLElBQUlVLGVBQWUsSUFBSSxDQUFDVCxNQUFNLENBQUNFLEtBQUs7UUFDcEMsSUFBSSxDQUFDRixNQUFNLENBQUNVLFFBQVEsQ0FBQ0Y7UUFDckIsSUFBSUwsWUFBWSxJQUFJLENBQUNILE1BQU0sQ0FBQ0ksVUFBVSxDQUFDO1FBQ3ZDLElBQUlPLFNBQVNSLGNBQWNKO1FBQzNCLElB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LGdDQUFnQztZQUNyRUEsaUNBQWlDLEdBQUcsMkNBQTJDLE1BQUssSUFBSSxDQUFDckMscUJBQXFCO1FBQ2xIO1FBRUEsSUFBSXNDLGFBQWFOLHdCQUF3Qks7UUFFekMsSUFBSUMsYUFBYSxHQUFHO1lBQ2hCLDBFQUEwRTtZQUMxRSxJQUFJLElBQUksQ0FBQzVELFdBQVcsQ0FBQ3NELHVCQUF1QnRFLElBQUk2RCxtQkFBbUIsR0FBRztZQUNsRSx5RUFBeUU7WUFDekUsa0JBQWtCO1lBQ3RCLE9BQU87Z0JBQ0gsdURBQXVEO2dCQUN2RCxrRUFBa0U7Z0JBQ2xFLElBQUksQ0FBQ3BELE1BQU0sQ0FBQ29FLElBQUksR0FBR0Q7WUFDdkI7UUFDSixPQUFPLElBQUlBLGFBQWEsR0FBRztZQUN2QixNQUFNLElBQUk5RCxNQUFNLDRCQUE0QmdFLEtBQUtDLEdBQUcsQ0FBQ0gsY0FBYztRQUN2RTtJQUNKO0lBQ0FJLGVBQWUsU0FBU0MsSUFBSTtRQUN4QixJQUFJLENBQUN4RSxNQUFNLEdBQUdaLFVBQVVvRjtJQUM1QjtJQUNBOzs7S0FHQyxHQUNEQyxNQUFNLFNBQVNELElBQUk7UUFDZixJQUFJLENBQUNELGFBQWEsQ0FBQ0M7UUFDbkIsSUFBSSxDQUFDaEIsZ0JBQWdCO1FBQ3JCLElBQUksQ0FBQ0wsY0FBYztRQUNuQixJQUFJLENBQUNSLGNBQWM7SUFDdkI7QUFDSjtBQUNBLHdCQUF3QjtBQUN4QitCLE9BQU9DLE9BQU8sR0FBR2pGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHNhLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2pzemlwL2xpYi96aXBFbnRyaWVzLmpzP2FlZWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcmVhZGVyRm9yID0gcmVxdWlyZShcIi4vcmVhZGVyL3JlYWRlckZvclwiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIHNpZyA9IHJlcXVpcmUoXCIuL3NpZ25hdHVyZVwiKTtcbnZhciBaaXBFbnRyeSA9IHJlcXVpcmUoXCIuL3ppcEVudHJ5XCIpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKFwiLi9zdXBwb3J0XCIpO1xuLy8gIGNsYXNzIFppcEVudHJpZXMge3t7XG4vKipcbiAqIEFsbCB0aGUgZW50cmllcyBpbiB0aGUgemlwIGZpbGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBsb2FkT3B0aW9ucyBPcHRpb25zIGZvciBsb2FkaW5nIHRoZSBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIFppcEVudHJpZXMobG9hZE9wdGlvbnMpIHtcbiAgICB0aGlzLmZpbGVzID0gW107XG4gICAgdGhpcy5sb2FkT3B0aW9ucyA9IGxvYWRPcHRpb25zO1xufVxuWmlwRW50cmllcy5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCB0aGUgcmVhZGVyIGlzIG9uIHRoZSBzcGVjaWZpZWQgc2lnbmF0dXJlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHBlY3RlZFNpZ25hdHVyZSB0aGUgZXhwZWN0ZWQgc2lnbmF0dXJlLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiBpdCBpcyBhbiBvdGhlciBzaWduYXR1cmUuXG4gICAgICovXG4gICAgY2hlY2tTaWduYXR1cmU6IGZ1bmN0aW9uKGV4cGVjdGVkU2lnbmF0dXJlKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWFkZXIucmVhZEFuZENoZWNrU2lnbmF0dXJlKGV4cGVjdGVkU2lnbmF0dXJlKSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkZXIuaW5kZXggLT0gNDtcbiAgICAgICAgICAgIHZhciBzaWduYXR1cmUgPSB0aGlzLnJlYWRlci5yZWFkU3RyaW5nKDQpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcCBvciBidWc6IHVuZXhwZWN0ZWQgc2lnbmF0dXJlIFwiICsgXCIoXCIgKyB1dGlscy5wcmV0dHkoc2lnbmF0dXJlKSArIFwiLCBleHBlY3RlZCBcIiArIHV0aWxzLnByZXR0eShleHBlY3RlZFNpZ25hdHVyZSkgKyBcIilcIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBnaXZlbiBzaWduYXR1cmUgaXMgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhc2tlZEluZGV4IHRoZSBpbmRleCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWRTaWduYXR1cmUgdGhlIHNpZ25hdHVyZSB0byBleHBlY3QuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2lnbmF0dXJlIGlzIGhlcmUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc1NpZ25hdHVyZTogZnVuY3Rpb24oYXNrZWRJbmRleCwgZXhwZWN0ZWRTaWduYXR1cmUpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IHRoaXMucmVhZGVyLmluZGV4O1xuICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChhc2tlZEluZGV4KTtcbiAgICAgICAgdmFyIHNpZ25hdHVyZSA9IHRoaXMucmVhZGVyLnJlYWRTdHJpbmcoNCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBzaWduYXR1cmUgPT09IGV4cGVjdGVkU2lnbmF0dXJlO1xuICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChjdXJyZW50SW5kZXgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgZW5kIG9mIHRoZSBjZW50cmFsIGRpcmVjdG9yeS5cbiAgICAgKi9cbiAgICByZWFkQmxvY2tFbmRPZkNlbnRyYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRpc2tOdW1iZXIgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmRpc2tXaXRoQ2VudHJhbERpclN0YXJ0ID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyUmVjb3Jkc09uVGhpc0Rpc2sgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyU2l6ZSA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpck9mZnNldCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG5cbiAgICAgICAgdGhpcy56aXBDb21tZW50TGVuZ3RoID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgLy8gd2FybmluZyA6IHRoZSBlbmNvZGluZyBkZXBlbmRzIG9mIHRoZSBzeXN0ZW0gbG9jYWxlXG4gICAgICAgIC8vIE9uIGEgbGludXggbWFjaGluZSB3aXRoIExBTkc9ZW5fVVMudXRmOCwgdGhpcyBmaWVsZCBpcyB1dGY4IGVuY29kZWQuXG4gICAgICAgIC8vIE9uIGEgd2luZG93cyBtYWNoaW5lLCB0aGlzIGZpZWxkIGlzIGVuY29kZWQgd2l0aCB0aGUgbG9jYWxpemVkIHdpbmRvd3MgY29kZSBwYWdlLlxuICAgICAgICB2YXIgemlwQ29tbWVudCA9IHRoaXMucmVhZGVyLnJlYWREYXRhKHRoaXMuemlwQ29tbWVudExlbmd0aCk7XG4gICAgICAgIHZhciBkZWNvZGVQYXJhbVR5cGUgPSBzdXBwb3J0LnVpbnQ4YXJyYXkgPyBcInVpbnQ4YXJyYXlcIiA6IFwiYXJyYXlcIjtcbiAgICAgICAgLy8gVG8gZ2V0IGNvbnNpc3RlbnQgYmVoYXZpb3Igd2l0aCB0aGUgZ2VuZXJhdGlvbiBwYXJ0LCB3ZSB3aWxsIGFzc3VtZSB0aGF0XG4gICAgICAgIC8vIHRoaXMgaXMgdXRmOCBlbmNvZGVkIHVubGVzcyBzcGVjaWZpZWQgb3RoZXJ3aXNlLlxuICAgICAgICB2YXIgZGVjb2RlQ29udGVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKGRlY29kZVBhcmFtVHlwZSwgemlwQ29tbWVudCk7XG4gICAgICAgIHRoaXMuemlwQ29tbWVudCA9IHRoaXMubG9hZE9wdGlvbnMuZGVjb2RlRmlsZU5hbWUoZGVjb2RlQ29udGVudCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBlbmQgb2YgdGhlIFppcCA2NCBjZW50cmFsIGRpcmVjdG9yeS5cbiAgICAgKiBOb3QgbWVyZ2VkIHdpdGggdGhlIG1ldGhvZCByZWFkRW5kT2ZDZW50cmFsIDpcbiAgICAgKiBUaGUgZW5kIG9mIGNlbnRyYWwgY2FuIGNvZXhpc3Qgd2l0aCBpdHMgWmlwNjQgYnJvdGhlcixcbiAgICAgKiBJIGRvbid0IHdhbnQgdG8gcmVhZCB0aGUgd3JvbmcgbnVtYmVyIG9mIGJ5dGVzICFcbiAgICAgKi9cbiAgICByZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuemlwNjRFbmRPZkNlbnRyYWxTaXplID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy5yZWFkZXIuc2tpcCg0KTtcbiAgICAgICAgLy8gdGhpcy52ZXJzaW9uTWFkZUJ5ID0gdGhpcy5yZWFkZXIucmVhZFN0cmluZygyKTtcbiAgICAgICAgLy8gdGhpcy52ZXJzaW9uTmVlZGVkID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5kaXNrTnVtYmVyID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5kaXNrV2l0aENlbnRyYWxEaXJTdGFydCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclJlY29yZHNPblRoaXNEaXNrID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyUmVjb3JkcyA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclNpemUgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuXG4gICAgICAgIHRoaXMuemlwNjRFeHRlbnNpYmxlRGF0YSA9IHt9O1xuICAgICAgICB2YXIgZXh0cmFEYXRhU2l6ZSA9IHRoaXMuemlwNjRFbmRPZkNlbnRyYWxTaXplIC0gNDQsXG4gICAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgICBleHRyYUZpZWxkSWQsXG4gICAgICAgICAgICBleHRyYUZpZWxkTGVuZ3RoLFxuICAgICAgICAgICAgZXh0cmFGaWVsZFZhbHVlO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBleHRyYURhdGFTaXplKSB7XG4gICAgICAgICAgICBleHRyYUZpZWxkSWQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICAgICAgZXh0cmFGaWVsZExlbmd0aCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgICAgICBleHRyYUZpZWxkVmFsdWUgPSB0aGlzLnJlYWRlci5yZWFkRGF0YShleHRyYUZpZWxkTGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuemlwNjRFeHRlbnNpYmxlRGF0YVtleHRyYUZpZWxkSWRdID0ge1xuICAgICAgICAgICAgICAgIGlkOiBleHRyYUZpZWxkSWQsXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBleHRyYUZpZWxkTGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBleHRyYUZpZWxkVmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGVuZCBvZiB0aGUgWmlwIDY0IGNlbnRyYWwgZGlyZWN0b3J5IGxvY2F0b3IuXG4gICAgICovXG4gICAgcmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWxMb2NhdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kaXNrV2l0aFppcDY0Q2VudHJhbERpclN0YXJ0ID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy5kaXNrc0NvdW50ID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgaWYgKHRoaXMuZGlza3NDb3VudCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11bHRpLXZvbHVtZXMgemlwIGFyZSBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBsb2NhbCBmaWxlcywgYmFzZWQgb24gdGhlIG9mZnNldCByZWFkIGluIHRoZSBjZW50cmFsIHBhcnQuXG4gICAgICovXG4gICAgcmVhZExvY2FsRmlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaSwgZmlsZTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZpbGUgPSB0aGlzLmZpbGVzW2ldO1xuICAgICAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgoZmlsZS5sb2NhbEhlYWRlck9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrU2lnbmF0dXJlKHNpZy5MT0NBTF9GSUxFX0hFQURFUik7XG4gICAgICAgICAgICBmaWxlLnJlYWRMb2NhbFBhcnQodGhpcy5yZWFkZXIpO1xuICAgICAgICAgICAgZmlsZS5oYW5kbGVVVEY4KCk7XG4gICAgICAgICAgICBmaWxlLnByb2Nlc3NBdHRyaWJ1dGVzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGNlbnRyYWwgZGlyZWN0b3J5LlxuICAgICAqL1xuICAgIHJlYWRDZW50cmFsRGlyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZpbGU7XG5cbiAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgodGhpcy5jZW50cmFsRGlyT2Zmc2V0KTtcbiAgICAgICAgd2hpbGUgKHRoaXMucmVhZGVyLnJlYWRBbmRDaGVja1NpZ25hdHVyZShzaWcuQ0VOVFJBTF9GSUxFX0hFQURFUikpIHtcbiAgICAgICAgICAgIGZpbGUgPSBuZXcgWmlwRW50cnkoe1xuICAgICAgICAgICAgICAgIHppcDY0OiB0aGlzLnppcDY0XG4gICAgICAgICAgICB9LCB0aGlzLmxvYWRPcHRpb25zKTtcbiAgICAgICAgICAgIGZpbGUucmVhZENlbnRyYWxQYXJ0KHRoaXMucmVhZGVyKTtcbiAgICAgICAgICAgIHRoaXMuZmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNlbnRyYWxEaXJSZWNvcmRzICE9PSB0aGlzLmZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2VudHJhbERpclJlY29yZHMgIT09IDAgJiYgdGhpcy5maWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBleHBlY3RlZCBzb21lIHJlY29yZHMgYnV0IGNvdWxkbid0IGZpbmQgQU5ZLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgcmVhbGx5IHN1c3BpY2lvdXMsIGFzIGlmIHNvbWV0aGluZyB3ZW50IHdyb25nLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgb3IgYnVnOiBleHBlY3RlZCBcIiArIHRoaXMuY2VudHJhbERpclJlY29yZHMgKyBcIiByZWNvcmRzIGluIGNlbnRyYWwgZGlyLCBnb3QgXCIgKyB0aGlzLmZpbGVzLmxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIHNvbWUgcmVjb3JkcyBidXQgbm90IGFsbC5cbiAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcgaXMgd3JvbmcgYnV0IHdlIGdvdCBzb21ldGhpbmcgZm9yIHRoZSB1c2VyOiBubyBlcnJvciBoZXJlLlxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybihcImV4cGVjdGVkXCIsIHRoaXMuY2VudHJhbERpclJlY29yZHMsIFwicmVjb3JkcyBpbiBjZW50cmFsIGRpciwgZ290XCIsIHRoaXMuZmlsZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5LlxuICAgICAqL1xuICAgIHJlYWRFbmRPZkNlbnRyYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5yZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmUoc2lnLkNFTlRSQUxfRElSRUNUT1JZX0VORCk7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGVudCBpcyBhIHRydW5jYXRlZCB6aXAgb3IgY29tcGxldGUgZ2FyYmFnZS5cbiAgICAgICAgICAgIC8vIEEgXCJMT0NBTF9GSUxFX0hFQURFUlwiIGlzIG5vdCByZXF1aXJlZCBhdCB0aGUgYmVnaW5uaW5nIChhdXRvXG4gICAgICAgICAgICAvLyBleHRyYWN0aWJsZSB6aXAgZm9yIGV4YW1wbGUpIGJ1dCBpdCBjYW4gZ2l2ZSBhIGdvb2QgaGludC5cbiAgICAgICAgICAgIC8vIElmIGFuIGFqYXggcmVxdWVzdCB3YXMgdXNlZCB3aXRob3V0IHJlc3BvbnNlVHlwZSwgd2Ugd2lsbCBhbHNvXG4gICAgICAgICAgICAvLyBnZXQgdW5yZWFkYWJsZSBkYXRhLlxuICAgICAgICAgICAgdmFyIGlzR2FyYmFnZSA9ICF0aGlzLmlzU2lnbmF0dXJlKDAsIHNpZy5MT0NBTF9GSUxFX0hFQURFUik7XG5cbiAgICAgICAgICAgIGlmIChpc0dhcmJhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBmaW5kIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSA6IGlzIHRoaXMgYSB6aXAgZmlsZSA/IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJJZiBpdCBpcywgc2VlIGh0dHBzOi8vc3R1ay5naXRodWIuaW8vanN6aXAvZG9jdW1lbnRhdGlvbi9ob3d0by9yZWFkX3ppcC5odG1sXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwOiBjYW4ndCBmaW5kIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KG9mZnNldCk7XG4gICAgICAgIHZhciBlbmRPZkNlbnRyYWxEaXJPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMuY2hlY2tTaWduYXR1cmUoc2lnLkNFTlRSQUxfRElSRUNUT1JZX0VORCk7XG4gICAgICAgIHRoaXMucmVhZEJsb2NrRW5kT2ZDZW50cmFsKCk7XG5cblxuICAgICAgICAvKiBleHRyYWN0IGZyb20gdGhlIHppcCBzcGVjIDpcbiAgICAgICAgICAgIDQpICBJZiBvbmUgb2YgdGhlIGZpZWxkcyBpbiB0aGUgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5XG4gICAgICAgICAgICAgICAgcmVjb3JkIGlzIHRvbyBzbWFsbCB0byBob2xkIHJlcXVpcmVkIGRhdGEsIHRoZSBmaWVsZFxuICAgICAgICAgICAgICAgIHNob3VsZCBiZSBzZXQgdG8gLTEgKDB4RkZGRiBvciAweEZGRkZGRkZGKSBhbmQgdGhlXG4gICAgICAgICAgICAgICAgWklQNjQgZm9ybWF0IHJlY29yZCBzaG91bGQgYmUgY3JlYXRlZC5cbiAgICAgICAgICAgIDUpICBUaGUgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IHJlY29yZCBhbmQgdGhlXG4gICAgICAgICAgICAgICAgWmlwNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IGxvY2F0b3IgcmVjb3JkIG11c3RcbiAgICAgICAgICAgICAgICByZXNpZGUgb24gdGhlIHNhbWUgZGlzayB3aGVuIHNwbGl0dGluZyBvciBzcGFubmluZ1xuICAgICAgICAgICAgICAgIGFuIGFyY2hpdmUuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5kaXNrTnVtYmVyID09PSB1dGlscy5NQVhfVkFMVUVfMTZCSVRTIHx8IHRoaXMuZGlza1dpdGhDZW50cmFsRGlyU3RhcnQgPT09IHV0aWxzLk1BWF9WQUxVRV8xNkJJVFMgfHwgdGhpcy5jZW50cmFsRGlyUmVjb3Jkc09uVGhpc0Rpc2sgPT09IHV0aWxzLk1BWF9WQUxVRV8xNkJJVFMgfHwgdGhpcy5jZW50cmFsRGlyUmVjb3JkcyA9PT0gdXRpbHMuTUFYX1ZBTFVFXzE2QklUUyB8fCB0aGlzLmNlbnRyYWxEaXJTaXplID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTIHx8IHRoaXMuY2VudHJhbERpck9mZnNldCA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUykge1xuICAgICAgICAgICAgdGhpcy56aXA2NCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBXYXJuaW5nIDogdGhlIHppcDY0IGV4dGVuc2lvbiBpcyBzdXBwb3J0ZWQsIGJ1dCBPTkxZIGlmIHRoZSA2NGJpdHMgaW50ZWdlciByZWFkIGZyb21cbiAgICAgICAgICAgIHRoZSB6aXAgZmlsZSBjYW4gZml0IGludG8gYSAzMmJpdHMgaW50ZWdlci4gVGhpcyBjYW5ub3QgYmUgc29sdmVkIDogSmF2YVNjcmlwdCByZXByZXNlbnRzXG4gICAgICAgICAgICBhbGwgbnVtYmVycyBhcyA2NC1iaXQgZG91YmxlIHByZWNpc2lvbiBJRUVFIDc1NCBmbG9hdGluZyBwb2ludCBudW1iZXJzLlxuICAgICAgICAgICAgU28sIHdlIGhhdmUgNTNiaXRzIGZvciBpbnRlZ2VycyBhbmQgYml0d2lzZSBvcGVyYXRpb25zIHRyZWF0IGV2ZXJ5dGhpbmcgYXMgMzJiaXRzLlxuICAgICAgICAgICAgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL0JpdHdpc2VfT3BlcmF0b3JzXG4gICAgICAgICAgICBhbmQgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL3B1YmxpY2F0aW9ucy9maWxlcy9FQ01BLVNUL0VDTUEtMjYyLnBkZiBzZWN0aW9uIDguNVxuICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgLy8gc2hvdWxkIGxvb2sgZm9yIGEgemlwNjQgRU9DRCBsb2NhdG9yXG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnJlYWRlci5sYXN0SW5kZXhPZlNpZ25hdHVyZShzaWcuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfTE9DQVRPUik7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXA6IGNhbid0IGZpbmQgdGhlIFpJUDY0IGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSBsb2NhdG9yXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgob2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tTaWduYXR1cmUoc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0xPQ0FUT1IpO1xuICAgICAgICAgICAgdGhpcy5yZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbExvY2F0b3IoKTtcblxuICAgICAgICAgICAgLy8gbm93IHRoZSB6aXA2NCBFT0NEIHJlY29yZFxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzU2lnbmF0dXJlKHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciwgc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oXCJaSVA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3Rvcnkgbm90IHdoZXJlIGV4cGVjdGVkLlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0RW5kT2ZaaXA2NENlbnRyYWxEaXIgPSB0aGlzLnJlYWRlci5sYXN0SW5kZXhPZlNpZ25hdHVyZShzaWcuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfRU5EKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwOiBjYW4ndCBmaW5kIHRoZSBaSVA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgodGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tTaWduYXR1cmUoc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCk7XG4gICAgICAgICAgICB0aGlzLnJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQgPSB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgKyB0aGlzLmNlbnRyYWxEaXJTaXplO1xuICAgICAgICBpZiAodGhpcy56aXA2NCkge1xuICAgICAgICAgICAgZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQgKz0gMjA7IC8vIGVuZCBvZiBjZW50cmFsIGRpciA2NCBsb2NhdG9yXG4gICAgICAgICAgICBleHBlY3RlZEVuZE9mQ2VudHJhbERpck9mZnNldCArPSAxMiAvKiBzaG91bGQgbm90IGluY2x1ZGUgdGhlIGxlYWRpbmcgMTIgYnl0ZXMgKi8gKyB0aGlzLnppcDY0RW5kT2ZDZW50cmFsU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleHRyYUJ5dGVzID0gZW5kT2ZDZW50cmFsRGlyT2Zmc2V0IC0gZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQ7XG5cbiAgICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAwKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oZXh0cmFCeXRlcywgXCJleHRyYSBieXRlcyBhdCBiZWdpbm5pbmcgb3Igd2l0aGluIHppcGZpbGVcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1NpZ25hdHVyZShlbmRPZkNlbnRyYWxEaXJPZmZzZXQsIHNpZy5DRU5UUkFMX0ZJTEVfSEVBREVSKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBvZmZzZXRzIHNlZW0gd3JvbmcsIGJ1dCB3ZSBoYXZlIHNvbWV0aGluZyBhdCB0aGUgc3BlY2lmaWVkIG9mZnNldC5cbiAgICAgICAgICAgICAgICAvLyBTb+KApiB3ZSBrZWVwIGl0LlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgb2Zmc2V0IGlzIHdyb25nLCB1cGRhdGUgdGhlIFwiemVyb1wiIG9mIHRoZSByZWFkZXJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGhhcHBlbnMgaWYgZGF0YSBoYXMgYmVlbiBwcmVwZW5kZWQgKGNyeCBmaWxlcyBmb3IgZXhhbXBsZSlcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRlci56ZXJvID0gZXh0cmFCeXRlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChleHRyYUJ5dGVzIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcDogbWlzc2luZyBcIiArIE1hdGguYWJzKGV4dHJhQnl0ZXMpICsgXCIgYnl0ZXMuXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBwcmVwYXJlUmVhZGVyOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMucmVhZGVyID0gcmVhZGVyRm9yKGRhdGEpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCBhIHppcCBmaWxlIGFuZCBjcmVhdGUgWmlwRW50cmllcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gZGF0YSB0aGUgYmluYXJ5IHN0cmluZyByZXByZXNlbnRpbmcgYSB6aXAgZmlsZS5cbiAgICAgKi9cbiAgICBsb2FkOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMucHJlcGFyZVJlYWRlcihkYXRhKTtcbiAgICAgICAgdGhpcy5yZWFkRW5kT2ZDZW50cmFsKCk7XG4gICAgICAgIHRoaXMucmVhZENlbnRyYWxEaXIoKTtcbiAgICAgICAgdGhpcy5yZWFkTG9jYWxGaWxlcygpO1xuICAgIH1cbn07XG4vLyB9fX0gZW5kIG9mIFppcEVudHJpZXNcbm1vZHVsZS5leHBvcnRzID0gWmlwRW50cmllcztcbiJdLCJuYW1lcyI6WyJyZWFkZXJGb3IiLCJyZXF1aXJlIiwidXRpbHMiLCJzaWciLCJaaXBFbnRyeSIsInN1cHBvcnQiLCJaaXBFbnRyaWVzIiwibG9hZE9wdGlvbnMiLCJmaWxlcyIsInByb3RvdHlwZSIsImNoZWNrU2lnbmF0dXJlIiwiZXhwZWN0ZWRTaWduYXR1cmUiLCJyZWFkZXIiLCJyZWFkQW5kQ2hlY2tTaWduYXR1cmUiLCJpbmRleCIsInNpZ25hdHVyZSIsInJlYWRTdHJpbmciLCJFcnJvciIsInByZXR0eSIsImlzU2lnbmF0dXJlIiwiYXNrZWRJbmRleCIsImN1cnJlbnRJbmRleCIsInNldEluZGV4IiwicmVzdWx0IiwicmVhZEJsb2NrRW5kT2ZDZW50cmFsIiwiZGlza051bWJlciIsInJlYWRJbnQiLCJkaXNrV2l0aENlbnRyYWxEaXJTdGFydCIsImNlbnRyYWxEaXJSZWNvcmRzT25UaGlzRGlzayIsImNlbnRyYWxEaXJSZWNvcmRzIiwiY2VudHJhbERpclNpemUiLCJjZW50cmFsRGlyT2Zmc2V0IiwiemlwQ29tbWVudExlbmd0aCIsInppcENvbW1lbnQiLCJyZWFkRGF0YSIsImRlY29kZVBhcmFtVHlwZSIsInVpbnQ4YXJyYXkiLCJkZWNvZGVDb250ZW50IiwidHJhbnNmb3JtVG8iLCJkZWNvZGVGaWxlTmFtZSIsInJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsIiwiemlwNjRFbmRPZkNlbnRyYWxTaXplIiwic2tpcCIsInppcDY0RXh0ZW5zaWJsZURhdGEiLCJleHRyYURhdGFTaXplIiwiZXh0cmFGaWVsZElkIiwiZXh0cmFGaWVsZExlbmd0aCIsImV4dHJhRmllbGRWYWx1ZSIsImlkIiwibGVuZ3RoIiwidmFsdWUiLCJyZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbExvY2F0b3IiLCJkaXNrV2l0aFppcDY0Q2VudHJhbERpclN0YXJ0IiwicmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciIsImRpc2tzQ291bnQiLCJyZWFkTG9jYWxGaWxlcyIsImkiLCJmaWxlIiwibG9jYWxIZWFkZXJPZmZzZXQiLCJMT0NBTF9GSUxFX0hFQURFUiIsInJlYWRMb2NhbFBhcnQiLCJoYW5kbGVVVEY4IiwicHJvY2Vzc0F0dHJpYnV0ZXMiLCJyZWFkQ2VudHJhbERpciIsIkNFTlRSQUxfRklMRV9IRUFERVIiLCJ6aXA2NCIsInJlYWRDZW50cmFsUGFydCIsInB1c2giLCJyZWFkRW5kT2ZDZW50cmFsIiwib2Zmc2V0IiwibGFzdEluZGV4T2ZTaWduYXR1cmUiLCJDRU5UUkFMX0RJUkVDVE9SWV9FTkQiLCJpc0dhcmJhZ2UiLCJlbmRPZkNlbnRyYWxEaXJPZmZzZXQiLCJNQVhfVkFMVUVfMTZCSVRTIiwiTUFYX1ZBTFVFXzMyQklUUyIsIlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0xPQ0FUT1IiLCJaSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQiLCJleHBlY3RlZEVuZE9mQ2VudHJhbERpck9mZnNldCIsImV4dHJhQnl0ZXMiLCJ6ZXJvIiwiTWF0aCIsImFicyIsInByZXBhcmVSZWFkZXIiLCJkYXRhIiwibG9hZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/zipEntries.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/zipEntry.js":
/*!********************************************!*\
  !*** ./node_modules/jszip/lib/zipEntry.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar readerFor = __webpack_require__(/*! ./reader/readerFor */ \"(ssr)/./node_modules/jszip/lib/reader/readerFor.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/jszip/lib/utils.js\");\nvar CompressedObject = __webpack_require__(/*! ./compressedObject */ \"(ssr)/./node_modules/jszip/lib/compressedObject.js\");\nvar crc32fn = __webpack_require__(/*! ./crc32 */ \"(ssr)/./node_modules/jszip/lib/crc32.js\");\nvar utf8 = __webpack_require__(/*! ./utf8 */ \"(ssr)/./node_modules/jszip/lib/utf8.js\");\nvar compressions = __webpack_require__(/*! ./compressions */ \"(ssr)/./node_modules/jszip/lib/compressions.js\");\nvar support = __webpack_require__(/*! ./support */ \"(ssr)/./node_modules/jszip/lib/support.js\");\nvar MADE_BY_DOS = 0x00;\nvar MADE_BY_UNIX = 0x03;\n/**\n * Find a compression registered in JSZip.\n * @param {string} compressionMethod the method magic to find.\n * @return {Object|null} the JSZip compression object, null if none found.\n */ var findCompression = function(compressionMethod) {\n    for(var method in compressions){\n        if (!Object.prototype.hasOwnProperty.call(compressions, method)) {\n            continue;\n        }\n        if (compressions[method].magic === compressionMethod) {\n            return compressions[method];\n        }\n    }\n    return null;\n};\n// class ZipEntry {{{\n/**\n * An entry in the zip file.\n * @constructor\n * @param {Object} options Options of the current file.\n * @param {Object} loadOptions Options for loading the stream.\n */ function ZipEntry(options, loadOptions) {\n    this.options = options;\n    this.loadOptions = loadOptions;\n}\nZipEntry.prototype = {\n    /**\n     * say if the file is encrypted.\n     * @return {boolean} true if the file is encrypted, false otherwise.\n     */ isEncrypted: function() {\n        // bit 1 is set\n        return (this.bitFlag & 0x0001) === 0x0001;\n    },\n    /**\n     * say if the file has utf-8 filename/comment.\n     * @return {boolean} true if the filename/comment is in utf-8, false otherwise.\n     */ useUTF8: function() {\n        // bit 11 is set\n        return (this.bitFlag & 0x0800) === 0x0800;\n    },\n    /**\n     * Read the local part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */ readLocalPart: function(reader) {\n        var compression, localExtraFieldsLength;\n        // we already know everything from the central dir !\n        // If the central dir data are false, we are doomed.\n        // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.\n        // The less data we get here, the more reliable this should be.\n        // Let's skip the whole header and dash to the data !\n        reader.skip(22);\n        // in some zip created on windows, the filename stored in the central dir contains \\ instead of /.\n        // Strangely, the filename here is OK.\n        // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes\n        // or APPNOTE#4.4.17.1, \"All slashes MUST be forward slashes '/'\") but there are a lot of bad zip generators...\n        // Search \"unzip mismatching \"local\" filename continuing with \"central\" filename version\" on\n        // the internet.\n        //\n        // I think I see the logic here : the central directory is used to display\n        // content and the local directory is used to extract the files. Mixing / and \\\n        // may be used to display \\ to windows users and use / when extracting the files.\n        // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394\n        this.fileNameLength = reader.readInt(2);\n        localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir\n        // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.\n        this.fileName = reader.readData(this.fileNameLength);\n        reader.skip(localExtraFieldsLength);\n        if (this.compressedSize === -1 || this.uncompressedSize === -1) {\n            throw new Error(\"Bug or corrupted zip : didn't get enough information from the central directory \" + \"(compressedSize === -1 || uncompressedSize === -1)\");\n        }\n        compression = findCompression(this.compressionMethod);\n        if (compression === null) {\n            throw new Error(\"Corrupted zip : compression \" + utils.pretty(this.compressionMethod) + \" unknown (inner file : \" + utils.transformTo(\"string\", this.fileName) + \")\");\n        }\n        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));\n    },\n    /**\n     * Read the central part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */ readCentralPart: function(reader) {\n        this.versionMadeBy = reader.readInt(2);\n        reader.skip(2);\n        // this.versionNeeded = reader.readInt(2);\n        this.bitFlag = reader.readInt(2);\n        this.compressionMethod = reader.readString(2);\n        this.date = reader.readDate();\n        this.crc32 = reader.readInt(4);\n        this.compressedSize = reader.readInt(4);\n        this.uncompressedSize = reader.readInt(4);\n        var fileNameLength = reader.readInt(2);\n        this.extraFieldsLength = reader.readInt(2);\n        this.fileCommentLength = reader.readInt(2);\n        this.diskNumberStart = reader.readInt(2);\n        this.internalFileAttributes = reader.readInt(2);\n        this.externalFileAttributes = reader.readInt(4);\n        this.localHeaderOffset = reader.readInt(4);\n        if (this.isEncrypted()) {\n            throw new Error(\"Encrypted zip are not supported\");\n        }\n        // will be read in the local part, see the comments there\n        reader.skip(fileNameLength);\n        this.readExtraFields(reader);\n        this.parseZIP64ExtraField(reader);\n        this.fileComment = reader.readData(this.fileCommentLength);\n    },\n    /**\n     * Parse the external file attributes and get the unix/dos permissions.\n     */ processAttributes: function() {\n        this.unixPermissions = null;\n        this.dosPermissions = null;\n        var madeBy = this.versionMadeBy >> 8;\n        // Check if we have the DOS directory flag set.\n        // We look for it in the DOS and UNIX permissions\n        // but some unknown platform could set it as a compatibility flag.\n        this.dir = this.externalFileAttributes & 0x0010 ? true : false;\n        if (madeBy === MADE_BY_DOS) {\n            // first 6 bits (0 to 5)\n            this.dosPermissions = this.externalFileAttributes & 0x3F;\n        }\n        if (madeBy === MADE_BY_UNIX) {\n            this.unixPermissions = this.externalFileAttributes >> 16 & 0xFFFF;\n        // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);\n        }\n        // fail safe : if the name ends with a / it probably means a folder\n        if (!this.dir && this.fileNameStr.slice(-1) === \"/\") {\n            this.dir = true;\n        }\n    },\n    /**\n     * Parse the ZIP64 extra field and merge the info in the current ZipEntry.\n     * @param {DataReader} reader the reader to use.\n     */ parseZIP64ExtraField: function() {\n        if (!this.extraFields[0x0001]) {\n            return;\n        }\n        // should be something, preparing the extra reader\n        var extraReader = readerFor(this.extraFields[0x0001].value);\n        // I really hope that these 64bits integer can fit in 32 bits integer, because js\n        // won't let us have more.\n        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {\n            this.uncompressedSize = extraReader.readInt(8);\n        }\n        if (this.compressedSize === utils.MAX_VALUE_32BITS) {\n            this.compressedSize = extraReader.readInt(8);\n        }\n        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {\n            this.localHeaderOffset = extraReader.readInt(8);\n        }\n        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {\n            this.diskNumberStart = extraReader.readInt(4);\n        }\n    },\n    /**\n     * Read the central part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */ readExtraFields: function(reader) {\n        var end = reader.index + this.extraFieldsLength, extraFieldId, extraFieldLength, extraFieldValue;\n        if (!this.extraFields) {\n            this.extraFields = {};\n        }\n        while(reader.index + 4 < end){\n            extraFieldId = reader.readInt(2);\n            extraFieldLength = reader.readInt(2);\n            extraFieldValue = reader.readData(extraFieldLength);\n            this.extraFields[extraFieldId] = {\n                id: extraFieldId,\n                length: extraFieldLength,\n                value: extraFieldValue\n            };\n        }\n        reader.setIndex(end);\n    },\n    /**\n     * Apply an UTF8 transformation if needed.\n     */ handleUTF8: function() {\n        var decodeParamType = support.uint8array ? \"uint8array\" : \"array\";\n        if (this.useUTF8()) {\n            this.fileNameStr = utf8.utf8decode(this.fileName);\n            this.fileCommentStr = utf8.utf8decode(this.fileComment);\n        } else {\n            var upath = this.findExtraFieldUnicodePath();\n            if (upath !== null) {\n                this.fileNameStr = upath;\n            } else {\n                // ASCII text or unsupported code page\n                var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);\n                this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);\n            }\n            var ucomment = this.findExtraFieldUnicodeComment();\n            if (ucomment !== null) {\n                this.fileCommentStr = ucomment;\n            } else {\n                // ASCII text or unsupported code page\n                var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);\n                this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);\n            }\n        }\n    },\n    /**\n     * Find the unicode path declared in the extra field, if any.\n     * @return {String} the unicode path, null otherwise.\n     */ findExtraFieldUnicodePath: function() {\n        var upathField = this.extraFields[0x7075];\n        if (upathField) {\n            var extraReader = readerFor(upathField.value);\n            // wrong version\n            if (extraReader.readInt(1) !== 1) {\n                return null;\n            }\n            // the crc of the filename changed, this field is out of date.\n            if (crc32fn(this.fileName) !== extraReader.readInt(4)) {\n                return null;\n            }\n            return utf8.utf8decode(extraReader.readData(upathField.length - 5));\n        }\n        return null;\n    },\n    /**\n     * Find the unicode comment declared in the extra field, if any.\n     * @return {String} the unicode comment, null otherwise.\n     */ findExtraFieldUnicodeComment: function() {\n        var ucommentField = this.extraFields[0x6375];\n        if (ucommentField) {\n            var extraReader = readerFor(ucommentField.value);\n            // wrong version\n            if (extraReader.readInt(1) !== 1) {\n                return null;\n            }\n            // the crc of the comment changed, this field is out of date.\n            if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {\n                return null;\n            }\n            return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));\n        }\n        return null;\n    }\n};\nmodule.exports = ZipEntry;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3ppcEVudHJ5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsWUFBWUMsbUJBQU9BLENBQUMsOEVBQW9CO0FBQzVDLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDLHdEQUFTO0FBQzdCLElBQUlFLG1CQUFtQkYsbUJBQU9BLENBQUMsOEVBQW9CO0FBQ25ELElBQUlHLFVBQVVILG1CQUFPQSxDQUFDLHdEQUFTO0FBQy9CLElBQUlJLE9BQU9KLG1CQUFPQSxDQUFDLHNEQUFRO0FBQzNCLElBQUlLLGVBQWVMLG1CQUFPQSxDQUFDLHNFQUFnQjtBQUMzQyxJQUFJTSxVQUFVTixtQkFBT0EsQ0FBQyw0REFBVztBQUVqQyxJQUFJTyxjQUFjO0FBQ2xCLElBQUlDLGVBQWU7QUFFbkI7Ozs7Q0FJQyxHQUNELElBQUlDLGtCQUFrQixTQUFTQyxpQkFBaUI7SUFDNUMsSUFBSyxJQUFJQyxVQUFVTixhQUFjO1FBQzdCLElBQUksQ0FBQ08sT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1YsY0FBY00sU0FBUztZQUM3RDtRQUNKO1FBQ0EsSUFBSU4sWUFBWSxDQUFDTSxPQUFPLENBQUNLLEtBQUssS0FBS04sbUJBQW1CO1lBQ2xELE9BQU9MLFlBQVksQ0FBQ00sT0FBTztRQUMvQjtJQUNKO0lBQ0EsT0FBTztBQUNYO0FBRUEscUJBQXFCO0FBQ3JCOzs7OztDQUtDLEdBQ0QsU0FBU00sU0FBU0MsT0FBTyxFQUFFQyxXQUFXO0lBQ2xDLElBQUksQ0FBQ0QsT0FBTyxHQUFHQTtJQUNmLElBQUksQ0FBQ0MsV0FBVyxHQUFHQTtBQUN2QjtBQUNBRixTQUFTSixTQUFTLEdBQUc7SUFDakI7OztLQUdDLEdBQ0RPLGFBQWE7UUFDVCxlQUFlO1FBQ2YsT0FBTyxDQUFDLElBQUksQ0FBQ0MsT0FBTyxHQUFHLE1BQUssTUFBTztJQUN2QztJQUNBOzs7S0FHQyxHQUNEQyxTQUFTO1FBQ0wsZ0JBQWdCO1FBQ2hCLE9B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STtnQkFDbkQsT0FBTztZQUNYO1lBRUEsT0FBT3pCLEtBQUt1RSxVQUFVLENBQUNkLFlBQVk5QixRQUFRLENBQUNxRCxXQUFXZCxNQUFNLEdBQUc7UUFDcEU7UUFDQSxPQUFPO0lBQ1g7SUFFQTs7O0tBR0MsR0FDRFksOEJBQThCO1FBQzFCLElBQUlHLGdCQUFnQixJQUFJLENBQUN6QixXQUFXLENBQUMsT0FBTztRQUM1QyxJQUFJeUIsZUFBZTtZQUNmLElBQUl4QixjQUFjOUQsVUFBVXNGLGNBQWN2QixLQUFLO1lBRS9DLGdCQUFnQjtZQUNoQixJQUFJRCxZQUFZaEMsT0FBTyxDQUFDLE9BQU8sR0FBRztnQkFDOUIsT0FBTztZQUNYO1lBRUEsNkRBQTZEO1lBQzdELElBQUkxQixRQUFRLElBQUksQ0FBQ2lELFdBQVcsTUFBTVMsWUFBWWhDLE9BQU8sQ0FBQyxJQUFJO2dCQUN0RCxPQUFPO1lBQ1g7WUFFQSxPQUFPekIsS0FBS3VFLFVBQVUsQ0FBQ2QsWUFBWTlCLFFBQVEsQ0FBQ3NELGNBQWNmLE1BQU0sR0FBRztRQUN2RTtRQUNBLE9BQU87SUFDWDtBQUNKO0FBQ0FnQixPQUFPQyxPQUFPLEdBQUd0RSIsInNvdXJjZXMiOlsid2VicGFjazovL3RzYS1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvemlwRW50cnkuanM/MzI0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciByZWFkZXJGb3IgPSByZXF1aXJlKFwiLi9yZWFkZXIvcmVhZGVyRm9yXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgQ29tcHJlc3NlZE9iamVjdCA9IHJlcXVpcmUoXCIuL2NvbXByZXNzZWRPYmplY3RcIik7XG52YXIgY3JjMzJmbiA9IHJlcXVpcmUoXCIuL2NyYzMyXCIpO1xudmFyIHV0ZjggPSByZXF1aXJlKFwiLi91dGY4XCIpO1xudmFyIGNvbXByZXNzaW9ucyA9IHJlcXVpcmUoXCIuL2NvbXByZXNzaW9uc1wiKTtcbnZhciBzdXBwb3J0ID0gcmVxdWlyZShcIi4vc3VwcG9ydFwiKTtcblxudmFyIE1BREVfQllfRE9TID0gMHgwMDtcbnZhciBNQURFX0JZX1VOSVggPSAweDAzO1xuXG4vKipcbiAqIEZpbmQgYSBjb21wcmVzc2lvbiByZWdpc3RlcmVkIGluIEpTWmlwLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXByZXNzaW9uTWV0aG9kIHRoZSBtZXRob2QgbWFnaWMgdG8gZmluZC5cbiAqIEByZXR1cm4ge09iamVjdHxudWxsfSB0aGUgSlNaaXAgY29tcHJlc3Npb24gb2JqZWN0LCBudWxsIGlmIG5vbmUgZm91bmQuXG4gKi9cbnZhciBmaW5kQ29tcHJlc3Npb24gPSBmdW5jdGlvbihjb21wcmVzc2lvbk1ldGhvZCkge1xuICAgIGZvciAodmFyIG1ldGhvZCBpbiBjb21wcmVzc2lvbnMpIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29tcHJlc3Npb25zLCBtZXRob2QpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHJlc3Npb25zW21ldGhvZF0ubWFnaWMgPT09IGNvbXByZXNzaW9uTWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcHJlc3Npb25zW21ldGhvZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vLyBjbGFzcyBaaXBFbnRyeSB7e3tcbi8qKlxuICogQW4gZW50cnkgaW4gdGhlIHppcCBmaWxlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9mIHRoZSBjdXJyZW50IGZpbGUuXG4gKiBAcGFyYW0ge09iamVjdH0gbG9hZE9wdGlvbnMgT3B0aW9ucyBmb3IgbG9hZGluZyB0aGUgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBaaXBFbnRyeShvcHRpb25zLCBsb2FkT3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5sb2FkT3B0aW9ucyA9IGxvYWRPcHRpb25zO1xufVxuWmlwRW50cnkucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNheSBpZiB0aGUgZmlsZSBpcyBlbmNyeXB0ZWQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZmlsZSBpcyBlbmNyeXB0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc0VuY3J5cHRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGJpdCAxIGlzIHNldFxuICAgICAgICByZXR1cm4gKHRoaXMuYml0RmxhZyAmIDB4MDAwMSkgPT09IDB4MDAwMTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHNheSBpZiB0aGUgZmlsZSBoYXMgdXRmLTggZmlsZW5hbWUvY29tbWVudC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBmaWxlbmFtZS9jb21tZW50IGlzIGluIHV0Zi04LCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgdXNlVVRGODogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGJpdCAxMSBpcyBzZXRcbiAgICAgICAgcmV0dXJuICh0aGlzLmJpdEZsYWcgJiAweDA4MDApID09PSAweDA4MDA7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBsb2NhbCBwYXJ0IG9mIGEgemlwIGZpbGUgYW5kIGFkZCB0aGUgaW5mbyBpbiB0aGlzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlciB0aGUgcmVhZGVyIHRvIHVzZS5cbiAgICAgKi9cbiAgICByZWFkTG9jYWxQYXJ0OiBmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAgICAgdmFyIGNvbXByZXNzaW9uLCBsb2NhbEV4dHJhRmllbGRzTGVuZ3RoO1xuXG4gICAgICAgIC8vIHdlIGFscmVhZHkga25vdyBldmVyeXRoaW5nIGZyb20gdGhlIGNlbnRyYWwgZGlyICFcbiAgICAgICAgLy8gSWYgdGhlIGNlbnRyYWwgZGlyIGRhdGEgYXJlIGZhbHNlLCB3ZSBhcmUgZG9vbWVkLlxuICAgICAgICAvLyBPbiB0aGUgYnJpZ2h0IHNpZGUsIHRoZSBsb2NhbCBwYXJ0IGlzIHNjYXJ5ICA6IHppcDY0LCBkYXRhIGRlc2NyaXB0b3JzLCBib3RoLCBldGMuXG4gICAgICAgIC8vIFRoZSBsZXNzIGRhdGEgd2UgZ2V0IGhlcmUsIHRoZSBtb3JlIHJlbGlhYmxlIHRoaXMgc2hvdWxkIGJlLlxuICAgICAgICAvLyBMZXQncyBza2lwIHRoZSB3aG9sZSBoZWFkZXIgYW5kIGRhc2ggdG8gdGhlIGRhdGEgIVxuICAgICAgICByZWFkZXIuc2tpcCgyMik7XG4gICAgICAgIC8vIGluIHNvbWUgemlwIGNyZWF0ZWQgb24gd2luZG93cywgdGhlIGZpbGVuYW1lIHN0b3JlZCBpbiB0aGUgY2VudHJhbCBkaXIgY29udGFpbnMgXFwgaW5zdGVhZCBvZiAvLlxuICAgICAgICAvLyBTdHJhbmdlbHksIHRoZSBmaWxlbmFtZSBoZXJlIGlzIE9LLlxuICAgICAgICAvLyBJIHdvdWxkIGxvdmUgdG8gdHJlYXQgdGhlc2UgemlwIGZpbGVzIGFzIGNvcnJ1cHRlZCAoc2VlIGh0dHA6Ly93d3cuaW5mby16aXAub3JnL0ZBUS5odG1sI2JhY2tzbGFzaGVzXG4gICAgICAgIC8vIG9yIEFQUE5PVEUjNC40LjE3LjEsIFwiQWxsIHNsYXNoZXMgTVVTVCBiZSBmb3J3YXJkIHNsYXNoZXMgJy8nXCIpIGJ1dCB0aGVyZSBhcmUgYSBsb3Qgb2YgYmFkIHppcCBnZW5lcmF0b3JzLi4uXG4gICAgICAgIC8vIFNlYXJjaCBcInVuemlwIG1pc21hdGNoaW5nIFwibG9jYWxcIiBmaWxlbmFtZSBjb250aW51aW5nIHdpdGggXCJjZW50cmFsXCIgZmlsZW5hbWUgdmVyc2lvblwiIG9uXG4gICAgICAgIC8vIHRoZSBpbnRlcm5ldC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSSB0aGluayBJIHNlZSB0aGUgbG9naWMgaGVyZSA6IHRoZSBjZW50cmFsIGRpcmVjdG9yeSBpcyB1c2VkIHRvIGRpc3BsYXlcbiAgICAgICAgLy8gY29udGVudCBhbmQgdGhlIGxvY2FsIGRpcmVjdG9yeSBpcyB1c2VkIHRvIGV4dHJhY3QgdGhlIGZpbGVzLiBNaXhpbmcgLyBhbmQgXFxcbiAgICAgICAgLy8gbWF5IGJlIHVzZWQgdG8gZGlzcGxheSBcXCB0byB3aW5kb3dzIHVzZXJzIGFuZCB1c2UgLyB3aGVuIGV4dHJhY3RpbmcgdGhlIGZpbGVzLlxuICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5LCB0aGlzIGxlYWQgYWxzbyB0byBzb21lIGlzc3VlcyA6IGh0dHA6Ly9zZWNsaXN0cy5vcmcvZnVsbGRpc2Nsb3N1cmUvMjAwOS9TZXAvMzk0XG4gICAgICAgIHRoaXMuZmlsZU5hbWVMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgbG9jYWxFeHRyYUZpZWxkc0xlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpOyAvLyBjYW4ndCBiZSBzdXJlIHRoaXMgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgY2VudHJhbCBkaXJcbiAgICAgICAgLy8gdGhlIGZpbGVOYW1lIGlzIHN0b3JlZCBhcyBiaW5hcnkgZGF0YSwgdGhlIGhhbmRsZVVURjggbWV0aG9kIHdpbGwgdGFrZSBjYXJlIG9mIHRoZSBlbmNvZGluZy5cbiAgICAgICAgdGhpcy5maWxlTmFtZSA9IHJlYWRlci5yZWFkRGF0YSh0aGlzLmZpbGVOYW1lTGVuZ3RoKTtcbiAgICAgICAgcmVhZGVyLnNraXAobG9jYWxFeHRyYUZpZWxkc0xlbmd0aCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29tcHJlc3NlZFNpemUgPT09IC0xIHx8IHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZyBvciBjb3JydXB0ZWQgemlwIDogZGlkbid0IGdldCBlbm91Z2ggaW5mb3JtYXRpb24gZnJvbSB0aGUgY2VudHJhbCBkaXJlY3RvcnkgXCIgKyBcIihjb21wcmVzc2VkU2l6ZSA9PT0gLTEgfHwgdW5jb21wcmVzc2VkU2l6ZSA9PT0gLTEpXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcHJlc3Npb24gPSBmaW5kQ29tcHJlc3Npb24odGhpcy5jb21wcmVzc2lvbk1ldGhvZCk7XG4gICAgICAgIGlmIChjb21wcmVzc2lvbiA9PT0gbnVsbCkgeyAvLyBubyBjb21wcmVzc2lvbiBmb3VuZFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcCA6IGNvbXByZXNzaW9uIFwiICsgdXRpbHMucHJldHR5KHRoaXMuY29tcHJlc3Npb25NZXRob2QpICsgXCIgdW5rbm93biAoaW5uZXIgZmlsZSA6IFwiICsgdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgdGhpcy5maWxlTmFtZSkgKyBcIilcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWNvbXByZXNzZWQgPSBuZXcgQ29tcHJlc3NlZE9iamVjdCh0aGlzLmNvbXByZXNzZWRTaXplLCB0aGlzLnVuY29tcHJlc3NlZFNpemUsIHRoaXMuY3JjMzIsIGNvbXByZXNzaW9uLCByZWFkZXIucmVhZERhdGEodGhpcy5jb21wcmVzc2VkU2l6ZSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBjZW50cmFsIHBhcnQgb2YgYSB6aXAgZmlsZSBhbmQgYWRkIHRoZSBpbmZvIGluIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyIHRoZSByZWFkZXIgdG8gdXNlLlxuICAgICAqL1xuICAgIHJlYWRDZW50cmFsUGFydDogZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICAgIHRoaXMudmVyc2lvbk1hZGVCeSA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICByZWFkZXIuc2tpcCgyKTtcbiAgICAgICAgLy8gdGhpcy52ZXJzaW9uTmVlZGVkID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuYml0RmxhZyA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmNvbXByZXNzaW9uTWV0aG9kID0gcmVhZGVyLnJlYWRTdHJpbmcoMik7XG4gICAgICAgIHRoaXMuZGF0ZSA9IHJlYWRlci5yZWFkRGF0ZSgpO1xuICAgICAgICB0aGlzLmNyYzMyID0gcmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMuY29tcHJlc3NlZFNpemUgPSByZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy51bmNvbXByZXNzZWRTaXplID0gcmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHZhciBmaWxlTmFtZUxlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmV4dHJhRmllbGRzTGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZmlsZUNvbW1lbnRMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5kaXNrTnVtYmVyU3RhcnQgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbEZpbGVBdHRyaWJ1dGVzID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyA9IHJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLmxvY2FsSGVhZGVyT2Zmc2V0ID0gcmVhZGVyLnJlYWRJbnQoNCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNFbmNyeXB0ZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5jcnlwdGVkIHppcCBhcmUgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdpbGwgYmUgcmVhZCBpbiB0aGUgbG9jYWwgcGFydCwgc2VlIHRoZSBjb21tZW50cyB0aGVyZVxuICAgICAgICByZWFkZXIuc2tpcChmaWxlTmFtZUxlbmd0aCk7XG4gICAgICAgIHRoaXMucmVhZEV4dHJhRmllbGRzKHJlYWRlcik7XG4gICAgICAgIHRoaXMucGFyc2VaSVA2NEV4dHJhRmllbGQocmVhZGVyKTtcbiAgICAgICAgdGhpcy5maWxlQ29tbWVudCA9IHJlYWRlci5yZWFkRGF0YSh0aGlzLmZpbGVDb21tZW50TGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgdGhlIGV4dGVybmFsIGZpbGUgYXR0cmlidXRlcyBhbmQgZ2V0IHRoZSB1bml4L2RvcyBwZXJtaXNzaW9ucy5cbiAgICAgKi9cbiAgICBwcm9jZXNzQXR0cmlidXRlczogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVuaXhQZXJtaXNzaW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMuZG9zUGVybWlzc2lvbnMgPSBudWxsO1xuICAgICAgICB2YXIgbWFkZUJ5ID0gdGhpcy52ZXJzaW9uTWFkZUJ5ID4+IDg7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSB0aGUgRE9TIGRpcmVjdG9yeSBmbGFnIHNldC5cbiAgICAgICAgLy8gV2UgbG9vayBmb3IgaXQgaW4gdGhlIERPUyBhbmQgVU5JWCBwZXJtaXNzaW9uc1xuICAgICAgICAvLyBidXQgc29tZSB1bmtub3duIHBsYXRmb3JtIGNvdWxkIHNldCBpdCBhcyBhIGNvbXBhdGliaWxpdHkgZmxhZy5cbiAgICAgICAgdGhpcy5kaXIgPSB0aGlzLmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMgJiAweDAwMTAgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgICAgaWYobWFkZUJ5ID09PSBNQURFX0JZX0RPUykge1xuICAgICAgICAgICAgLy8gZmlyc3QgNiBiaXRzICgwIHRvIDUpXG4gICAgICAgICAgICB0aGlzLmRvc1Blcm1pc3Npb25zID0gdGhpcy5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzICYgMHgzRjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKG1hZGVCeSA9PT0gTUFERV9CWV9VTklYKSB7XG4gICAgICAgICAgICB0aGlzLnVuaXhQZXJtaXNzaW9ucyA9ICh0aGlzLmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMgPj4gMTYpICYgMHhGRkZGO1xuICAgICAgICAgICAgLy8gdGhlIG9jdGFsIHBlcm1pc3Npb25zIGFyZSBpbiAodGhpcy51bml4UGVybWlzc2lvbnMgJiAweDAxRkYpLnRvU3RyaW5nKDgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmFpbCBzYWZlIDogaWYgdGhlIG5hbWUgZW5kcyB3aXRoIGEgLyBpdCBwcm9iYWJseSBtZWFucyBhIGZvbGRlclxuICAgICAgICBpZiAoIXRoaXMuZGlyICYmIHRoaXMuZmlsZU5hbWVTdHIuc2xpY2UoLTEpID09PSBcIi9cIikge1xuICAgICAgICAgICAgdGhpcy5kaXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBaSVA2NCBleHRyYSBmaWVsZCBhbmQgbWVyZ2UgdGhlIGluZm8gaW4gdGhlIGN1cnJlbnQgWmlwRW50cnkuXG4gICAgICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXIgdGhlIHJlYWRlciB0byB1c2UuXG4gICAgICovXG4gICAgcGFyc2VaSVA2NEV4dHJhRmllbGQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuZXh0cmFGaWVsZHNbMHgwMDAxXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2hvdWxkIGJlIHNvbWV0aGluZywgcHJlcGFyaW5nIHRoZSBleHRyYSByZWFkZXJcbiAgICAgICAgdmFyIGV4dHJhUmVhZGVyID0gcmVhZGVyRm9yKHRoaXMuZXh0cmFGaWVsZHNbMHgwMDAxXS52YWx1ZSk7XG5cbiAgICAgICAgLy8gSSByZWFsbHkgaG9wZSB0aGF0IHRoZXNlIDY0Yml0cyBpbnRlZ2VyIGNhbiBmaXQgaW4gMzIgYml0cyBpbnRlZ2VyLCBiZWNhdXNlIGpzXG4gICAgICAgIC8vIHdvbid0IGxldCB1cyBoYXZlIG1vcmUuXG4gICAgICAgIGlmICh0aGlzLnVuY29tcHJlc3NlZFNpemUgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMpIHtcbiAgICAgICAgICAgIHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9IGV4dHJhUmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29tcHJlc3NlZFNpemUgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcHJlc3NlZFNpemUgPSBleHRyYVJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxvY2FsSGVhZGVyT2Zmc2V0ID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsSGVhZGVyT2Zmc2V0ID0gZXh0cmFSZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaXNrTnVtYmVyU3RhcnQgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMpIHtcbiAgICAgICAgICAgIHRoaXMuZGlza051bWJlclN0YXJ0ID0gZXh0cmFSZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgY2VudHJhbCBwYXJ0IG9mIGEgemlwIGZpbGUgYW5kIGFkZCB0aGUgaW5mbyBpbiB0aGlzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlciB0aGUgcmVhZGVyIHRvIHVzZS5cbiAgICAgKi9cbiAgICByZWFkRXh0cmFGaWVsZHM6IGZ1bmN0aW9uKHJlYWRlcikge1xuICAgICAgICB2YXIgZW5kID0gcmVhZGVyLmluZGV4ICsgdGhpcy5leHRyYUZpZWxkc0xlbmd0aCxcbiAgICAgICAgICAgIGV4dHJhRmllbGRJZCxcbiAgICAgICAgICAgIGV4dHJhRmllbGRMZW5ndGgsXG4gICAgICAgICAgICBleHRyYUZpZWxkVmFsdWU7XG5cbiAgICAgICAgaWYgKCF0aGlzLmV4dHJhRmllbGRzKSB7XG4gICAgICAgICAgICB0aGlzLmV4dHJhRmllbGRzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAocmVhZGVyLmluZGV4ICsgNCA8IGVuZCkge1xuICAgICAgICAgICAgZXh0cmFGaWVsZElkID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgICAgICBleHRyYUZpZWxkTGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgICAgICBleHRyYUZpZWxkVmFsdWUgPSByZWFkZXIucmVhZERhdGEoZXh0cmFGaWVsZExlbmd0aCk7XG5cbiAgICAgICAgICAgIHRoaXMuZXh0cmFGaWVsZHNbZXh0cmFGaWVsZElkXSA9IHtcbiAgICAgICAgICAgICAgICBpZDogZXh0cmFGaWVsZElkLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogZXh0cmFGaWVsZExlbmd0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZXh0cmFGaWVsZFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVhZGVyLnNldEluZGV4KGVuZCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBcHBseSBhbiBVVEY4IHRyYW5zZm9ybWF0aW9uIGlmIG5lZWRlZC5cbiAgICAgKi9cbiAgICBoYW5kbGVVVEY4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRlY29kZVBhcmFtVHlwZSA9IHN1cHBvcnQudWludDhhcnJheSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiO1xuICAgICAgICBpZiAodGhpcy51c2VVVEY4KCkpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsZU5hbWVTdHIgPSB1dGY4LnV0ZjhkZWNvZGUodGhpcy5maWxlTmFtZSk7XG4gICAgICAgICAgICB0aGlzLmZpbGVDb21tZW50U3RyID0gdXRmOC51dGY4ZGVjb2RlKHRoaXMuZmlsZUNvbW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHVwYXRoID0gdGhpcy5maW5kRXh0cmFGaWVsZFVuaWNvZGVQYXRoKCk7XG4gICAgICAgICAgICBpZiAodXBhdGggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVOYW1lU3RyID0gdXBhdGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFTQ0lJIHRleHQgb3IgdW5zdXBwb3J0ZWQgY29kZSBwYWdlXG4gICAgICAgICAgICAgICAgdmFyIGZpbGVOYW1lQnl0ZUFycmF5ID0gIHV0aWxzLnRyYW5zZm9ybVRvKGRlY29kZVBhcmFtVHlwZSwgdGhpcy5maWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlTmFtZVN0ciA9IHRoaXMubG9hZE9wdGlvbnMuZGVjb2RlRmlsZU5hbWUoZmlsZU5hbWVCeXRlQXJyYXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdWNvbW1lbnQgPSB0aGlzLmZpbmRFeHRyYUZpZWxkVW5pY29kZUNvbW1lbnQoKTtcbiAgICAgICAgICAgIGlmICh1Y29tbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZUNvbW1lbnRTdHIgPSB1Y29tbWVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQVNDSUkgdGV4dCBvciB1bnN1cHBvcnRlZCBjb2RlIHBhZ2VcbiAgICAgICAgICAgICAgICB2YXIgY29tbWVudEJ5dGVBcnJheSA9ICB1dGlscy50cmFuc2Zvcm1UbyhkZWNvZGVQYXJhbVR5cGUsIHRoaXMuZmlsZUNvbW1lbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZUNvbW1lbnRTdHIgPSB0aGlzLmxvYWRPcHRpb25zLmRlY29kZUZpbGVOYW1lKGNvbW1lbnRCeXRlQXJyYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIHVuaWNvZGUgcGF0aCBkZWNsYXJlZCBpbiB0aGUgZXh0cmEgZmllbGQsIGlmIGFueS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSB1bmljb2RlIHBhdGgsIG51bGwgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGZpbmRFeHRyYUZpZWxkVW5pY29kZVBhdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdXBhdGhGaWVsZCA9IHRoaXMuZXh0cmFGaWVsZHNbMHg3MDc1XTtcbiAgICAgICAgaWYgKHVwYXRoRmllbGQpIHtcbiAgICAgICAgICAgIHZhciBleHRyYVJlYWRlciA9IHJlYWRlckZvcih1cGF0aEZpZWxkLnZhbHVlKTtcblxuICAgICAgICAgICAgLy8gd3JvbmcgdmVyc2lvblxuICAgICAgICAgICAgaWYgKGV4dHJhUmVhZGVyLnJlYWRJbnQoMSkgIT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhlIGNyYyBvZiB0aGUgZmlsZW5hbWUgY2hhbmdlZCwgdGhpcyBmaWVsZCBpcyBvdXQgb2YgZGF0ZS5cbiAgICAgICAgICAgIGlmIChjcmMzMmZuKHRoaXMuZmlsZU5hbWUpICE9PSBleHRyYVJlYWRlci5yZWFkSW50KDQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB1dGY4LnV0ZjhkZWNvZGUoZXh0cmFSZWFkZXIucmVhZERhdGEodXBhdGhGaWVsZC5sZW5ndGggLSA1KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIHVuaWNvZGUgY29tbWVudCBkZWNsYXJlZCBpbiB0aGUgZXh0cmEgZmllbGQsIGlmIGFueS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSB1bmljb2RlIGNvbW1lbnQsIG51bGwgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGZpbmRFeHRyYUZpZWxkVW5pY29kZUNvbW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdWNvbW1lbnRGaWVsZCA9IHRoaXMuZXh0cmFGaWVsZHNbMHg2Mzc1XTtcbiAgICAgICAgaWYgKHVjb21tZW50RmllbGQpIHtcbiAgICAgICAgICAgIHZhciBleHRyYVJlYWRlciA9IHJlYWRlckZvcih1Y29tbWVudEZpZWxkLnZhbHVlKTtcblxuICAgICAgICAgICAgLy8gd3JvbmcgdmVyc2lvblxuICAgICAgICAgICAgaWYgKGV4dHJhUmVhZGVyLnJlYWRJbnQoMSkgIT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhlIGNyYyBvZiB0aGUgY29tbWVudCBjaGFuZ2VkLCB0aGlzIGZpZWxkIGlzIG91dCBvZiBkYXRlLlxuICAgICAgICAgICAgaWYgKGNyYzMyZm4odGhpcy5maWxlQ29tbWVudCkgIT09IGV4dHJhUmVhZGVyLnJlYWRJbnQoNCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHV0ZjgudXRmOGRlY29kZShleHRyYVJlYWRlci5yZWFkRGF0YSh1Y29tbWVudEZpZWxkLmxlbmd0aCAtIDUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBaaXBFbnRyeTtcbiJdLCJuYW1lcyI6WyJyZWFkZXJGb3IiLCJyZXF1aXJlIiwidXRpbHMiLCJDb21wcmVzc2VkT2JqZWN0IiwiY3JjMzJmbiIsInV0ZjgiLCJjb21wcmVzc2lvbnMiLCJzdXBwb3J0IiwiTUFERV9CWV9ET1MiLCJNQURFX0JZX1VOSVgiLCJmaW5kQ29tcHJlc3Npb24iLCJjb21wcmVzc2lvbk1ldGhvZCIsIm1ldGhvZCIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIm1hZ2ljIiwiWmlwRW50cnkiLCJvcHRpb25zIiwibG9hZE9wdGlvbnMiLCJpc0VuY3J5cHRlZCIsImJpdEZsYWciLCJ1c2VVVEY4IiwicmVhZExvY2FsUGFydCIsInJlYWRlciIsImNvbXByZXNzaW9uIiwibG9jYWxFeHRyYUZpZWxkc0xlbmd0aCIsInNraXAiLCJmaWxlTmFtZUxlbmd0aCIsInJlYWRJbnQiLCJmaWxlTmFtZSIsInJlYWREYXRhIiwiY29tcHJlc3NlZFNpemUiLCJ1bmNvbXByZXNzZWRTaXplIiwiRXJyb3IiLCJwcmV0dHkiLCJ0cmFuc2Zvcm1UbyIsImRlY29tcHJlc3NlZCIsImNyYzMyIiwicmVhZENlbnRyYWxQYXJ0IiwidmVyc2lvbk1hZGVCeSIsInJlYWRTdHJpbmciLCJkYXRlIiwicmVhZERhdGUiLCJleHRyYUZpZWxkc0xlbmd0aCIsImZpbGVDb21tZW50TGVuZ3RoIiwiZGlza051bWJlclN0YXJ0IiwiaW50ZXJuYWxGaWxlQXR0cmlidXRlcyIsImV4dGVybmFsRmlsZUF0dHJpYnV0ZXMiLCJsb2NhbEhlYWRlck9mZnNldCIsInJlYWRFeHRyYUZpZWxkcyIsInBhcnNlWklQNjRFeHRyYUZpZWxkIiwiZmlsZUNvbW1lbnQiLCJwcm9jZXNzQXR0cmlidXRlcyIsInVuaXhQZXJtaXNzaW9ucyIsImRvc1Blcm1pc3Npb25zIiwibWFkZUJ5IiwiZGlyIiwiZmlsZU5hbWVTdHIiLCJzbGljZSIsImV4dHJhRmllbGRzIiwiZXh0cmFSZWFkZXIiLCJ2YWx1ZSIsIk1BWF9WQUxVRV8zMkJJVFMiLCJlbmQiLCJpbmRleCIsImV4dHJhRmllbGRJZCIsImV4dHJhRmllbGRMZW5ndGgiLCJleHRyYUZpZWxkVmFsdWUiLCJpZCIsImxlbmd0aCIsInNldEluZGV4IiwiaGFuZGxlVVRGOCIsImRlY29kZVBhcmFtVHlwZSIsInVpbnQ4YXJyYXkiLCJ1dGY4ZGVjb2RlIiwiZmlsZUNvbW1lbnRTdHIiLCJ1cGF0aCIsImZpbmRFeHRyYUZpZWxkVW5pY29kZVBhdGgiLCJmaWxlTmFtZUJ5dGVBcnJheSIsImRlY29kZUZpbGVOYW1lIiwidWNvbW1lbnQiLCJmaW5kRXh0cmFGaWVsZFVuaWNvZGVDb21tZW50IiwiY29tbWVudEJ5dGVBcnJheSIsInVwYXRoRmllbGQiLCJ1Y29tbWVudEZpZWxkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/zipEntry.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jszip/lib/zipObject.js":
/*!*********************************************!*\
  !*** ./node_modules/jszip/lib/zipObject.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar StreamHelper = __webpack_require__(/*! ./stream/StreamHelper */ \"(ssr)/./node_modules/jszip/lib/stream/StreamHelper.js\");\nvar DataWorker = __webpack_require__(/*! ./stream/DataWorker */ \"(ssr)/./node_modules/jszip/lib/stream/DataWorker.js\");\nvar utf8 = __webpack_require__(/*! ./utf8 */ \"(ssr)/./node_modules/jszip/lib/utf8.js\");\nvar CompressedObject = __webpack_require__(/*! ./compressedObject */ \"(ssr)/./node_modules/jszip/lib/compressedObject.js\");\nvar GenericWorker = __webpack_require__(/*! ./stream/GenericWorker */ \"(ssr)/./node_modules/jszip/lib/stream/GenericWorker.js\");\n/**\n * A simple object representing a file in the zip file.\n * @constructor\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data\n * @param {Object} options the options of the file\n */ var ZipObject = function(name, data, options) {\n    this.name = name;\n    this.dir = options.dir;\n    this.date = options.date;\n    this.comment = options.comment;\n    this.unixPermissions = options.unixPermissions;\n    this.dosPermissions = options.dosPermissions;\n    this._data = data;\n    this._dataBinary = options.binary;\n    // keep only the compression\n    this.options = {\n        compression: options.compression,\n        compressionOptions: options.compressionOptions\n    };\n};\nZipObject.prototype = {\n    /**\n     * Create an internal stream for the content of this object.\n     * @param {String} type the type of each chunk.\n     * @return StreamHelper the stream.\n     */ internalStream: function(type) {\n        var result = null, outputType = \"string\";\n        try {\n            if (!type) {\n                throw new Error(\"No output type specified.\");\n            }\n            outputType = type.toLowerCase();\n            var askUnicodeString = outputType === \"string\" || outputType === \"text\";\n            if (outputType === \"binarystring\" || outputType === \"text\") {\n                outputType = \"string\";\n            }\n            result = this._decompressWorker();\n            var isUnicodeString = !this._dataBinary;\n            if (isUnicodeString && !askUnicodeString) {\n                result = result.pipe(new utf8.Utf8EncodeWorker());\n            }\n            if (!isUnicodeString && askUnicodeString) {\n                result = result.pipe(new utf8.Utf8DecodeWorker());\n            }\n        } catch (e) {\n            result = new GenericWorker(\"error\");\n            result.error(e);\n        }\n        return new StreamHelper(result, outputType, \"\");\n    },\n    /**\n     * Prepare the content in the asked type.\n     * @param {String} type the type of the result.\n     * @param {Function} onUpdate a function to call on each internal update.\n     * @return Promise the promise of the result.\n     */ async: function(type, onUpdate) {\n        return this.internalStream(type).accumulate(onUpdate);\n    },\n    /**\n     * Prepare the content as a nodejs stream.\n     * @param {String} type the type of each chunk.\n     * @param {Function} onUpdate a function to call on each internal update.\n     * @return Stream the stream.\n     */ nodeStream: function(type, onUpdate) {\n        return this.internalStream(type || \"nodebuffer\").toNodejsStream(onUpdate);\n    },\n    /**\n     * Return a worker for the compressed content.\n     * @private\n     * @param {Object} compression the compression object to use.\n     * @param {Object} compressionOptions the options to use when compressing.\n     * @return Worker the worker.\n     */ _compressWorker: function(compression, compressionOptions) {\n        if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {\n            return this._data.getCompressedWorker();\n        } else {\n            var result = this._decompressWorker();\n            if (!this._dataBinary) {\n                result = result.pipe(new utf8.Utf8EncodeWorker());\n            }\n            return CompressedObject.createWorkerFrom(result, compression, compressionOptions);\n        }\n    },\n    /**\n     * Return a worker for the decompressed content.\n     * @private\n     * @return Worker the worker.\n     */ _decompressWorker: function() {\n        if (this._data instanceof CompressedObject) {\n            return this._data.getContentWorker();\n        } else if (this._data instanceof GenericWorker) {\n            return this._data;\n        } else {\n            return new DataWorker(this._data);\n        }\n    }\n};\nvar removedMethods = [\n    \"asText\",\n    \"asBinary\",\n    \"asNodeBuffer\",\n    \"asUint8Array\",\n    \"asArrayBuffer\"\n];\nvar removedFn = function() {\n    throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n};\nfor(var i = 0; i < removedMethods.length; i++){\n    ZipObject.prototype[removedMethods[i]] = removedFn;\n}\nmodule.exports = ZipObject;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanN6aXAvbGliL3ppcE9iamVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLElBQUlBLGVBQWVDLG1CQUFPQSxDQUFDLG9GQUF1QjtBQUNsRCxJQUFJQyxhQUFhRCxtQkFBT0EsQ0FBQyxnRkFBcUI7QUFDOUMsSUFBSUUsT0FBT0YsbUJBQU9BLENBQUMsc0RBQVE7QUFDM0IsSUFBSUcsbUJBQW1CSCxtQkFBT0EsQ0FBQyw4RUFBb0I7QUFDbkQsSUFBSUksZ0JBQWdCSixtQkFBT0EsQ0FBQyxzRkFBd0I7QUFFcEQ7Ozs7OztDQU1DLEdBQ0QsSUFBSUssWUFBWSxTQUFTQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsT0FBTztJQUN4QyxJQUFJLENBQUNGLElBQUksR0FBR0E7SUFDWixJQUFJLENBQUNHLEdBQUcsR0FBR0QsUUFBUUMsR0FBRztJQUN0QixJQUFJLENBQUNDLElBQUksR0FBR0YsUUFBUUUsSUFBSTtJQUN4QixJQUFJLENBQUNDLE9BQU8sR0FBR0gsUUFBUUcsT0FBTztJQUM5QixJQUFJLENBQUNDLGVBQWUsR0FBR0osUUFBUUksZUFBZTtJQUM5QyxJQUFJLENBQUNDLGNBQWMsR0FBR0wsUUFBUUssY0FBYztJQUU1QyxJQUFJLENBQUNDLEtBQUssR0FBR1A7SUFDYixJQUFJLENBQUNRLFdBQVcsR0FBR1AsUUFBUVEsTUFBTTtJQUNqQyw0QkFBNEI7SUFDNUIsSUFBSSxDQUFDUixPQUFPLEdBQUc7UUFDWFMsYUFBY1QsUUFBUVMsV0FBVztRQUNqQ0Msb0JBQXFCVixRQUFRVSxrQkFBa0I7SUFDbkQ7QUFDSjtBQUVBYixVQUFVYyxTQUFTLEdBQUc7SUFDbEI7Ozs7S0FJQyxHQUNEQyxnQkFBZ0IsU0FBVUMsSUFBSTtRQUMxQixJQUFJQyxTQUFTLE1BQU1DLGFBQWE7UUFDaEMsSUFBSTtZQUNBLElBQUksQ0FBQ0YsTUFBTTtnQkFDUCxNQUFNLElBQUlHLE1BQU07WUFDcEI7WUFDQUQsYUFBYUYsS0FBS0ksV0FBVztZQUM3QixJQUFJQyxtQkFBbUJILGVBQWUsWUFBWUEsZUFBZTtZQUNqRSxJQUFJQSxlQUFlLGtCQUFrQkEsZUFBZSxRQUFRO2dCQUN4REEsYUFBYTtZQUNqQjtZQUNBRCxTQUFTLElBQUksQ0FBQ0ssaUJBQWlCO1lBRS9CLElBQUlDLGtCQUFrQixDQUFDLElBQUksQ0FBQ2IsV0FBVztZQUV2QyxJQUFJYSxtQkFBbUIsQ0FBQ0Ysa0JBQWtCO2dCQUN0Q0osU0FBU0EsT0FBT08sSUFBSSxDQUFDLElBQUkzQixLQUFLNEIsZ0JBQWdCO1lBQ2xEO1lBQ0EsSUFBSSxDQUFDRixtQkFBbUJGLGtCQUFrQjtnQkFDdENKLFNBQVNBLE9BQU9PLElBQUksQ0FBQyxJQUFJM0IsS0FBSzZCLGdCQUFnQjtZQUNsRDtRQUNKLEVBQUUsT0FBT0MsR0FBRztZQUNSVixTQUFTLElBQUlsQixjQUFjO1lBQzNCa0IsT0FBT1csS0FBSyxDQUFDRDtRQUNqQjtRQUVBLE9BQU8sSUFBSWpDLGFBQWF1QixRQUFRQyxZQUFZO0lBQ2hEO0lBRUE7Ozs7O0tBS0MsR0FDRFcsT0FBTyxTQUFVYixJQUFJLEVBQUVjLFFBQVE7UUFDM0IsT0FBTyxJQUFJLENBQUNmLGNBQWMsQ0FBQ0MsTUFBTWUsVUFBVSxDQUFDRDtJQUNoRDtJQUVBOzs7OztLQUtDLEdBQ0RFLFlBQVksU0FBVWhCLElBQUksRUFBRWMsUUFBUTtRQUNoQyxPQUFPLElBQUksQ0FBQ2YsY0FBYyxDQUFDQyxRQUFRLGNBQWNpQixjQUFjLENBQUNIO0lBQ3BFO0lBRUE7Ozs7OztLQU1DLEdBQ0RJLGlCQUFpQixTQUFVdEIsV0FBVyxFQUFFQyxrQkFBa0I7UUFDdEQsSUFDSSxJQUFJLENBQUNKLEtBQUssWUFBWVgsb0JBQ3RCLElBQUksQ0FBQ1csS0FBSyxDQUFDRyxXQUFXLENBQUN1QixLQUFLLEtBQUt2QixZQUFZdUIsS0FBSyxFQUNwRDtZQUNFLE9BQU8sSUFBSSxDQUFDMUIsS0FBSyxDQUFDMkIsbUJBQW1CO1FBQ3pDLE9BQU87WUFDSCxJQUFJbkIsU0FBUyxJQUFJLENBQUNLLGlCQUFpQjtZQUNuQyxJQUFHLENBQUMsSUFBSSxDQUFDWixXQUFXLEVBQUU7Z0JBQ2xCTyxTQUFTQSxPQUFPTyxJQUFJLENBQUMsSUFBSTNCLEtBQUs0QixnQkFBZ0I7WUFDbEQ7WUFDQSxPQUFPM0IsaUJBQWlCdUMsZ0JBQWdCLENBQUNwQixRQUFRTCxhQUFhQztRQUNsRTtJQUNKO0lBQ0E7Ozs7S0FJQyxHQUNEUyxtQkFBb0I7UUFDaEIsSUFBSSxJQUFJLENBQUNiLEtBQUssWUFBWVgsa0JBQWtCO1lBQ3hDLE9BQU8sSUFBSSxDQUFDVyxLQUFLLENBQUM2QixnQkFBZ0I7UUFDdEMsT0FBTyxJQUFJLElBQUksQ0FBQzdCLEtBQUssWUFBWVYsZUFBZTtZQUM1QyxPQUFPLElBQUksQ0FBQ1UsS0FBSztRQUNyQixPQUFPO1lBQ0gsT0FBTyxJQUFJYixXQUFXLElBQUksQ0FBQ2EsS0FBSztRQUNwQztJQUNKO0FBQ0o7QUFFQSxJQUFJOEIsaUJBQWlCO0lBQUM7SUFBVTtJQUFZO0lBQWdCO0lBQWdCO0NBQWdCO0FBQzVGLElBQUlDLFlBQVk7SUFDWixNQUFNLElBQUlyQixNQUFNO0FBQ3BCO0FBRUEsSUFBSSxJQUFJc0IsSUFBSSxHQUFHQSxJQUFJRixlQUFlRyxNQUFNLEVBQUVELElBQUs7SUFDM0N6QyxVQUFVYyxTQUFTLENBQUN5QixjQUFjLENBQUNFLEVBQUUsQ0FBQyxHQUFHRDtBQUM3QztBQUNBRyxPQUFPQyxPQUFPLEdBQUc1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3RzYS1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9qc3ppcC9saWIvemlwT2JqZWN0LmpzPzcxNDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBTdHJlYW1IZWxwZXIgPSByZXF1aXJlKFwiLi9zdHJlYW0vU3RyZWFtSGVscGVyXCIpO1xudmFyIERhdGFXb3JrZXIgPSByZXF1aXJlKFwiLi9zdHJlYW0vRGF0YVdvcmtlclwiKTtcbnZhciB1dGY4ID0gcmVxdWlyZShcIi4vdXRmOFwiKTtcbnZhciBDb21wcmVzc2VkT2JqZWN0ID0gcmVxdWlyZShcIi4vY29tcHJlc3NlZE9iamVjdFwiKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZShcIi4vc3RyZWFtL0dlbmVyaWNXb3JrZXJcIik7XG5cbi8qKlxuICogQSBzaW1wbGUgb2JqZWN0IHJlcHJlc2VudGluZyBhIGZpbGUgaW4gdGhlIHppcCBmaWxlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZVxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIG9mIHRoZSBmaWxlXG4gKi9cbnZhciBaaXBPYmplY3QgPSBmdW5jdGlvbihuYW1lLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmRpciA9IG9wdGlvbnMuZGlyO1xuICAgIHRoaXMuZGF0ZSA9IG9wdGlvbnMuZGF0ZTtcbiAgICB0aGlzLmNvbW1lbnQgPSBvcHRpb25zLmNvbW1lbnQ7XG4gICAgdGhpcy51bml4UGVybWlzc2lvbnMgPSBvcHRpb25zLnVuaXhQZXJtaXNzaW9ucztcbiAgICB0aGlzLmRvc1Blcm1pc3Npb25zID0gb3B0aW9ucy5kb3NQZXJtaXNzaW9ucztcblxuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgIHRoaXMuX2RhdGFCaW5hcnkgPSBvcHRpb25zLmJpbmFyeTtcbiAgICAvLyBrZWVwIG9ubHkgdGhlIGNvbXByZXNzaW9uXG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICBjb21wcmVzc2lvbiA6IG9wdGlvbnMuY29tcHJlc3Npb24sXG4gICAgICAgIGNvbXByZXNzaW9uT3B0aW9ucyA6IG9wdGlvbnMuY29tcHJlc3Npb25PcHRpb25zXG4gICAgfTtcbn07XG5cblppcE9iamVjdC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGludGVybmFsIHN0cmVhbSBmb3IgdGhlIGNvbnRlbnQgb2YgdGhpcyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgZWFjaCBjaHVuay5cbiAgICAgKiBAcmV0dXJuIFN0cmVhbUhlbHBlciB0aGUgc3RyZWFtLlxuICAgICAqL1xuICAgIGludGVybmFsU3RyZWFtOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbCwgb3V0cHV0VHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBvdXRwdXQgdHlwZSBzcGVjaWZpZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0VHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBhc2tVbmljb2RlU3RyaW5nID0gb3V0cHV0VHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBvdXRwdXRUeXBlID09PSBcInRleHRcIjtcbiAgICAgICAgICAgIGlmIChvdXRwdXRUeXBlID09PSBcImJpbmFyeXN0cmluZ1wiIHx8IG91dHB1dFR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0VHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9kZWNvbXByZXNzV29ya2VyKCk7XG5cbiAgICAgICAgICAgIHZhciBpc1VuaWNvZGVTdHJpbmcgPSAhdGhpcy5fZGF0YUJpbmFyeTtcblxuICAgICAgICAgICAgaWYgKGlzVW5pY29kZVN0cmluZyAmJiAhYXNrVW5pY29kZVN0cmluZykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKG5ldyB1dGY4LlV0ZjhFbmNvZGVXb3JrZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzVW5pY29kZVN0cmluZyAmJiBhc2tVbmljb2RlU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBpcGUobmV3IHV0ZjguVXRmOERlY29kZVdvcmtlcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEdlbmVyaWNXb3JrZXIoXCJlcnJvclwiKTtcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvcihlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSGVscGVyKHJlc3VsdCwgb3V0cHV0VHlwZSwgXCJcIik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdGhlIGNvbnRlbnQgaW4gdGhlIGFza2VkIHR5cGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgdGhlIHJlc3VsdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblVwZGF0ZSBhIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBpbnRlcm5hbCB1cGRhdGUuXG4gICAgICogQHJldHVybiBQcm9taXNlIHRoZSBwcm9taXNlIG9mIHRoZSByZXN1bHQuXG4gICAgICovXG4gICAgYXN5bmM6IGZ1bmN0aW9uICh0eXBlLCBvblVwZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFN0cmVhbSh0eXBlKS5hY2N1bXVsYXRlKG9uVXBkYXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSB0aGUgY29udGVudCBhcyBhIG5vZGVqcyBzdHJlYW0uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgZWFjaCBjaHVuay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblVwZGF0ZSBhIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBpbnRlcm5hbCB1cGRhdGUuXG4gICAgICogQHJldHVybiBTdHJlYW0gdGhlIHN0cmVhbS5cbiAgICAgKi9cbiAgICBub2RlU3RyZWFtOiBmdW5jdGlvbiAodHlwZSwgb25VcGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxTdHJlYW0odHlwZSB8fCBcIm5vZGVidWZmZXJcIikudG9Ob2RlanNTdHJlYW0ob25VcGRhdGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSB3b3JrZXIgZm9yIHRoZSBjb21wcmVzc2VkIGNvbnRlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29tcHJlc3Npb24gdGhlIGNvbXByZXNzaW9uIG9iamVjdCB0byB1c2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbXByZXNzaW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2Ugd2hlbiBjb21wcmVzc2luZy5cbiAgICAgKiBAcmV0dXJuIFdvcmtlciB0aGUgd29ya2VyLlxuICAgICAqL1xuICAgIF9jb21wcmVzc1dvcmtlcjogZnVuY3Rpb24gKGNvbXByZXNzaW9uLCBjb21wcmVzc2lvbk9wdGlvbnMpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5fZGF0YSBpbnN0YW5jZW9mIENvbXByZXNzZWRPYmplY3QgJiZcbiAgICAgICAgICAgIHRoaXMuX2RhdGEuY29tcHJlc3Npb24ubWFnaWMgPT09IGNvbXByZXNzaW9uLm1hZ2ljXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZ2V0Q29tcHJlc3NlZFdvcmtlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2RlY29tcHJlc3NXb3JrZXIoKTtcbiAgICAgICAgICAgIGlmKCF0aGlzLl9kYXRhQmluYXJ5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBpcGUobmV3IHV0ZjguVXRmOEVuY29kZVdvcmtlcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBDb21wcmVzc2VkT2JqZWN0LmNyZWF0ZVdvcmtlckZyb20ocmVzdWx0LCBjb21wcmVzc2lvbiwgY29tcHJlc3Npb25PcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgd29ya2VyIGZvciB0aGUgZGVjb21wcmVzc2VkIGNvbnRlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIFdvcmtlciB0aGUgd29ya2VyLlxuICAgICAqL1xuICAgIF9kZWNvbXByZXNzV29ya2VyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fZGF0YSBpbnN0YW5jZW9mIENvbXByZXNzZWRPYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmdldENvbnRlbnRXb3JrZXIoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9kYXRhIGluc3RhbmNlb2YgR2VuZXJpY1dvcmtlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGFXb3JrZXIodGhpcy5fZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgcmVtb3ZlZE1ldGhvZHMgPSBbXCJhc1RleHRcIiwgXCJhc0JpbmFyeVwiLCBcImFzTm9kZUJ1ZmZlclwiLCBcImFzVWludDhBcnJheVwiLCBcImFzQXJyYXlCdWZmZXJcIl07XG52YXIgcmVtb3ZlZEZuID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbWV0aG9kIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xufTtcblxuZm9yKHZhciBpID0gMDsgaSA8IHJlbW92ZWRNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgWmlwT2JqZWN0LnByb3RvdHlwZVtyZW1vdmVkTWV0aG9kc1tpXV0gPSByZW1vdmVkRm47XG59XG5tb2R1bGUuZXhwb3J0cyA9IFppcE9iamVjdDtcbiJdLCJuYW1lcyI6WyJTdHJlYW1IZWxwZXIiLCJyZXF1aXJlIiwiRGF0YVdvcmtlciIsInV0ZjgiLCJDb21wcmVzc2VkT2JqZWN0IiwiR2VuZXJpY1dvcmtlciIsIlppcE9iamVjdCIsIm5hbWUiLCJkYXRhIiwib3B0aW9ucyIsImRpciIsImRhdGUiLCJjb21tZW50IiwidW5peFBlcm1pc3Npb25zIiwiZG9zUGVybWlzc2lvbnMiLCJfZGF0YSIsIl9kYXRhQmluYXJ5IiwiYmluYXJ5IiwiY29tcHJlc3Npb24iLCJjb21wcmVzc2lvbk9wdGlvbnMiLCJwcm90b3R5cGUiLCJpbnRlcm5hbFN0cmVhbSIsInR5cGUiLCJyZXN1bHQiLCJvdXRwdXRUeXBlIiwiRXJyb3IiLCJ0b0xvd2VyQ2FzZSIsImFza1VuaWNvZGVTdHJpbmciLCJfZGVjb21wcmVzc1dvcmtlciIsImlzVW5pY29kZVN0cmluZyIsInBpcGUiLCJVdGY4RW5jb2RlV29ya2VyIiwiVXRmOERlY29kZVdvcmtlciIsImUiLCJlcnJvciIsImFzeW5jIiwib25VcGRhdGUiLCJhY2N1bXVsYXRlIiwibm9kZVN0cmVhbSIsInRvTm9kZWpzU3RyZWFtIiwiX2NvbXByZXNzV29ya2VyIiwibWFnaWMiLCJnZXRDb21wcmVzc2VkV29ya2VyIiwiY3JlYXRlV29ya2VyRnJvbSIsImdldENvbnRlbnRXb3JrZXIiLCJyZW1vdmVkTWV0aG9kcyIsInJlbW92ZWRGbiIsImkiLCJsZW5ndGgiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jszip/lib/zipObject.js\n");

/***/ })

};
;