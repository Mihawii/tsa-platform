"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pdfjs-dist";
exports.ids = ["vendor-chunks/pdfjs-dist"];
exports.modules = {

/***/ "(ssr)/./node_modules/pdfjs-dist/build/pdf.mjs":
/*!***********************************************!*\
  !*** ./node_modules/pdfjs-dist/build/pdf.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortException: () => (/* binding */ AbortException),\n/* harmony export */   AnnotationEditorLayer: () => (/* binding */ AnnotationEditorLayer),\n/* harmony export */   AnnotationEditorParamsType: () => (/* binding */ AnnotationEditorParamsType),\n/* harmony export */   AnnotationEditorType: () => (/* binding */ AnnotationEditorType),\n/* harmony export */   AnnotationEditorUIManager: () => (/* binding */ AnnotationEditorUIManager),\n/* harmony export */   AnnotationLayer: () => (/* binding */ AnnotationLayer),\n/* harmony export */   AnnotationMode: () => (/* binding */ AnnotationMode),\n/* harmony export */   AnnotationType: () => (/* binding */ AnnotationType),\n/* harmony export */   ColorPicker: () => (/* binding */ ColorPicker),\n/* harmony export */   DOMSVGFactory: () => (/* binding */ DOMSVGFactory),\n/* harmony export */   DrawLayer: () => (/* binding */ DrawLayer),\n/* harmony export */   FeatureTest: () => (/* binding */ util_FeatureTest),\n/* harmony export */   GlobalWorkerOptions: () => (/* binding */ GlobalWorkerOptions),\n/* harmony export */   ImageKind: () => (/* binding */ util_ImageKind),\n/* harmony export */   InvalidPDFException: () => (/* binding */ InvalidPDFException),\n/* harmony export */   MathClamp: () => (/* binding */ MathClamp),\n/* harmony export */   OPS: () => (/* binding */ OPS),\n/* harmony export */   OutputScale: () => (/* binding */ OutputScale),\n/* harmony export */   PDFDataRangeTransport: () => (/* binding */ PDFDataRangeTransport),\n/* harmony export */   PDFDateString: () => (/* binding */ PDFDateString),\n/* harmony export */   PDFWorker: () => (/* binding */ PDFWorker),\n/* harmony export */   PasswordResponses: () => (/* binding */ PasswordResponses),\n/* harmony export */   PermissionFlag: () => (/* binding */ PermissionFlag),\n/* harmony export */   PixelsPerInch: () => (/* binding */ PixelsPerInch),\n/* harmony export */   RenderingCancelledException: () => (/* binding */ RenderingCancelledException),\n/* harmony export */   ResponseException: () => (/* binding */ ResponseException),\n/* harmony export */   SignatureExtractor: () => (/* binding */ SignatureExtractor),\n/* harmony export */   SupportedImageMimeTypes: () => (/* binding */ SupportedImageMimeTypes),\n/* harmony export */   TextLayer: () => (/* binding */ TextLayer),\n/* harmony export */   TouchManager: () => (/* binding */ TouchManager),\n/* harmony export */   Util: () => (/* binding */ Util),\n/* harmony export */   VerbosityLevel: () => (/* binding */ VerbosityLevel),\n/* harmony export */   XfaLayer: () => (/* binding */ XfaLayer),\n/* harmony export */   build: () => (/* binding */ build),\n/* harmony export */   createValidAbsoluteUrl: () => (/* binding */ createValidAbsoluteUrl),\n/* harmony export */   fetchData: () => (/* binding */ fetchData),\n/* harmony export */   getDocument: () => (/* binding */ getDocument),\n/* harmony export */   getFilenameFromUrl: () => (/* binding */ getFilenameFromUrl),\n/* harmony export */   getPdfFilenameFromUrl: () => (/* binding */ getPdfFilenameFromUrl),\n/* harmony export */   getUuid: () => (/* binding */ getUuid),\n/* harmony export */   getXfaPageViewport: () => (/* binding */ getXfaPageViewport),\n/* harmony export */   isDataScheme: () => (/* binding */ isDataScheme),\n/* harmony export */   isPdfFile: () => (/* binding */ isPdfFile),\n/* harmony export */   isValidExplicitDest: () => (/* binding */ isValidExplicitDest),\n/* harmony export */   noContextMenu: () => (/* binding */ noContextMenu),\n/* harmony export */   normalizeUnicode: () => (/* binding */ normalizeUnicode),\n/* harmony export */   setLayerDimensions: () => (/* binding */ setLayerDimensions),\n/* harmony export */   shadow: () => (/* binding */ shadow),\n/* harmony export */   stopEvent: () => (/* binding */ stopEvent),\n/* harmony export */   updateUrlHash: () => (/* binding */ updateUrlHash),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n; // ./src/shared/util.js\nconst isNodeJS = typeof process === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\");\nconst FONT_IDENTITY_MATRIX = [\n    0.001,\n    0,\n    0,\n    0.001,\n    0,\n    0\n];\nconst LINE_FACTOR = 1.35;\nconst LINE_DESCENT_FACTOR = 0.35;\nconst BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;\nconst RenderingIntentFlag = {\n    ANY: 0x01,\n    DISPLAY: 0x02,\n    PRINT: 0x04,\n    SAVE: 0x08,\n    ANNOTATIONS_FORMS: 0x10,\n    ANNOTATIONS_STORAGE: 0x20,\n    ANNOTATIONS_DISABLE: 0x40,\n    IS_EDITING: 0x80,\n    OPLIST: 0x100\n};\nconst AnnotationMode = {\n    DISABLE: 0,\n    ENABLE: 1,\n    ENABLE_FORMS: 2,\n    ENABLE_STORAGE: 3\n};\nconst AnnotationEditorPrefix = \"pdfjs_internal_editor_\";\nconst AnnotationEditorType = {\n    DISABLE: -1,\n    NONE: 0,\n    FREETEXT: 3,\n    HIGHLIGHT: 9,\n    STAMP: 13,\n    INK: 15,\n    SIGNATURE: 101\n};\nconst AnnotationEditorParamsType = {\n    RESIZE: 1,\n    CREATE: 2,\n    FREETEXT_SIZE: 11,\n    FREETEXT_COLOR: 12,\n    FREETEXT_OPACITY: 13,\n    INK_COLOR: 21,\n    INK_THICKNESS: 22,\n    INK_OPACITY: 23,\n    HIGHLIGHT_COLOR: 31,\n    HIGHLIGHT_DEFAULT_COLOR: 32,\n    HIGHLIGHT_THICKNESS: 33,\n    HIGHLIGHT_FREE: 34,\n    HIGHLIGHT_SHOW_ALL: 35,\n    DRAW_STEP: 41\n};\nconst PermissionFlag = {\n    PRINT: 0x04,\n    MODIFY_CONTENTS: 0x08,\n    COPY: 0x10,\n    MODIFY_ANNOTATIONS: 0x20,\n    FILL_INTERACTIVE_FORMS: 0x100,\n    COPY_FOR_ACCESSIBILITY: 0x200,\n    ASSEMBLE: 0x400,\n    PRINT_HIGH_QUALITY: 0x800\n};\nconst TextRenderingMode = {\n    FILL: 0,\n    STROKE: 1,\n    FILL_STROKE: 2,\n    INVISIBLE: 3,\n    FILL_ADD_TO_PATH: 4,\n    STROKE_ADD_TO_PATH: 5,\n    FILL_STROKE_ADD_TO_PATH: 6,\n    ADD_TO_PATH: 7,\n    FILL_STROKE_MASK: 3,\n    ADD_TO_PATH_FLAG: 4\n};\nconst util_ImageKind = {\n    GRAYSCALE_1BPP: 1,\n    RGB_24BPP: 2,\n    RGBA_32BPP: 3\n};\nconst AnnotationType = {\n    TEXT: 1,\n    LINK: 2,\n    FREETEXT: 3,\n    LINE: 4,\n    SQUARE: 5,\n    CIRCLE: 6,\n    POLYGON: 7,\n    POLYLINE: 8,\n    HIGHLIGHT: 9,\n    UNDERLINE: 10,\n    SQUIGGLY: 11,\n    STRIKEOUT: 12,\n    STAMP: 13,\n    CARET: 14,\n    INK: 15,\n    POPUP: 16,\n    FILEATTACHMENT: 17,\n    SOUND: 18,\n    MOVIE: 19,\n    WIDGET: 20,\n    SCREEN: 21,\n    PRINTERMARK: 22,\n    TRAPNET: 23,\n    WATERMARK: 24,\n    THREED: 25,\n    REDACT: 26\n};\nconst AnnotationReplyType = {\n    GROUP: \"Group\",\n    REPLY: \"R\"\n};\nconst AnnotationFlag = {\n    INVISIBLE: 0x01,\n    HIDDEN: 0x02,\n    PRINT: 0x04,\n    NOZOOM: 0x08,\n    NOROTATE: 0x10,\n    NOVIEW: 0x20,\n    READONLY: 0x40,\n    LOCKED: 0x80,\n    TOGGLENOVIEW: 0x100,\n    LOCKEDCONTENTS: 0x200\n};\nconst AnnotationFieldFlag = {\n    READONLY: 0x0000001,\n    REQUIRED: 0x0000002,\n    NOEXPORT: 0x0000004,\n    MULTILINE: 0x0001000,\n    PASSWORD: 0x0002000,\n    NOTOGGLETOOFF: 0x0004000,\n    RADIO: 0x0008000,\n    PUSHBUTTON: 0x0010000,\n    COMBO: 0x0020000,\n    EDIT: 0x0040000,\n    SORT: 0x0080000,\n    FILESELECT: 0x0100000,\n    MULTISELECT: 0x0200000,\n    DONOTSPELLCHECK: 0x0400000,\n    DONOTSCROLL: 0x0800000,\n    COMB: 0x1000000,\n    RICHTEXT: 0x2000000,\n    RADIOSINUNISON: 0x2000000,\n    COMMITONSELCHANGE: 0x4000000\n};\nconst AnnotationBorderStyleType = {\n    SOLID: 1,\n    DASHED: 2,\n    BEVELED: 3,\n    INSET: 4,\n    UNDERLINE: 5\n};\nconst AnnotationActionEventType = {\n    E: \"Mouse Enter\",\n    X: \"Mouse Exit\",\n    D: \"Mouse Down\",\n    U: \"Mouse Up\",\n    Fo: \"Focus\",\n    Bl: \"Blur\",\n    PO: \"PageOpen\",\n    PC: \"PageClose\",\n    PV: \"PageVisible\",\n    PI: \"PageInvisible\",\n    K: \"Keystroke\",\n    F: \"Format\",\n    V: \"Validate\",\n    C: \"Calculate\"\n};\nconst DocumentActionEventType = {\n    WC: \"WillClose\",\n    WS: \"WillSave\",\n    DS: \"DidSave\",\n    WP: \"WillPrint\",\n    DP: \"DidPrint\"\n};\nconst PageActionEventType = {\n    O: \"PageOpen\",\n    C: \"PageClose\"\n};\nconst VerbosityLevel = {\n    ERRORS: 0,\n    WARNINGS: 1,\n    INFOS: 5\n};\nconst OPS = {\n    dependency: 1,\n    setLineWidth: 2,\n    setLineCap: 3,\n    setLineJoin: 4,\n    setMiterLimit: 5,\n    setDash: 6,\n    setRenderingIntent: 7,\n    setFlatness: 8,\n    setGState: 9,\n    save: 10,\n    restore: 11,\n    transform: 12,\n    moveTo: 13,\n    lineTo: 14,\n    curveTo: 15,\n    curveTo2: 16,\n    curveTo3: 17,\n    closePath: 18,\n    rectangle: 19,\n    stroke: 20,\n    closeStroke: 21,\n    fill: 22,\n    eoFill: 23,\n    fillStroke: 24,\n    eoFillStroke: 25,\n    closeFillStroke: 26,\n    closeEOFillStroke: 27,\n    endPath: 28,\n    clip: 29,\n    eoClip: 30,\n    beginText: 31,\n    endText: 32,\n    setCharSpacing: 33,\n    setWordSpacing: 34,\n    setHScale: 35,\n    setLeading: 36,\n    setFont: 37,\n    setTextRenderingMode: 38,\n    setTextRise: 39,\n    moveText: 40,\n    setLeadingMoveText: 41,\n    setTextMatrix: 42,\n    nextLine: 43,\n    showText: 44,\n    showSpacedText: 45,\n    nextLineShowText: 46,\n    nextLineSetSpacingShowText: 47,\n    setCharWidth: 48,\n    setCharWidthAndBounds: 49,\n    setStrokeColorSpace: 50,\n    setFillColorSpace: 51,\n    setStrokeColor: 52,\n    setStrokeColorN: 53,\n    setFillColor: 54,\n    setFillColorN: 55,\n    setStrokeGray: 56,\n    setFillGray: 57,\n    setStrokeRGBColor: 58,\n    setFillRGBColor: 59,\n    setStrokeCMYKColor: 60,\n    setFillCMYKColor: 61,\n    shadingFill: 62,\n    beginInlineImage: 63,\n    beginImageData: 64,\n    endInlineImage: 65,\n    paintXObject: 66,\n    markPoint: 67,\n    markPointProps: 68,\n    beginMarkedContent: 69,\n    beginMarkedContentProps: 70,\n    endMarkedContent: 71,\n    beginCompat: 72,\n    endCompat: 73,\n    paintFormXObjectBegin: 74,\n    paintFormXObjectEnd: 75,\n    beginGroup: 76,\n    endGroup: 77,\n    beginAnnotation: 80,\n    endAnnotation: 81,\n    paintImageMaskXObject: 83,\n    paintImageMaskXObjectGroup: 84,\n    paintImageXObject: 85,\n    paintInlineImageXObject: 86,\n    paintInlineImageXObjectGroup: 87,\n    paintImageXObjectRepeat: 88,\n    paintImageMaskXObjectRepeat: 89,\n    paintSolidColorImageMask: 90,\n    constructPath: 91,\n    setStrokeTransparent: 92,\n    setFillTransparent: 93,\n    rawFillPath: 94\n};\nconst DrawOPS = {\n    moveTo: 0,\n    lineTo: 1,\n    curveTo: 2,\n    closePath: 3\n};\nconst PasswordResponses = {\n    NEED_PASSWORD: 1,\n    INCORRECT_PASSWORD: 2\n};\nlet verbosity = VerbosityLevel.WARNINGS;\nfunction setVerbosityLevel(level) {\n    if (Number.isInteger(level)) {\n        verbosity = level;\n    }\n}\nfunction getVerbosityLevel() {\n    return verbosity;\n}\nfunction info(msg) {\n    if (verbosity >= VerbosityLevel.INFOS) {\n        console.log(`Info: ${msg}`);\n    }\n}\nfunction warn(msg) {\n    if (verbosity >= VerbosityLevel.WARNINGS) {\n        console.log(`Warning: ${msg}`);\n    }\n}\nfunction unreachable(msg) {\n    throw new Error(msg);\n}\nfunction assert(cond, msg) {\n    if (!cond) {\n        unreachable(msg);\n    }\n}\nfunction _isValidProtocol(url) {\n    switch(url?.protocol){\n        case \"http:\":\n        case \"https:\":\n        case \"ftp:\":\n        case \"mailto:\":\n        case \"tel:\":\n            return true;\n        default:\n            return false;\n    }\n}\nfunction createValidAbsoluteUrl(url, baseUrl = null, options = null) {\n    if (!url) {\n        return null;\n    }\n    if (options && typeof url === \"string\") {\n        if (options.addDefaultProtocol && url.startsWith(\"www.\")) {\n            const dots = url.match(/\\./g);\n            if (dots?.length >= 2) {\n                url = `http://${url}`;\n            }\n        }\n        if (options.tryConvertEncoding) {\n            try {\n                url = stringToUTF8String(url);\n            } catch  {}\n        }\n    }\n    const absoluteUrl = baseUrl ? URL.parse(url, baseUrl) : URL.parse(url);\n    return _isValidProtocol(absoluteUrl) ? absoluteUrl : null;\n}\nfunction updateUrlHash(url, hash, allowRel = false) {\n    const res = URL.parse(url);\n    if (res) {\n        res.hash = hash;\n        return res.href;\n    }\n    if (allowRel && createValidAbsoluteUrl(url, \"http://example.com\")) {\n        return url.split(\"#\", 1)[0] + `${hash ? `#${hash}` : \"\"}`;\n    }\n    return \"\";\n}\nfunction shadow(obj, prop, value, nonSerializable = false) {\n    Object.defineProperty(obj, prop, {\n        value,\n        enumerable: !nonSerializable,\n        configurable: true,\n        writable: false\n    });\n    return value;\n}\nconst BaseException = function BaseExceptionClosure() {\n    function BaseException(message, name) {\n        this.message = message;\n        this.name = name;\n    }\n    BaseException.prototype = new Error();\n    BaseException.constructor = BaseException;\n    return BaseException;\n}();\nclass PasswordException extends BaseException {\n    constructor(msg, code){\n        super(msg, \"PasswordException\");\n        this.code = code;\n    }\n}\nclass UnknownErrorException extends BaseException {\n    constructor(msg, details){\n        super(msg, \"UnknownErrorException\");\n        this.details = details;\n    }\n}\nclass InvalidPDFException extends BaseException {\n    constructor(msg){\n        super(msg, \"InvalidPDFException\");\n    }\n}\nclass ResponseException extends BaseException {\n    constructor(msg, status, missing){\n        super(msg, \"ResponseException\");\n        this.status = status;\n        this.missing = missing;\n    }\n}\nclass FormatError extends BaseException {\n    constructor(msg){\n        super(msg, \"FormatError\");\n    }\n}\nclass AbortException extends BaseException {\n    constructor(msg){\n        super(msg, \"AbortException\");\n    }\n}\nfunction bytesToString(bytes) {\n    if (typeof bytes !== \"object\" || bytes?.length === undefined) {\n        unreachable(\"Invalid argument for bytesToString\");\n    }\n    const length = bytes.length;\n    const MAX_ARGUMENT_COUNT = 8192;\n    if (length < MAX_ARGUMENT_COUNT) {\n        return String.fromCharCode.apply(null, bytes);\n    }\n    const strBuf = [];\n    for(let i = 0; i < length; i += MAX_ARGUMENT_COUNT){\n        const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n        const chunk = bytes.subarray(i, chunkEnd);\n        strBuf.push(String.fromCharCode.apply(null, chunk));\n    }\n    return strBuf.join(\"\");\n}\nfunction stringToBytes(str) {\n    if (typeof str !== \"string\") {\n        unreachable(\"Invalid argument for stringToBytes\");\n    }\n    const length = str.length;\n    const bytes = new Uint8Array(length);\n    for(let i = 0; i < length; ++i){\n        bytes[i] = str.charCodeAt(i) & 0xff;\n    }\n    return bytes;\n}\nfunction string32(value) {\n    return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\n}\nfunction objectSize(obj) {\n    return Object.keys(obj).length;\n}\nfunction isLittleEndian() {\n    const buffer8 = new Uint8Array(4);\n    buffer8[0] = 1;\n    const view32 = new Uint32Array(buffer8.buffer, 0, 1);\n    return view32[0] === 1;\n}\nfunction isEvalSupported() {\n    try {\n        new Function(\"\");\n        return true;\n    } catch  {\n        return false;\n    }\n}\nclass util_FeatureTest {\n    static get isLittleEndian() {\n        return shadow(this, \"isLittleEndian\", isLittleEndian());\n    }\n    static get isEvalSupported() {\n        return shadow(this, \"isEvalSupported\", isEvalSupported());\n    }\n    static get isOffscreenCanvasSupported() {\n        return shadow(this, \"isOffscreenCanvasSupported\", typeof OffscreenCanvas !== \"undefined\");\n    }\n    static get isImageDecoderSupported() {\n        return shadow(this, \"isImageDecoderSupported\", typeof ImageDecoder !== \"undefined\");\n    }\n    static get platform() {\n        if (typeof navigator !== \"undefined\" && typeof navigator?.platform === \"string\" && typeof navigator?.userAgent === \"string\") {\n            const { platform, userAgent } = navigator;\n            return shadow(this, \"platform\", {\n                isAndroid: userAgent.includes(\"Android\"),\n                isLinux: platform.includes(\"Linux\"),\n                isMac: platform.includes(\"Mac\"),\n                isWindows: platform.includes(\"Win\"),\n                isFirefox: userAgent.includes(\"Firefox\")\n            });\n        }\n        return shadow(this, \"platform\", {\n            isAndroid: false,\n            isLinux: false,\n            isMac: false,\n            isWindows: false,\n            isFirefox: false\n        });\n    }\n    static get isCSSRoundSupported() {\n        return shadow(this, \"isCSSRoundSupported\", globalThis.CSS?.supports?.(\"width: round(1.5px, 1px)\"));\n    }\n}\nconst hexNumbers = Array.from(Array(256).keys(), (n)=>n.toString(16).padStart(2, \"0\"));\nclass Util {\n    static makeHexColor(r, g, b) {\n        return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;\n    }\n    static scaleMinMax(transform, minMax) {\n        let temp;\n        if (transform[0]) {\n            if (transform[0] < 0) {\n                temp = minMax[0];\n                minMax[0] = minMax[2];\n                minMax[2] = temp;\n            }\n            minMax[0] *= transform[0];\n            minMax[2] *= transform[0];\n            if (transform[3] < 0) {\n                temp = minMax[1];\n                minMax[1] = minMax[3];\n                minMax[3] = temp;\n            }\n            minMax[1] *= transform[3];\n            minMax[3] *= transform[3];\n        } else {\n            temp = minMax[0];\n            minMax[0] = minMax[1];\n            minMax[1] = temp;\n            temp = minMax[2];\n            minMax[2] = minMax[3];\n            minMax[3] = temp;\n            if (transform[1] < 0) {\n                temp = minMax[1];\n                minMax[1] = minMax[3];\n                minMax[3] = temp;\n            }\n            minMax[1] *= transform[1];\n            minMax[3] *= transform[1];\n            if (transform[2] < 0) {\n                temp = minMax[0];\n                minMax[0] = minMax[2];\n                minMax[2] = temp;\n            }\n            minMax[0] *= transform[2];\n            minMax[2] *= transform[2];\n        }\n        minMax[0] += transform[4];\n        minMax[1] += transform[5];\n        minMax[2] += transform[4];\n        minMax[3] += transform[5];\n    }\n    static transform(m1, m2) {\n        return [\n            m1[0] * m2[0] + m1[2] * m2[1],\n            m1[1] * m2[0] + m1[3] * m2[1],\n            m1[0] * m2[2] + m1[2] * m2[3],\n            m1[1] * m2[2] + m1[3] * m2[3],\n            m1[0] * m2[4] + m1[2] * m2[5] + m1[4],\n            m1[1] * m2[4] + m1[3] * m2[5] + m1[5]\n        ];\n    }\n    static applyTransform(p, m, pos = 0) {\n        const p0 = p[pos];\n        const p1 = p[pos + 1];\n        p[pos] = p0 * m[0] + p1 * m[2] + m[4];\n        p[pos + 1] = p0 * m[1] + p1 * m[3] + m[5];\n    }\n    static applyTransformToBezier(p, transform, pos = 0) {\n        const m0 = transform[0];\n        const m1 = transform[1];\n        const m2 = transform[2];\n        const m3 = transform[3];\n        const m4 = transform[4];\n        const m5 = transform[5];\n        for(let i = 0; i < 6; i += 2){\n            const pI = p[pos + i];\n            const pI1 = p[pos + i + 1];\n            p[pos + i] = pI * m0 + pI1 * m2 + m4;\n            p[pos + i + 1] = pI * m1 + pI1 * m3 + m5;\n        }\n    }\n    static applyInverseTransform(p, m) {\n        const p0 = p[0];\n        const p1 = p[1];\n        const d = m[0] * m[3] - m[1] * m[2];\n        p[0] = (p0 * m[3] - p1 * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n        p[1] = (-p0 * m[1] + p1 * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n    }\n    static axialAlignedBoundingBox(rect, transform, output) {\n        const m0 = transform[0];\n        const m1 = transform[1];\n        const m2 = transform[2];\n        const m3 = transform[3];\n        const m4 = transform[4];\n        const m5 = transform[5];\n        const r0 = rect[0];\n        const r1 = rect[1];\n        const r2 = rect[2];\n        const r3 = rect[3];\n        let a0 = m0 * r0 + m4;\n        let a2 = a0;\n        let a1 = m0 * r2 + m4;\n        let a3 = a1;\n        let b0 = m3 * r1 + m5;\n        let b2 = b0;\n        let b1 = m3 * r3 + m5;\n        let b3 = b1;\n        if (m1 !== 0 || m2 !== 0) {\n            const m1r0 = m1 * r0;\n            const m1r2 = m1 * r2;\n            const m2r1 = m2 * r1;\n            const m2r3 = m2 * r3;\n            a0 += m2r1;\n            a3 += m2r1;\n            a1 += m2r3;\n            a2 += m2r3;\n            b0 += m1r0;\n            b3 += m1r0;\n            b1 += m1r2;\n            b2 += m1r2;\n        }\n        output[0] = Math.min(output[0], a0, a1, a2, a3);\n        output[1] = Math.min(output[1], b0, b1, b2, b3);\n        output[2] = Math.max(output[2], a0, a1, a2, a3);\n        output[3] = Math.max(output[3], b0, b1, b2, b3);\n    }\n    static inverseTransform(m) {\n        const d = m[0] * m[3] - m[1] * m[2];\n        return [\n            m[3] / d,\n            -m[1] / d,\n            -m[2] / d,\n            m[0] / d,\n            (m[2] * m[5] - m[4] * m[3]) / d,\n            (m[4] * m[1] - m[5] * m[0]) / d\n        ];\n    }\n    static singularValueDecompose2dScale(matrix, output) {\n        const m0 = matrix[0];\n        const m1 = matrix[1];\n        const m2 = matrix[2];\n        const m3 = matrix[3];\n        const a = m0 ** 2 + m1 ** 2;\n        const b = m0 * m2 + m1 * m3;\n        const c = m2 ** 2 + m3 ** 2;\n        const first = (a + c) / 2;\n        const second = Math.sqrt(first ** 2 - (a * c - b ** 2));\n        output[0] = Math.sqrt(first + second || 1);\n        output[1] = Math.sqrt(first - second || 1);\n    }\n    static normalizeRect(rect) {\n        const r = rect.slice(0);\n        if (rect[0] > rect[2]) {\n            r[0] = rect[2];\n            r[2] = rect[0];\n        }\n        if (rect[1] > rect[3]) {\n            r[1] = rect[3];\n            r[3] = rect[1];\n        }\n        return r;\n    }\n    static intersect(rect1, rect2) {\n        const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));\n        const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));\n        if (xLow > xHigh) {\n            return null;\n        }\n        const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));\n        const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));\n        if (yLow > yHigh) {\n            return null;\n        }\n        return [\n            xLow,\n            yLow,\n            xHigh,\n            yHigh\n        ];\n    }\n    static pointBoundingBox(x, y, minMax) {\n        minMax[0] = Math.min(minMax[0], x);\n        minMax[1] = Math.min(minMax[1], y);\n        minMax[2] = Math.max(minMax[2], x);\n        minMax[3] = Math.max(minMax[3], y);\n    }\n    static rectBoundingBox(x0, y0, x1, y1, minMax) {\n        minMax[0] = Math.min(minMax[0], x0, x1);\n        minMax[1] = Math.min(minMax[1], y0, y1);\n        minMax[2] = Math.max(minMax[2], x0, x1);\n        minMax[3] = Math.max(minMax[3], y0, y1);\n    }\n    static #getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, t, minMax) {\n        if (t <= 0 || t >= 1) {\n            return;\n        }\n        const mt = 1 - t;\n        const tt = t * t;\n        const ttt = tt * t;\n        const x = mt * (mt * (mt * x0 + 3 * t * x1) + 3 * tt * x2) + ttt * x3;\n        const y = mt * (mt * (mt * y0 + 3 * t * y1) + 3 * tt * y2) + ttt * y3;\n        minMax[0] = Math.min(minMax[0], x);\n        minMax[1] = Math.min(minMax[1], y);\n        minMax[2] = Math.max(minMax[2], x);\n        minMax[3] = Math.max(minMax[3], y);\n    }\n    static #getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, a, b, c, minMax) {\n        if (Math.abs(a) < 1e-12) {\n            if (Math.abs(b) >= 1e-12) {\n                this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, -c / b, minMax);\n            }\n            return;\n        }\n        const delta = b ** 2 - 4 * c * a;\n        if (delta < 0) {\n            return;\n        }\n        const sqrtDelta = Math.sqrt(delta);\n        const a2 = 2 * a;\n        this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b + sqrtDelta) / a2, minMax);\n        this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b - sqrtDelta) / a2, minMax);\n    }\n    static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax) {\n        minMax[0] = Math.min(minMax[0], x0, x3);\n        minMax[1] = Math.min(minMax[1], y0, y3);\n        minMax[2] = Math.max(minMax[2], x0, x3);\n        minMax[3] = Math.max(minMax[3], y0, y3);\n        this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-x0 + 3 * (x1 - x2) + x3), 6 * (x0 - 2 * x1 + x2), 3 * (x1 - x0), minMax);\n        this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-y0 + 3 * (y1 - y2) + y3), 6 * (y0 - 2 * y1 + y2), 3 * (y1 - y0), minMax);\n    }\n}\nconst PDFStringTranslateTable = /* unused pure expression or super */ null && 0;\nfunction stringToPDFString(str) {\n    if (str[0] >= \"\\xef\") {\n        let encoding;\n        if (str[0] === \"\\xfe\" && str[1] === \"\\xff\") {\n            encoding = \"utf-16be\";\n            if (str.length % 2 === 1) {\n                str = str.slice(0, -1);\n            }\n        } else if (str[0] === \"\\xff\" && str[1] === \"\\xfe\") {\n            encoding = \"utf-16le\";\n            if (str.length % 2 === 1) {\n                str = str.slice(0, -1);\n            }\n        } else if (str[0] === \"\\xef\" && str[1] === \"\\xbb\" && str[2] === \"\\xbf\") {\n            encoding = \"utf-8\";\n        }\n        if (encoding) {\n            try {\n                const decoder = new TextDecoder(encoding, {\n                    fatal: true\n                });\n                const buffer = stringToBytes(str);\n                const decoded = decoder.decode(buffer);\n                if (!decoded.includes(\"\\x1b\")) {\n                    return decoded;\n                }\n                return decoded.replaceAll(/\\x1b[^\\x1b]*(?:\\x1b|$)/g, \"\");\n            } catch (ex) {\n                warn(`stringToPDFString: \"${ex}\".`);\n            }\n        }\n    }\n    const strBuf = [];\n    for(let i = 0, ii = str.length; i < ii; i++){\n        const charCode = str.charCodeAt(i);\n        if (charCode === 0x1b) {\n            while(++i < ii && str.charCodeAt(i) !== 0x1b){}\n            continue;\n        }\n        const code = PDFStringTranslateTable[charCode];\n        strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\n    }\n    return strBuf.join(\"\");\n}\nfunction stringToUTF8String(str) {\n    return decodeURIComponent(escape(str));\n}\nfunction utf8StringToString(str) {\n    return unescape(encodeURIComponent(str));\n}\nfunction isArrayEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n    for(let i = 0, ii = arr1.length; i < ii; i++){\n        if (arr1[i] !== arr2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getModificationDate(date = new Date()) {\n    const buffer = [\n        date.getUTCFullYear().toString(),\n        (date.getUTCMonth() + 1).toString().padStart(2, \"0\"),\n        date.getUTCDate().toString().padStart(2, \"0\"),\n        date.getUTCHours().toString().padStart(2, \"0\"),\n        date.getUTCMinutes().toString().padStart(2, \"0\"),\n        date.getUTCSeconds().toString().padStart(2, \"0\")\n    ];\n    return buffer.join(\"\");\n}\nlet NormalizeRegex = null;\nlet NormalizationMap = null;\nfunction normalizeUnicode(str) {\n    if (!NormalizeRegex) {\n        NormalizeRegex = /([\\u00a0\\u00b5\\u037e\\u0eb3\\u2000-\\u200a\\u202f\\u2126\\ufb00-\\ufb04\\ufb06\\ufb20-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufba1\\ufba4-\\ufba9\\ufbae-\\ufbb1\\ufbd3-\\ufbdc\\ufbde-\\ufbe7\\ufbea-\\ufbf8\\ufbfc-\\ufbfd\\ufc00-\\ufc5d\\ufc64-\\ufcf1\\ufcf5-\\ufd3d\\ufd88\\ufdf4\\ufdfa-\\ufdfb\\ufe71\\ufe77\\ufe79\\ufe7b\\ufe7d]+)|(\\ufb05+)/gu;\n        NormalizationMap = new Map([\n            [\n                \"ﬅ\",\n                \"ſt\"\n            ]\n        ]);\n    }\n    return str.replaceAll(NormalizeRegex, (_, p1, p2)=>p1 ? p1.normalize(\"NFKC\") : NormalizationMap.get(p2));\n}\nfunction getUuid() {\n    if (typeof crypto.randomUUID === \"function\") {\n        return crypto.randomUUID();\n    }\n    const buf = new Uint8Array(32);\n    crypto.getRandomValues(buf);\n    return bytesToString(buf);\n}\nconst AnnotationPrefix = \"pdfjs_internal_id_\";\nfunction _isValidExplicitDest(validRef, validName, dest) {\n    if (!Array.isArray(dest) || dest.length < 2) {\n        return false;\n    }\n    const [page, zoom, ...args] = dest;\n    if (!validRef(page) && !Number.isInteger(page)) {\n        return false;\n    }\n    if (!validName(zoom)) {\n        return false;\n    }\n    const argsLen = args.length;\n    let allowNull = true;\n    switch(zoom.name){\n        case \"XYZ\":\n            if (argsLen < 2 || argsLen > 3) {\n                return false;\n            }\n            break;\n        case \"Fit\":\n        case \"FitB\":\n            return argsLen === 0;\n        case \"FitH\":\n        case \"FitBH\":\n        case \"FitV\":\n        case \"FitBV\":\n            if (argsLen > 1) {\n                return false;\n            }\n            break;\n        case \"FitR\":\n            if (argsLen !== 4) {\n                return false;\n            }\n            allowNull = false;\n            break;\n        default:\n            return false;\n    }\n    for (const arg of args){\n        if (typeof arg === \"number\" || allowNull && arg === null) {\n            continue;\n        }\n        return false;\n    }\n    return true;\n}\nfunction MathClamp(v, min, max) {\n    return Math.min(Math.max(v, min), max);\n}\nfunction toHexUtil(arr) {\n    if (Uint8Array.prototype.toHex) {\n        return arr.toHex();\n    }\n    return Array.from(arr, (num)=>hexNumbers[num]).join(\"\");\n}\nfunction toBase64Util(arr) {\n    if (Uint8Array.prototype.toBase64) {\n        return arr.toBase64();\n    }\n    return btoa(bytesToString(arr));\n}\nfunction fromBase64Util(str) {\n    if (Uint8Array.fromBase64) {\n        return Uint8Array.fromBase64(str);\n    }\n    return stringToBytes(atob(str));\n}\nif (typeof Promise.try !== \"function\") {\n    Promise.try = function(fn, ...args) {\n        return new Promise((resolve)=>{\n            resolve(fn(...args));\n        });\n    };\n}\nif (typeof Math.sumPrecise !== \"function\") {\n    Math.sumPrecise = function(numbers) {\n        return numbers.reduce((a, b)=>a + b, 0);\n    };\n}\n; // ./src/display/display_utils.js\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\nclass PixelsPerInch {\n    static{\n        this.CSS = 96.0;\n    }\n    static{\n        this.PDF = 72.0;\n    }\n    static{\n        this.PDF_TO_CSS_UNITS = this.CSS / this.PDF;\n    }\n}\nasync function fetchData(url, type = \"text\") {\n    if (isValidFetchUrl(url, document.baseURI)) {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(response.statusText);\n        }\n        switch(type){\n            case \"arraybuffer\":\n                return response.arrayBuffer();\n            case \"blob\":\n                return response.blob();\n            case \"json\":\n                return response.json();\n        }\n        return response.text();\n    }\n    return new Promise((resolve, reject)=>{\n        const request = new XMLHttpRequest();\n        request.open(\"GET\", url, true);\n        request.responseType = type;\n        request.onreadystatechange = ()=>{\n            if (request.readyState !== XMLHttpRequest.DONE) {\n                return;\n            }\n            if (request.status === 200 || request.status === 0) {\n                switch(type){\n                    case \"arraybuffer\":\n                    case \"blob\":\n                    case \"json\":\n                        resolve(request.response);\n                        return;\n                }\n                resolve(request.responseText);\n                return;\n            }\n            reject(new Error(request.statusText));\n        };\n        request.send(null);\n    });\n}\nclass PageViewport {\n    constructor({ viewBox, userUnit, scale, rotation, offsetX = 0, offsetY = 0, dontFlip = false }){\n        this.viewBox = viewBox;\n        this.userUnit = userUnit;\n        this.scale = scale;\n        this.rotation = rotation;\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        scale *= userUnit;\n        const centerX = (viewBox[2] + viewBox[0]) / 2;\n        const centerY = (viewBox[3] + viewBox[1]) / 2;\n        let rotateA, rotateB, rotateC, rotateD;\n        rotation %= 360;\n        if (rotation < 0) {\n            rotation += 360;\n        }\n        switch(rotation){\n            case 180:\n                rotateA = -1;\n                rotateB = 0;\n                rotateC = 0;\n                rotateD = 1;\n                break;\n            case 90:\n                rotateA = 0;\n                rotateB = 1;\n                rotateC = 1;\n                rotateD = 0;\n                break;\n            case 270:\n                rotateA = 0;\n                rotateB = -1;\n                rotateC = -1;\n                rotateD = 0;\n                break;\n            case 0:\n                rotateA = 1;\n                rotateB = 0;\n                rotateC = 0;\n                rotateD = -1;\n                break;\n            default:\n                throw new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\");\n        }\n        if (dontFlip) {\n            rotateC = -rotateC;\n            rotateD = -rotateD;\n        }\n        let offsetCanvasX, offsetCanvasY;\n        let width, height;\n        if (rotateA === 0) {\n            offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n            offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n            width = (viewBox[3] - viewBox[1]) * scale;\n            height = (viewBox[2] - viewBox[0]) * scale;\n        } else {\n            offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n            offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n            width = (viewBox[2] - viewBox[0]) * scale;\n            height = (viewBox[3] - viewBox[1]) * scale;\n        }\n        this.transform = [\n            rotateA * scale,\n            rotateB * scale,\n            rotateC * scale,\n            rotateD * scale,\n            offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY,\n            offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY\n        ];\n        this.width = width;\n        this.height = height;\n    }\n    get rawDims() {\n        const dims = this.viewBox;\n        return shadow(this, \"rawDims\", {\n            pageWidth: dims[2] - dims[0],\n            pageHeight: dims[3] - dims[1],\n            pageX: dims[0],\n            pageY: dims[1]\n        });\n    }\n    clone({ scale = this.scale, rotation = this.rotation, offsetX = this.offsetX, offsetY = this.offsetY, dontFlip = false } = {}) {\n        return new PageViewport({\n            viewBox: this.viewBox.slice(),\n            userUnit: this.userUnit,\n            scale,\n            rotation,\n            offsetX,\n            offsetY,\n            dontFlip\n        });\n    }\n    convertToViewportPoint(x, y) {\n        const p = [\n            x,\n            y\n        ];\n        Util.applyTransform(p, this.transform);\n        return p;\n    }\n    convertToViewportRectangle(rect) {\n        const topLeft = [\n            rect[0],\n            rect[1]\n        ];\n        Util.applyTransform(topLeft, this.transform);\n        const bottomRight = [\n            rect[2],\n            rect[3]\n        ];\n        Util.applyTransform(bottomRight, this.transform);\n        return [\n            topLeft[0],\n            topLeft[1],\n            bottomRight[0],\n            bottomRight[1]\n        ];\n    }\n    convertToPdfPoint(x, y) {\n        const p = [\n            x,\n            y\n        ];\n        Util.applyInverseTransform(p, this.transform);\n        return p;\n    }\n}\nclass RenderingCancelledException extends BaseException {\n    constructor(msg, extraDelay = 0){\n        super(msg, \"RenderingCancelledException\");\n        this.extraDelay = extraDelay;\n    }\n}\nfunction isDataScheme(url) {\n    const ii = url.length;\n    let i = 0;\n    while(i < ii && url[i].trim() === \"\"){\n        i++;\n    }\n    return url.substring(i, i + 5).toLowerCase() === \"data:\";\n}\nfunction isPdfFile(filename) {\n    return typeof filename === \"string\" && /\\.pdf$/i.test(filename);\n}\nfunction getFilenameFromUrl(url) {\n    [url] = url.split(/[#?]/, 1);\n    return url.substring(url.lastIndexOf(\"/\") + 1);\n}\nfunction getPdfFilenameFromUrl(url, defaultFilename = \"document.pdf\") {\n    if (typeof url !== \"string\") {\n        return defaultFilename;\n    }\n    if (isDataScheme(url)) {\n        warn('getPdfFilenameFromUrl: ignore \"data:\"-URL for performance reasons.');\n        return defaultFilename;\n    }\n    const reURI = /^(?:(?:[^:]+:)?\\/\\/[^/]+)?([^?#]*)(\\?[^#]*)?(#.*)?$/;\n    const reFilename = /[^/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i;\n    const splitURI = reURI.exec(url);\n    let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);\n    if (suggestedFilename) {\n        suggestedFilename = suggestedFilename[0];\n        if (suggestedFilename.includes(\"%\")) {\n            try {\n                suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];\n            } catch  {}\n        }\n    }\n    return suggestedFilename || defaultFilename;\n}\nclass StatTimer {\n    time(name) {\n        if (name in this.started) {\n            warn(`Timer is already running for ${name}`);\n        }\n        this.started[name] = Date.now();\n    }\n    timeEnd(name) {\n        if (!(name in this.started)) {\n            warn(`Timer has not been started for ${name}`);\n        }\n        this.times.push({\n            name,\n            start: this.started[name],\n            end: Date.now()\n        });\n        delete this.started[name];\n    }\n    toString() {\n        const outBuf = [];\n        let longest = 0;\n        for (const { name } of this.times){\n            longest = Math.max(name.length, longest);\n        }\n        for (const { name, start, end } of this.times){\n            outBuf.push(`${name.padEnd(longest)} ${end - start}ms\\n`);\n        }\n        return outBuf.join(\"\");\n    }\n    constructor(){\n        this.started = Object.create(null);\n        this.times = [];\n    }\n}\nfunction isValidFetchUrl(url, baseUrl) {\n    const res = baseUrl ? URL.parse(url, baseUrl) : URL.parse(url);\n    return res?.protocol === \"http:\" || res?.protocol === \"https:\";\n}\nfunction noContextMenu(e) {\n    e.preventDefault();\n}\nfunction stopEvent(e) {\n    e.preventDefault();\n    e.stopPropagation();\n}\nfunction deprecated(details) {\n    console.log(\"Deprecated API usage: \" + details);\n}\nclass PDFDateString {\n    static #regex;\n    static toDateObject(input) {\n        if (!input || typeof input !== \"string\") {\n            return null;\n        }\n        this.#regex ||= new RegExp(\"^D:\" + \"(\\\\d{4})\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"([Z|+|-])?\" + \"(\\\\d{2})?\" + \"'?\" + \"(\\\\d{2})?\" + \"'?\");\n        const matches = this.#regex.exec(input);\n        if (!matches) {\n            return null;\n        }\n        const year = parseInt(matches[1], 10);\n        let month = parseInt(matches[2], 10);\n        month = month >= 1 && month <= 12 ? month - 1 : 0;\n        let day = parseInt(matches[3], 10);\n        day = day >= 1 && day <= 31 ? day : 1;\n        let hour = parseInt(matches[4], 10);\n        hour = hour >= 0 && hour <= 23 ? hour : 0;\n        let minute = parseInt(matches[5], 10);\n        minute = minute >= 0 && minute <= 59 ? minute : 0;\n        let second = parseInt(matches[6], 10);\n        second = second >= 0 && second <= 59 ? second : 0;\n        const universalTimeRelation = matches[7] || \"Z\";\n        let offsetHour = parseInt(matches[8], 10);\n        offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\n        let offsetMinute = parseInt(matches[9], 10) || 0;\n        offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\n        if (universalTimeRelation === \"-\") {\n            hour += offsetHour;\n            minute += offsetMinute;\n        } else if (universalTimeRelation === \"+\") {\n            hour -= offsetHour;\n            minute -= offsetMinute;\n        }\n        return new Date(Date.UTC(year, month, day, hour, minute, second));\n    }\n}\nfunction getXfaPageViewport(xfaPage, { scale = 1, rotation = 0 }) {\n    const { width, height } = xfaPage.attributes.style;\n    const viewBox = [\n        0,\n        0,\n        parseInt(width),\n        parseInt(height)\n    ];\n    return new PageViewport({\n        viewBox,\n        userUnit: 1,\n        scale,\n        rotation\n    });\n}\nfunction getRGB(color) {\n    if (color.startsWith(\"#\")) {\n        const colorRGB = parseInt(color.slice(1), 16);\n        return [\n            (colorRGB & 0xff0000) >> 16,\n            (colorRGB & 0x00ff00) >> 8,\n            colorRGB & 0x0000ff\n        ];\n    }\n    if (color.startsWith(\"rgb(\")) {\n        return color.slice(4, -1).split(\",\").map((x)=>parseInt(x));\n    }\n    if (color.startsWith(\"rgba(\")) {\n        return color.slice(5, -1).split(\",\").map((x)=>parseInt(x)).slice(0, 3);\n    }\n    warn(`Not a valid color format: \"${color}\"`);\n    return [\n        0,\n        0,\n        0\n    ];\n}\nfunction getColorValues(colors) {\n    const span = document.createElement(\"span\");\n    span.style.visibility = \"hidden\";\n    span.style.colorScheme = \"only light\";\n    document.body.append(span);\n    for (const name of colors.keys()){\n        span.style.color = name;\n        const computedColor = window.getComputedStyle(span).color;\n        colors.set(name, getRGB(computedColor));\n    }\n    span.remove();\n}\nfunction getCurrentTransform(ctx) {\n    const { a, b, c, d, e, f } = ctx.getTransform();\n    return [\n        a,\n        b,\n        c,\n        d,\n        e,\n        f\n    ];\n}\nfunction getCurrentTransformInverse(ctx) {\n    const { a, b, c, d, e, f } = ctx.getTransform().invertSelf();\n    return [\n        a,\n        b,\n        c,\n        d,\n        e,\n        f\n    ];\n}\nfunction setLayerDimensions(div, viewport, mustFlip = false, mustRotate = true) {\n    if (viewport instanceof PageViewport) {\n        const { pageWidth, pageHeight } = viewport.rawDims;\n        const { style } = div;\n        const useRound = util_FeatureTest.isCSSRoundSupported;\n        const w = `var(--total-scale-factor) * ${pageWidth}px`, h = `var(--total-scale-factor) * ${pageHeight}px`;\n        const widthStr = useRound ? `round(down, ${w}, var(--scale-round-x))` : `calc(${w})`, heightStr = useRound ? `round(down, ${h}, var(--scale-round-y))` : `calc(${h})`;\n        if (!mustFlip || viewport.rotation % 180 === 0) {\n            style.width = widthStr;\n            style.height = heightStr;\n        } else {\n            style.width = heightStr;\n            style.height = widthStr;\n        }\n    }\n    if (mustRotate) {\n        div.setAttribute(\"data-main-rotation\", viewport.rotation);\n    }\n}\nclass OutputScale {\n    constructor(){\n        const { pixelRatio } = OutputScale;\n        this.sx = pixelRatio;\n        this.sy = pixelRatio;\n    }\n    get scaled() {\n        return this.sx !== 1 || this.sy !== 1;\n    }\n    get symmetric() {\n        return this.sx === this.sy;\n    }\n    limitCanvas(width, height, maxPixels, maxDim) {\n        let maxAreaScale = Infinity, maxWidthScale = Infinity, maxHeightScale = Infinity;\n        if (maxPixels > 0) {\n            maxAreaScale = Math.sqrt(maxPixels / (width * height));\n        }\n        if (maxDim !== -1) {\n            maxWidthScale = maxDim / width;\n            maxHeightScale = maxDim / height;\n        }\n        const maxScale = Math.min(maxAreaScale, maxWidthScale, maxHeightScale);\n        if (this.sx > maxScale || this.sy > maxScale) {\n            this.sx = maxScale;\n            this.sy = maxScale;\n            return true;\n        }\n        return false;\n    }\n    static get pixelRatio() {\n        return globalThis.devicePixelRatio || 1;\n    }\n}\nconst SupportedImageMimeTypes = [\n    \"image/apng\",\n    \"image/avif\",\n    \"image/bmp\",\n    \"image/gif\",\n    \"image/jpeg\",\n    \"image/png\",\n    \"image/svg+xml\",\n    \"image/webp\",\n    \"image/x-icon\"\n];\n; // ./src/display/editor/toolbar.js\nclass EditorToolbar {\n    #toolbar;\n    #colorPicker;\n    #editor;\n    #buttons;\n    #altText;\n    #signatureDescriptionButton;\n    static #l10nRemove = null;\n    constructor(editor){\n        this.#toolbar = null;\n        this.#colorPicker = null;\n        this.#buttons = null;\n        this.#altText = null;\n        this.#signatureDescriptionButton = null;\n        this.#editor = editor;\n        EditorToolbar.#l10nRemove ||= Object.freeze({\n            freetext: \"pdfjs-editor-remove-freetext-button\",\n            highlight: \"pdfjs-editor-remove-highlight-button\",\n            ink: \"pdfjs-editor-remove-ink-button\",\n            stamp: \"pdfjs-editor-remove-stamp-button\",\n            signature: \"pdfjs-editor-remove-signature-button\"\n        });\n    }\n    render() {\n        const editToolbar = this.#toolbar = document.createElement(\"div\");\n        editToolbar.classList.add(\"editToolbar\", \"hidden\");\n        editToolbar.setAttribute(\"role\", \"toolbar\");\n        const signal = this.#editor._uiManager._signal;\n        editToolbar.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        editToolbar.addEventListener(\"pointerdown\", EditorToolbar.#pointerDown, {\n            signal\n        });\n        const buttons = this.#buttons = document.createElement(\"div\");\n        buttons.className = \"buttons\";\n        editToolbar.append(buttons);\n        const position = this.#editor.toolbarPosition;\n        if (position) {\n            const { style } = editToolbar;\n            const x = this.#editor._uiManager.direction === \"ltr\" ? 1 - position[0] : position[0];\n            style.insetInlineEnd = `${100 * x}%`;\n            style.top = `calc(${100 * position[1]}% + var(--editor-toolbar-vert-offset))`;\n        }\n        this.#addDeleteButton();\n        return editToolbar;\n    }\n    get div() {\n        return this.#toolbar;\n    }\n    static #pointerDown(e) {\n        e.stopPropagation();\n    }\n    #focusIn(e) {\n        this.#editor._focusEventsAllowed = false;\n        stopEvent(e);\n    }\n    #focusOut(e) {\n        this.#editor._focusEventsAllowed = true;\n        stopEvent(e);\n    }\n    #addListenersToElement(element) {\n        const signal = this.#editor._uiManager._signal;\n        element.addEventListener(\"focusin\", this.#focusIn.bind(this), {\n            capture: true,\n            signal\n        });\n        element.addEventListener(\"focusout\", this.#focusOut.bind(this), {\n            capture: true,\n            signal\n        });\n        element.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n    }\n    hide() {\n        this.#toolbar.classList.add(\"hidden\");\n        this.#colorPicker?.hideDropdown();\n    }\n    show() {\n        this.#toolbar.classList.remove(\"hidden\");\n        this.#altText?.shown();\n    }\n    #addDeleteButton() {\n        const { editorType, _uiManager } = this.#editor;\n        const button = document.createElement(\"button\");\n        button.className = \"delete\";\n        button.tabIndex = 0;\n        button.setAttribute(\"data-l10n-id\", EditorToolbar.#l10nRemove[editorType]);\n        this.#addListenersToElement(button);\n        button.addEventListener(\"click\", (e)=>{\n            _uiManager.delete();\n        }, {\n            signal: _uiManager._signal\n        });\n        this.#buttons.append(button);\n    }\n    get #divider() {\n        const divider = document.createElement(\"div\");\n        divider.className = \"divider\";\n        return divider;\n    }\n    async addAltText(altText) {\n        const button = await altText.render();\n        this.#addListenersToElement(button);\n        this.#buttons.prepend(button, this.#divider);\n        this.#altText = altText;\n    }\n    addColorPicker(colorPicker) {\n        this.#colorPicker = colorPicker;\n        const button = colorPicker.renderButton();\n        this.#addListenersToElement(button);\n        this.#buttons.prepend(button, this.#divider);\n    }\n    async addEditSignatureButton(signatureManager) {\n        const button = this.#signatureDescriptionButton = await signatureManager.renderEditButton(this.#editor);\n        this.#addListenersToElement(button);\n        this.#buttons.prepend(button, this.#divider);\n    }\n    updateEditSignatureButton(description) {\n        if (this.#signatureDescriptionButton) {\n            this.#signatureDescriptionButton.title = description;\n        }\n    }\n    remove() {\n        this.#toolbar.remove();\n        this.#colorPicker?.destroy();\n        this.#colorPicker = null;\n    }\n}\nclass HighlightToolbar {\n    #buttons;\n    #toolbar;\n    #uiManager;\n    constructor(uiManager){\n        this.#buttons = null;\n        this.#toolbar = null;\n        this.#uiManager = uiManager;\n    }\n    #render() {\n        const editToolbar = this.#toolbar = document.createElement(\"div\");\n        editToolbar.className = \"editToolbar\";\n        editToolbar.setAttribute(\"role\", \"toolbar\");\n        editToolbar.addEventListener(\"contextmenu\", noContextMenu, {\n            signal: this.#uiManager._signal\n        });\n        const buttons = this.#buttons = document.createElement(\"div\");\n        buttons.className = \"buttons\";\n        editToolbar.append(buttons);\n        this.#addHighlightButton();\n        return editToolbar;\n    }\n    #getLastPoint(boxes, isLTR) {\n        let lastY = 0;\n        let lastX = 0;\n        for (const box of boxes){\n            const y = box.y + box.height;\n            if (y < lastY) {\n                continue;\n            }\n            const x = box.x + (isLTR ? box.width : 0);\n            if (y > lastY) {\n                lastX = x;\n                lastY = y;\n                continue;\n            }\n            if (isLTR) {\n                if (x > lastX) {\n                    lastX = x;\n                }\n            } else if (x < lastX) {\n                lastX = x;\n            }\n        }\n        return [\n            isLTR ? 1 - lastX : lastX,\n            lastY\n        ];\n    }\n    show(parent, boxes, isLTR) {\n        const [x, y] = this.#getLastPoint(boxes, isLTR);\n        const { style } = this.#toolbar ||= this.#render();\n        parent.append(this.#toolbar);\n        style.insetInlineEnd = `${100 * x}%`;\n        style.top = `calc(${100 * y}% + var(--editor-toolbar-vert-offset))`;\n    }\n    hide() {\n        this.#toolbar.remove();\n    }\n    #addHighlightButton() {\n        const button = document.createElement(\"button\");\n        button.className = \"highlightButton\";\n        button.tabIndex = 0;\n        button.setAttribute(\"data-l10n-id\", `pdfjs-highlight-floating-button1`);\n        const span = document.createElement(\"span\");\n        button.append(span);\n        span.className = \"visuallyHidden\";\n        span.setAttribute(\"data-l10n-id\", \"pdfjs-highlight-floating-button-label\");\n        const signal = this.#uiManager._signal;\n        button.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        button.addEventListener(\"click\", ()=>{\n            this.#uiManager.highlightSelection(\"floating_button\");\n        }, {\n            signal\n        });\n        this.#buttons.append(button);\n    }\n}\n; // ./src/display/editor/tools.js\nfunction bindEvents(obj, element, names) {\n    for (const name of names){\n        element.addEventListener(name, obj[name].bind(obj));\n    }\n}\nclass IdManager {\n    #id;\n    get id() {\n        return `${AnnotationEditorPrefix}${this.#id++}`;\n    }\n    constructor(){\n        this.#id = 0;\n    }\n}\nclass ImageManager {\n    #baseId;\n    #id;\n    #cache;\n    static get _isSVGFittingCanvas() {\n        const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n        const canvas = new OffscreenCanvas(1, 3);\n        const ctx = canvas.getContext(\"2d\", {\n            willReadFrequently: true\n        });\n        const image = new Image();\n        image.src = svg;\n        const promise = image.decode().then(()=>{\n            ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);\n            return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;\n        });\n        return shadow(this, \"_isSVGFittingCanvas\", promise);\n    }\n    async #get(key, rawData) {\n        this.#cache ||= new Map();\n        let data = this.#cache.get(key);\n        if (data === null) {\n            return null;\n        }\n        if (data?.bitmap) {\n            data.refCounter += 1;\n            return data;\n        }\n        try {\n            data ||= {\n                bitmap: null,\n                id: `image_${this.#baseId}_${this.#id++}`,\n                refCounter: 0,\n                isSvg: false\n            };\n            let image;\n            if (typeof rawData === \"string\") {\n                data.url = rawData;\n                image = await fetchData(rawData, \"blob\");\n            } else if (rawData instanceof File) {\n                image = data.file = rawData;\n            } else if (rawData instanceof Blob) {\n                image = rawData;\n            }\n            if (image.type === \"image/svg+xml\") {\n                const mustRemoveAspectRatioPromise = ImageManager._isSVGFittingCanvas;\n                const fileReader = new FileReader();\n                const imageElement = new Image();\n                const imagePromise = new Promise((resolve, reject)=>{\n                    imageElement.onload = ()=>{\n                        data.bitmap = imageElement;\n                        data.isSvg = true;\n                        resolve();\n                    };\n                    fileReader.onload = async ()=>{\n                        const url = data.svgUrl = fileReader.result;\n                        imageElement.src = await mustRemoveAspectRatioPromise ? `${url}#svgView(preserveAspectRatio(none))` : url;\n                    };\n                    imageElement.onerror = fileReader.onerror = reject;\n                });\n                fileReader.readAsDataURL(image);\n                await imagePromise;\n            } else {\n                data.bitmap = await createImageBitmap(image);\n            }\n            data.refCounter = 1;\n        } catch (e) {\n            warn(e);\n            data = null;\n        }\n        this.#cache.set(key, data);\n        if (data) {\n            this.#cache.set(data.id, data);\n        }\n        return data;\n    }\n    async getFromFile(file) {\n        const { lastModified, name, size, type } = file;\n        return this.#get(`${lastModified}_${name}_${size}_${type}`, file);\n    }\n    async getFromUrl(url) {\n        return this.#get(url, url);\n    }\n    async getFromBlob(id, blobPromise) {\n        const blob = await blobPromise;\n        return this.#get(id, blob);\n    }\n    async getFromId(id) {\n        this.#cache ||= new Map();\n        const data = this.#cache.get(id);\n        if (!data) {\n            return null;\n        }\n        if (data.bitmap) {\n            data.refCounter += 1;\n            return data;\n        }\n        if (data.file) {\n            return this.getFromFile(data.file);\n        }\n        if (data.blobPromise) {\n            const { blobPromise } = data;\n            delete data.blobPromise;\n            return this.getFromBlob(data.id, blobPromise);\n        }\n        return this.getFromUrl(data.url);\n    }\n    getFromCanvas(id, canvas) {\n        this.#cache ||= new Map();\n        let data = this.#cache.get(id);\n        if (data?.bitmap) {\n            data.refCounter += 1;\n            return data;\n        }\n        const offscreen = new OffscreenCanvas(canvas.width, canvas.height);\n        const ctx = offscreen.getContext(\"2d\");\n        ctx.drawImage(canvas, 0, 0);\n        data = {\n            bitmap: offscreen.transferToImageBitmap(),\n            id: `image_${this.#baseId}_${this.#id++}`,\n            refCounter: 1,\n            isSvg: false\n        };\n        this.#cache.set(id, data);\n        this.#cache.set(data.id, data);\n        return data;\n    }\n    getSvgUrl(id) {\n        const data = this.#cache.get(id);\n        if (!data?.isSvg) {\n            return null;\n        }\n        return data.svgUrl;\n    }\n    deleteId(id) {\n        this.#cache ||= new Map();\n        const data = this.#cache.get(id);\n        if (!data) {\n            return;\n        }\n        data.refCounter -= 1;\n        if (data.refCounter !== 0) {\n            return;\n        }\n        const { bitmap } = data;\n        if (!data.url && !data.file) {\n            const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);\n            const ctx = canvas.getContext(\"bitmaprenderer\");\n            ctx.transferFromImageBitmap(bitmap);\n            data.blobPromise = canvas.convertToBlob();\n        }\n        bitmap.close?.();\n        data.bitmap = null;\n    }\n    isValidId(id) {\n        return id.startsWith(`image_${this.#baseId}_`);\n    }\n    constructor(){\n        this.#baseId = getUuid();\n        this.#id = 0;\n        this.#cache = null;\n    }\n}\nclass CommandManager {\n    #commands;\n    #locked;\n    #maxSize;\n    #position;\n    constructor(maxSize = 128){\n        this.#commands = [];\n        this.#locked = false;\n        this.#position = -1;\n        this.#maxSize = maxSize;\n    }\n    add({ cmd, undo, post, mustExec, type = NaN, overwriteIfSameType = false, keepUndo = false }) {\n        if (mustExec) {\n            cmd();\n        }\n        if (this.#locked) {\n            return;\n        }\n        const save = {\n            cmd,\n            undo,\n            post,\n            type\n        };\n        if (this.#position === -1) {\n            if (this.#commands.length > 0) {\n                this.#commands.length = 0;\n            }\n            this.#position = 0;\n            this.#commands.push(save);\n            return;\n        }\n        if (overwriteIfSameType && this.#commands[this.#position].type === type) {\n            if (keepUndo) {\n                save.undo = this.#commands[this.#position].undo;\n            }\n            this.#commands[this.#position] = save;\n            return;\n        }\n        const next = this.#position + 1;\n        if (next === this.#maxSize) {\n            this.#commands.splice(0, 1);\n        } else {\n            this.#position = next;\n            if (next < this.#commands.length) {\n                this.#commands.splice(next);\n            }\n        }\n        this.#commands.push(save);\n    }\n    undo() {\n        if (this.#position === -1) {\n            return;\n        }\n        this.#locked = true;\n        const { undo, post } = this.#commands[this.#position];\n        undo();\n        post?.();\n        this.#locked = false;\n        this.#position -= 1;\n    }\n    redo() {\n        if (this.#position < this.#commands.length - 1) {\n            this.#position += 1;\n            this.#locked = true;\n            const { cmd, post } = this.#commands[this.#position];\n            cmd();\n            post?.();\n            this.#locked = false;\n        }\n    }\n    hasSomethingToUndo() {\n        return this.#position !== -1;\n    }\n    hasSomethingToRedo() {\n        return this.#position < this.#commands.length - 1;\n    }\n    cleanType(type) {\n        if (this.#position === -1) {\n            return;\n        }\n        for(let i = this.#position; i >= 0; i--){\n            if (this.#commands[i].type !== type) {\n                this.#commands.splice(i + 1, this.#position - i);\n                this.#position = i;\n                return;\n            }\n        }\n        this.#commands.length = 0;\n        this.#position = -1;\n    }\n    destroy() {\n        this.#commands = null;\n    }\n}\nclass KeyboardManager {\n    constructor(callbacks){\n        this.buffer = [];\n        this.callbacks = new Map();\n        this.allKeys = new Set();\n        const { isMac } = util_FeatureTest.platform;\n        for (const [keys, callback, options = {}] of callbacks){\n            for (const key of keys){\n                const isMacKey = key.startsWith(\"mac+\");\n                if (isMac && isMacKey) {\n                    this.callbacks.set(key.slice(4), {\n                        callback,\n                        options\n                    });\n                    this.allKeys.add(key.split(\"+\").at(-1));\n                } else if (!isMac && !isMacKey) {\n                    this.callbacks.set(key, {\n                        callback,\n                        options\n                    });\n                    this.allKeys.add(key.split(\"+\").at(-1));\n                }\n            }\n        }\n    }\n    #serialize(event) {\n        if (event.altKey) {\n            this.buffer.push(\"alt\");\n        }\n        if (event.ctrlKey) {\n            this.buffer.push(\"ctrl\");\n        }\n        if (event.metaKey) {\n            this.buffer.push(\"meta\");\n        }\n        if (event.shiftKey) {\n            this.buffer.push(\"shift\");\n        }\n        this.buffer.push(event.key);\n        const str = this.buffer.join(\"+\");\n        this.buffer.length = 0;\n        return str;\n    }\n    exec(self, event) {\n        if (!this.allKeys.has(event.key)) {\n            return;\n        }\n        const info = this.callbacks.get(this.#serialize(event));\n        if (!info) {\n            return;\n        }\n        const { callback, options: { bubbles = false, args = [], checker = null } } = info;\n        if (checker && !checker(self, event)) {\n            return;\n        }\n        callback.bind(self, ...args, event)();\n        if (!bubbles) {\n            stopEvent(event);\n        }\n    }\n}\nclass ColorManager {\n    static{\n        this._colorsMapping = new Map([\n            [\n                \"CanvasText\",\n                [\n                    0,\n                    0,\n                    0\n                ]\n            ],\n            [\n                \"Canvas\",\n                [\n                    255,\n                    255,\n                    255\n                ]\n            ]\n        ]);\n    }\n    get _colors() {\n        const colors = new Map([\n            [\n                \"CanvasText\",\n                null\n            ],\n            [\n                \"Canvas\",\n                null\n            ]\n        ]);\n        getColorValues(colors);\n        return shadow(this, \"_colors\", colors);\n    }\n    convert(color) {\n        const rgb = getRGB(color);\n        if (!window.matchMedia(\"(forced-colors: active)\").matches) {\n            return rgb;\n        }\n        for (const [name, RGB] of this._colors){\n            if (RGB.every((x, i)=>x === rgb[i])) {\n                return ColorManager._colorsMapping.get(name);\n            }\n        }\n        return rgb;\n    }\n    getHexCode(name) {\n        const rgb = this._colors.get(name);\n        if (!rgb) {\n            return name;\n        }\n        return Util.makeHexColor(...rgb);\n    }\n}\nclass AnnotationEditorUIManager {\n    #abortController;\n    #activeEditor;\n    #allEditors;\n    #allLayers;\n    #altTextManager;\n    #annotationStorage;\n    #changedExistingAnnotations;\n    #commandManager;\n    #copyPasteAC;\n    #currentDrawingSession;\n    #currentPageIndex;\n    #deletedAnnotationsElementIds;\n    #draggingEditors;\n    #editorTypes;\n    #editorsToRescale;\n    #enableHighlightFloatingButton;\n    #enableUpdatedAddImage;\n    #enableNewAltTextWhenAddingImage;\n    #filterFactory;\n    #focusMainContainerTimeoutId;\n    #focusManagerAC;\n    #highlightColors;\n    #highlightWhenShiftUp;\n    #highlightToolbar;\n    #idManager;\n    #isEnabled;\n    #isWaiting;\n    #keyboardManagerAC;\n    #lastActiveElement;\n    #mainHighlightColorPicker;\n    #missingCanvases;\n    #mlManager;\n    #mode;\n    #selectedEditors;\n    #selectedTextNode;\n    #signatureManager;\n    #pageColors;\n    #showAllStates;\n    #previousStates;\n    #translation;\n    #translationTimeoutId;\n    #container;\n    #viewer;\n    #updateModeCapability;\n    static{\n        this.TRANSLATE_SMALL = 1;\n    }\n    static{\n        this.TRANSLATE_BIG = 10;\n    }\n    static get _keyboardManager() {\n        const proto = AnnotationEditorUIManager.prototype;\n        const arrowChecker = (self)=>self.#container.contains(document.activeElement) && document.activeElement.tagName !== \"BUTTON\" && self.hasSomethingToControl();\n        const textInputChecker = (_self, { target: el })=>{\n            if (el instanceof HTMLInputElement) {\n                const { type } = el;\n                return type !== \"text\" && type !== \"number\";\n            }\n            return true;\n        };\n        const small = this.TRANSLATE_SMALL;\n        const big = this.TRANSLATE_BIG;\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ctrl+a\",\n                    \"mac+meta+a\"\n                ],\n                proto.selectAll,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+z\",\n                    \"mac+meta+z\"\n                ],\n                proto.undo,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+y\",\n                    \"ctrl+shift+z\",\n                    \"mac+meta+shift+z\",\n                    \"ctrl+shift+Z\",\n                    \"mac+meta+shift+Z\"\n                ],\n                proto.redo,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"Backspace\",\n                    \"alt+Backspace\",\n                    \"ctrl+Backspace\",\n                    \"shift+Backspace\",\n                    \"mac+Backspace\",\n                    \"mac+alt+Backspace\",\n                    \"mac+ctrl+Backspace\",\n                    \"Delete\",\n                    \"ctrl+Delete\",\n                    \"shift+Delete\",\n                    \"mac+Delete\"\n                ],\n                proto.delete,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"Enter\",\n                    \"mac+Enter\"\n                ],\n                proto.addNewEditorFromKeyboard,\n                {\n                    checker: (self, { target: el })=>!(el instanceof HTMLButtonElement) && self.#container.contains(el) && !self.isEnterHandled\n                }\n            ],\n            [\n                [\n                    \" \",\n                    \"mac+ \"\n                ],\n                proto.addNewEditorFromKeyboard,\n                {\n                    checker: (self, { target: el })=>!(el instanceof HTMLButtonElement) && self.#container.contains(document.activeElement)\n                }\n            ],\n            [\n                [\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                proto.unselectAll\n            ],\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        -small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowLeft\",\n                    \"mac+shift+ArrowLeft\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        -big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowRight\",\n                    \"mac+shift+ArrowRight\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        -small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowUp\",\n                    \"mac+shift+ArrowUp\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        -big\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowDown\",\n                    \"mac+shift+ArrowDown\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        big\n                    ],\n                    checker: arrowChecker\n                }\n            ]\n        ]));\n    }\n    constructor(container, viewer, altTextManager, signatureManager, eventBus, pdfDocument, pageColors, highlightColors, enableHighlightFloatingButton, enableUpdatedAddImage, enableNewAltTextWhenAddingImage, mlManager, editorUndoBar, supportsPinchToZoom){\n        this.#abortController = new AbortController();\n        this.#activeEditor = null;\n        this.#allEditors = new Map();\n        this.#allLayers = new Map();\n        this.#altTextManager = null;\n        this.#annotationStorage = null;\n        this.#changedExistingAnnotations = null;\n        this.#commandManager = new CommandManager();\n        this.#copyPasteAC = null;\n        this.#currentDrawingSession = null;\n        this.#currentPageIndex = 0;\n        this.#deletedAnnotationsElementIds = new Set();\n        this.#draggingEditors = null;\n        this.#editorTypes = null;\n        this.#editorsToRescale = new Set();\n        this._editorUndoBar = null;\n        this.#enableHighlightFloatingButton = false;\n        this.#enableUpdatedAddImage = false;\n        this.#enableNewAltTextWhenAddingImage = false;\n        this.#filterFactory = null;\n        this.#focusMainContainerTimeoutId = null;\n        this.#focusManagerAC = null;\n        this.#highlightColors = null;\n        this.#highlightWhenShiftUp = false;\n        this.#highlightToolbar = null;\n        this.#idManager = new IdManager();\n        this.#isEnabled = false;\n        this.#isWaiting = false;\n        this.#keyboardManagerAC = null;\n        this.#lastActiveElement = null;\n        this.#mainHighlightColorPicker = null;\n        this.#missingCanvases = null;\n        this.#mlManager = null;\n        this.#mode = AnnotationEditorType.NONE;\n        this.#selectedEditors = new Set();\n        this.#selectedTextNode = null;\n        this.#signatureManager = null;\n        this.#pageColors = null;\n        this.#showAllStates = null;\n        this.#previousStates = {\n            isEditing: false,\n            isEmpty: true,\n            hasSomethingToUndo: false,\n            hasSomethingToRedo: false,\n            hasSelectedEditor: false,\n            hasSelectedText: false\n        };\n        this.#translation = [\n            0,\n            0\n        ];\n        this.#translationTimeoutId = null;\n        this.#container = null;\n        this.#viewer = null;\n        this.#updateModeCapability = null;\n        const signal = this._signal = this.#abortController.signal;\n        this.#container = container;\n        this.#viewer = viewer;\n        this.#altTextManager = altTextManager;\n        this.#signatureManager = signatureManager;\n        this._eventBus = eventBus;\n        eventBus._on(\"editingaction\", this.onEditingAction.bind(this), {\n            signal\n        });\n        eventBus._on(\"pagechanging\", this.onPageChanging.bind(this), {\n            signal\n        });\n        eventBus._on(\"scalechanging\", this.onScaleChanging.bind(this), {\n            signal\n        });\n        eventBus._on(\"rotationchanging\", this.onRotationChanging.bind(this), {\n            signal\n        });\n        eventBus._on(\"setpreference\", this.onSetPreference.bind(this), {\n            signal\n        });\n        eventBus._on(\"switchannotationeditorparams\", (evt)=>this.updateParams(evt.type, evt.value), {\n            signal\n        });\n        this.#addSelectionListener();\n        this.#addDragAndDropListeners();\n        this.#addKeyboardManager();\n        this.#annotationStorage = pdfDocument.annotationStorage;\n        this.#filterFactory = pdfDocument.filterFactory;\n        this.#pageColors = pageColors;\n        this.#highlightColors = highlightColors || null;\n        this.#enableHighlightFloatingButton = enableHighlightFloatingButton;\n        this.#enableUpdatedAddImage = enableUpdatedAddImage;\n        this.#enableNewAltTextWhenAddingImage = enableNewAltTextWhenAddingImage;\n        this.#mlManager = mlManager || null;\n        this.viewParameters = {\n            realScale: PixelsPerInch.PDF_TO_CSS_UNITS,\n            rotation: 0\n        };\n        this.isShiftKeyDown = false;\n        this._editorUndoBar = editorUndoBar || null;\n        this._supportsPinchToZoom = supportsPinchToZoom !== false;\n    }\n    destroy() {\n        this.#updateModeCapability?.resolve();\n        this.#updateModeCapability = null;\n        this.#abortController?.abort();\n        this.#abortController = null;\n        this._signal = null;\n        for (const layer of this.#allLayers.values()){\n            layer.destroy();\n        }\n        this.#allLayers.clear();\n        this.#allEditors.clear();\n        this.#editorsToRescale.clear();\n        this.#missingCanvases?.clear();\n        this.#activeEditor = null;\n        this.#selectedEditors.clear();\n        this.#commandManager.destroy();\n        this.#altTextManager?.destroy();\n        this.#signatureManager?.destroy();\n        this.#highlightToolbar?.hide();\n        this.#highlightToolbar = null;\n        this.#mainHighlightColorPicker?.destroy();\n        this.#mainHighlightColorPicker = null;\n        if (this.#focusMainContainerTimeoutId) {\n            clearTimeout(this.#focusMainContainerTimeoutId);\n            this.#focusMainContainerTimeoutId = null;\n        }\n        if (this.#translationTimeoutId) {\n            clearTimeout(this.#translationTimeoutId);\n            this.#translationTimeoutId = null;\n        }\n        this._editorUndoBar?.destroy();\n    }\n    combinedSignal(ac) {\n        return AbortSignal.any([\n            this._signal,\n            ac.signal\n        ]);\n    }\n    get mlManager() {\n        return this.#mlManager;\n    }\n    get useNewAltTextFlow() {\n        return this.#enableUpdatedAddImage;\n    }\n    get useNewAltTextWhenAddingImage() {\n        return this.#enableNewAltTextWhenAddingImage;\n    }\n    get hcmFilter() {\n        return shadow(this, \"hcmFilter\", this.#pageColors ? this.#filterFactory.addHCMFilter(this.#pageColors.foreground, this.#pageColors.background) : \"none\");\n    }\n    get direction() {\n        return shadow(this, \"direction\", getComputedStyle(this.#container).direction);\n    }\n    get highlightColors() {\n        return shadow(this, \"highlightColors\", this.#highlightColors ? new Map(this.#highlightColors.split(\",\").map((pair)=>pair.split(\"=\").map((x)=>x.trim()))) : null);\n    }\n    get highlightColorNames() {\n        return shadow(this, \"highlightColorNames\", this.highlightColors ? new Map(Array.from(this.highlightColors, (e)=>e.reverse())) : null);\n    }\n    setCurrentDrawingSession(layer) {\n        if (layer) {\n            this.unselectAll();\n            this.disableUserSelect(true);\n        } else {\n            this.disableUserSelect(false);\n        }\n        this.#currentDrawingSession = layer;\n    }\n    setMainHighlightColorPicker(colorPicker) {\n        this.#mainHighlightColorPicker = colorPicker;\n    }\n    editAltText(editor, firstTime = false) {\n        this.#altTextManager?.editAltText(this, editor, firstTime);\n    }\n    getSignature(editor) {\n        this.#signatureManager?.getSignature({\n            uiManager: this,\n            editor\n        });\n    }\n    get signatureManager() {\n        return this.#signatureManager;\n    }\n    switchToMode(mode, callback) {\n        this._eventBus.on(\"annotationeditormodechanged\", callback, {\n            once: true,\n            signal: this._signal\n        });\n        this._eventBus.dispatch(\"showannotationeditorui\", {\n            source: this,\n            mode\n        });\n    }\n    setPreference(name, value) {\n        this._eventBus.dispatch(\"setpreference\", {\n            source: this,\n            name,\n            value\n        });\n    }\n    onSetPreference({ name, value }) {\n        switch(name){\n            case \"enableNewAltTextWhenAddingImage\":\n                this.#enableNewAltTextWhenAddingImage = value;\n                break;\n        }\n    }\n    onPageChanging({ pageNumber }) {\n        this.#currentPageIndex = pageNumber - 1;\n    }\n    focusMainContainer() {\n        this.#container.focus();\n    }\n    findParent(x, y) {\n        for (const layer of this.#allLayers.values()){\n            const { x: layerX, y: layerY, width, height } = layer.div.getBoundingClientRect();\n            if (x >= layerX && x <= layerX + width && y >= layerY && y <= layerY + height) {\n                return layer;\n            }\n        }\n        return null;\n    }\n    disableUserSelect(value = false) {\n        this.#viewer.classList.toggle(\"noUserSelect\", value);\n    }\n    addShouldRescale(editor) {\n        this.#editorsToRescale.add(editor);\n    }\n    removeShouldRescale(editor) {\n        this.#editorsToRescale.delete(editor);\n    }\n    onScaleChanging({ scale }) {\n        this.commitOrRemove();\n        this.viewParameters.realScale = scale * PixelsPerInch.PDF_TO_CSS_UNITS;\n        for (const editor of this.#editorsToRescale){\n            editor.onScaleChanging();\n        }\n        this.#currentDrawingSession?.onScaleChanging();\n    }\n    onRotationChanging({ pagesRotation }) {\n        this.commitOrRemove();\n        this.viewParameters.rotation = pagesRotation;\n    }\n    #getAnchorElementForSelection({ anchorNode }) {\n        return anchorNode.nodeType === Node.TEXT_NODE ? anchorNode.parentElement : anchorNode;\n    }\n    #getLayerForTextLayer(textLayer) {\n        const { currentLayer } = this;\n        if (currentLayer.hasTextLayer(textLayer)) {\n            return currentLayer;\n        }\n        for (const layer of this.#allLayers.values()){\n            if (layer.hasTextLayer(textLayer)) {\n                return layer;\n            }\n        }\n        return null;\n    }\n    highlightSelection(methodOfCreation = \"\") {\n        const selection = document.getSelection();\n        if (!selection || selection.isCollapsed) {\n            return;\n        }\n        const { anchorNode, anchorOffset, focusNode, focusOffset } = selection;\n        const text = selection.toString();\n        const anchorElement = this.#getAnchorElementForSelection(selection);\n        const textLayer = anchorElement.closest(\".textLayer\");\n        const boxes = this.getSelectionBoxes(textLayer);\n        if (!boxes) {\n            return;\n        }\n        selection.empty();\n        const layer = this.#getLayerForTextLayer(textLayer);\n        const isNoneMode = this.#mode === AnnotationEditorType.NONE;\n        const callback = ()=>{\n            layer?.createAndAddNewEditor({\n                x: 0,\n                y: 0\n            }, false, {\n                methodOfCreation,\n                boxes,\n                anchorNode,\n                anchorOffset,\n                focusNode,\n                focusOffset,\n                text\n            });\n            if (isNoneMode) {\n                this.showAllEditors(\"highlight\", true, true);\n            }\n        };\n        if (isNoneMode) {\n            this.switchToMode(AnnotationEditorType.HIGHLIGHT, callback);\n            return;\n        }\n        callback();\n    }\n    #displayHighlightToolbar() {\n        const selection = document.getSelection();\n        if (!selection || selection.isCollapsed) {\n            return;\n        }\n        const anchorElement = this.#getAnchorElementForSelection(selection);\n        const textLayer = anchorElement.closest(\".textLayer\");\n        const boxes = this.getSelectionBoxes(textLayer);\n        if (!boxes) {\n            return;\n        }\n        this.#highlightToolbar ||= new HighlightToolbar(this);\n        this.#highlightToolbar.show(textLayer, boxes, this.direction === \"ltr\");\n    }\n    addToAnnotationStorage(editor) {\n        if (!editor.isEmpty() && this.#annotationStorage && !this.#annotationStorage.has(editor.id)) {\n            this.#annotationStorage.setValue(editor.id, editor);\n        }\n    }\n    #selectionChange() {\n        const selection = document.getSelection();\n        if (!selection || selection.isCollapsed) {\n            if (this.#selectedTextNode) {\n                this.#highlightToolbar?.hide();\n                this.#selectedTextNode = null;\n                this.#dispatchUpdateStates({\n                    hasSelectedText: false\n                });\n            }\n            return;\n        }\n        const { anchorNode } = selection;\n        if (anchorNode === this.#selectedTextNode) {\n            return;\n        }\n        const anchorElement = this.#getAnchorElementForSelection(selection);\n        const textLayer = anchorElement.closest(\".textLayer\");\n        if (!textLayer) {\n            if (this.#selectedTextNode) {\n                this.#highlightToolbar?.hide();\n                this.#selectedTextNode = null;\n                this.#dispatchUpdateStates({\n                    hasSelectedText: false\n                });\n            }\n            return;\n        }\n        this.#highlightToolbar?.hide();\n        this.#selectedTextNode = anchorNode;\n        this.#dispatchUpdateStates({\n            hasSelectedText: true\n        });\n        if (this.#mode !== AnnotationEditorType.HIGHLIGHT && this.#mode !== AnnotationEditorType.NONE) {\n            return;\n        }\n        if (this.#mode === AnnotationEditorType.HIGHLIGHT) {\n            this.showAllEditors(\"highlight\", true, true);\n        }\n        this.#highlightWhenShiftUp = this.isShiftKeyDown;\n        if (!this.isShiftKeyDown) {\n            const activeLayer = this.#mode === AnnotationEditorType.HIGHLIGHT ? this.#getLayerForTextLayer(textLayer) : null;\n            activeLayer?.toggleDrawing();\n            const ac = new AbortController();\n            const signal = this.combinedSignal(ac);\n            const pointerup = (e)=>{\n                if (e.type === \"pointerup\" && e.button !== 0) {\n                    return;\n                }\n                ac.abort();\n                activeLayer?.toggleDrawing(true);\n                if (e.type === \"pointerup\") {\n                    this.#onSelectEnd(\"main_toolbar\");\n                }\n            };\n            window.addEventListener(\"pointerup\", pointerup, {\n                signal\n            });\n            window.addEventListener(\"blur\", pointerup, {\n                signal\n            });\n        }\n    }\n    #onSelectEnd(methodOfCreation = \"\") {\n        if (this.#mode === AnnotationEditorType.HIGHLIGHT) {\n            this.highlightSelection(methodOfCreation);\n        } else if (this.#enableHighlightFloatingButton) {\n            this.#displayHighlightToolbar();\n        }\n    }\n    #addSelectionListener() {\n        document.addEventListener(\"selectionchange\", this.#selectionChange.bind(this), {\n            signal: this._signal\n        });\n    }\n    #addFocusManager() {\n        if (this.#focusManagerAC) {\n            return;\n        }\n        this.#focusManagerAC = new AbortController();\n        const signal = this.combinedSignal(this.#focusManagerAC);\n        window.addEventListener(\"focus\", this.focus.bind(this), {\n            signal\n        });\n        window.addEventListener(\"blur\", this.blur.bind(this), {\n            signal\n        });\n    }\n    #removeFocusManager() {\n        this.#focusManagerAC?.abort();\n        this.#focusManagerAC = null;\n    }\n    blur() {\n        this.isShiftKeyDown = false;\n        if (this.#highlightWhenShiftUp) {\n            this.#highlightWhenShiftUp = false;\n            this.#onSelectEnd(\"main_toolbar\");\n        }\n        if (!this.hasSelection) {\n            return;\n        }\n        const { activeElement } = document;\n        for (const editor of this.#selectedEditors){\n            if (editor.div.contains(activeElement)) {\n                this.#lastActiveElement = [\n                    editor,\n                    activeElement\n                ];\n                editor._focusEventsAllowed = false;\n                break;\n            }\n        }\n    }\n    focus() {\n        if (!this.#lastActiveElement) {\n            return;\n        }\n        const [lastEditor, lastActiveElement] = this.#lastActiveElement;\n        this.#lastActiveElement = null;\n        lastActiveElement.addEventListener(\"focusin\", ()=>{\n            lastEditor._focusEventsAllowed = true;\n        }, {\n            once: true,\n            signal: this._signal\n        });\n        lastActiveElement.focus();\n    }\n    #addKeyboardManager() {\n        if (this.#keyboardManagerAC) {\n            return;\n        }\n        this.#keyboardManagerAC = new AbortController();\n        const signal = this.combinedSignal(this.#keyboardManagerAC);\n        window.addEventListener(\"keydown\", this.keydown.bind(this), {\n            signal\n        });\n        window.addEventListener(\"keyup\", this.keyup.bind(this), {\n            signal\n        });\n    }\n    #removeKeyboardManager() {\n        this.#keyboardManagerAC?.abort();\n        this.#keyboardManagerAC = null;\n    }\n    #addCopyPasteListeners() {\n        if (this.#copyPasteAC) {\n            return;\n        }\n        this.#copyPasteAC = new AbortController();\n        const signal = this.combinedSignal(this.#copyPasteAC);\n        document.addEventListener(\"copy\", this.copy.bind(this), {\n            signal\n        });\n        document.addEventListener(\"cut\", this.cut.bind(this), {\n            signal\n        });\n        document.addEventListener(\"paste\", this.paste.bind(this), {\n            signal\n        });\n    }\n    #removeCopyPasteListeners() {\n        this.#copyPasteAC?.abort();\n        this.#copyPasteAC = null;\n    }\n    #addDragAndDropListeners() {\n        const signal = this._signal;\n        document.addEventListener(\"dragover\", this.dragOver.bind(this), {\n            signal\n        });\n        document.addEventListener(\"drop\", this.drop.bind(this), {\n            signal\n        });\n    }\n    addEditListeners() {\n        this.#addKeyboardManager();\n        this.#addCopyPasteListeners();\n    }\n    removeEditListeners() {\n        this.#removeKeyboardManager();\n        this.#removeCopyPasteListeners();\n    }\n    dragOver(event) {\n        for (const { type } of event.dataTransfer.items){\n            for (const editorType of this.#editorTypes){\n                if (editorType.isHandlingMimeForPasting(type)) {\n                    event.dataTransfer.dropEffect = \"copy\";\n                    event.preventDefault();\n                    return;\n                }\n            }\n        }\n    }\n    drop(event) {\n        for (const item of event.dataTransfer.items){\n            for (const editorType of this.#editorTypes){\n                if (editorType.isHandlingMimeForPasting(item.type)) {\n                    editorType.paste(item, this.currentLayer);\n                    event.preventDefault();\n                    return;\n                }\n            }\n        }\n    }\n    copy(event) {\n        event.preventDefault();\n        this.#activeEditor?.commitOrRemove();\n        if (!this.hasSelection) {\n            return;\n        }\n        const editors = [];\n        for (const editor of this.#selectedEditors){\n            const serialized = editor.serialize(true);\n            if (serialized) {\n                editors.push(serialized);\n            }\n        }\n        if (editors.length === 0) {\n            return;\n        }\n        event.clipboardData.setData(\"application/pdfjs\", JSON.stringify(editors));\n    }\n    cut(event) {\n        this.copy(event);\n        this.delete();\n    }\n    async paste(event) {\n        event.preventDefault();\n        const { clipboardData } = event;\n        for (const item of clipboardData.items){\n            for (const editorType of this.#editorTypes){\n                if (editorType.isHandlingMimeForPasting(item.type)) {\n                    editorType.paste(item, this.currentLayer);\n                    return;\n                }\n            }\n        }\n        let data = clipboardData.getData(\"application/pdfjs\");\n        if (!data) {\n            return;\n        }\n        try {\n            data = JSON.parse(data);\n        } catch (ex) {\n            warn(`paste: \"${ex.message}\".`);\n            return;\n        }\n        if (!Array.isArray(data)) {\n            return;\n        }\n        this.unselectAll();\n        const layer = this.currentLayer;\n        try {\n            const newEditors = [];\n            for (const editor of data){\n                const deserializedEditor = await layer.deserialize(editor);\n                if (!deserializedEditor) {\n                    return;\n                }\n                newEditors.push(deserializedEditor);\n            }\n            const cmd = ()=>{\n                for (const editor of newEditors){\n                    this.#addEditorToLayer(editor);\n                }\n                this.#selectEditors(newEditors);\n            };\n            const undo = ()=>{\n                for (const editor of newEditors){\n                    editor.remove();\n                }\n            };\n            this.addCommands({\n                cmd,\n                undo,\n                mustExec: true\n            });\n        } catch (ex) {\n            warn(`paste: \"${ex.message}\".`);\n        }\n    }\n    keydown(event) {\n        if (!this.isShiftKeyDown && event.key === \"Shift\") {\n            this.isShiftKeyDown = true;\n        }\n        if (this.#mode !== AnnotationEditorType.NONE && !this.isEditorHandlingKeyboard) {\n            AnnotationEditorUIManager._keyboardManager.exec(this, event);\n        }\n    }\n    keyup(event) {\n        if (this.isShiftKeyDown && event.key === \"Shift\") {\n            this.isShiftKeyDown = false;\n            if (this.#highlightWhenShiftUp) {\n                this.#highlightWhenShiftUp = false;\n                this.#onSelectEnd(\"main_toolbar\");\n            }\n        }\n    }\n    onEditingAction({ name }) {\n        switch(name){\n            case \"undo\":\n            case \"redo\":\n            case \"delete\":\n            case \"selectAll\":\n                this[name]();\n                break;\n            case \"highlightSelection\":\n                this.highlightSelection(\"context_menu\");\n                break;\n        }\n    }\n    #dispatchUpdateStates(details) {\n        const hasChanged = Object.entries(details).some(([key, value])=>this.#previousStates[key] !== value);\n        if (hasChanged) {\n            this._eventBus.dispatch(\"annotationeditorstateschanged\", {\n                source: this,\n                details: Object.assign(this.#previousStates, details)\n            });\n            if (this.#mode === AnnotationEditorType.HIGHLIGHT && details.hasSelectedEditor === false) {\n                this.#dispatchUpdateUI([\n                    [\n                        AnnotationEditorParamsType.HIGHLIGHT_FREE,\n                        true\n                    ]\n                ]);\n            }\n        }\n    }\n    #dispatchUpdateUI(details) {\n        this._eventBus.dispatch(\"annotationeditorparamschanged\", {\n            source: this,\n            details\n        });\n    }\n    setEditingState(isEditing) {\n        if (isEditing) {\n            this.#addFocusManager();\n            this.#addCopyPasteListeners();\n            this.#dispatchUpdateStates({\n                isEditing: this.#mode !== AnnotationEditorType.NONE,\n                isEmpty: this.#isEmpty(),\n                hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n                hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n                hasSelectedEditor: false\n            });\n        } else {\n            this.#removeFocusManager();\n            this.#removeCopyPasteListeners();\n            this.#dispatchUpdateStates({\n                isEditing: false\n            });\n            this.disableUserSelect(false);\n        }\n    }\n    registerEditorTypes(types) {\n        if (this.#editorTypes) {\n            return;\n        }\n        this.#editorTypes = types;\n        for (const editorType of this.#editorTypes){\n            this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);\n        }\n    }\n    getId() {\n        return this.#idManager.id;\n    }\n    get currentLayer() {\n        return this.#allLayers.get(this.#currentPageIndex);\n    }\n    getLayer(pageIndex) {\n        return this.#allLayers.get(pageIndex);\n    }\n    get currentPageIndex() {\n        return this.#currentPageIndex;\n    }\n    addLayer(layer) {\n        this.#allLayers.set(layer.pageIndex, layer);\n        if (this.#isEnabled) {\n            layer.enable();\n        } else {\n            layer.disable();\n        }\n    }\n    removeLayer(layer) {\n        this.#allLayers.delete(layer.pageIndex);\n    }\n    async updateMode(mode, editId = null, isFromKeyboard = false) {\n        if (this.#mode === mode) {\n            return;\n        }\n        if (this.#updateModeCapability) {\n            await this.#updateModeCapability.promise;\n            if (!this.#updateModeCapability) {\n                return;\n            }\n        }\n        this.#updateModeCapability = Promise.withResolvers();\n        this.#currentDrawingSession?.commitOrRemove();\n        this.#mode = mode;\n        if (mode === AnnotationEditorType.NONE) {\n            this.setEditingState(false);\n            this.#disableAll();\n            this._editorUndoBar?.hide();\n            this.#updateModeCapability.resolve();\n            return;\n        }\n        if (mode === AnnotationEditorType.SIGNATURE) {\n            await this.#signatureManager?.loadSignatures();\n        }\n        this.setEditingState(true);\n        await this.#enableAll();\n        this.unselectAll();\n        for (const layer of this.#allLayers.values()){\n            layer.updateMode(mode);\n        }\n        if (!editId) {\n            if (isFromKeyboard) {\n                this.addNewEditorFromKeyboard();\n            }\n            this.#updateModeCapability.resolve();\n            return;\n        }\n        for (const editor of this.#allEditors.values()){\n            if (editor.annotationElementId === editId) {\n                this.setSelected(editor);\n                editor.enterInEditMode();\n            } else {\n                editor.unselect();\n            }\n        }\n        this.#updateModeCapability.resolve();\n    }\n    addNewEditorFromKeyboard() {\n        if (this.currentLayer.canCreateNewEmptyEditor()) {\n            this.currentLayer.addNewEditor();\n        }\n    }\n    updateToolbar(mode) {\n        if (mode === this.#mode) {\n            return;\n        }\n        this._eventBus.dispatch(\"switchannotationeditormode\", {\n            source: this,\n            mode\n        });\n    }\n    updateParams(type, value) {\n        if (!this.#editorTypes) {\n            return;\n        }\n        switch(type){\n            case AnnotationEditorParamsType.CREATE:\n                this.currentLayer.addNewEditor(value);\n                return;\n            case AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR:\n                this.#mainHighlightColorPicker?.updateColor(value);\n                break;\n            case AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL:\n                this._eventBus.dispatch(\"reporttelemetry\", {\n                    source: this,\n                    details: {\n                        type: \"editing\",\n                        data: {\n                            type: \"highlight\",\n                            action: \"toggle_visibility\"\n                        }\n                    }\n                });\n                (this.#showAllStates ||= new Map()).set(type, value);\n                this.showAllEditors(\"highlight\", value);\n                break;\n        }\n        for (const editor of this.#selectedEditors){\n            editor.updateParams(type, value);\n        }\n        for (const editorType of this.#editorTypes){\n            editorType.updateDefaultParams(type, value);\n        }\n    }\n    showAllEditors(type, visible, updateButton = false) {\n        for (const editor of this.#allEditors.values()){\n            if (editor.editorType === type) {\n                editor.show(visible);\n            }\n        }\n        const state = this.#showAllStates?.get(AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL) ?? true;\n        if (state !== visible) {\n            this.#dispatchUpdateUI([\n                [\n                    AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL,\n                    visible\n                ]\n            ]);\n        }\n    }\n    enableWaiting(mustWait = false) {\n        if (this.#isWaiting === mustWait) {\n            return;\n        }\n        this.#isWaiting = mustWait;\n        for (const layer of this.#allLayers.values()){\n            if (mustWait) {\n                layer.disableClick();\n            } else {\n                layer.enableClick();\n            }\n            layer.div.classList.toggle(\"waiting\", mustWait);\n        }\n    }\n    async #enableAll() {\n        if (!this.#isEnabled) {\n            this.#isEnabled = true;\n            const promises = [];\n            for (const layer of this.#allLayers.values()){\n                promises.push(layer.enable());\n            }\n            await Promise.all(promises);\n            for (const editor of this.#allEditors.values()){\n                editor.enable();\n            }\n        }\n    }\n    #disableAll() {\n        this.unselectAll();\n        if (this.#isEnabled) {\n            this.#isEnabled = false;\n            for (const layer of this.#allLayers.values()){\n                layer.disable();\n            }\n            for (const editor of this.#allEditors.values()){\n                editor.disable();\n            }\n        }\n    }\n    getEditors(pageIndex) {\n        const editors = [];\n        for (const editor of this.#allEditors.values()){\n            if (editor.pageIndex === pageIndex) {\n                editors.push(editor);\n            }\n        }\n        return editors;\n    }\n    getEditor(id) {\n        return this.#allEditors.get(id);\n    }\n    addEditor(editor) {\n        this.#allEditors.set(editor.id, editor);\n    }\n    removeEditor(editor) {\n        if (editor.div.contains(document.activeElement)) {\n            if (this.#focusMainContainerTimeoutId) {\n                clearTimeout(this.#focusMainContainerTimeoutId);\n            }\n            this.#focusMainContainerTimeoutId = setTimeout(()=>{\n                this.focusMainContainer();\n                this.#focusMainContainerTimeoutId = null;\n            }, 0);\n        }\n        this.#allEditors.delete(editor.id);\n        if (editor.annotationElementId) {\n            this.#missingCanvases?.delete(editor.annotationElementId);\n        }\n        this.unselect(editor);\n        if (!editor.annotationElementId || !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)) {\n            this.#annotationStorage?.remove(editor.id);\n        }\n    }\n    addDeletedAnnotationElement(editor) {\n        this.#deletedAnnotationsElementIds.add(editor.annotationElementId);\n        this.addChangedExistingAnnotation(editor);\n        editor.deleted = true;\n    }\n    isDeletedAnnotationElement(annotationElementId) {\n        return this.#deletedAnnotationsElementIds.has(annotationElementId);\n    }\n    removeDeletedAnnotationElement(editor) {\n        this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);\n        this.removeChangedExistingAnnotation(editor);\n        editor.deleted = false;\n    }\n    #addEditorToLayer(editor) {\n        const layer = this.#allLayers.get(editor.pageIndex);\n        if (layer) {\n            layer.addOrRebuild(editor);\n        } else {\n            this.addEditor(editor);\n            this.addToAnnotationStorage(editor);\n        }\n    }\n    setActiveEditor(editor) {\n        if (this.#activeEditor === editor) {\n            return;\n        }\n        this.#activeEditor = editor;\n        if (editor) {\n            this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        }\n    }\n    get #lastSelectedEditor() {\n        let ed = null;\n        for (ed of this.#selectedEditors){}\n        return ed;\n    }\n    updateUI(editor) {\n        if (this.#lastSelectedEditor === editor) {\n            this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        }\n    }\n    updateUIForDefaultProperties(editorType) {\n        this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);\n    }\n    toggleSelected(editor) {\n        if (this.#selectedEditors.has(editor)) {\n            this.#selectedEditors.delete(editor);\n            editor.unselect();\n            this.#dispatchUpdateStates({\n                hasSelectedEditor: this.hasSelection\n            });\n            return;\n        }\n        this.#selectedEditors.add(editor);\n        editor.select();\n        this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: true\n        });\n    }\n    setSelected(editor) {\n        this.#currentDrawingSession?.commitOrRemove();\n        for (const ed of this.#selectedEditors){\n            if (ed !== editor) {\n                ed.unselect();\n            }\n        }\n        this.#selectedEditors.clear();\n        this.#selectedEditors.add(editor);\n        editor.select();\n        this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: true\n        });\n    }\n    isSelected(editor) {\n        return this.#selectedEditors.has(editor);\n    }\n    get firstSelectedEditor() {\n        return this.#selectedEditors.values().next().value;\n    }\n    unselect(editor) {\n        editor.unselect();\n        this.#selectedEditors.delete(editor);\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: this.hasSelection\n        });\n    }\n    get hasSelection() {\n        return this.#selectedEditors.size !== 0;\n    }\n    get isEnterHandled() {\n        return this.#selectedEditors.size === 1 && this.firstSelectedEditor.isEnterHandled;\n    }\n    undo() {\n        this.#commandManager.undo();\n        this.#dispatchUpdateStates({\n            hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n            hasSomethingToRedo: true,\n            isEmpty: this.#isEmpty()\n        });\n        this._editorUndoBar?.hide();\n    }\n    redo() {\n        this.#commandManager.redo();\n        this.#dispatchUpdateStates({\n            hasSomethingToUndo: true,\n            hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n            isEmpty: this.#isEmpty()\n        });\n    }\n    addCommands(params) {\n        this.#commandManager.add(params);\n        this.#dispatchUpdateStates({\n            hasSomethingToUndo: true,\n            hasSomethingToRedo: false,\n            isEmpty: this.#isEmpty()\n        });\n    }\n    cleanUndoStack(type) {\n        this.#commandManager.cleanType(type);\n    }\n    #isEmpty() {\n        if (this.#allEditors.size === 0) {\n            return true;\n        }\n        if (this.#allEditors.size === 1) {\n            for (const editor of this.#allEditors.values()){\n                return editor.isEmpty();\n            }\n        }\n        return false;\n    }\n    delete() {\n        this.commitOrRemove();\n        const drawingEditor = this.currentLayer?.endDrawingSession(true);\n        if (!this.hasSelection && !drawingEditor) {\n            return;\n        }\n        const editors = drawingEditor ? [\n            drawingEditor\n        ] : [\n            ...this.#selectedEditors\n        ];\n        const cmd = ()=>{\n            this._editorUndoBar?.show(undo, editors.length === 1 ? editors[0].editorType : editors.length);\n            for (const editor of editors){\n                editor.remove();\n            }\n        };\n        const undo = ()=>{\n            for (const editor of editors){\n                this.#addEditorToLayer(editor);\n            }\n        };\n        this.addCommands({\n            cmd,\n            undo,\n            mustExec: true\n        });\n    }\n    commitOrRemove() {\n        this.#activeEditor?.commitOrRemove();\n    }\n    hasSomethingToControl() {\n        return this.#activeEditor || this.hasSelection;\n    }\n    #selectEditors(editors) {\n        for (const editor of this.#selectedEditors){\n            editor.unselect();\n        }\n        this.#selectedEditors.clear();\n        for (const editor of editors){\n            if (editor.isEmpty()) {\n                continue;\n            }\n            this.#selectedEditors.add(editor);\n            editor.select();\n        }\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: this.hasSelection\n        });\n    }\n    selectAll() {\n        for (const editor of this.#selectedEditors){\n            editor.commit();\n        }\n        this.#selectEditors(this.#allEditors.values());\n    }\n    unselectAll() {\n        if (this.#activeEditor) {\n            this.#activeEditor.commitOrRemove();\n            if (this.#mode !== AnnotationEditorType.NONE) {\n                return;\n            }\n        }\n        if (this.#currentDrawingSession?.commitOrRemove()) {\n            return;\n        }\n        if (!this.hasSelection) {\n            return;\n        }\n        for (const editor of this.#selectedEditors){\n            editor.unselect();\n        }\n        this.#selectedEditors.clear();\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: false\n        });\n    }\n    translateSelectedEditors(x, y, noCommit = false) {\n        if (!noCommit) {\n            this.commitOrRemove();\n        }\n        if (!this.hasSelection) {\n            return;\n        }\n        this.#translation[0] += x;\n        this.#translation[1] += y;\n        const [totalX, totalY] = this.#translation;\n        const editors = [\n            ...this.#selectedEditors\n        ];\n        const TIME_TO_WAIT = 1000;\n        if (this.#translationTimeoutId) {\n            clearTimeout(this.#translationTimeoutId);\n        }\n        this.#translationTimeoutId = setTimeout(()=>{\n            this.#translationTimeoutId = null;\n            this.#translation[0] = this.#translation[1] = 0;\n            this.addCommands({\n                cmd: ()=>{\n                    for (const editor of editors){\n                        if (this.#allEditors.has(editor.id)) {\n                            editor.translateInPage(totalX, totalY);\n                            editor.translationDone();\n                        }\n                    }\n                },\n                undo: ()=>{\n                    for (const editor of editors){\n                        if (this.#allEditors.has(editor.id)) {\n                            editor.translateInPage(-totalX, -totalY);\n                            editor.translationDone();\n                        }\n                    }\n                },\n                mustExec: false\n            });\n        }, TIME_TO_WAIT);\n        for (const editor of editors){\n            editor.translateInPage(x, y);\n            editor.translationDone();\n        }\n    }\n    setUpDragSession() {\n        if (!this.hasSelection) {\n            return;\n        }\n        this.disableUserSelect(true);\n        this.#draggingEditors = new Map();\n        for (const editor of this.#selectedEditors){\n            this.#draggingEditors.set(editor, {\n                savedX: editor.x,\n                savedY: editor.y,\n                savedPageIndex: editor.pageIndex,\n                newX: 0,\n                newY: 0,\n                newPageIndex: -1\n            });\n        }\n    }\n    endDragSession() {\n        if (!this.#draggingEditors) {\n            return false;\n        }\n        this.disableUserSelect(false);\n        const map = this.#draggingEditors;\n        this.#draggingEditors = null;\n        let mustBeAddedInUndoStack = false;\n        for (const [{ x, y, pageIndex }, value] of map){\n            value.newX = x;\n            value.newY = y;\n            value.newPageIndex = pageIndex;\n            mustBeAddedInUndoStack ||= x !== value.savedX || y !== value.savedY || pageIndex !== value.savedPageIndex;\n        }\n        if (!mustBeAddedInUndoStack) {\n            return false;\n        }\n        const move = (editor, x, y, pageIndex)=>{\n            if (this.#allEditors.has(editor.id)) {\n                const parent = this.#allLayers.get(pageIndex);\n                if (parent) {\n                    editor._setParentAndPosition(parent, x, y);\n                } else {\n                    editor.pageIndex = pageIndex;\n                    editor.x = x;\n                    editor.y = y;\n                }\n            }\n        };\n        this.addCommands({\n            cmd: ()=>{\n                for (const [editor, { newX, newY, newPageIndex }] of map){\n                    move(editor, newX, newY, newPageIndex);\n                }\n            },\n            undo: ()=>{\n                for (const [editor, { savedX, savedY, savedPageIndex }] of map){\n                    move(editor, savedX, savedY, savedPageIndex);\n                }\n            },\n            mustExec: true\n        });\n        return true;\n    }\n    dragSelectedEditors(tx, ty) {\n        if (!this.#draggingEditors) {\n            return;\n        }\n        for (const editor of this.#draggingEditors.keys()){\n            editor.drag(tx, ty);\n        }\n    }\n    rebuild(editor) {\n        if (editor.parent === null) {\n            const parent = this.getLayer(editor.pageIndex);\n            if (parent) {\n                parent.changeParent(editor);\n                parent.addOrRebuild(editor);\n            } else {\n                this.addEditor(editor);\n                this.addToAnnotationStorage(editor);\n                editor.rebuild();\n            }\n        } else {\n            editor.parent.addOrRebuild(editor);\n        }\n    }\n    get isEditorHandlingKeyboard() {\n        return this.getActive()?.shouldGetKeyboardEvents() || this.#selectedEditors.size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();\n    }\n    isActive(editor) {\n        return this.#activeEditor === editor;\n    }\n    getActive() {\n        return this.#activeEditor;\n    }\n    getMode() {\n        return this.#mode;\n    }\n    get imageManager() {\n        return shadow(this, \"imageManager\", new ImageManager());\n    }\n    getSelectionBoxes(textLayer) {\n        if (!textLayer) {\n            return null;\n        }\n        const selection = document.getSelection();\n        for(let i = 0, ii = selection.rangeCount; i < ii; i++){\n            if (!textLayer.contains(selection.getRangeAt(i).commonAncestorContainer)) {\n                return null;\n            }\n        }\n        const { x: layerX, y: layerY, width: parentWidth, height: parentHeight } = textLayer.getBoundingClientRect();\n        let rotator;\n        switch(textLayer.getAttribute(\"data-main-rotation\")){\n            case \"90\":\n                rotator = (x, y, w, h)=>({\n                        x: (y - layerY) / parentHeight,\n                        y: 1 - (x + w - layerX) / parentWidth,\n                        width: h / parentHeight,\n                        height: w / parentWidth\n                    });\n                break;\n            case \"180\":\n                rotator = (x, y, w, h)=>({\n                        x: 1 - (x + w - layerX) / parentWidth,\n                        y: 1 - (y + h - layerY) / parentHeight,\n                        width: w / parentWidth,\n                        height: h / parentHeight\n                    });\n                break;\n            case \"270\":\n                rotator = (x, y, w, h)=>({\n                        x: 1 - (y + h - layerY) / parentHeight,\n                        y: (x - layerX) / parentWidth,\n                        width: h / parentHeight,\n                        height: w / parentWidth\n                    });\n                break;\n            default:\n                rotator = (x, y, w, h)=>({\n                        x: (x - layerX) / parentWidth,\n                        y: (y - layerY) / parentHeight,\n                        width: w / parentWidth,\n                        height: h / parentHeight\n                    });\n                break;\n        }\n        const boxes = [];\n        for(let i = 0, ii = selection.rangeCount; i < ii; i++){\n            const range = selection.getRangeAt(i);\n            if (range.collapsed) {\n                continue;\n            }\n            for (const { x, y, width, height } of range.getClientRects()){\n                if (width === 0 || height === 0) {\n                    continue;\n                }\n                boxes.push(rotator(x, y, width, height));\n            }\n        }\n        return boxes.length === 0 ? null : boxes;\n    }\n    addChangedExistingAnnotation({ annotationElementId, id }) {\n        (this.#changedExistingAnnotations ||= new Map()).set(annotationElementId, id);\n    }\n    removeChangedExistingAnnotation({ annotationElementId }) {\n        this.#changedExistingAnnotations?.delete(annotationElementId);\n    }\n    renderAnnotationElement(annotation) {\n        const editorId = this.#changedExistingAnnotations?.get(annotation.data.id);\n        if (!editorId) {\n            return;\n        }\n        const editor = this.#annotationStorage.getRawValue(editorId);\n        if (!editor) {\n            return;\n        }\n        if (this.#mode === AnnotationEditorType.NONE && !editor.hasBeenModified) {\n            return;\n        }\n        editor.renderAnnotationElement(annotation);\n    }\n    setMissingCanvas(annotationId, annotationElementId, canvas) {\n        const editor = this.#missingCanvases?.get(annotationId);\n        if (!editor) {\n            return;\n        }\n        editor.setCanvas(annotationElementId, canvas);\n        this.#missingCanvases.delete(annotationId);\n    }\n    addMissingCanvas(annotationId, editor) {\n        (this.#missingCanvases ||= new Map()).set(annotationId, editor);\n    }\n}\n; // ./src/display/editor/alt_text.js\nclass AltText {\n    #altText;\n    #altTextDecorative;\n    #altTextButton;\n    #altTextButtonLabel;\n    #altTextTooltip;\n    #altTextTooltipTimeout;\n    #altTextWasFromKeyBoard;\n    #badge;\n    #editor;\n    #guessedText;\n    #textWithDisclaimer;\n    #useNewAltTextFlow;\n    static #l10nNewButton = null;\n    static{\n        this._l10n = null;\n    }\n    constructor(editor){\n        this.#altText = null;\n        this.#altTextDecorative = false;\n        this.#altTextButton = null;\n        this.#altTextButtonLabel = null;\n        this.#altTextTooltip = null;\n        this.#altTextTooltipTimeout = null;\n        this.#altTextWasFromKeyBoard = false;\n        this.#badge = null;\n        this.#editor = null;\n        this.#guessedText = null;\n        this.#textWithDisclaimer = null;\n        this.#useNewAltTextFlow = false;\n        this.#editor = editor;\n        this.#useNewAltTextFlow = editor._uiManager.useNewAltTextFlow;\n        AltText.#l10nNewButton ||= Object.freeze({\n            added: \"pdfjs-editor-new-alt-text-added-button\",\n            \"added-label\": \"pdfjs-editor-new-alt-text-added-button-label\",\n            missing: \"pdfjs-editor-new-alt-text-missing-button\",\n            \"missing-label\": \"pdfjs-editor-new-alt-text-missing-button-label\",\n            review: \"pdfjs-editor-new-alt-text-to-review-button\",\n            \"review-label\": \"pdfjs-editor-new-alt-text-to-review-button-label\"\n        });\n    }\n    static initialize(l10n) {\n        AltText._l10n ??= l10n;\n    }\n    async render() {\n        const altText = this.#altTextButton = document.createElement(\"button\");\n        altText.className = \"altText\";\n        altText.tabIndex = \"0\";\n        const label = this.#altTextButtonLabel = document.createElement(\"span\");\n        altText.append(label);\n        if (this.#useNewAltTextFlow) {\n            altText.classList.add(\"new\");\n            altText.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton.missing);\n            label.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[\"missing-label\"]);\n        } else {\n            altText.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-button\");\n            label.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-button-label\");\n        }\n        const signal = this.#editor._uiManager._signal;\n        altText.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        altText.addEventListener(\"pointerdown\", (event)=>event.stopPropagation(), {\n            signal\n        });\n        const onClick = (event)=>{\n            event.preventDefault();\n            this.#editor._uiManager.editAltText(this.#editor);\n            if (this.#useNewAltTextFlow) {\n                this.#editor._reportTelemetry({\n                    action: \"pdfjs.image.alt_text.image_status_label_clicked\",\n                    data: {\n                        label: this.#label\n                    }\n                });\n            }\n        };\n        altText.addEventListener(\"click\", onClick, {\n            capture: true,\n            signal\n        });\n        altText.addEventListener(\"keydown\", (event)=>{\n            if (event.target === altText && event.key === \"Enter\") {\n                this.#altTextWasFromKeyBoard = true;\n                onClick(event);\n            }\n        }, {\n            signal\n        });\n        await this.#setState();\n        return altText;\n    }\n    get #label() {\n        return this.#altText && \"added\" || this.#altText === null && this.guessedText && \"review\" || \"missing\";\n    }\n    finish() {\n        if (!this.#altTextButton) {\n            return;\n        }\n        this.#altTextButton.focus({\n            focusVisible: this.#altTextWasFromKeyBoard\n        });\n        this.#altTextWasFromKeyBoard = false;\n    }\n    isEmpty() {\n        if (this.#useNewAltTextFlow) {\n            return this.#altText === null;\n        }\n        return !this.#altText && !this.#altTextDecorative;\n    }\n    hasData() {\n        if (this.#useNewAltTextFlow) {\n            return this.#altText !== null || !!this.#guessedText;\n        }\n        return this.isEmpty();\n    }\n    get guessedText() {\n        return this.#guessedText;\n    }\n    async setGuessedText(guessedText) {\n        if (this.#altText !== null) {\n            return;\n        }\n        this.#guessedText = guessedText;\n        this.#textWithDisclaimer = await AltText._l10n.get(\"pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer\", {\n            generatedAltText: guessedText\n        });\n        this.#setState();\n    }\n    toggleAltTextBadge(visibility = false) {\n        if (!this.#useNewAltTextFlow || this.#altText) {\n            this.#badge?.remove();\n            this.#badge = null;\n            return;\n        }\n        if (!this.#badge) {\n            const badge = this.#badge = document.createElement(\"div\");\n            badge.className = \"noAltTextBadge\";\n            this.#editor.div.append(badge);\n        }\n        this.#badge.classList.toggle(\"hidden\", !visibility);\n    }\n    serialize(isForCopying) {\n        let altText = this.#altText;\n        if (!isForCopying && this.#guessedText === altText) {\n            altText = this.#textWithDisclaimer;\n        }\n        return {\n            altText,\n            decorative: this.#altTextDecorative,\n            guessedText: this.#guessedText,\n            textWithDisclaimer: this.#textWithDisclaimer\n        };\n    }\n    get data() {\n        return {\n            altText: this.#altText,\n            decorative: this.#altTextDecorative\n        };\n    }\n    set data({ altText, decorative, guessedText, textWithDisclaimer, cancel = false }) {\n        if (guessedText) {\n            this.#guessedText = guessedText;\n            this.#textWithDisclaimer = textWithDisclaimer;\n        }\n        if (this.#altText === altText && this.#altTextDecorative === decorative) {\n            return;\n        }\n        if (!cancel) {\n            this.#altText = altText;\n            this.#altTextDecorative = decorative;\n        }\n        this.#setState();\n    }\n    toggle(enabled = false) {\n        if (!this.#altTextButton) {\n            return;\n        }\n        if (!enabled && this.#altTextTooltipTimeout) {\n            clearTimeout(this.#altTextTooltipTimeout);\n            this.#altTextTooltipTimeout = null;\n        }\n        this.#altTextButton.disabled = !enabled;\n    }\n    shown() {\n        this.#editor._reportTelemetry({\n            action: \"pdfjs.image.alt_text.image_status_label_displayed\",\n            data: {\n                label: this.#label\n            }\n        });\n    }\n    destroy() {\n        this.#altTextButton?.remove();\n        this.#altTextButton = null;\n        this.#altTextButtonLabel = null;\n        this.#altTextTooltip = null;\n        this.#badge?.remove();\n        this.#badge = null;\n    }\n    async #setState() {\n        const button = this.#altTextButton;\n        if (!button) {\n            return;\n        }\n        if (this.#useNewAltTextFlow) {\n            button.classList.toggle(\"done\", !!this.#altText);\n            button.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[this.#label]);\n            this.#altTextButtonLabel?.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[`${this.#label}-label`]);\n            if (!this.#altText) {\n                this.#altTextTooltip?.remove();\n                return;\n            }\n        } else {\n            if (!this.#altText && !this.#altTextDecorative) {\n                button.classList.remove(\"done\");\n                this.#altTextTooltip?.remove();\n                return;\n            }\n            button.classList.add(\"done\");\n            button.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-edit-button\");\n        }\n        let tooltip = this.#altTextTooltip;\n        if (!tooltip) {\n            this.#altTextTooltip = tooltip = document.createElement(\"span\");\n            tooltip.className = \"tooltip\";\n            tooltip.setAttribute(\"role\", \"tooltip\");\n            tooltip.id = `alt-text-tooltip-${this.#editor.id}`;\n            const DELAY_TO_SHOW_TOOLTIP = 100;\n            const signal = this.#editor._uiManager._signal;\n            signal.addEventListener(\"abort\", ()=>{\n                clearTimeout(this.#altTextTooltipTimeout);\n                this.#altTextTooltipTimeout = null;\n            }, {\n                once: true\n            });\n            button.addEventListener(\"mouseenter\", ()=>{\n                this.#altTextTooltipTimeout = setTimeout(()=>{\n                    this.#altTextTooltipTimeout = null;\n                    this.#altTextTooltip.classList.add(\"show\");\n                    this.#editor._reportTelemetry({\n                        action: \"alt_text_tooltip\"\n                    });\n                }, DELAY_TO_SHOW_TOOLTIP);\n            }, {\n                signal\n            });\n            button.addEventListener(\"mouseleave\", ()=>{\n                if (this.#altTextTooltipTimeout) {\n                    clearTimeout(this.#altTextTooltipTimeout);\n                    this.#altTextTooltipTimeout = null;\n                }\n                this.#altTextTooltip?.classList.remove(\"show\");\n            }, {\n                signal\n            });\n        }\n        if (this.#altTextDecorative) {\n            tooltip.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-decorative-tooltip\");\n        } else {\n            tooltip.removeAttribute(\"data-l10n-id\");\n            tooltip.textContent = this.#altText;\n        }\n        if (!tooltip.parentNode) {\n            button.append(tooltip);\n        }\n        const element = this.#editor.getElementForAltText();\n        element?.setAttribute(\"aria-describedby\", tooltip.id);\n    }\n}\n; // ./src/display/touch_manager.js\nclass TouchManager {\n    #container;\n    #isPinching;\n    #isPinchingStopped;\n    #isPinchingDisabled;\n    #onPinchStart;\n    #onPinching;\n    #onPinchEnd;\n    #pointerDownAC;\n    #signal;\n    #touchInfo;\n    #touchManagerAC;\n    #touchMoveAC;\n    constructor({ container, isPinchingDisabled = null, isPinchingStopped = null, onPinchStart = null, onPinching = null, onPinchEnd = null, signal }){\n        this.#isPinching = false;\n        this.#isPinchingStopped = null;\n        this.#pointerDownAC = null;\n        this.#touchInfo = null;\n        this.#touchMoveAC = null;\n        this.#container = container;\n        this.#isPinchingStopped = isPinchingStopped;\n        this.#isPinchingDisabled = isPinchingDisabled;\n        this.#onPinchStart = onPinchStart;\n        this.#onPinching = onPinching;\n        this.#onPinchEnd = onPinchEnd;\n        this.#touchManagerAC = new AbortController();\n        this.#signal = AbortSignal.any([\n            signal,\n            this.#touchManagerAC.signal\n        ]);\n        container.addEventListener(\"touchstart\", this.#onTouchStart.bind(this), {\n            passive: false,\n            signal: this.#signal\n        });\n    }\n    get MIN_TOUCH_DISTANCE_TO_PINCH() {\n        return 35 / OutputScale.pixelRatio;\n    }\n    #onTouchStart(evt) {\n        if (this.#isPinchingDisabled?.()) {\n            return;\n        }\n        if (evt.touches.length === 1) {\n            if (this.#pointerDownAC) {\n                return;\n            }\n            const pointerDownAC = this.#pointerDownAC = new AbortController();\n            const signal = AbortSignal.any([\n                this.#signal,\n                pointerDownAC.signal\n            ]);\n            const container = this.#container;\n            const opts = {\n                capture: true,\n                signal,\n                passive: false\n            };\n            const cancelPointerDown = (e)=>{\n                if (e.pointerType === \"touch\") {\n                    this.#pointerDownAC?.abort();\n                    this.#pointerDownAC = null;\n                }\n            };\n            container.addEventListener(\"pointerdown\", (e)=>{\n                if (e.pointerType === \"touch\") {\n                    stopEvent(e);\n                    cancelPointerDown(e);\n                }\n            }, opts);\n            container.addEventListener(\"pointerup\", cancelPointerDown, opts);\n            container.addEventListener(\"pointercancel\", cancelPointerDown, opts);\n            return;\n        }\n        if (!this.#touchMoveAC) {\n            this.#touchMoveAC = new AbortController();\n            const signal = AbortSignal.any([\n                this.#signal,\n                this.#touchMoveAC.signal\n            ]);\n            const container = this.#container;\n            const opt = {\n                signal,\n                capture: false,\n                passive: false\n            };\n            container.addEventListener(\"touchmove\", this.#onTouchMove.bind(this), opt);\n            const onTouchEnd = this.#onTouchEnd.bind(this);\n            container.addEventListener(\"touchend\", onTouchEnd, opt);\n            container.addEventListener(\"touchcancel\", onTouchEnd, opt);\n            opt.capture = true;\n            container.addEventListener(\"pointerdown\", stopEvent, opt);\n            container.addEventListener(\"pointermove\", stopEvent, opt);\n            container.addEventListener(\"pointercancel\", stopEvent, opt);\n            container.addEventListener(\"pointerup\", stopEvent, opt);\n            this.#onPinchStart?.();\n        }\n        stopEvent(evt);\n        if (evt.touches.length !== 2 || this.#isPinchingStopped?.()) {\n            this.#touchInfo = null;\n            return;\n        }\n        let [touch0, touch1] = evt.touches;\n        if (touch0.identifier > touch1.identifier) {\n            [touch0, touch1] = [\n                touch1,\n                touch0\n            ];\n        }\n        this.#touchInfo = {\n            touch0X: touch0.screenX,\n            touch0Y: touch0.screenY,\n            touch1X: touch1.screenX,\n            touch1Y: touch1.screenY\n        };\n    }\n    #onTouchMove(evt) {\n        if (!this.#touchInfo || evt.touches.length !== 2) {\n            return;\n        }\n        stopEvent(evt);\n        let [touch0, touch1] = evt.touches;\n        if (touch0.identifier > touch1.identifier) {\n            [touch0, touch1] = [\n                touch1,\n                touch0\n            ];\n        }\n        const { screenX: screen0X, screenY: screen0Y } = touch0;\n        const { screenX: screen1X, screenY: screen1Y } = touch1;\n        const touchInfo = this.#touchInfo;\n        const { touch0X: pTouch0X, touch0Y: pTouch0Y, touch1X: pTouch1X, touch1Y: pTouch1Y } = touchInfo;\n        const prevGapX = pTouch1X - pTouch0X;\n        const prevGapY = pTouch1Y - pTouch0Y;\n        const currGapX = screen1X - screen0X;\n        const currGapY = screen1Y - screen0Y;\n        const distance = Math.hypot(currGapX, currGapY) || 1;\n        const pDistance = Math.hypot(prevGapX, prevGapY) || 1;\n        if (!this.#isPinching && Math.abs(pDistance - distance) <= TouchManager.MIN_TOUCH_DISTANCE_TO_PINCH) {\n            return;\n        }\n        touchInfo.touch0X = screen0X;\n        touchInfo.touch0Y = screen0Y;\n        touchInfo.touch1X = screen1X;\n        touchInfo.touch1Y = screen1Y;\n        if (!this.#isPinching) {\n            this.#isPinching = true;\n            return;\n        }\n        const origin = [\n            (screen0X + screen1X) / 2,\n            (screen0Y + screen1Y) / 2\n        ];\n        this.#onPinching?.(origin, pDistance, distance);\n    }\n    #onTouchEnd(evt) {\n        if (evt.touches.length >= 2) {\n            return;\n        }\n        if (this.#touchMoveAC) {\n            this.#touchMoveAC.abort();\n            this.#touchMoveAC = null;\n            this.#onPinchEnd?.();\n        }\n        if (!this.#touchInfo) {\n            return;\n        }\n        stopEvent(evt);\n        this.#touchInfo = null;\n        this.#isPinching = false;\n    }\n    destroy() {\n        this.#touchManagerAC?.abort();\n        this.#touchManagerAC = null;\n        this.#pointerDownAC?.abort();\n        this.#pointerDownAC = null;\n    }\n}\n; // ./src/display/editor/editor.js\nclass AnnotationEditor {\n    #accessibilityData;\n    #allResizerDivs;\n    #altText;\n    #disabled;\n    #dragPointerId;\n    #dragPointerType;\n    #keepAspectRatio;\n    #resizersDiv;\n    #lastPointerCoords;\n    #savedDimensions;\n    #focusAC;\n    #focusedResizerName;\n    #hasBeenClicked;\n    #initialRect;\n    #isEditing;\n    #isInEditMode;\n    #isResizerEnabledForKeyboard;\n    #moveInDOMTimeout;\n    #prevDragX;\n    #prevDragY;\n    #telemetryTimeouts;\n    #touchManager;\n    static{\n        this._l10n = null;\n    }\n    static{\n        this._l10nResizer = null;\n    }\n    #isDraggable;\n    #zIndex;\n    static{\n        this._borderLineWidth = -1;\n    }\n    static{\n        this._colorManager = new ColorManager();\n    }\n    static{\n        this._zIndex = 1;\n    }\n    static{\n        this._telemetryTimeout = 1000;\n    }\n    static get _resizerKeyboardManager() {\n        const resize = AnnotationEditor.prototype._resizeWithKeyboard;\n        const small = AnnotationEditorUIManager.TRANSLATE_SMALL;\n        const big = AnnotationEditorUIManager.TRANSLATE_BIG;\n        return shadow(this, \"_resizerKeyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                resize,\n                {\n                    args: [\n                        -small,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowLeft\",\n                    \"mac+shift+ArrowLeft\"\n                ],\n                resize,\n                {\n                    args: [\n                        -big,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                resize,\n                {\n                    args: [\n                        small,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowRight\",\n                    \"mac+shift+ArrowRight\"\n                ],\n                resize,\n                {\n                    args: [\n                        big,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        -small\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowUp\",\n                    \"mac+shift+ArrowUp\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        -big\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        small\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowDown\",\n                    \"mac+shift+ArrowDown\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        big\n                    ]\n                }\n            ],\n            [\n                [\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                AnnotationEditor.prototype._stopResizingWithKeyboard\n            ]\n        ]));\n    }\n    constructor(parameters){\n        this.#accessibilityData = null;\n        this.#allResizerDivs = null;\n        this.#altText = null;\n        this.#disabled = false;\n        this.#dragPointerId = null;\n        this.#dragPointerType = \"\";\n        this.#keepAspectRatio = false;\n        this.#resizersDiv = null;\n        this.#lastPointerCoords = null;\n        this.#savedDimensions = null;\n        this.#focusAC = null;\n        this.#focusedResizerName = \"\";\n        this.#hasBeenClicked = false;\n        this.#initialRect = null;\n        this.#isEditing = false;\n        this.#isInEditMode = false;\n        this.#isResizerEnabledForKeyboard = false;\n        this.#moveInDOMTimeout = null;\n        this.#prevDragX = 0;\n        this.#prevDragY = 0;\n        this.#telemetryTimeouts = null;\n        this.#touchManager = null;\n        this._isCopy = false;\n        this._editToolbar = null;\n        this._initialOptions = Object.create(null);\n        this._initialData = null;\n        this._isVisible = true;\n        this._uiManager = null;\n        this._focusEventsAllowed = true;\n        this.#isDraggable = false;\n        this.#zIndex = AnnotationEditor._zIndex++;\n        this.parent = parameters.parent;\n        this.id = parameters.id;\n        this.width = this.height = null;\n        this.pageIndex = parameters.parent.pageIndex;\n        this.name = parameters.name;\n        this.div = null;\n        this._uiManager = parameters.uiManager;\n        this.annotationElementId = null;\n        this._willKeepAspectRatio = false;\n        this._initialOptions.isCentered = parameters.isCentered;\n        this._structTreeParentId = null;\n        const { rotation, rawDims: { pageWidth, pageHeight, pageX, pageY } } = this.parent.viewport;\n        this.rotation = rotation;\n        this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;\n        this.pageDimensions = [\n            pageWidth,\n            pageHeight\n        ];\n        this.pageTranslation = [\n            pageX,\n            pageY\n        ];\n        const [width, height] = this.parentDimensions;\n        this.x = parameters.x / width;\n        this.y = parameters.y / height;\n        this.isAttachedToDOM = false;\n        this.deleted = false;\n    }\n    get editorType() {\n        return Object.getPrototypeOf(this).constructor._type;\n    }\n    static get isDrawer() {\n        return false;\n    }\n    static get _defaultLineColor() {\n        return shadow(this, \"_defaultLineColor\", this._colorManager.getHexCode(\"CanvasText\"));\n    }\n    static deleteAnnotationElement(editor) {\n        const fakeEditor = new FakeEditor({\n            id: editor.parent.getNextId(),\n            parent: editor.parent,\n            uiManager: editor._uiManager\n        });\n        fakeEditor.annotationElementId = editor.annotationElementId;\n        fakeEditor.deleted = true;\n        fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);\n    }\n    static initialize(l10n, _uiManager) {\n        AnnotationEditor._l10n ??= l10n;\n        AnnotationEditor._l10nResizer ||= Object.freeze({\n            topLeft: \"pdfjs-editor-resizer-top-left\",\n            topMiddle: \"pdfjs-editor-resizer-top-middle\",\n            topRight: \"pdfjs-editor-resizer-top-right\",\n            middleRight: \"pdfjs-editor-resizer-middle-right\",\n            bottomRight: \"pdfjs-editor-resizer-bottom-right\",\n            bottomMiddle: \"pdfjs-editor-resizer-bottom-middle\",\n            bottomLeft: \"pdfjs-editor-resizer-bottom-left\",\n            middleLeft: \"pdfjs-editor-resizer-middle-left\"\n        });\n        if (AnnotationEditor._borderLineWidth !== -1) {\n            return;\n        }\n        const style = getComputedStyle(document.documentElement);\n        AnnotationEditor._borderLineWidth = parseFloat(style.getPropertyValue(\"--outline-width\")) || 0;\n    }\n    static updateDefaultParams(_type, _value) {}\n    static get defaultPropertiesToUpdate() {\n        return [];\n    }\n    static isHandlingMimeForPasting(mime) {\n        return false;\n    }\n    static paste(item, parent) {\n        unreachable(\"Not implemented\");\n    }\n    get propertiesToUpdate() {\n        return [];\n    }\n    get _isDraggable() {\n        return this.#isDraggable;\n    }\n    set _isDraggable(value) {\n        this.#isDraggable = value;\n        this.div?.classList.toggle(\"draggable\", value);\n    }\n    get isEnterHandled() {\n        return true;\n    }\n    center() {\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        switch(this.parentRotation){\n            case 90:\n                this.x -= this.height * pageHeight / (pageWidth * 2);\n                this.y += this.width * pageWidth / (pageHeight * 2);\n                break;\n            case 180:\n                this.x += this.width / 2;\n                this.y += this.height / 2;\n                break;\n            case 270:\n                this.x += this.height * pageHeight / (pageWidth * 2);\n                this.y -= this.width * pageWidth / (pageHeight * 2);\n                break;\n            default:\n                this.x -= this.width / 2;\n                this.y -= this.height / 2;\n                break;\n        }\n        this.fixAndSetPosition();\n    }\n    addCommands(params) {\n        this._uiManager.addCommands(params);\n    }\n    get currentLayer() {\n        return this._uiManager.currentLayer;\n    }\n    setInBackground() {\n        this.div.style.zIndex = 0;\n    }\n    setInForeground() {\n        this.div.style.zIndex = this.#zIndex;\n    }\n    setParent(parent) {\n        if (parent !== null) {\n            this.pageIndex = parent.pageIndex;\n            this.pageDimensions = parent.pageDimensions;\n        } else {\n            this.#stopResizing();\n        }\n        this.parent = parent;\n    }\n    focusin(event) {\n        if (!this._focusEventsAllowed) {\n            return;\n        }\n        if (!this.#hasBeenClicked) {\n            this.parent.setSelected(this);\n        } else {\n            this.#hasBeenClicked = false;\n        }\n    }\n    focusout(event) {\n        if (!this._focusEventsAllowed) {\n            return;\n        }\n        if (!this.isAttachedToDOM) {\n            return;\n        }\n        const target = event.relatedTarget;\n        if (target?.closest(`#${this.id}`)) {\n            return;\n        }\n        event.preventDefault();\n        if (!this.parent?.isMultipleSelection) {\n            this.commitOrRemove();\n        }\n    }\n    commitOrRemove() {\n        if (this.isEmpty()) {\n            this.remove();\n        } else {\n            this.commit();\n        }\n    }\n    commit() {\n        this.addToAnnotationStorage();\n    }\n    addToAnnotationStorage() {\n        this._uiManager.addToAnnotationStorage(this);\n    }\n    setAt(x, y, tx, ty) {\n        const [width, height] = this.parentDimensions;\n        [tx, ty] = this.screenToPageTranslation(tx, ty);\n        this.x = (x + tx) / width;\n        this.y = (y + ty) / height;\n        this.fixAndSetPosition();\n    }\n    _moveAfterPaste(baseX, baseY) {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n        this._onTranslated();\n    }\n    #translate([width, height], x, y) {\n        [x, y] = this.screenToPageTranslation(x, y);\n        this.x += x / width;\n        this.y += y / height;\n        this._onTranslating(this.x, this.y);\n        this.fixAndSetPosition();\n    }\n    translate(x, y) {\n        this.#translate(this.parentDimensions, x, y);\n    }\n    translateInPage(x, y) {\n        this.#initialRect ||= [\n            this.x,\n            this.y,\n            this.width,\n            this.height\n        ];\n        this.#translate(this.pageDimensions, x, y);\n        this.div.scrollIntoView({\n            block: \"nearest\"\n        });\n    }\n    translationDone() {\n        this._onTranslated(this.x, this.y);\n    }\n    drag(tx, ty) {\n        this.#initialRect ||= [\n            this.x,\n            this.y,\n            this.width,\n            this.height\n        ];\n        const { div, parentDimensions: [parentWidth, parentHeight] } = this;\n        this.x += tx / parentWidth;\n        this.y += ty / parentHeight;\n        if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {\n            const { x, y } = this.div.getBoundingClientRect();\n            if (this.parent.findNewParent(this, x, y)) {\n                this.x -= Math.floor(this.x);\n                this.y -= Math.floor(this.y);\n            }\n        }\n        let { x, y } = this;\n        const [bx, by] = this.getBaseTranslation();\n        x += bx;\n        y += by;\n        const { style } = div;\n        style.left = `${(100 * x).toFixed(2)}%`;\n        style.top = `${(100 * y).toFixed(2)}%`;\n        this._onTranslating(x, y);\n        div.scrollIntoView({\n            block: \"nearest\"\n        });\n    }\n    _onTranslating(x, y) {}\n    _onTranslated(x, y) {}\n    get _hasBeenMoved() {\n        return !!this.#initialRect && (this.#initialRect[0] !== this.x || this.#initialRect[1] !== this.y);\n    }\n    get _hasBeenResized() {\n        return !!this.#initialRect && (this.#initialRect[2] !== this.width || this.#initialRect[3] !== this.height);\n    }\n    getBaseTranslation() {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const { _borderLineWidth } = AnnotationEditor;\n        const x = _borderLineWidth / parentWidth;\n        const y = _borderLineWidth / parentHeight;\n        switch(this.rotation){\n            case 90:\n                return [\n                    -x,\n                    y\n                ];\n            case 180:\n                return [\n                    x,\n                    y\n                ];\n            case 270:\n                return [\n                    x,\n                    -y\n                ];\n            default:\n                return [\n                    -x,\n                    -y\n                ];\n        }\n    }\n    get _mustFixPosition() {\n        return true;\n    }\n    fixAndSetPosition(rotation = this.rotation) {\n        const { div: { style }, pageDimensions: [pageWidth, pageHeight] } = this;\n        let { x, y, width, height } = this;\n        width *= pageWidth;\n        height *= pageHeight;\n        x *= pageWidth;\n        y *= pageHeight;\n        if (this._mustFixPosition) {\n            switch(rotation){\n                case 0:\n                    x = MathClamp(x, 0, pageWidth - width);\n                    y = MathClamp(y, 0, pageHeight - height);\n                    break;\n                case 90:\n                    x = MathClamp(x, 0, pageWidth - height);\n                    y = MathClamp(y, width, pageHeight);\n                    break;\n                case 180:\n                    x = MathClamp(x, width, pageWidth);\n                    y = MathClamp(y, height, pageHeight);\n                    break;\n                case 270:\n                    x = MathClamp(x, height, pageWidth);\n                    y = MathClamp(y, 0, pageHeight - width);\n                    break;\n            }\n        }\n        this.x = x /= pageWidth;\n        this.y = y /= pageHeight;\n        const [bx, by] = this.getBaseTranslation();\n        x += bx;\n        y += by;\n        style.left = `${(100 * x).toFixed(2)}%`;\n        style.top = `${(100 * y).toFixed(2)}%`;\n        this.moveInDOM();\n    }\n    static #rotatePoint(x, y, angle) {\n        switch(angle){\n            case 90:\n                return [\n                    y,\n                    -x\n                ];\n            case 180:\n                return [\n                    -x,\n                    -y\n                ];\n            case 270:\n                return [\n                    -y,\n                    x\n                ];\n            default:\n                return [\n                    x,\n                    y\n                ];\n        }\n    }\n    screenToPageTranslation(x, y) {\n        return AnnotationEditor.#rotatePoint(x, y, this.parentRotation);\n    }\n    pageTranslationToScreen(x, y) {\n        return AnnotationEditor.#rotatePoint(x, y, 360 - this.parentRotation);\n    }\n    #getRotationMatrix(rotation) {\n        switch(rotation){\n            case 90:\n                {\n                    const [pageWidth, pageHeight] = this.pageDimensions;\n                    return [\n                        0,\n                        -pageWidth / pageHeight,\n                        pageHeight / pageWidth,\n                        0\n                    ];\n                }\n            case 180:\n                return [\n                    -1,\n                    0,\n                    0,\n                    -1\n                ];\n            case 270:\n                {\n                    const [pageWidth, pageHeight] = this.pageDimensions;\n                    return [\n                        0,\n                        pageWidth / pageHeight,\n                        -pageHeight / pageWidth,\n                        0\n                    ];\n                }\n            default:\n                return [\n                    1,\n                    0,\n                    0,\n                    1\n                ];\n        }\n    }\n    get parentScale() {\n        return this._uiManager.viewParameters.realScale;\n    }\n    get parentRotation() {\n        return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;\n    }\n    get parentDimensions() {\n        const { parentScale, pageDimensions: [pageWidth, pageHeight] } = this;\n        return [\n            pageWidth * parentScale,\n            pageHeight * parentScale\n        ];\n    }\n    setDims(width, height) {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const { style } = this.div;\n        style.width = `${(100 * width / parentWidth).toFixed(2)}%`;\n        if (!this.#keepAspectRatio) {\n            style.height = `${(100 * height / parentHeight).toFixed(2)}%`;\n        }\n    }\n    fixDims() {\n        const { style } = this.div;\n        const { height, width } = style;\n        const widthPercent = width.endsWith(\"%\");\n        const heightPercent = !this.#keepAspectRatio && height.endsWith(\"%\");\n        if (widthPercent && heightPercent) {\n            return;\n        }\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        if (!widthPercent) {\n            style.width = `${(100 * parseFloat(width) / parentWidth).toFixed(2)}%`;\n        }\n        if (!this.#keepAspectRatio && !heightPercent) {\n            style.height = `${(100 * parseFloat(height) / parentHeight).toFixed(2)}%`;\n        }\n    }\n    getInitialTranslation() {\n        return [\n            0,\n            0\n        ];\n    }\n    #createResizers() {\n        if (this.#resizersDiv) {\n            return;\n        }\n        this.#resizersDiv = document.createElement(\"div\");\n        this.#resizersDiv.classList.add(\"resizers\");\n        const classes = this._willKeepAspectRatio ? [\n            \"topLeft\",\n            \"topRight\",\n            \"bottomRight\",\n            \"bottomLeft\"\n        ] : [\n            \"topLeft\",\n            \"topMiddle\",\n            \"topRight\",\n            \"middleRight\",\n            \"bottomRight\",\n            \"bottomMiddle\",\n            \"bottomLeft\",\n            \"middleLeft\"\n        ];\n        const signal = this._uiManager._signal;\n        for (const name of classes){\n            const div = document.createElement(\"div\");\n            this.#resizersDiv.append(div);\n            div.classList.add(\"resizer\", name);\n            div.setAttribute(\"data-resizer-name\", name);\n            div.addEventListener(\"pointerdown\", this.#resizerPointerdown.bind(this, name), {\n                signal\n            });\n            div.addEventListener(\"contextmenu\", noContextMenu, {\n                signal\n            });\n            div.tabIndex = -1;\n        }\n        this.div.prepend(this.#resizersDiv);\n    }\n    #resizerPointerdown(name, event) {\n        event.preventDefault();\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            return;\n        }\n        this.#altText?.toggle(false);\n        const savedDraggable = this._isDraggable;\n        this._isDraggable = false;\n        this.#lastPointerCoords = [\n            event.screenX,\n            event.screenY\n        ];\n        const ac = new AbortController();\n        const signal = this._uiManager.combinedSignal(ac);\n        this.parent.togglePointerEvents(false);\n        window.addEventListener(\"pointermove\", this.#resizerPointermove.bind(this, name), {\n            passive: true,\n            capture: true,\n            signal\n        });\n        window.addEventListener(\"touchmove\", stopEvent, {\n            passive: false,\n            signal\n        });\n        window.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        this.#savedDimensions = {\n            savedX: this.x,\n            savedY: this.y,\n            savedWidth: this.width,\n            savedHeight: this.height\n        };\n        const savedParentCursor = this.parent.div.style.cursor;\n        const savedCursor = this.div.style.cursor;\n        this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;\n        const pointerUpCallback = ()=>{\n            ac.abort();\n            this.parent.togglePointerEvents(true);\n            this.#altText?.toggle(true);\n            this._isDraggable = savedDraggable;\n            this.parent.div.style.cursor = savedParentCursor;\n            this.div.style.cursor = savedCursor;\n            this.#addResizeToUndoStack();\n        };\n        window.addEventListener(\"pointerup\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"blur\", pointerUpCallback, {\n            signal\n        });\n    }\n    #resize(x, y, width, height) {\n        this.width = width;\n        this.height = height;\n        this.x = x;\n        this.y = y;\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setDims(parentWidth * width, parentHeight * height);\n        this.fixAndSetPosition();\n        this._onResized();\n    }\n    _onResized() {}\n    #addResizeToUndoStack() {\n        if (!this.#savedDimensions) {\n            return;\n        }\n        const { savedX, savedY, savedWidth, savedHeight } = this.#savedDimensions;\n        this.#savedDimensions = null;\n        const newX = this.x;\n        const newY = this.y;\n        const newWidth = this.width;\n        const newHeight = this.height;\n        if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) {\n            return;\n        }\n        this.addCommands({\n            cmd: this.#resize.bind(this, newX, newY, newWidth, newHeight),\n            undo: this.#resize.bind(this, savedX, savedY, savedWidth, savedHeight),\n            mustExec: true\n        });\n    }\n    static _round(x) {\n        return Math.round(x * 10000) / 10000;\n    }\n    #resizerPointermove(name, event) {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const savedX = this.x;\n        const savedY = this.y;\n        const savedWidth = this.width;\n        const savedHeight = this.height;\n        const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;\n        const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;\n        const rotationMatrix = this.#getRotationMatrix(this.rotation);\n        const transf = (x, y)=>[\n                rotationMatrix[0] * x + rotationMatrix[2] * y,\n                rotationMatrix[1] * x + rotationMatrix[3] * y\n            ];\n        const invRotationMatrix = this.#getRotationMatrix(360 - this.rotation);\n        const invTransf = (x, y)=>[\n                invRotationMatrix[0] * x + invRotationMatrix[2] * y,\n                invRotationMatrix[1] * x + invRotationMatrix[3] * y\n            ];\n        let getPoint;\n        let getOpposite;\n        let isDiagonal = false;\n        let isHorizontal = false;\n        switch(name){\n            case \"topLeft\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        0,\n                        0\n                    ];\n                getOpposite = (w, h)=>[\n                        w,\n                        h\n                    ];\n                break;\n            case \"topMiddle\":\n                getPoint = (w, h)=>[\n                        w / 2,\n                        0\n                    ];\n                getOpposite = (w, h)=>[\n                        w / 2,\n                        h\n                    ];\n                break;\n            case \"topRight\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        w,\n                        0\n                    ];\n                getOpposite = (w, h)=>[\n                        0,\n                        h\n                    ];\n                break;\n            case \"middleRight\":\n                isHorizontal = true;\n                getPoint = (w, h)=>[\n                        w,\n                        h / 2\n                    ];\n                getOpposite = (w, h)=>[\n                        0,\n                        h / 2\n                    ];\n                break;\n            case \"bottomRight\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        w,\n                        h\n                    ];\n                getOpposite = (w, h)=>[\n                        0,\n                        0\n                    ];\n                break;\n            case \"bottomMiddle\":\n                getPoint = (w, h)=>[\n                        w / 2,\n                        h\n                    ];\n                getOpposite = (w, h)=>[\n                        w / 2,\n                        0\n                    ];\n                break;\n            case \"bottomLeft\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        0,\n                        h\n                    ];\n                getOpposite = (w, h)=>[\n                        w,\n                        0\n                    ];\n                break;\n            case \"middleLeft\":\n                isHorizontal = true;\n                getPoint = (w, h)=>[\n                        0,\n                        h / 2\n                    ];\n                getOpposite = (w, h)=>[\n                        w,\n                        h / 2\n                    ];\n                break;\n        }\n        const point = getPoint(savedWidth, savedHeight);\n        const oppositePoint = getOpposite(savedWidth, savedHeight);\n        let transfOppositePoint = transf(...oppositePoint);\n        const oppositeX = AnnotationEditor._round(savedX + transfOppositePoint[0]);\n        const oppositeY = AnnotationEditor._round(savedY + transfOppositePoint[1]);\n        let ratioX = 1;\n        let ratioY = 1;\n        let deltaX, deltaY;\n        if (!event.fromKeyboard) {\n            const { screenX, screenY } = event;\n            const [lastScreenX, lastScreenY] = this.#lastPointerCoords;\n            [deltaX, deltaY] = this.screenToPageTranslation(screenX - lastScreenX, screenY - lastScreenY);\n            this.#lastPointerCoords[0] = screenX;\n            this.#lastPointerCoords[1] = screenY;\n        } else {\n            ({ deltaX, deltaY } = event);\n        }\n        [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);\n        if (isDiagonal) {\n            const oldDiag = Math.hypot(savedWidth, savedHeight);\n            ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);\n        } else if (isHorizontal) {\n            ratioX = MathClamp(Math.abs(oppositePoint[0] - point[0] - deltaX), minWidth, 1) / savedWidth;\n        } else {\n            ratioY = MathClamp(Math.abs(oppositePoint[1] - point[1] - deltaY), minHeight, 1) / savedHeight;\n        }\n        const newWidth = AnnotationEditor._round(savedWidth * ratioX);\n        const newHeight = AnnotationEditor._round(savedHeight * ratioY);\n        transfOppositePoint = transf(...getOpposite(newWidth, newHeight));\n        const newX = oppositeX - transfOppositePoint[0];\n        const newY = oppositeY - transfOppositePoint[1];\n        this.#initialRect ||= [\n            this.x,\n            this.y,\n            this.width,\n            this.height\n        ];\n        this.width = newWidth;\n        this.height = newHeight;\n        this.x = newX;\n        this.y = newY;\n        this.setDims(parentWidth * newWidth, parentHeight * newHeight);\n        this.fixAndSetPosition();\n        this._onResizing();\n    }\n    _onResizing() {}\n    altTextFinish() {\n        this.#altText?.finish();\n    }\n    async addEditToolbar() {\n        if (this._editToolbar || this.#isInEditMode) {\n            return this._editToolbar;\n        }\n        this._editToolbar = new EditorToolbar(this);\n        this.div.append(this._editToolbar.render());\n        if (this.#altText) {\n            await this._editToolbar.addAltText(this.#altText);\n        }\n        return this._editToolbar;\n    }\n    removeEditToolbar() {\n        if (!this._editToolbar) {\n            return;\n        }\n        this._editToolbar.remove();\n        this._editToolbar = null;\n        this.#altText?.destroy();\n    }\n    addContainer(container) {\n        const editToolbarDiv = this._editToolbar?.div;\n        if (editToolbarDiv) {\n            editToolbarDiv.before(container);\n        } else {\n            this.div.append(container);\n        }\n    }\n    getClientDimensions() {\n        return this.div.getBoundingClientRect();\n    }\n    async addAltTextButton() {\n        if (this.#altText) {\n            return;\n        }\n        AltText.initialize(AnnotationEditor._l10n);\n        this.#altText = new AltText(this);\n        if (this.#accessibilityData) {\n            this.#altText.data = this.#accessibilityData;\n            this.#accessibilityData = null;\n        }\n        await this.addEditToolbar();\n    }\n    get altTextData() {\n        return this.#altText?.data;\n    }\n    set altTextData(data) {\n        if (!this.#altText) {\n            return;\n        }\n        this.#altText.data = data;\n    }\n    get guessedAltText() {\n        return this.#altText?.guessedText;\n    }\n    async setGuessedAltText(text) {\n        await this.#altText?.setGuessedText(text);\n    }\n    serializeAltText(isForCopying) {\n        return this.#altText?.serialize(isForCopying);\n    }\n    hasAltText() {\n        return !!this.#altText && !this.#altText.isEmpty();\n    }\n    hasAltTextData() {\n        return this.#altText?.hasData() ?? false;\n    }\n    render() {\n        const div = this.div = document.createElement(\"div\");\n        div.setAttribute(\"data-editor-rotation\", (360 - this.rotation) % 360);\n        div.className = this.name;\n        div.setAttribute(\"id\", this.id);\n        div.tabIndex = this.#disabled ? -1 : 0;\n        div.setAttribute(\"role\", \"application\");\n        if (this.defaultL10nId) {\n            div.setAttribute(\"data-l10n-id\", this.defaultL10nId);\n        }\n        if (!this._isVisible) {\n            div.classList.add(\"hidden\");\n        }\n        this.setInForeground();\n        this.#addFocusListeners();\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        if (this.parentRotation % 180 !== 0) {\n            div.style.maxWidth = `${(100 * parentHeight / parentWidth).toFixed(2)}%`;\n            div.style.maxHeight = `${(100 * parentWidth / parentHeight).toFixed(2)}%`;\n        }\n        const [tx, ty] = this.getInitialTranslation();\n        this.translate(tx, ty);\n        bindEvents(this, div, [\n            \"keydown\",\n            \"pointerdown\"\n        ]);\n        if (this.isResizable && this._uiManager._supportsPinchToZoom) {\n            this.#touchManager ||= new TouchManager({\n                container: div,\n                isPinchingDisabled: ()=>!this.isSelected,\n                onPinchStart: this.#touchPinchStartCallback.bind(this),\n                onPinching: this.#touchPinchCallback.bind(this),\n                onPinchEnd: this.#touchPinchEndCallback.bind(this),\n                signal: this._uiManager._signal\n            });\n        }\n        this._uiManager._editorUndoBar?.hide();\n        return div;\n    }\n    #touchPinchStartCallback() {\n        this.#savedDimensions = {\n            savedX: this.x,\n            savedY: this.y,\n            savedWidth: this.width,\n            savedHeight: this.height\n        };\n        this.#altText?.toggle(false);\n        this.parent.togglePointerEvents(false);\n    }\n    #touchPinchCallback(_origin, prevDistance, distance) {\n        const slowDownFactor = 0.7;\n        let factor = slowDownFactor * (distance / prevDistance) + 1 - slowDownFactor;\n        if (factor === 1) {\n            return;\n        }\n        const rotationMatrix = this.#getRotationMatrix(this.rotation);\n        const transf = (x, y)=>[\n                rotationMatrix[0] * x + rotationMatrix[2] * y,\n                rotationMatrix[1] * x + rotationMatrix[3] * y\n            ];\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const savedX = this.x;\n        const savedY = this.y;\n        const savedWidth = this.width;\n        const savedHeight = this.height;\n        const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;\n        const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;\n        factor = Math.max(Math.min(factor, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);\n        const newWidth = AnnotationEditor._round(savedWidth * factor);\n        const newHeight = AnnotationEditor._round(savedHeight * factor);\n        if (newWidth === savedWidth && newHeight === savedHeight) {\n            return;\n        }\n        this.#initialRect ||= [\n            savedX,\n            savedY,\n            savedWidth,\n            savedHeight\n        ];\n        const transfCenterPoint = transf(savedWidth / 2, savedHeight / 2);\n        const centerX = AnnotationEditor._round(savedX + transfCenterPoint[0]);\n        const centerY = AnnotationEditor._round(savedY + transfCenterPoint[1]);\n        const newTransfCenterPoint = transf(newWidth / 2, newHeight / 2);\n        this.x = centerX - newTransfCenterPoint[0];\n        this.y = centerY - newTransfCenterPoint[1];\n        this.width = newWidth;\n        this.height = newHeight;\n        this.setDims(parentWidth * newWidth, parentHeight * newHeight);\n        this.fixAndSetPosition();\n        this._onResizing();\n    }\n    #touchPinchEndCallback() {\n        this.#altText?.toggle(true);\n        this.parent.togglePointerEvents(true);\n        this.#addResizeToUndoStack();\n    }\n    pointerdown(event) {\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            event.preventDefault();\n            return;\n        }\n        this.#hasBeenClicked = true;\n        if (this._isDraggable) {\n            this.#setUpDragSession(event);\n            return;\n        }\n        this.#selectOnPointerEvent(event);\n    }\n    get isSelected() {\n        return this._uiManager.isSelected(this);\n    }\n    #selectOnPointerEvent(event) {\n        const { isMac } = util_FeatureTest.platform;\n        if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {\n            this.parent.toggleSelected(this);\n        } else {\n            this.parent.setSelected(this);\n        }\n    }\n    #setUpDragSession(event) {\n        const { isSelected } = this;\n        this._uiManager.setUpDragSession();\n        let hasDraggingStarted = false;\n        const ac = new AbortController();\n        const signal = this._uiManager.combinedSignal(ac);\n        const opts = {\n            capture: true,\n            passive: false,\n            signal\n        };\n        const cancelDrag = (e)=>{\n            ac.abort();\n            this.#dragPointerId = null;\n            this.#hasBeenClicked = false;\n            if (!this._uiManager.endDragSession()) {\n                this.#selectOnPointerEvent(e);\n            }\n            if (hasDraggingStarted) {\n                this._onStopDragging();\n            }\n        };\n        if (isSelected) {\n            this.#prevDragX = event.clientX;\n            this.#prevDragY = event.clientY;\n            this.#dragPointerId = event.pointerId;\n            this.#dragPointerType = event.pointerType;\n            window.addEventListener(\"pointermove\", (e)=>{\n                if (!hasDraggingStarted) {\n                    hasDraggingStarted = true;\n                    this._onStartDragging();\n                }\n                const { clientX: x, clientY: y, pointerId } = e;\n                if (pointerId !== this.#dragPointerId) {\n                    stopEvent(e);\n                    return;\n                }\n                const [tx, ty] = this.screenToPageTranslation(x - this.#prevDragX, y - this.#prevDragY);\n                this.#prevDragX = x;\n                this.#prevDragY = y;\n                this._uiManager.dragSelectedEditors(tx, ty);\n            }, opts);\n            window.addEventListener(\"touchmove\", stopEvent, opts);\n            window.addEventListener(\"pointerdown\", (e)=>{\n                if (e.pointerType === this.#dragPointerType) {\n                    if (this.#touchManager || e.isPrimary) {\n                        cancelDrag(e);\n                    }\n                }\n                stopEvent(e);\n            }, opts);\n        }\n        const pointerUpCallback = (e)=>{\n            if (!this.#dragPointerId || this.#dragPointerId === e.pointerId) {\n                cancelDrag(e);\n                return;\n            }\n            stopEvent(e);\n        };\n        window.addEventListener(\"pointerup\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"blur\", pointerUpCallback, {\n            signal\n        });\n    }\n    _onStartDragging() {}\n    _onStopDragging() {}\n    moveInDOM() {\n        if (this.#moveInDOMTimeout) {\n            clearTimeout(this.#moveInDOMTimeout);\n        }\n        this.#moveInDOMTimeout = setTimeout(()=>{\n            this.#moveInDOMTimeout = null;\n            this.parent?.moveEditorInDOM(this);\n        }, 0);\n    }\n    _setParentAndPosition(parent, x, y) {\n        parent.changeParent(this);\n        this.x = x;\n        this.y = y;\n        this.fixAndSetPosition();\n        this._onTranslated();\n    }\n    getRect(tx, ty, rotation = this.rotation) {\n        const scale = this.parentScale;\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const [pageX, pageY] = this.pageTranslation;\n        const shiftX = tx / scale;\n        const shiftY = ty / scale;\n        const x = this.x * pageWidth;\n        const y = this.y * pageHeight;\n        const width = this.width * pageWidth;\n        const height = this.height * pageHeight;\n        switch(rotation){\n            case 0:\n                return [\n                    x + shiftX + pageX,\n                    pageHeight - y - shiftY - height + pageY,\n                    x + shiftX + width + pageX,\n                    pageHeight - y - shiftY + pageY\n                ];\n            case 90:\n                return [\n                    x + shiftY + pageX,\n                    pageHeight - y + shiftX + pageY,\n                    x + shiftY + height + pageX,\n                    pageHeight - y + shiftX + width + pageY\n                ];\n            case 180:\n                return [\n                    x - shiftX - width + pageX,\n                    pageHeight - y + shiftY + pageY,\n                    x - shiftX + pageX,\n                    pageHeight - y + shiftY + height + pageY\n                ];\n            case 270:\n                return [\n                    x - shiftY - height + pageX,\n                    pageHeight - y - shiftX - width + pageY,\n                    x - shiftY + pageX,\n                    pageHeight - y - shiftX + pageY\n                ];\n            default:\n                throw new Error(\"Invalid rotation\");\n        }\n    }\n    getRectInCurrentCoords(rect, pageHeight) {\n        const [x1, y1, x2, y2] = rect;\n        const width = x2 - x1;\n        const height = y2 - y1;\n        switch(this.rotation){\n            case 0:\n                return [\n                    x1,\n                    pageHeight - y2,\n                    width,\n                    height\n                ];\n            case 90:\n                return [\n                    x1,\n                    pageHeight - y1,\n                    height,\n                    width\n                ];\n            case 180:\n                return [\n                    x2,\n                    pageHeight - y1,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    x2,\n                    pageHeight - y2,\n                    height,\n                    width\n                ];\n            default:\n                throw new Error(\"Invalid rotation\");\n        }\n    }\n    onceAdded(focus) {}\n    isEmpty() {\n        return false;\n    }\n    enableEditMode() {\n        this.#isInEditMode = true;\n    }\n    disableEditMode() {\n        this.#isInEditMode = false;\n    }\n    isInEditMode() {\n        return this.#isInEditMode;\n    }\n    shouldGetKeyboardEvents() {\n        return this.#isResizerEnabledForKeyboard;\n    }\n    needsToBeRebuilt() {\n        return this.div && !this.isAttachedToDOM;\n    }\n    get isOnScreen() {\n        const { top, left, bottom, right } = this.getClientDimensions();\n        const { innerHeight, innerWidth } = window;\n        return left < innerWidth && right > 0 && top < innerHeight && bottom > 0;\n    }\n    #addFocusListeners() {\n        if (this.#focusAC || !this.div) {\n            return;\n        }\n        this.#focusAC = new AbortController();\n        const signal = this._uiManager.combinedSignal(this.#focusAC);\n        this.div.addEventListener(\"focusin\", this.focusin.bind(this), {\n            signal\n        });\n        this.div.addEventListener(\"focusout\", this.focusout.bind(this), {\n            signal\n        });\n    }\n    rebuild() {\n        this.#addFocusListeners();\n    }\n    rotate(_angle) {}\n    resize() {}\n    serializeDeleted() {\n        return {\n            id: this.annotationElementId,\n            deleted: true,\n            pageIndex: this.pageIndex,\n            popupRef: this._initialData?.popupRef || \"\"\n        };\n    }\n    serialize(isForCopying = false, context = null) {\n        unreachable(\"An editor must be serializable\");\n    }\n    static async deserialize(data, parent, uiManager) {\n        const editor = new this.prototype.constructor({\n            parent,\n            id: parent.getNextId(),\n            uiManager\n        });\n        editor.rotation = data.rotation;\n        editor.#accessibilityData = data.accessibilityData;\n        editor._isCopy = data.isCopy || false;\n        const [pageWidth, pageHeight] = editor.pageDimensions;\n        const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);\n        editor.x = x / pageWidth;\n        editor.y = y / pageHeight;\n        editor.width = width / pageWidth;\n        editor.height = height / pageHeight;\n        return editor;\n    }\n    get hasBeenModified() {\n        return !!this.annotationElementId && (this.deleted || this.serialize() !== null);\n    }\n    remove() {\n        this.#focusAC?.abort();\n        this.#focusAC = null;\n        if (!this.isEmpty()) {\n            this.commit();\n        }\n        if (this.parent) {\n            this.parent.remove(this);\n        } else {\n            this._uiManager.removeEditor(this);\n        }\n        if (this.#moveInDOMTimeout) {\n            clearTimeout(this.#moveInDOMTimeout);\n            this.#moveInDOMTimeout = null;\n        }\n        this.#stopResizing();\n        this.removeEditToolbar();\n        if (this.#telemetryTimeouts) {\n            for (const timeout of this.#telemetryTimeouts.values()){\n                clearTimeout(timeout);\n            }\n            this.#telemetryTimeouts = null;\n        }\n        this.parent = null;\n        this.#touchManager?.destroy();\n        this.#touchManager = null;\n    }\n    get isResizable() {\n        return false;\n    }\n    makeResizable() {\n        if (this.isResizable) {\n            this.#createResizers();\n            this.#resizersDiv.classList.remove(\"hidden\");\n        }\n    }\n    get toolbarPosition() {\n        return null;\n    }\n    keydown(event) {\n        if (!this.isResizable || event.target !== this.div || event.key !== \"Enter\") {\n            return;\n        }\n        this._uiManager.setSelected(this);\n        this.#savedDimensions = {\n            savedX: this.x,\n            savedY: this.y,\n            savedWidth: this.width,\n            savedHeight: this.height\n        };\n        const children = this.#resizersDiv.children;\n        if (!this.#allResizerDivs) {\n            this.#allResizerDivs = Array.from(children);\n            const boundResizerKeydown = this.#resizerKeydown.bind(this);\n            const boundResizerBlur = this.#resizerBlur.bind(this);\n            const signal = this._uiManager._signal;\n            for (const div of this.#allResizerDivs){\n                const name = div.getAttribute(\"data-resizer-name\");\n                div.setAttribute(\"role\", \"spinbutton\");\n                div.addEventListener(\"keydown\", boundResizerKeydown, {\n                    signal\n                });\n                div.addEventListener(\"blur\", boundResizerBlur, {\n                    signal\n                });\n                div.addEventListener(\"focus\", this.#resizerFocus.bind(this, name), {\n                    signal\n                });\n                div.setAttribute(\"data-l10n-id\", AnnotationEditor._l10nResizer[name]);\n            }\n        }\n        const first = this.#allResizerDivs[0];\n        let firstPosition = 0;\n        for (const div of children){\n            if (div === first) {\n                break;\n            }\n            firstPosition++;\n        }\n        const nextFirstPosition = (360 - this.rotation + this.parentRotation) % 360 / 90 * (this.#allResizerDivs.length / 4);\n        if (nextFirstPosition !== firstPosition) {\n            if (nextFirstPosition < firstPosition) {\n                for(let i = 0; i < firstPosition - nextFirstPosition; i++){\n                    this.#resizersDiv.append(this.#resizersDiv.firstChild);\n                }\n            } else if (nextFirstPosition > firstPosition) {\n                for(let i = 0; i < nextFirstPosition - firstPosition; i++){\n                    this.#resizersDiv.firstChild.before(this.#resizersDiv.lastChild);\n                }\n            }\n            let i = 0;\n            for (const child of children){\n                const div = this.#allResizerDivs[i++];\n                const name = div.getAttribute(\"data-resizer-name\");\n                child.setAttribute(\"data-l10n-id\", AnnotationEditor._l10nResizer[name]);\n            }\n        }\n        this.#setResizerTabIndex(0);\n        this.#isResizerEnabledForKeyboard = true;\n        this.#resizersDiv.firstChild.focus({\n            focusVisible: true\n        });\n        event.preventDefault();\n        event.stopImmediatePropagation();\n    }\n    #resizerKeydown(event) {\n        AnnotationEditor._resizerKeyboardManager.exec(this, event);\n    }\n    #resizerBlur(event) {\n        if (this.#isResizerEnabledForKeyboard && event.relatedTarget?.parentNode !== this.#resizersDiv) {\n            this.#stopResizing();\n        }\n    }\n    #resizerFocus(name) {\n        this.#focusedResizerName = this.#isResizerEnabledForKeyboard ? name : \"\";\n    }\n    #setResizerTabIndex(value) {\n        if (!this.#allResizerDivs) {\n            return;\n        }\n        for (const div of this.#allResizerDivs){\n            div.tabIndex = value;\n        }\n    }\n    _resizeWithKeyboard(x, y) {\n        if (!this.#isResizerEnabledForKeyboard) {\n            return;\n        }\n        this.#resizerPointermove(this.#focusedResizerName, {\n            deltaX: x,\n            deltaY: y,\n            fromKeyboard: true\n        });\n    }\n    #stopResizing() {\n        this.#isResizerEnabledForKeyboard = false;\n        this.#setResizerTabIndex(-1);\n        this.#addResizeToUndoStack();\n    }\n    _stopResizingWithKeyboard() {\n        this.#stopResizing();\n        this.div.focus();\n    }\n    select() {\n        this.makeResizable();\n        this.div?.classList.add(\"selectedEditor\");\n        if (!this._editToolbar) {\n            this.addEditToolbar().then(()=>{\n                if (this.div?.classList.contains(\"selectedEditor\")) {\n                    this._editToolbar?.show();\n                }\n            });\n            return;\n        }\n        this._editToolbar?.show();\n        this.#altText?.toggleAltTextBadge(false);\n    }\n    unselect() {\n        this.#resizersDiv?.classList.add(\"hidden\");\n        this.div?.classList.remove(\"selectedEditor\");\n        if (this.div?.contains(document.activeElement)) {\n            this._uiManager.currentLayer.div.focus({\n                preventScroll: true\n            });\n        }\n        this._editToolbar?.hide();\n        this.#altText?.toggleAltTextBadge(true);\n    }\n    updateParams(type, value) {}\n    disableEditing() {}\n    enableEditing() {}\n    enterInEditMode() {}\n    getElementForAltText() {\n        return this.div;\n    }\n    get contentDiv() {\n        return this.div;\n    }\n    get isEditing() {\n        return this.#isEditing;\n    }\n    set isEditing(value) {\n        this.#isEditing = value;\n        if (!this.parent) {\n            return;\n        }\n        if (value) {\n            this.parent.setSelected(this);\n            this.parent.setActiveEditor(this);\n        } else {\n            this.parent.setActiveEditor(null);\n        }\n    }\n    setAspectRatio(width, height) {\n        this.#keepAspectRatio = true;\n        const aspectRatio = width / height;\n        const { style } = this.div;\n        style.aspectRatio = aspectRatio;\n        style.height = \"auto\";\n    }\n    static get MIN_SIZE() {\n        return 16;\n    }\n    static canCreateNewEmptyEditor() {\n        return true;\n    }\n    get telemetryInitialData() {\n        return {\n            action: \"added\"\n        };\n    }\n    get telemetryFinalData() {\n        return null;\n    }\n    _reportTelemetry(data, mustWait = false) {\n        if (mustWait) {\n            this.#telemetryTimeouts ||= new Map();\n            const { action } = data;\n            let timeout = this.#telemetryTimeouts.get(action);\n            if (timeout) {\n                clearTimeout(timeout);\n            }\n            timeout = setTimeout(()=>{\n                this._reportTelemetry(data);\n                this.#telemetryTimeouts.delete(action);\n                if (this.#telemetryTimeouts.size === 0) {\n                    this.#telemetryTimeouts = null;\n                }\n            }, AnnotationEditor._telemetryTimeout);\n            this.#telemetryTimeouts.set(action, timeout);\n            return;\n        }\n        data.type ||= this.editorType;\n        this._uiManager._eventBus.dispatch(\"reporttelemetry\", {\n            source: this,\n            details: {\n                type: \"editing\",\n                data\n            }\n        });\n    }\n    show(visible = this._isVisible) {\n        this.div.classList.toggle(\"hidden\", !visible);\n        this._isVisible = visible;\n    }\n    enable() {\n        if (this.div) {\n            this.div.tabIndex = 0;\n        }\n        this.#disabled = false;\n    }\n    disable() {\n        if (this.div) {\n            this.div.tabIndex = -1;\n        }\n        this.#disabled = true;\n    }\n    renderAnnotationElement(annotation) {\n        let content = annotation.container.querySelector(\".annotationContent\");\n        if (!content) {\n            content = document.createElement(\"div\");\n            content.classList.add(\"annotationContent\", this.editorType);\n            annotation.container.prepend(content);\n        } else if (content.nodeName === \"CANVAS\") {\n            const canvas = content;\n            content = document.createElement(\"div\");\n            content.classList.add(\"annotationContent\", this.editorType);\n            canvas.before(content);\n        }\n        return content;\n    }\n    resetAnnotationElement(annotation) {\n        const { firstChild } = annotation.container;\n        if (firstChild?.nodeName === \"DIV\" && firstChild.classList.contains(\"annotationContent\")) {\n            firstChild.remove();\n        }\n    }\n}\nclass FakeEditor extends AnnotationEditor {\n    constructor(params){\n        super(params);\n        this.annotationElementId = params.annotationElementId;\n        this.deleted = true;\n    }\n    serialize() {\n        return this.serializeDeleted();\n    }\n}\n; // ./src/shared/murmurhash3.js\nconst SEED = 0xc3d2e1f0;\nconst MASK_HIGH = 0xffff0000;\nconst MASK_LOW = 0xffff;\nclass MurmurHash3_64 {\n    constructor(seed){\n        this.h1 = seed ? seed & 0xffffffff : SEED;\n        this.h2 = seed ? seed & 0xffffffff : SEED;\n    }\n    update(input) {\n        let data, length;\n        if (typeof input === \"string\") {\n            data = new Uint8Array(input.length * 2);\n            length = 0;\n            for(let i = 0, ii = input.length; i < ii; i++){\n                const code = input.charCodeAt(i);\n                if (code <= 0xff) {\n                    data[length++] = code;\n                } else {\n                    data[length++] = code >>> 8;\n                    data[length++] = code & 0xff;\n                }\n            }\n        } else if (ArrayBuffer.isView(input)) {\n            data = input.slice();\n            length = data.byteLength;\n        } else {\n            throw new Error(\"Invalid data format, must be a string or TypedArray.\");\n        }\n        const blockCounts = length >> 2;\n        const tailLength = length - blockCounts * 4;\n        const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);\n        let k1 = 0, k2 = 0;\n        let h1 = this.h1, h2 = this.h2;\n        const C1 = 0xcc9e2d51, C2 = 0x1b873593;\n        const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;\n        for(let i = 0; i < blockCounts; i++){\n            if (i & 1) {\n                k1 = dataUint32[i];\n                k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n                k1 = k1 << 15 | k1 >>> 17;\n                k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n                h1 ^= k1;\n                h1 = h1 << 13 | h1 >>> 19;\n                h1 = h1 * 5 + 0xe6546b64;\n            } else {\n                k2 = dataUint32[i];\n                k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;\n                k2 = k2 << 15 | k2 >>> 17;\n                k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;\n                h2 ^= k2;\n                h2 = h2 << 13 | h2 >>> 19;\n                h2 = h2 * 5 + 0xe6546b64;\n            }\n        }\n        k1 = 0;\n        switch(tailLength){\n            case 3:\n                k1 ^= data[blockCounts * 4 + 2] << 16;\n            case 2:\n                k1 ^= data[blockCounts * 4 + 1] << 8;\n            case 1:\n                k1 ^= data[blockCounts * 4];\n                k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n                k1 = k1 << 15 | k1 >>> 17;\n                k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n                if (blockCounts & 1) {\n                    h1 ^= k1;\n                } else {\n                    h2 ^= k1;\n                }\n        }\n        this.h1 = h1;\n        this.h2 = h2;\n    }\n    hexdigest() {\n        let h1 = this.h1, h2 = this.h2;\n        h1 ^= h2 >>> 1;\n        h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;\n        h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;\n        h1 ^= h2 >>> 1;\n        h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;\n        h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;\n        h1 ^= h2 >>> 1;\n        return (h1 >>> 0).toString(16).padStart(8, \"0\") + (h2 >>> 0).toString(16).padStart(8, \"0\");\n    }\n}\n; // ./src/display/annotation_storage.js\nconst SerializableEmpty = Object.freeze({\n    map: null,\n    hash: \"\",\n    transfer: undefined\n});\nclass AnnotationStorage {\n    #modified;\n    #modifiedIds;\n    #storage;\n    constructor(){\n        this.#modified = false;\n        this.#modifiedIds = null;\n        this.#storage = new Map();\n        this.onSetModified = null;\n        this.onResetModified = null;\n        this.onAnnotationEditor = null;\n    }\n    getValue(key, defaultValue) {\n        const value = this.#storage.get(key);\n        if (value === undefined) {\n            return defaultValue;\n        }\n        return Object.assign(defaultValue, value);\n    }\n    getRawValue(key) {\n        return this.#storage.get(key);\n    }\n    remove(key) {\n        this.#storage.delete(key);\n        if (this.#storage.size === 0) {\n            this.resetModified();\n        }\n        if (typeof this.onAnnotationEditor === \"function\") {\n            for (const value of this.#storage.values()){\n                if (value instanceof AnnotationEditor) {\n                    return;\n                }\n            }\n            this.onAnnotationEditor(null);\n        }\n    }\n    setValue(key, value) {\n        const obj = this.#storage.get(key);\n        let modified = false;\n        if (obj !== undefined) {\n            for (const [entry, val] of Object.entries(value)){\n                if (obj[entry] !== val) {\n                    modified = true;\n                    obj[entry] = val;\n                }\n            }\n        } else {\n            modified = true;\n            this.#storage.set(key, value);\n        }\n        if (modified) {\n            this.#setModified();\n        }\n        if (value instanceof AnnotationEditor && typeof this.onAnnotationEditor === \"function\") {\n            this.onAnnotationEditor(value.constructor._type);\n        }\n    }\n    has(key) {\n        return this.#storage.has(key);\n    }\n    get size() {\n        return this.#storage.size;\n    }\n    #setModified() {\n        if (!this.#modified) {\n            this.#modified = true;\n            if (typeof this.onSetModified === \"function\") {\n                this.onSetModified();\n            }\n        }\n    }\n    resetModified() {\n        if (this.#modified) {\n            this.#modified = false;\n            if (typeof this.onResetModified === \"function\") {\n                this.onResetModified();\n            }\n        }\n    }\n    get print() {\n        return new PrintAnnotationStorage(this);\n    }\n    get serializable() {\n        if (this.#storage.size === 0) {\n            return SerializableEmpty;\n        }\n        const map = new Map(), hash = new MurmurHash3_64(), transfer = [];\n        const context = Object.create(null);\n        let hasBitmap = false;\n        for (const [key, val] of this.#storage){\n            const serialized = val instanceof AnnotationEditor ? val.serialize(false, context) : val;\n            if (serialized) {\n                map.set(key, serialized);\n                hash.update(`${key}:${JSON.stringify(serialized)}`);\n                hasBitmap ||= !!serialized.bitmap;\n            }\n        }\n        if (hasBitmap) {\n            for (const value of map.values()){\n                if (value.bitmap) {\n                    transfer.push(value.bitmap);\n                }\n            }\n        }\n        return map.size > 0 ? {\n            map,\n            hash: hash.hexdigest(),\n            transfer\n        } : SerializableEmpty;\n    }\n    get editorStats() {\n        let stats = null;\n        const typeToEditor = new Map();\n        for (const value of this.#storage.values()){\n            if (!(value instanceof AnnotationEditor)) {\n                continue;\n            }\n            const editorStats = value.telemetryFinalData;\n            if (!editorStats) {\n                continue;\n            }\n            const { type } = editorStats;\n            if (!typeToEditor.has(type)) {\n                typeToEditor.set(type, Object.getPrototypeOf(value).constructor);\n            }\n            stats ||= Object.create(null);\n            const map = stats[type] ||= new Map();\n            for (const [key, val] of Object.entries(editorStats)){\n                if (key === \"type\") {\n                    continue;\n                }\n                let counters = map.get(key);\n                if (!counters) {\n                    counters = new Map();\n                    map.set(key, counters);\n                }\n                const count = counters.get(val) ?? 0;\n                counters.set(val, count + 1);\n            }\n        }\n        for (const [type, editor] of typeToEditor){\n            stats[type] = editor.computeTelemetryFinalData(stats[type]);\n        }\n        return stats;\n    }\n    resetModifiedIds() {\n        this.#modifiedIds = null;\n    }\n    get modifiedIds() {\n        if (this.#modifiedIds) {\n            return this.#modifiedIds;\n        }\n        const ids = [];\n        for (const value of this.#storage.values()){\n            if (!(value instanceof AnnotationEditor) || !value.annotationElementId || !value.serialize()) {\n                continue;\n            }\n            ids.push(value.annotationElementId);\n        }\n        return this.#modifiedIds = {\n            ids: new Set(ids),\n            hash: ids.join(\",\")\n        };\n    }\n    [Symbol.iterator]() {\n        return this.#storage.entries();\n    }\n}\nclass PrintAnnotationStorage extends AnnotationStorage {\n    #serializable;\n    constructor(parent){\n        super();\n        const { map, hash, transfer } = parent.serializable;\n        const clone = structuredClone(map, transfer ? {\n            transfer\n        } : null);\n        this.#serializable = {\n            map: clone,\n            hash,\n            transfer\n        };\n    }\n    get print() {\n        unreachable(\"Should not call PrintAnnotationStorage.print\");\n    }\n    get serializable() {\n        return this.#serializable;\n    }\n    get modifiedIds() {\n        return shadow(this, \"modifiedIds\", {\n            ids: new Set(),\n            hash: \"\"\n        });\n    }\n}\n; // ./src/display/font_loader.js\nclass FontLoader {\n    #systemFonts;\n    constructor({ ownerDocument = globalThis.document, styleElement = null }){\n        this.#systemFonts = new Set();\n        this._document = ownerDocument;\n        this.nativeFontFaces = new Set();\n        this.styleElement = null;\n        this.loadingRequests = [];\n        this.loadTestFontId = 0;\n    }\n    addNativeFontFace(nativeFontFace) {\n        this.nativeFontFaces.add(nativeFontFace);\n        this._document.fonts.add(nativeFontFace);\n    }\n    removeNativeFontFace(nativeFontFace) {\n        this.nativeFontFaces.delete(nativeFontFace);\n        this._document.fonts.delete(nativeFontFace);\n    }\n    insertRule(rule) {\n        if (!this.styleElement) {\n            this.styleElement = this._document.createElement(\"style\");\n            this._document.documentElement.getElementsByTagName(\"head\")[0].append(this.styleElement);\n        }\n        const styleSheet = this.styleElement.sheet;\n        styleSheet.insertRule(rule, styleSheet.cssRules.length);\n    }\n    clear() {\n        for (const nativeFontFace of this.nativeFontFaces){\n            this._document.fonts.delete(nativeFontFace);\n        }\n        this.nativeFontFaces.clear();\n        this.#systemFonts.clear();\n        if (this.styleElement) {\n            this.styleElement.remove();\n            this.styleElement = null;\n        }\n    }\n    async loadSystemFont({ systemFontInfo: info, disableFontFace, _inspectFont }) {\n        if (!info || this.#systemFonts.has(info.loadedName)) {\n            return;\n        }\n        assert(!disableFontFace, \"loadSystemFont shouldn't be called when `disableFontFace` is set.\");\n        if (this.isFontLoadingAPISupported) {\n            const { loadedName, src, style } = info;\n            const fontFace = new FontFace(loadedName, src, style);\n            this.addNativeFontFace(fontFace);\n            try {\n                await fontFace.load();\n                this.#systemFonts.add(loadedName);\n                _inspectFont?.(info);\n            } catch  {\n                warn(`Cannot load system font: ${info.baseFontName}, installing it could help to improve PDF rendering.`);\n                this.removeNativeFontFace(fontFace);\n            }\n            return;\n        }\n        unreachable(\"Not implemented: loadSystemFont without the Font Loading API.\");\n    }\n    async bind(font) {\n        if (font.attached || font.missingFile && !font.systemFontInfo) {\n            return;\n        }\n        font.attached = true;\n        if (font.systemFontInfo) {\n            await this.loadSystemFont(font);\n            return;\n        }\n        if (this.isFontLoadingAPISupported) {\n            const nativeFontFace = font.createNativeFontFace();\n            if (nativeFontFace) {\n                this.addNativeFontFace(nativeFontFace);\n                try {\n                    await nativeFontFace.loaded;\n                } catch (ex) {\n                    warn(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);\n                    font.disableFontFace = true;\n                    throw ex;\n                }\n            }\n            return;\n        }\n        const rule = font.createFontFaceRule();\n        if (rule) {\n            this.insertRule(rule);\n            if (this.isSyncFontLoadingSupported) {\n                return;\n            }\n            await new Promise((resolve)=>{\n                const request = this._queueLoadingCallback(resolve);\n                this._prepareFontLoadEvent(font, request);\n            });\n        }\n    }\n    get isFontLoadingAPISupported() {\n        const hasFonts = !!this._document?.fonts;\n        return shadow(this, \"isFontLoadingAPISupported\", hasFonts);\n    }\n    get isSyncFontLoadingSupported() {\n        return shadow(this, \"isSyncFontLoadingSupported\", isNodeJS || util_FeatureTest.platform.isFirefox);\n    }\n    _queueLoadingCallback(callback) {\n        function completeRequest() {\n            assert(!request.done, \"completeRequest() cannot be called twice.\");\n            request.done = true;\n            while(loadingRequests.length > 0 && loadingRequests[0].done){\n                const otherRequest = loadingRequests.shift();\n                setTimeout(otherRequest.callback, 0);\n            }\n        }\n        const { loadingRequests } = this;\n        const request = {\n            done: false,\n            complete: completeRequest,\n            callback\n        };\n        loadingRequests.push(request);\n        return request;\n    }\n    get _loadTestFont() {\n        const testFont = atob(\"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA\" + \"FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA\" + \"ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA\" + \"AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1\" + \"AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD\" + \"6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM\" + \"AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D\" + \"IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA\" + \"AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA\" + \"AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB\" + \"AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY\" + \"AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA\" + \"AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA\" + \"AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC\" + \"AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3\" + \"Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj\" + \"FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\");\n        return shadow(this, \"_loadTestFont\", testFont);\n    }\n    _prepareFontLoadEvent(font, request) {\n        function int32(data, offset) {\n            return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;\n        }\n        function spliceString(s, offset, remove, insert) {\n            const chunk1 = s.substring(0, offset);\n            const chunk2 = s.substring(offset + remove);\n            return chunk1 + insert + chunk2;\n        }\n        let i, ii;\n        const canvas = this._document.createElement(\"canvas\");\n        canvas.width = 1;\n        canvas.height = 1;\n        const ctx = canvas.getContext(\"2d\");\n        let called = 0;\n        function isFontReady(name, callback) {\n            if (++called > 30) {\n                warn(\"Load test font never loaded.\");\n                callback();\n                return;\n            }\n            ctx.font = \"30px \" + name;\n            ctx.fillText(\".\", 0, 20);\n            const imageData = ctx.getImageData(0, 0, 1, 1);\n            if (imageData.data[3] > 0) {\n                callback();\n                return;\n            }\n            setTimeout(isFontReady.bind(null, name, callback));\n        }\n        const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;\n        let data = this._loadTestFont;\n        const COMMENT_OFFSET = 976;\n        data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\n        const CFF_CHECKSUM_OFFSET = 16;\n        const XXXX_VALUE = 0x58585858;\n        let checksum = int32(data, CFF_CHECKSUM_OFFSET);\n        for(i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4){\n            checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\n        }\n        if (i < loadTestFontId.length) {\n            checksum = checksum - XXXX_VALUE + int32(loadTestFontId + \"XXX\", i) | 0;\n        }\n        data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, string32(checksum));\n        const url = `url(data:font/opentype;base64,${btoa(data)});`;\n        const rule = `@font-face {font-family:\"${loadTestFontId}\";src:${url}}`;\n        this.insertRule(rule);\n        const div = this._document.createElement(\"div\");\n        div.style.visibility = \"hidden\";\n        div.style.width = div.style.height = \"10px\";\n        div.style.position = \"absolute\";\n        div.style.top = div.style.left = \"0px\";\n        for (const name of [\n            font.loadedName,\n            loadTestFontId\n        ]){\n            const span = this._document.createElement(\"span\");\n            span.textContent = \"Hi\";\n            span.style.fontFamily = name;\n            div.append(span);\n        }\n        this._document.body.append(div);\n        isFontReady(loadTestFontId, ()=>{\n            div.remove();\n            request.complete();\n        });\n    }\n}\nclass FontFaceObject {\n    constructor(translatedData, inspectFont = null){\n        this.compiledGlyphs = Object.create(null);\n        for(const i in translatedData){\n            this[i] = translatedData[i];\n        }\n        this._inspectFont = inspectFont;\n    }\n    createNativeFontFace() {\n        if (!this.data || this.disableFontFace) {\n            return null;\n        }\n        let nativeFontFace;\n        if (!this.cssFontInfo) {\n            nativeFontFace = new FontFace(this.loadedName, this.data, {});\n        } else {\n            const css = {\n                weight: this.cssFontInfo.fontWeight\n            };\n            if (this.cssFontInfo.italicAngle) {\n                css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;\n            }\n            nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);\n        }\n        this._inspectFont?.(this);\n        return nativeFontFace;\n    }\n    createFontFaceRule() {\n        if (!this.data || this.disableFontFace) {\n            return null;\n        }\n        const url = `url(data:${this.mimetype};base64,${toBase64Util(this.data)});`;\n        let rule;\n        if (!this.cssFontInfo) {\n            rule = `@font-face {font-family:\"${this.loadedName}\";src:${url}}`;\n        } else {\n            let css = `font-weight: ${this.cssFontInfo.fontWeight};`;\n            if (this.cssFontInfo.italicAngle) {\n                css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;\n            }\n            rule = `@font-face {font-family:\"${this.cssFontInfo.fontFamily}\";${css}src:${url}}`;\n        }\n        this._inspectFont?.(this, url);\n        return rule;\n    }\n    getPathGenerator(objs, character) {\n        if (this.compiledGlyphs[character] !== undefined) {\n            return this.compiledGlyphs[character];\n        }\n        const objId = this.loadedName + \"_path_\" + character;\n        let cmds;\n        try {\n            cmds = objs.get(objId);\n        } catch (ex) {\n            warn(`getPathGenerator - ignoring character: \"${ex}\".`);\n        }\n        const path = new Path2D(cmds || \"\");\n        if (!this.fontExtraProperties) {\n            objs.delete(objId);\n        }\n        return this.compiledGlyphs[character] = path;\n    }\n}\n; // ./src/shared/message_handler.js\nconst CallbackKind = {\n    DATA: 1,\n    ERROR: 2\n};\nconst StreamKind = {\n    CANCEL: 1,\n    CANCEL_COMPLETE: 2,\n    CLOSE: 3,\n    ENQUEUE: 4,\n    ERROR: 5,\n    PULL: 6,\n    PULL_COMPLETE: 7,\n    START_COMPLETE: 8\n};\nfunction onFn() {}\nfunction wrapReason(ex) {\n    if (ex instanceof AbortException || ex instanceof InvalidPDFException || ex instanceof PasswordException || ex instanceof ResponseException || ex instanceof UnknownErrorException) {\n        return ex;\n    }\n    if (!(ex instanceof Error || typeof ex === \"object\" && ex !== null)) {\n        unreachable('wrapReason: Expected \"reason\" to be a (possibly cloned) Error.');\n    }\n    switch(ex.name){\n        case \"AbortException\":\n            return new AbortException(ex.message);\n        case \"InvalidPDFException\":\n            return new InvalidPDFException(ex.message);\n        case \"PasswordException\":\n            return new PasswordException(ex.message, ex.code);\n        case \"ResponseException\":\n            return new ResponseException(ex.message, ex.status, ex.missing);\n        case \"UnknownErrorException\":\n            return new UnknownErrorException(ex.message, ex.details);\n    }\n    return new UnknownErrorException(ex.message, ex.toString());\n}\nclass MessageHandler {\n    #messageAC;\n    constructor(sourceName, targetName, comObj){\n        this.#messageAC = new AbortController();\n        this.sourceName = sourceName;\n        this.targetName = targetName;\n        this.comObj = comObj;\n        this.callbackId = 1;\n        this.streamId = 1;\n        this.streamSinks = Object.create(null);\n        this.streamControllers = Object.create(null);\n        this.callbackCapabilities = Object.create(null);\n        this.actionHandler = Object.create(null);\n        comObj.addEventListener(\"message\", this.#onMessage.bind(this), {\n            signal: this.#messageAC.signal\n        });\n    }\n    #onMessage({ data }) {\n        if (data.targetName !== this.sourceName) {\n            return;\n        }\n        if (data.stream) {\n            this.#processStreamMessage(data);\n            return;\n        }\n        if (data.callback) {\n            const callbackId = data.callbackId;\n            const capability = this.callbackCapabilities[callbackId];\n            if (!capability) {\n                throw new Error(`Cannot resolve callback ${callbackId}`);\n            }\n            delete this.callbackCapabilities[callbackId];\n            if (data.callback === CallbackKind.DATA) {\n                capability.resolve(data.data);\n            } else if (data.callback === CallbackKind.ERROR) {\n                capability.reject(wrapReason(data.reason));\n            } else {\n                throw new Error(\"Unexpected callback case\");\n            }\n            return;\n        }\n        const action = this.actionHandler[data.action];\n        if (!action) {\n            throw new Error(`Unknown action from worker: ${data.action}`);\n        }\n        if (data.callbackId) {\n            const sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n            Promise.try(action, data.data).then(function(result) {\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    callback: CallbackKind.DATA,\n                    callbackId: data.callbackId,\n                    data: result\n                });\n            }, function(reason) {\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    callback: CallbackKind.ERROR,\n                    callbackId: data.callbackId,\n                    reason: wrapReason(reason)\n                });\n            });\n            return;\n        }\n        if (data.streamId) {\n            this.#createStreamSink(data);\n            return;\n        }\n        action(data.data);\n    }\n    on(actionName, handler) {\n        const ah = this.actionHandler;\n        if (ah[actionName]) {\n            throw new Error(`There is already an actionName called \"${actionName}\"`);\n        }\n        ah[actionName] = handler;\n    }\n    send(actionName, data, transfers) {\n        this.comObj.postMessage({\n            sourceName: this.sourceName,\n            targetName: this.targetName,\n            action: actionName,\n            data\n        }, transfers);\n    }\n    sendWithPromise(actionName, data, transfers) {\n        const callbackId = this.callbackId++;\n        const capability = Promise.withResolvers();\n        this.callbackCapabilities[callbackId] = capability;\n        try {\n            this.comObj.postMessage({\n                sourceName: this.sourceName,\n                targetName: this.targetName,\n                action: actionName,\n                callbackId,\n                data\n            }, transfers);\n        } catch (ex) {\n            capability.reject(ex);\n        }\n        return capability.promise;\n    }\n    sendWithStream(actionName, data, queueingStrategy, transfers) {\n        const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;\n        return new ReadableStream({\n            start: (controller)=>{\n                const startCapability = Promise.withResolvers();\n                this.streamControllers[streamId] = {\n                    controller,\n                    startCall: startCapability,\n                    pullCall: null,\n                    cancelCall: null,\n                    isClosed: false\n                };\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    action: actionName,\n                    streamId,\n                    data,\n                    desiredSize: controller.desiredSize\n                }, transfers);\n                return startCapability.promise;\n            },\n            pull: (controller)=>{\n                const pullCapability = Promise.withResolvers();\n                this.streamControllers[streamId].pullCall = pullCapability;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.PULL,\n                    streamId,\n                    desiredSize: controller.desiredSize\n                });\n                return pullCapability.promise;\n            },\n            cancel: (reason)=>{\n                assert(reason instanceof Error, \"cancel must have a valid reason\");\n                const cancelCapability = Promise.withResolvers();\n                this.streamControllers[streamId].cancelCall = cancelCapability;\n                this.streamControllers[streamId].isClosed = true;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.CANCEL,\n                    streamId,\n                    reason: wrapReason(reason)\n                });\n                return cancelCapability.promise;\n            }\n        }, queueingStrategy);\n    }\n    #createStreamSink(data) {\n        const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n        const self = this, action = this.actionHandler[data.action];\n        const streamSink = {\n            enqueue (chunk, size = 1, transfers) {\n                if (this.isCancelled) {\n                    return;\n                }\n                const lastDesiredSize = this.desiredSize;\n                this.desiredSize -= size;\n                if (lastDesiredSize > 0 && this.desiredSize <= 0) {\n                    this.sinkCapability = Promise.withResolvers();\n                    this.ready = this.sinkCapability.promise;\n                }\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.ENQUEUE,\n                    streamId,\n                    chunk\n                }, transfers);\n            },\n            close () {\n                if (this.isCancelled) {\n                    return;\n                }\n                this.isCancelled = true;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.CLOSE,\n                    streamId\n                });\n                delete self.streamSinks[streamId];\n            },\n            error (reason) {\n                assert(reason instanceof Error, \"error must have a valid reason\");\n                if (this.isCancelled) {\n                    return;\n                }\n                this.isCancelled = true;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.ERROR,\n                    streamId,\n                    reason: wrapReason(reason)\n                });\n            },\n            sinkCapability: Promise.withResolvers(),\n            onPull: null,\n            onCancel: null,\n            isCancelled: false,\n            desiredSize: data.desiredSize,\n            ready: null\n        };\n        streamSink.sinkCapability.resolve();\n        streamSink.ready = streamSink.sinkCapability.promise;\n        this.streamSinks[streamId] = streamSink;\n        Promise.try(action, data.data, streamSink).then(function() {\n            comObj.postMessage({\n                sourceName,\n                targetName,\n                stream: StreamKind.START_COMPLETE,\n                streamId,\n                success: true\n            });\n        }, function(reason) {\n            comObj.postMessage({\n                sourceName,\n                targetName,\n                stream: StreamKind.START_COMPLETE,\n                streamId,\n                reason: wrapReason(reason)\n            });\n        });\n    }\n    #processStreamMessage(data) {\n        const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n        const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];\n        switch(data.stream){\n            case StreamKind.START_COMPLETE:\n                if (data.success) {\n                    streamController.startCall.resolve();\n                } else {\n                    streamController.startCall.reject(wrapReason(data.reason));\n                }\n                break;\n            case StreamKind.PULL_COMPLETE:\n                if (data.success) {\n                    streamController.pullCall.resolve();\n                } else {\n                    streamController.pullCall.reject(wrapReason(data.reason));\n                }\n                break;\n            case StreamKind.PULL:\n                if (!streamSink) {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.PULL_COMPLETE,\n                        streamId,\n                        success: true\n                    });\n                    break;\n                }\n                if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {\n                    streamSink.sinkCapability.resolve();\n                }\n                streamSink.desiredSize = data.desiredSize;\n                Promise.try(streamSink.onPull || onFn).then(function() {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.PULL_COMPLETE,\n                        streamId,\n                        success: true\n                    });\n                }, function(reason) {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.PULL_COMPLETE,\n                        streamId,\n                        reason: wrapReason(reason)\n                    });\n                });\n                break;\n            case StreamKind.ENQUEUE:\n                assert(streamController, \"enqueue should have stream controller\");\n                if (streamController.isClosed) {\n                    break;\n                }\n                streamController.controller.enqueue(data.chunk);\n                break;\n            case StreamKind.CLOSE:\n                assert(streamController, \"close should have stream controller\");\n                if (streamController.isClosed) {\n                    break;\n                }\n                streamController.isClosed = true;\n                streamController.controller.close();\n                this.#deleteStreamController(streamController, streamId);\n                break;\n            case StreamKind.ERROR:\n                assert(streamController, \"error should have stream controller\");\n                streamController.controller.error(wrapReason(data.reason));\n                this.#deleteStreamController(streamController, streamId);\n                break;\n            case StreamKind.CANCEL_COMPLETE:\n                if (data.success) {\n                    streamController.cancelCall.resolve();\n                } else {\n                    streamController.cancelCall.reject(wrapReason(data.reason));\n                }\n                this.#deleteStreamController(streamController, streamId);\n                break;\n            case StreamKind.CANCEL:\n                if (!streamSink) {\n                    break;\n                }\n                const dataReason = wrapReason(data.reason);\n                Promise.try(streamSink.onCancel || onFn, dataReason).then(function() {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.CANCEL_COMPLETE,\n                        streamId,\n                        success: true\n                    });\n                }, function(reason) {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.CANCEL_COMPLETE,\n                        streamId,\n                        reason: wrapReason(reason)\n                    });\n                });\n                streamSink.sinkCapability.reject(dataReason);\n                streamSink.isCancelled = true;\n                delete this.streamSinks[streamId];\n                break;\n            default:\n                throw new Error(\"Unexpected stream case\");\n        }\n    }\n    async #deleteStreamController(streamController, streamId) {\n        await Promise.allSettled([\n            streamController.startCall?.promise,\n            streamController.pullCall?.promise,\n            streamController.cancelCall?.promise\n        ]);\n        delete this.streamControllers[streamId];\n    }\n    destroy() {\n        this.#messageAC?.abort();\n        this.#messageAC = null;\n    }\n}\n; // ./src/display/canvas_factory.js\nclass BaseCanvasFactory {\n    #enableHWA;\n    constructor({ enableHWA = false }){\n        this.#enableHWA = false;\n        this.#enableHWA = enableHWA;\n    }\n    create(width, height) {\n        if (width <= 0 || height <= 0) {\n            throw new Error(\"Invalid canvas size\");\n        }\n        const canvas = this._createCanvas(width, height);\n        return {\n            canvas,\n            context: canvas.getContext(\"2d\", {\n                willReadFrequently: !this.#enableHWA\n            })\n        };\n    }\n    reset(canvasAndContext, width, height) {\n        if (!canvasAndContext.canvas) {\n            throw new Error(\"Canvas is not specified\");\n        }\n        if (width <= 0 || height <= 0) {\n            throw new Error(\"Invalid canvas size\");\n        }\n        canvasAndContext.canvas.width = width;\n        canvasAndContext.canvas.height = height;\n    }\n    destroy(canvasAndContext) {\n        if (!canvasAndContext.canvas) {\n            throw new Error(\"Canvas is not specified\");\n        }\n        canvasAndContext.canvas.width = 0;\n        canvasAndContext.canvas.height = 0;\n        canvasAndContext.canvas = null;\n        canvasAndContext.context = null;\n    }\n    _createCanvas(width, height) {\n        unreachable(\"Abstract method `_createCanvas` called.\");\n    }\n}\nclass DOMCanvasFactory extends BaseCanvasFactory {\n    constructor({ ownerDocument = globalThis.document, enableHWA = false }){\n        super({\n            enableHWA\n        });\n        this._document = ownerDocument;\n    }\n    _createCanvas(width, height) {\n        const canvas = this._document.createElement(\"canvas\");\n        canvas.width = width;\n        canvas.height = height;\n        return canvas;\n    }\n}\n; // ./src/display/cmap_reader_factory.js\nclass BaseCMapReaderFactory {\n    constructor({ baseUrl = null, isCompressed = true }){\n        this.baseUrl = baseUrl;\n        this.isCompressed = isCompressed;\n    }\n    async fetch({ name }) {\n        if (!this.baseUrl) {\n            throw new Error(\"Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.\");\n        }\n        if (!name) {\n            throw new Error(\"CMap name must be specified.\");\n        }\n        const url = this.baseUrl + name + (this.isCompressed ? \".bcmap\" : \"\");\n        return this._fetch(url).then((cMapData)=>({\n                cMapData,\n                isCompressed: this.isCompressed\n            })).catch((reason)=>{\n            throw new Error(`Unable to load ${this.isCompressed ? \"binary \" : \"\"}CMap at: ${url}`);\n        });\n    }\n    async _fetch(url) {\n        unreachable(\"Abstract method `_fetch` called.\");\n    }\n}\nclass DOMCMapReaderFactory extends BaseCMapReaderFactory {\n    async _fetch(url) {\n        const data = await fetchData(url, this.isCompressed ? \"arraybuffer\" : \"text\");\n        return data instanceof ArrayBuffer ? new Uint8Array(data) : stringToBytes(data);\n    }\n}\n; // ./src/display/filter_factory.js\nclass BaseFilterFactory {\n    addFilter(maps) {\n        return \"none\";\n    }\n    addHCMFilter(fgColor, bgColor) {\n        return \"none\";\n    }\n    addAlphaFilter(map) {\n        return \"none\";\n    }\n    addLuminosityFilter(map) {\n        return \"none\";\n    }\n    addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {\n        return \"none\";\n    }\n    destroy(keepHCM = false) {}\n}\nclass DOMFilterFactory extends BaseFilterFactory {\n    #baseUrl;\n    #_cache;\n    #_defs;\n    #docId;\n    #document;\n    #_hcmCache;\n    #id;\n    constructor({ docId, ownerDocument = globalThis.document }){\n        super();\n        this.#id = 0;\n        this.#docId = docId;\n        this.#document = ownerDocument;\n    }\n    get #cache() {\n        return this.#_cache ||= new Map();\n    }\n    get #hcmCache() {\n        return this.#_hcmCache ||= new Map();\n    }\n    get #defs() {\n        if (!this.#_defs) {\n            const div = this.#document.createElement(\"div\");\n            const { style } = div;\n            style.visibility = \"hidden\";\n            style.contain = \"strict\";\n            style.width = style.height = 0;\n            style.position = \"absolute\";\n            style.top = style.left = 0;\n            style.zIndex = -1;\n            const svg = this.#document.createElementNS(SVG_NS, \"svg\");\n            svg.setAttribute(\"width\", 0);\n            svg.setAttribute(\"height\", 0);\n            this.#_defs = this.#document.createElementNS(SVG_NS, \"defs\");\n            div.append(svg);\n            svg.append(this.#_defs);\n            this.#document.body.append(div);\n        }\n        return this.#_defs;\n    }\n    #createTables(maps) {\n        if (maps.length === 1) {\n            const mapR = maps[0];\n            const buffer = new Array(256);\n            for(let i = 0; i < 256; i++){\n                buffer[i] = mapR[i] / 255;\n            }\n            const table = buffer.join(\",\");\n            return [\n                table,\n                table,\n                table\n            ];\n        }\n        const [mapR, mapG, mapB] = maps;\n        const bufferR = new Array(256);\n        const bufferG = new Array(256);\n        const bufferB = new Array(256);\n        for(let i = 0; i < 256; i++){\n            bufferR[i] = mapR[i] / 255;\n            bufferG[i] = mapG[i] / 255;\n            bufferB[i] = mapB[i] / 255;\n        }\n        return [\n            bufferR.join(\",\"),\n            bufferG.join(\",\"),\n            bufferB.join(\",\")\n        ];\n    }\n    #createUrl(id) {\n        if (this.#baseUrl === undefined) {\n            this.#baseUrl = \"\";\n            const url = this.#document.URL;\n            if (url !== this.#document.baseURI) {\n                if (isDataScheme(url)) {\n                    warn('#createUrl: ignore \"data:\"-URL for performance reasons.');\n                } else {\n                    this.#baseUrl = updateUrlHash(url, \"\");\n                }\n            }\n        }\n        return `url(${this.#baseUrl}#${id})`;\n    }\n    addFilter(maps) {\n        if (!maps) {\n            return \"none\";\n        }\n        let value = this.#cache.get(maps);\n        if (value) {\n            return value;\n        }\n        const [tableR, tableG, tableB] = this.#createTables(maps);\n        const key = maps.length === 1 ? tableR : `${tableR}${tableG}${tableB}`;\n        value = this.#cache.get(key);\n        if (value) {\n            this.#cache.set(maps, value);\n            return value;\n        }\n        const id = `g_${this.#docId}_transfer_map_${this.#id++}`;\n        const url = this.#createUrl(id);\n        this.#cache.set(maps, url);\n        this.#cache.set(key, url);\n        const filter = this.#createFilter(id);\n        this.#addTransferMapConversion(tableR, tableG, tableB, filter);\n        return url;\n    }\n    addHCMFilter(fgColor, bgColor) {\n        const key = `${fgColor}-${bgColor}`;\n        const filterName = \"base\";\n        let info = this.#hcmCache.get(filterName);\n        if (info?.key === key) {\n            return info.url;\n        }\n        if (info) {\n            info.filter?.remove();\n            info.key = key;\n            info.url = \"none\";\n            info.filter = null;\n        } else {\n            info = {\n                key,\n                url: \"none\",\n                filter: null\n            };\n            this.#hcmCache.set(filterName, info);\n        }\n        if (!fgColor || !bgColor) {\n            return info.url;\n        }\n        const fgRGB = this.#getRGB(fgColor);\n        fgColor = Util.makeHexColor(...fgRGB);\n        const bgRGB = this.#getRGB(bgColor);\n        bgColor = Util.makeHexColor(...bgRGB);\n        this.#defs.style.color = \"\";\n        if (fgColor === \"#000000\" && bgColor === \"#ffffff\" || fgColor === bgColor) {\n            return info.url;\n        }\n        const map = new Array(256);\n        for(let i = 0; i <= 255; i++){\n            const x = i / 255;\n            map[i] = x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;\n        }\n        const table = map.join(\",\");\n        const id = `g_${this.#docId}_hcm_filter`;\n        const filter = info.filter = this.#createFilter(id);\n        this.#addTransferMapConversion(table, table, table, filter);\n        this.#addGrayConversion(filter);\n        const getSteps = (c, n)=>{\n            const start = fgRGB[c] / 255;\n            const end = bgRGB[c] / 255;\n            const arr = new Array(n + 1);\n            for(let i = 0; i <= n; i++){\n                arr[i] = start + i / n * (end - start);\n            }\n            return arr.join(\",\");\n        };\n        this.#addTransferMapConversion(getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);\n        info.url = this.#createUrl(id);\n        return info.url;\n    }\n    addAlphaFilter(map) {\n        let value = this.#cache.get(map);\n        if (value) {\n            return value;\n        }\n        const [tableA] = this.#createTables([\n            map\n        ]);\n        const key = `alpha_${tableA}`;\n        value = this.#cache.get(key);\n        if (value) {\n            this.#cache.set(map, value);\n            return value;\n        }\n        const id = `g_${this.#docId}_alpha_map_${this.#id++}`;\n        const url = this.#createUrl(id);\n        this.#cache.set(map, url);\n        this.#cache.set(key, url);\n        const filter = this.#createFilter(id);\n        this.#addTransferMapAlphaConversion(tableA, filter);\n        return url;\n    }\n    addLuminosityFilter(map) {\n        let value = this.#cache.get(map || \"luminosity\");\n        if (value) {\n            return value;\n        }\n        let tableA, key;\n        if (map) {\n            [tableA] = this.#createTables([\n                map\n            ]);\n            key = `luminosity_${tableA}`;\n        } else {\n            key = \"luminosity\";\n        }\n        value = this.#cache.get(key);\n        if (value) {\n            this.#cache.set(map, value);\n            return value;\n        }\n        const id = `g_${this.#docId}_luminosity_map_${this.#id++}`;\n        const url = this.#createUrl(id);\n        this.#cache.set(map, url);\n        this.#cache.set(key, url);\n        const filter = this.#createFilter(id);\n        this.#addLuminosityConversion(filter);\n        if (map) {\n            this.#addTransferMapAlphaConversion(tableA, filter);\n        }\n        return url;\n    }\n    addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {\n        const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;\n        let info = this.#hcmCache.get(filterName);\n        if (info?.key === key) {\n            return info.url;\n        }\n        if (info) {\n            info.filter?.remove();\n            info.key = key;\n            info.url = \"none\";\n            info.filter = null;\n        } else {\n            info = {\n                key,\n                url: \"none\",\n                filter: null\n            };\n            this.#hcmCache.set(filterName, info);\n        }\n        if (!fgColor || !bgColor) {\n            return info.url;\n        }\n        const [fgRGB, bgRGB] = [\n            fgColor,\n            bgColor\n        ].map(this.#getRGB.bind(this));\n        let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);\n        let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);\n        let [newFgRGB, newBgRGB] = [\n            newFgColor,\n            newBgColor\n        ].map(this.#getRGB.bind(this));\n        if (bgGray < fgGray) {\n            [fgGray, bgGray, newFgRGB, newBgRGB] = [\n                bgGray,\n                fgGray,\n                newBgRGB,\n                newFgRGB\n            ];\n        }\n        this.#defs.style.color = \"\";\n        const getSteps = (fg, bg, n)=>{\n            const arr = new Array(256);\n            const step = (bgGray - fgGray) / n;\n            const newStart = fg / 255;\n            const newStep = (bg - fg) / (255 * n);\n            let prev = 0;\n            for(let i = 0; i <= n; i++){\n                const k = Math.round(fgGray + i * step);\n                const value = newStart + i * newStep;\n                for(let j = prev; j <= k; j++){\n                    arr[j] = value;\n                }\n                prev = k + 1;\n            }\n            for(let i = prev; i < 256; i++){\n                arr[i] = arr[prev - 1];\n            }\n            return arr.join(\",\");\n        };\n        const id = `g_${this.#docId}_hcm_${filterName}_filter`;\n        const filter = info.filter = this.#createFilter(id);\n        this.#addGrayConversion(filter);\n        this.#addTransferMapConversion(getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);\n        info.url = this.#createUrl(id);\n        return info.url;\n    }\n    destroy(keepHCM = false) {\n        if (keepHCM && this.#_hcmCache?.size) {\n            return;\n        }\n        this.#_defs?.parentNode.parentNode.remove();\n        this.#_defs = null;\n        this.#_cache?.clear();\n        this.#_cache = null;\n        this.#_hcmCache?.clear();\n        this.#_hcmCache = null;\n        this.#id = 0;\n    }\n    #addLuminosityConversion(filter) {\n        const feColorMatrix = this.#document.createElementNS(SVG_NS, \"feColorMatrix\");\n        feColorMatrix.setAttribute(\"type\", \"matrix\");\n        feColorMatrix.setAttribute(\"values\", \"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0\");\n        filter.append(feColorMatrix);\n    }\n    #addGrayConversion(filter) {\n        const feColorMatrix = this.#document.createElementNS(SVG_NS, \"feColorMatrix\");\n        feColorMatrix.setAttribute(\"type\", \"matrix\");\n        feColorMatrix.setAttribute(\"values\", \"0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0\");\n        filter.append(feColorMatrix);\n    }\n    #createFilter(id) {\n        const filter = this.#document.createElementNS(SVG_NS, \"filter\");\n        filter.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n        filter.setAttribute(\"id\", id);\n        this.#defs.append(filter);\n        return filter;\n    }\n    #appendFeFunc(feComponentTransfer, func, table) {\n        const feFunc = this.#document.createElementNS(SVG_NS, func);\n        feFunc.setAttribute(\"type\", \"discrete\");\n        feFunc.setAttribute(\"tableValues\", table);\n        feComponentTransfer.append(feFunc);\n    }\n    #addTransferMapConversion(rTable, gTable, bTable, filter) {\n        const feComponentTransfer = this.#document.createElementNS(SVG_NS, \"feComponentTransfer\");\n        filter.append(feComponentTransfer);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncR\", rTable);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncG\", gTable);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncB\", bTable);\n    }\n    #addTransferMapAlphaConversion(aTable, filter) {\n        const feComponentTransfer = this.#document.createElementNS(SVG_NS, \"feComponentTransfer\");\n        filter.append(feComponentTransfer);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncA\", aTable);\n    }\n    #getRGB(color) {\n        this.#defs.style.color = color;\n        return getRGB(getComputedStyle(this.#defs).getPropertyValue(\"color\"));\n    }\n}\n; // ./src/display/standard_fontdata_factory.js\nclass BaseStandardFontDataFactory {\n    constructor({ baseUrl = null }){\n        this.baseUrl = baseUrl;\n    }\n    async fetch({ filename }) {\n        if (!this.baseUrl) {\n            throw new Error(\"Ensure that the `standardFontDataUrl` API parameter is provided.\");\n        }\n        if (!filename) {\n            throw new Error(\"Font filename must be specified.\");\n        }\n        const url = `${this.baseUrl}${filename}`;\n        return this._fetch(url).catch((reason)=>{\n            throw new Error(`Unable to load font data at: ${url}`);\n        });\n    }\n    async _fetch(url) {\n        unreachable(\"Abstract method `_fetch` called.\");\n    }\n}\nclass DOMStandardFontDataFactory extends BaseStandardFontDataFactory {\n    async _fetch(url) {\n        const data = await fetchData(url, \"arraybuffer\");\n        return new Uint8Array(data);\n    }\n}\n; // ./src/display/wasm_factory.js\nclass BaseWasmFactory {\n    constructor({ baseUrl = null }){\n        this.baseUrl = baseUrl;\n    }\n    async fetch({ filename }) {\n        if (!this.baseUrl) {\n            throw new Error(\"Ensure that the `wasmUrl` API parameter is provided.\");\n        }\n        if (!filename) {\n            throw new Error(\"Wasm filename must be specified.\");\n        }\n        const url = `${this.baseUrl}${filename}`;\n        return this._fetch(url).catch((reason)=>{\n            throw new Error(`Unable to load wasm data at: ${url}`);\n        });\n    }\n    async _fetch(url) {\n        unreachable(\"Abstract method `_fetch` called.\");\n    }\n}\nclass DOMWasmFactory extends BaseWasmFactory {\n    async _fetch(url) {\n        const data = await fetchData(url, \"arraybuffer\");\n        return new Uint8Array(data);\n    }\n}\n; // ./src/display/node_utils.js\nif (isNodeJS) {\n    warn(\"Please use the `legacy` build in Node.js environments.\");\n}\nasync function node_utils_fetchData(url) {\n    const fs = process.getBuiltinModule(\"fs\");\n    const data = await fs.promises.readFile(url);\n    return new Uint8Array(data);\n}\nclass NodeFilterFactory extends BaseFilterFactory {\n}\nclass NodeCanvasFactory extends BaseCanvasFactory {\n    _createCanvas(width, height) {\n        const require = process.getBuiltinModule(\"module\").createRequire(\"file:///Users/mihawii/tsa%20platform/node_modules/pdfjs-dist/build/pdf.mjs\");\n        const canvas = require(\"@napi-rs/canvas\");\n        return canvas.createCanvas(width, height);\n    }\n}\nclass NodeCMapReaderFactory extends BaseCMapReaderFactory {\n    async _fetch(url) {\n        return node_utils_fetchData(url);\n    }\n}\nclass NodeStandardFontDataFactory extends BaseStandardFontDataFactory {\n    async _fetch(url) {\n        return node_utils_fetchData(url);\n    }\n}\nclass NodeWasmFactory extends BaseWasmFactory {\n    async _fetch(url) {\n        return node_utils_fetchData(url);\n    }\n}\n; // ./src/display/pattern_helper.js\nconst PathType = {\n    FILL: \"Fill\",\n    STROKE: \"Stroke\",\n    SHADING: \"Shading\"\n};\nfunction applyBoundingBox(ctx, bbox) {\n    if (!bbox) {\n        return;\n    }\n    const width = bbox[2] - bbox[0];\n    const height = bbox[3] - bbox[1];\n    const region = new Path2D();\n    region.rect(bbox[0], bbox[1], width, height);\n    ctx.clip(region);\n}\nclass BaseShadingPattern {\n    isModifyingCurrentTransform() {\n        return false;\n    }\n    getPattern() {\n        unreachable(\"Abstract method `getPattern` called.\");\n    }\n}\nclass RadialAxialShadingPattern extends BaseShadingPattern {\n    constructor(IR){\n        super();\n        this._type = IR[1];\n        this._bbox = IR[2];\n        this._colorStops = IR[3];\n        this._p0 = IR[4];\n        this._p1 = IR[5];\n        this._r0 = IR[6];\n        this._r1 = IR[7];\n        this.matrix = null;\n    }\n    _createGradient(ctx) {\n        let grad;\n        if (this._type === \"axial\") {\n            grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);\n        } else if (this._type === \"radial\") {\n            grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);\n        }\n        for (const colorStop of this._colorStops){\n            grad.addColorStop(colorStop[0], colorStop[1]);\n        }\n        return grad;\n    }\n    getPattern(ctx, owner, inverse, pathType) {\n        let pattern;\n        if (pathType === PathType.STROKE || pathType === PathType.FILL) {\n            const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, getCurrentTransform(ctx)) || [\n                0,\n                0,\n                0,\n                0\n            ];\n            const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;\n            const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;\n            const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", width, height);\n            const tmpCtx = tmpCanvas.context;\n            tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n            tmpCtx.beginPath();\n            tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n            tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);\n            inverse = Util.transform(inverse, [\n                1,\n                0,\n                0,\n                1,\n                ownerBBox[0],\n                ownerBBox[1]\n            ]);\n            tmpCtx.transform(...owner.baseTransform);\n            if (this.matrix) {\n                tmpCtx.transform(...this.matrix);\n            }\n            applyBoundingBox(tmpCtx, this._bbox);\n            tmpCtx.fillStyle = this._createGradient(tmpCtx);\n            tmpCtx.fill();\n            pattern = ctx.createPattern(tmpCanvas.canvas, \"no-repeat\");\n            const domMatrix = new DOMMatrix(inverse);\n            pattern.setTransform(domMatrix);\n        } else {\n            applyBoundingBox(ctx, this._bbox);\n            pattern = this._createGradient(ctx);\n        }\n        return pattern;\n    }\n}\nfunction drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n    const coords = context.coords, colors = context.colors;\n    const bytes = data.data, rowSize = data.width * 4;\n    let tmp;\n    if (coords[p1 + 1] > coords[p2 + 1]) {\n        tmp = p1;\n        p1 = p2;\n        p2 = tmp;\n        tmp = c1;\n        c1 = c2;\n        c2 = tmp;\n    }\n    if (coords[p2 + 1] > coords[p3 + 1]) {\n        tmp = p2;\n        p2 = p3;\n        p3 = tmp;\n        tmp = c2;\n        c2 = c3;\n        c3 = tmp;\n    }\n    if (coords[p1 + 1] > coords[p2 + 1]) {\n        tmp = p1;\n        p1 = p2;\n        p2 = tmp;\n        tmp = c1;\n        c1 = c2;\n        c2 = tmp;\n    }\n    const x1 = (coords[p1] + context.offsetX) * context.scaleX;\n    const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n    const x2 = (coords[p2] + context.offsetX) * context.scaleX;\n    const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n    const x3 = (coords[p3] + context.offsetX) * context.scaleX;\n    const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n    if (y1 >= y3) {\n        return;\n    }\n    const c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];\n    const c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];\n    const c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];\n    const minY = Math.round(y1), maxY = Math.round(y3);\n    let xa, car, cag, cab;\n    let xb, cbr, cbg, cbb;\n    for(let y = minY; y <= maxY; y++){\n        if (y < y2) {\n            const k = y < y1 ? 0 : (y1 - y) / (y1 - y2);\n            xa = x1 - (x1 - x2) * k;\n            car = c1r - (c1r - c2r) * k;\n            cag = c1g - (c1g - c2g) * k;\n            cab = c1b - (c1b - c2b) * k;\n        } else {\n            let k;\n            if (y > y3) {\n                k = 1;\n            } else if (y2 === y3) {\n                k = 0;\n            } else {\n                k = (y2 - y) / (y2 - y3);\n            }\n            xa = x2 - (x2 - x3) * k;\n            car = c2r - (c2r - c3r) * k;\n            cag = c2g - (c2g - c3g) * k;\n            cab = c2b - (c2b - c3b) * k;\n        }\n        let k;\n        if (y < y1) {\n            k = 0;\n        } else if (y > y3) {\n            k = 1;\n        } else {\n            k = (y1 - y) / (y1 - y3);\n        }\n        xb = x1 - (x1 - x3) * k;\n        cbr = c1r - (c1r - c3r) * k;\n        cbg = c1g - (c1g - c3g) * k;\n        cbb = c1b - (c1b - c3b) * k;\n        const x1_ = Math.round(Math.min(xa, xb));\n        const x2_ = Math.round(Math.max(xa, xb));\n        let j = rowSize * y + x1_ * 4;\n        for(let x = x1_; x <= x2_; x++){\n            k = (xa - x) / (xa - xb);\n            if (k < 0) {\n                k = 0;\n            } else if (k > 1) {\n                k = 1;\n            }\n            bytes[j++] = car - (car - cbr) * k | 0;\n            bytes[j++] = cag - (cag - cbg) * k | 0;\n            bytes[j++] = cab - (cab - cbb) * k | 0;\n            bytes[j++] = 255;\n        }\n    }\n}\nfunction drawFigure(data, figure, context) {\n    const ps = figure.coords;\n    const cs = figure.colors;\n    let i, ii;\n    switch(figure.type){\n        case \"lattice\":\n            const verticesPerRow = figure.verticesPerRow;\n            const rows = Math.floor(ps.length / verticesPerRow) - 1;\n            const cols = verticesPerRow - 1;\n            for(i = 0; i < rows; i++){\n                let q = i * verticesPerRow;\n                for(let j = 0; j < cols; j++, q++){\n                    drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\n                    drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\n                }\n            }\n            break;\n        case \"triangles\":\n            for(i = 0, ii = ps.length; i < ii; i += 3){\n                drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\n            }\n            break;\n        default:\n            throw new Error(\"illegal figure\");\n    }\n}\nclass MeshShadingPattern extends BaseShadingPattern {\n    constructor(IR){\n        super();\n        this._coords = IR[2];\n        this._colors = IR[3];\n        this._figures = IR[4];\n        this._bounds = IR[5];\n        this._bbox = IR[6];\n        this._background = IR[7];\n        this.matrix = null;\n    }\n    _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {\n        const EXPECTED_SCALE = 1.1;\n        const MAX_PATTERN_SIZE = 3000;\n        const BORDER_SIZE = 2;\n        const offsetX = Math.floor(this._bounds[0]);\n        const offsetY = Math.floor(this._bounds[1]);\n        const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;\n        const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;\n        const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n        const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n        const scaleX = boundsWidth / width;\n        const scaleY = boundsHeight / height;\n        const context = {\n            coords: this._coords,\n            colors: this._colors,\n            offsetX: -offsetX,\n            offsetY: -offsetY,\n            scaleX: 1 / scaleX,\n            scaleY: 1 / scaleY\n        };\n        const paddedWidth = width + BORDER_SIZE * 2;\n        const paddedHeight = height + BORDER_SIZE * 2;\n        const tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight);\n        const tmpCtx = tmpCanvas.context;\n        const data = tmpCtx.createImageData(width, height);\n        if (backgroundColor) {\n            const bytes = data.data;\n            for(let i = 0, ii = bytes.length; i < ii; i += 4){\n                bytes[i] = backgroundColor[0];\n                bytes[i + 1] = backgroundColor[1];\n                bytes[i + 2] = backgroundColor[2];\n                bytes[i + 3] = 255;\n            }\n        }\n        for (const figure of this._figures){\n            drawFigure(data, figure, context);\n        }\n        tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\n        const canvas = tmpCanvas.canvas;\n        return {\n            canvas,\n            offsetX: offsetX - BORDER_SIZE * scaleX,\n            offsetY: offsetY - BORDER_SIZE * scaleY,\n            scaleX,\n            scaleY\n        };\n    }\n    isModifyingCurrentTransform() {\n        return true;\n    }\n    getPattern(ctx, owner, inverse, pathType) {\n        applyBoundingBox(ctx, this._bbox);\n        const scale = new Float32Array(2);\n        if (pathType === PathType.SHADING) {\n            Util.singularValueDecompose2dScale(getCurrentTransform(ctx), scale);\n        } else if (this.matrix) {\n            Util.singularValueDecompose2dScale(this.matrix, scale);\n            const [matrixScaleX, matrixScaleY] = scale;\n            Util.singularValueDecompose2dScale(owner.baseTransform, scale);\n            scale[0] *= matrixScaleX;\n            scale[1] *= matrixScaleY;\n        } else {\n            Util.singularValueDecompose2dScale(owner.baseTransform, scale);\n        }\n        const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);\n        if (pathType !== PathType.SHADING) {\n            ctx.setTransform(...owner.baseTransform);\n            if (this.matrix) {\n                ctx.transform(...this.matrix);\n            }\n        }\n        ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n        ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\n        return ctx.createPattern(temporaryPatternCanvas.canvas, \"no-repeat\");\n    }\n}\nclass DummyShadingPattern extends BaseShadingPattern {\n    getPattern() {\n        return \"hotpink\";\n    }\n}\nfunction getShadingPattern(IR) {\n    switch(IR[0]){\n        case \"RadialAxial\":\n            return new RadialAxialShadingPattern(IR);\n        case \"Mesh\":\n            return new MeshShadingPattern(IR);\n        case \"Dummy\":\n            return new DummyShadingPattern();\n    }\n    throw new Error(`Unknown IR type: ${IR[0]}`);\n}\nconst PaintType = {\n    COLORED: 1,\n    UNCOLORED: 2\n};\nclass TilingPattern {\n    static{\n        this.MAX_PATTERN_SIZE = 3000;\n    }\n    constructor(IR, ctx, canvasGraphicsFactory, baseTransform){\n        this.color = IR[1];\n        this.operatorList = IR[2];\n        this.matrix = IR[3];\n        this.bbox = IR[4];\n        this.xstep = IR[5];\n        this.ystep = IR[6];\n        this.paintType = IR[7];\n        this.tilingType = IR[8];\n        this.ctx = ctx;\n        this.canvasGraphicsFactory = canvasGraphicsFactory;\n        this.baseTransform = baseTransform;\n    }\n    createPatternCanvas(owner) {\n        const { bbox, operatorList, paintType, tilingType, color, canvasGraphicsFactory } = this;\n        let { xstep, ystep } = this;\n        xstep = Math.abs(xstep);\n        ystep = Math.abs(ystep);\n        info(\"TilingType: \" + tilingType);\n        const x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];\n        const width = x1 - x0;\n        const height = y1 - y0;\n        const scale = new Float32Array(2);\n        Util.singularValueDecompose2dScale(this.matrix, scale);\n        const [matrixScaleX, matrixScaleY] = scale;\n        Util.singularValueDecompose2dScale(this.baseTransform, scale);\n        const combinedScaleX = matrixScaleX * scale[0];\n        const combinedScaleY = matrixScaleY * scale[1];\n        let canvasWidth = width, canvasHeight = height, redrawHorizontally = false, redrawVertically = false;\n        const xScaledStep = Math.ceil(xstep * combinedScaleX);\n        const yScaledStep = Math.ceil(ystep * combinedScaleY);\n        const xScaledWidth = Math.ceil(width * combinedScaleX);\n        const yScaledHeight = Math.ceil(height * combinedScaleY);\n        if (xScaledStep >= xScaledWidth) {\n            canvasWidth = xstep;\n        } else {\n            redrawHorizontally = true;\n        }\n        if (yScaledStep >= yScaledHeight) {\n            canvasHeight = ystep;\n        } else {\n            redrawVertically = true;\n        }\n        const dimx = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);\n        const dimy = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);\n        const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", dimx.size, dimy.size);\n        const tmpCtx = tmpCanvas.context;\n        const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);\n        graphics.groupLevel = owner.groupLevel;\n        this.setFillAndStrokeStyleToContext(graphics, paintType, color);\n        tmpCtx.translate(-dimx.scale * x0, -dimy.scale * y0);\n        graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);\n        tmpCtx.save();\n        this.clipBbox(graphics, x0, y0, x1, y1);\n        graphics.baseTransform = getCurrentTransform(graphics.ctx);\n        graphics.executeOperatorList(operatorList);\n        graphics.endDrawing();\n        tmpCtx.restore();\n        if (redrawHorizontally || redrawVertically) {\n            const image = tmpCanvas.canvas;\n            if (redrawHorizontally) {\n                canvasWidth = xstep;\n            }\n            if (redrawVertically) {\n                canvasHeight = ystep;\n            }\n            const dimx2 = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);\n            const dimy2 = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);\n            const xSize = dimx2.size;\n            const ySize = dimy2.size;\n            const tmpCanvas2 = owner.cachedCanvases.getCanvas(\"pattern-workaround\", xSize, ySize);\n            const tmpCtx2 = tmpCanvas2.context;\n            const ii = redrawHorizontally ? Math.floor(width / xstep) : 0;\n            const jj = redrawVertically ? Math.floor(height / ystep) : 0;\n            for(let i = 0; i <= ii; i++){\n                for(let j = 0; j <= jj; j++){\n                    tmpCtx2.drawImage(image, xSize * i, ySize * j, xSize, ySize, 0, 0, xSize, ySize);\n                }\n            }\n            return {\n                canvas: tmpCanvas2.canvas,\n                scaleX: dimx2.scale,\n                scaleY: dimy2.scale,\n                offsetX: x0,\n                offsetY: y0\n            };\n        }\n        return {\n            canvas: tmpCanvas.canvas,\n            scaleX: dimx.scale,\n            scaleY: dimy.scale,\n            offsetX: x0,\n            offsetY: y0\n        };\n    }\n    getSizeAndScale(step, realOutputSize, scale) {\n        const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);\n        let size = Math.ceil(step * scale);\n        if (size >= maxSize) {\n            size = maxSize;\n        } else {\n            scale = size / step;\n        }\n        return {\n            scale,\n            size\n        };\n    }\n    clipBbox(graphics, x0, y0, x1, y1) {\n        const bboxWidth = x1 - x0;\n        const bboxHeight = y1 - y0;\n        graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n        Util.axialAlignedBoundingBox([\n            x0,\n            y0,\n            x1,\n            y1\n        ], getCurrentTransform(graphics.ctx), graphics.current.minMax);\n        graphics.clip();\n        graphics.endPath();\n    }\n    setFillAndStrokeStyleToContext(graphics, paintType, color) {\n        const context = graphics.ctx, current = graphics.current;\n        switch(paintType){\n            case PaintType.COLORED:\n                const ctx = this.ctx;\n                context.fillStyle = ctx.fillStyle;\n                context.strokeStyle = ctx.strokeStyle;\n                current.fillColor = ctx.fillStyle;\n                current.strokeColor = ctx.strokeStyle;\n                break;\n            case PaintType.UNCOLORED:\n                const cssColor = Util.makeHexColor(color[0], color[1], color[2]);\n                context.fillStyle = cssColor;\n                context.strokeStyle = cssColor;\n                current.fillColor = cssColor;\n                current.strokeColor = cssColor;\n                break;\n            default:\n                throw new FormatError(`Unsupported paint type: ${paintType}`);\n        }\n    }\n    isModifyingCurrentTransform() {\n        return false;\n    }\n    getPattern(ctx, owner, inverse, pathType) {\n        let matrix = inverse;\n        if (pathType !== PathType.SHADING) {\n            matrix = Util.transform(matrix, owner.baseTransform);\n            if (this.matrix) {\n                matrix = Util.transform(matrix, this.matrix);\n            }\n        }\n        const temporaryPatternCanvas = this.createPatternCanvas(owner);\n        let domMatrix = new DOMMatrix(matrix);\n        domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n        domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);\n        const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, \"repeat\");\n        pattern.setTransform(domMatrix);\n        return pattern;\n    }\n}\n; // ./src/shared/image_utils.js\nfunction convertToRGBA(params) {\n    switch(params.kind){\n        case ImageKind.GRAYSCALE_1BPP:\n            return convertBlackAndWhiteToRGBA(params);\n        case ImageKind.RGB_24BPP:\n            return convertRGBToRGBA(params);\n    }\n    return null;\n}\nfunction convertBlackAndWhiteToRGBA({ src, srcPos = 0, dest, width, height, nonBlackColor = 0xffffffff, inverseDecode = false }) {\n    const black = util_FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n    const [zeroMapping, oneMapping] = inverseDecode ? [\n        nonBlackColor,\n        black\n    ] : [\n        black,\n        nonBlackColor\n    ];\n    const widthInSource = width >> 3;\n    const widthRemainder = width & 7;\n    const srcLength = src.length;\n    dest = new Uint32Array(dest.buffer);\n    let destPos = 0;\n    for(let i = 0; i < height; i++){\n        for(const max = srcPos + widthInSource; srcPos < max; srcPos++){\n            const elem = srcPos < srcLength ? src[srcPos] : 255;\n            dest[destPos++] = elem & 128 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 64 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 32 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 16 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 8 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 4 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 2 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 1 ? oneMapping : zeroMapping;\n        }\n        if (widthRemainder === 0) {\n            continue;\n        }\n        const elem = srcPos < srcLength ? src[srcPos++] : 255;\n        for(let j = 0; j < widthRemainder; j++){\n            dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;\n        }\n    }\n    return {\n        srcPos,\n        destPos\n    };\n}\nfunction convertRGBToRGBA({ src, srcPos = 0, dest, destPos = 0, width, height }) {\n    let i = 0;\n    const len = width * height * 3;\n    const len32 = len >> 2;\n    const src32 = new Uint32Array(src.buffer, srcPos, len32);\n    if (FeatureTest.isLittleEndian) {\n        for(; i < len32 - 2; i += 3, destPos += 4){\n            const s1 = src32[i];\n            const s2 = src32[i + 1];\n            const s3 = src32[i + 2];\n            dest[destPos] = s1 | 0xff000000;\n            dest[destPos + 1] = s1 >>> 24 | s2 << 8 | 0xff000000;\n            dest[destPos + 2] = s2 >>> 16 | s3 << 16 | 0xff000000;\n            dest[destPos + 3] = s3 >>> 8 | 0xff000000;\n        }\n        for(let j = i * 4, jj = srcPos + len; j < jj; j += 3){\n            dest[destPos++] = src[j] | src[j + 1] << 8 | src[j + 2] << 16 | 0xff000000;\n        }\n    } else {\n        for(; i < len32 - 2; i += 3, destPos += 4){\n            const s1 = src32[i];\n            const s2 = src32[i + 1];\n            const s3 = src32[i + 2];\n            dest[destPos] = s1 | 0xff;\n            dest[destPos + 1] = s1 << 24 | s2 >>> 8 | 0xff;\n            dest[destPos + 2] = s2 << 16 | s3 >>> 16 | 0xff;\n            dest[destPos + 3] = s3 << 8 | 0xff;\n        }\n        for(let j = i * 4, jj = srcPos + len; j < jj; j += 3){\n            dest[destPos++] = src[j] << 24 | src[j + 1] << 16 | src[j + 2] << 8 | 0xff;\n        }\n    }\n    return {\n        srcPos: srcPos + len,\n        destPos\n    };\n}\nfunction grayToRGBA(src, dest) {\n    if (FeatureTest.isLittleEndian) {\n        for(let i = 0, ii = src.length; i < ii; i++){\n            dest[i] = src[i] * 0x10101 | 0xff000000;\n        }\n    } else {\n        for(let i = 0, ii = src.length; i < ii; i++){\n            dest[i] = src[i] * 0x1010100 | 0x000000ff;\n        }\n    }\n}\n; // ./src/display/canvas.js\nconst MIN_FONT_SIZE = 16;\nconst MAX_FONT_SIZE = 100;\nconst EXECUTION_TIME = 15;\nconst EXECUTION_STEPS = 10;\nconst FULL_CHUNK_HEIGHT = 16;\nconst SCALE_MATRIX = new DOMMatrix();\nconst XY = new Float32Array(2);\nconst MIN_MAX_INIT = new Float32Array([\n    Infinity,\n    Infinity,\n    -Infinity,\n    -Infinity\n]);\nfunction mirrorContextOperations(ctx, destCtx) {\n    if (ctx._removeMirroring) {\n        throw new Error(\"Context is already forwarding operations.\");\n    }\n    ctx.__originalSave = ctx.save;\n    ctx.__originalRestore = ctx.restore;\n    ctx.__originalRotate = ctx.rotate;\n    ctx.__originalScale = ctx.scale;\n    ctx.__originalTranslate = ctx.translate;\n    ctx.__originalTransform = ctx.transform;\n    ctx.__originalSetTransform = ctx.setTransform;\n    ctx.__originalResetTransform = ctx.resetTransform;\n    ctx.__originalClip = ctx.clip;\n    ctx.__originalMoveTo = ctx.moveTo;\n    ctx.__originalLineTo = ctx.lineTo;\n    ctx.__originalBezierCurveTo = ctx.bezierCurveTo;\n    ctx.__originalRect = ctx.rect;\n    ctx.__originalClosePath = ctx.closePath;\n    ctx.__originalBeginPath = ctx.beginPath;\n    ctx._removeMirroring = ()=>{\n        ctx.save = ctx.__originalSave;\n        ctx.restore = ctx.__originalRestore;\n        ctx.rotate = ctx.__originalRotate;\n        ctx.scale = ctx.__originalScale;\n        ctx.translate = ctx.__originalTranslate;\n        ctx.transform = ctx.__originalTransform;\n        ctx.setTransform = ctx.__originalSetTransform;\n        ctx.resetTransform = ctx.__originalResetTransform;\n        ctx.clip = ctx.__originalClip;\n        ctx.moveTo = ctx.__originalMoveTo;\n        ctx.lineTo = ctx.__originalLineTo;\n        ctx.bezierCurveTo = ctx.__originalBezierCurveTo;\n        ctx.rect = ctx.__originalRect;\n        ctx.closePath = ctx.__originalClosePath;\n        ctx.beginPath = ctx.__originalBeginPath;\n        delete ctx._removeMirroring;\n    };\n    ctx.save = function() {\n        destCtx.save();\n        this.__originalSave();\n    };\n    ctx.restore = function() {\n        destCtx.restore();\n        this.__originalRestore();\n    };\n    ctx.translate = function(x, y) {\n        destCtx.translate(x, y);\n        this.__originalTranslate(x, y);\n    };\n    ctx.scale = function(x, y) {\n        destCtx.scale(x, y);\n        this.__originalScale(x, y);\n    };\n    ctx.transform = function(a, b, c, d, e, f) {\n        destCtx.transform(a, b, c, d, e, f);\n        this.__originalTransform(a, b, c, d, e, f);\n    };\n    ctx.setTransform = function(a, b, c, d, e, f) {\n        destCtx.setTransform(a, b, c, d, e, f);\n        this.__originalSetTransform(a, b, c, d, e, f);\n    };\n    ctx.resetTransform = function() {\n        destCtx.resetTransform();\n        this.__originalResetTransform();\n    };\n    ctx.rotate = function(angle) {\n        destCtx.rotate(angle);\n        this.__originalRotate(angle);\n    };\n    ctx.clip = function(rule) {\n        destCtx.clip(rule);\n        this.__originalClip(rule);\n    };\n    ctx.moveTo = function(x, y) {\n        destCtx.moveTo(x, y);\n        this.__originalMoveTo(x, y);\n    };\n    ctx.lineTo = function(x, y) {\n        destCtx.lineTo(x, y);\n        this.__originalLineTo(x, y);\n    };\n    ctx.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {\n        destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n        this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n    };\n    ctx.rect = function(x, y, width, height) {\n        destCtx.rect(x, y, width, height);\n        this.__originalRect(x, y, width, height);\n    };\n    ctx.closePath = function() {\n        destCtx.closePath();\n        this.__originalClosePath();\n    };\n    ctx.beginPath = function() {\n        destCtx.beginPath();\n        this.__originalBeginPath();\n    };\n}\nclass CachedCanvases {\n    constructor(canvasFactory){\n        this.canvasFactory = canvasFactory;\n        this.cache = Object.create(null);\n    }\n    getCanvas(id, width, height) {\n        let canvasEntry;\n        if (this.cache[id] !== undefined) {\n            canvasEntry = this.cache[id];\n            this.canvasFactory.reset(canvasEntry, width, height);\n        } else {\n            canvasEntry = this.canvasFactory.create(width, height);\n            this.cache[id] = canvasEntry;\n        }\n        return canvasEntry;\n    }\n    delete(id) {\n        delete this.cache[id];\n    }\n    clear() {\n        for(const id in this.cache){\n            const canvasEntry = this.cache[id];\n            this.canvasFactory.destroy(canvasEntry);\n            delete this.cache[id];\n        }\n    }\n}\nfunction drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {\n    const [a, b, c, d, tx, ty] = getCurrentTransform(ctx);\n    if (b === 0 && c === 0) {\n        const tlX = destX * a + tx;\n        const rTlX = Math.round(tlX);\n        const tlY = destY * d + ty;\n        const rTlY = Math.round(tlY);\n        const brX = (destX + destW) * a + tx;\n        const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n        const brY = (destY + destH) * d + ty;\n        const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n        ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);\n        ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);\n        ctx.setTransform(a, b, c, d, tx, ty);\n        return [\n            rWidth,\n            rHeight\n        ];\n    }\n    if (a === 0 && d === 0) {\n        const tlX = destY * c + tx;\n        const rTlX = Math.round(tlX);\n        const tlY = destX * b + ty;\n        const rTlY = Math.round(tlY);\n        const brX = (destY + destH) * c + tx;\n        const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n        const brY = (destX + destW) * b + ty;\n        const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n        ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);\n        ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);\n        ctx.setTransform(a, b, c, d, tx, ty);\n        return [\n            rHeight,\n            rWidth\n        ];\n    }\n    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);\n    const scaleX = Math.hypot(a, b);\n    const scaleY = Math.hypot(c, d);\n    return [\n        scaleX * destW,\n        scaleY * destH\n    ];\n}\nclass CanvasExtraState {\n    constructor(width, height){\n        this.alphaIsShape = false;\n        this.fontSize = 0;\n        this.fontSizeScale = 1;\n        this.textMatrix = null;\n        this.textMatrixScale = 1;\n        this.fontMatrix = FONT_IDENTITY_MATRIX;\n        this.leading = 0;\n        this.x = 0;\n        this.y = 0;\n        this.lineX = 0;\n        this.lineY = 0;\n        this.charSpacing = 0;\n        this.wordSpacing = 0;\n        this.textHScale = 1;\n        this.textRenderingMode = TextRenderingMode.FILL;\n        this.textRise = 0;\n        this.fillColor = \"#000000\";\n        this.strokeColor = \"#000000\";\n        this.patternFill = false;\n        this.patternStroke = false;\n        this.fillAlpha = 1;\n        this.strokeAlpha = 1;\n        this.lineWidth = 1;\n        this.activeSMask = null;\n        this.transferMaps = \"none\";\n        this.clipBox = new Float32Array([\n            0,\n            0,\n            width,\n            height\n        ]);\n        this.minMax = MIN_MAX_INIT.slice();\n    }\n    clone() {\n        const clone = Object.create(this);\n        clone.clipBox = this.clipBox.slice();\n        clone.minMax = this.minMax.slice();\n        return clone;\n    }\n    getPathBoundingBox(pathType = PathType.FILL, transform = null) {\n        const box = this.minMax.slice();\n        if (pathType === PathType.STROKE) {\n            if (!transform) {\n                unreachable(\"Stroke bounding box must include transform.\");\n            }\n            Util.singularValueDecompose2dScale(transform, XY);\n            const xStrokePad = XY[0] * this.lineWidth / 2;\n            const yStrokePad = XY[1] * this.lineWidth / 2;\n            box[0] -= xStrokePad;\n            box[1] -= yStrokePad;\n            box[2] += xStrokePad;\n            box[3] += yStrokePad;\n        }\n        return box;\n    }\n    updateClipFromPath() {\n        const intersect = Util.intersect(this.clipBox, this.getPathBoundingBox());\n        this.startNewPathAndClipBox(intersect || [\n            0,\n            0,\n            0,\n            0\n        ]);\n    }\n    isEmptyClip() {\n        return this.minMax[0] === Infinity;\n    }\n    startNewPathAndClipBox(box) {\n        this.clipBox.set(box, 0);\n        this.minMax.set(MIN_MAX_INIT, 0);\n    }\n    getClippedPathBoundingBox(pathType = PathType.FILL, transform = null) {\n        return Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));\n    }\n}\nfunction putBinaryImageData(ctx, imgData) {\n    if (imgData instanceof ImageData) {\n        ctx.putImageData(imgData, 0, 0);\n        return;\n    }\n    const height = imgData.height, width = imgData.width;\n    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n    let srcPos = 0, destPos;\n    const src = imgData.data;\n    const dest = chunkImgData.data;\n    let i, j, thisChunkHeight, elemsInThisChunk;\n    if (imgData.kind === util_ImageKind.GRAYSCALE_1BPP) {\n        const srcLength = src.byteLength;\n        const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\n        const dest32DataLength = dest32.length;\n        const fullSrcDiff = width + 7 >> 3;\n        const white = 0xffffffff;\n        const black = util_FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n        for(i = 0; i < totalChunks; i++){\n            thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n            destPos = 0;\n            for(j = 0; j < thisChunkHeight; j++){\n                const srcDiff = srcLength - srcPos;\n                let k = 0;\n                const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\n                const kEndUnrolled = kEnd & ~7;\n                let mask = 0;\n                let srcByte = 0;\n                for(; k < kEndUnrolled; k += 8){\n                    srcByte = src[srcPos++];\n                    dest32[destPos++] = srcByte & 128 ? white : black;\n                    dest32[destPos++] = srcByte & 64 ? white : black;\n                    dest32[destPos++] = srcByte & 32 ? white : black;\n                    dest32[destPos++] = srcByte & 16 ? white : black;\n                    dest32[destPos++] = srcByte & 8 ? white : black;\n                    dest32[destPos++] = srcByte & 4 ? white : black;\n                    dest32[destPos++] = srcByte & 2 ? white : black;\n                    dest32[destPos++] = srcByte & 1 ? white : black;\n                }\n                for(; k < kEnd; k++){\n                    if (mask === 0) {\n                        srcByte = src[srcPos++];\n                        mask = 128;\n                    }\n                    dest32[destPos++] = srcByte & mask ? white : black;\n                    mask >>= 1;\n                }\n            }\n            while(destPos < dest32DataLength){\n                dest32[destPos++] = 0;\n            }\n            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n        }\n    } else if (imgData.kind === util_ImageKind.RGBA_32BPP) {\n        j = 0;\n        elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n        for(i = 0; i < fullChunks; i++){\n            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n            srcPos += elemsInThisChunk;\n            ctx.putImageData(chunkImgData, 0, j);\n            j += FULL_CHUNK_HEIGHT;\n        }\n        if (i < totalChunks) {\n            elemsInThisChunk = width * partialChunkHeight * 4;\n            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n            ctx.putImageData(chunkImgData, 0, j);\n        }\n    } else if (imgData.kind === util_ImageKind.RGB_24BPP) {\n        thisChunkHeight = FULL_CHUNK_HEIGHT;\n        elemsInThisChunk = width * thisChunkHeight;\n        for(i = 0; i < totalChunks; i++){\n            if (i >= fullChunks) {\n                thisChunkHeight = partialChunkHeight;\n                elemsInThisChunk = width * thisChunkHeight;\n            }\n            destPos = 0;\n            for(j = elemsInThisChunk; j--;){\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = 255;\n            }\n            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n        }\n    } else {\n        throw new Error(`bad image kind: ${imgData.kind}`);\n    }\n}\nfunction putBinaryImageMask(ctx, imgData) {\n    if (imgData.bitmap) {\n        ctx.drawImage(imgData.bitmap, 0, 0);\n        return;\n    }\n    const height = imgData.height, width = imgData.width;\n    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n    let srcPos = 0;\n    const src = imgData.data;\n    const dest = chunkImgData.data;\n    for(let i = 0; i < totalChunks; i++){\n        const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n        ({ srcPos } = convertBlackAndWhiteToRGBA({\n            src,\n            srcPos,\n            dest,\n            width,\n            height: thisChunkHeight,\n            nonBlackColor: 0\n        }));\n        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n}\nfunction copyCtxState(sourceCtx, destCtx) {\n    const properties = [\n        \"strokeStyle\",\n        \"fillStyle\",\n        \"fillRule\",\n        \"globalAlpha\",\n        \"lineWidth\",\n        \"lineCap\",\n        \"lineJoin\",\n        \"miterLimit\",\n        \"globalCompositeOperation\",\n        \"font\",\n        \"filter\"\n    ];\n    for (const property of properties){\n        if (sourceCtx[property] !== undefined) {\n            destCtx[property] = sourceCtx[property];\n        }\n    }\n    if (sourceCtx.setLineDash !== undefined) {\n        destCtx.setLineDash(sourceCtx.getLineDash());\n        destCtx.lineDashOffset = sourceCtx.lineDashOffset;\n    }\n}\nfunction resetCtxToDefault(ctx) {\n    ctx.strokeStyle = ctx.fillStyle = \"#000000\";\n    ctx.fillRule = \"nonzero\";\n    ctx.globalAlpha = 1;\n    ctx.lineWidth = 1;\n    ctx.lineCap = \"butt\";\n    ctx.lineJoin = \"miter\";\n    ctx.miterLimit = 10;\n    ctx.globalCompositeOperation = \"source-over\";\n    ctx.font = \"10px sans-serif\";\n    if (ctx.setLineDash !== undefined) {\n        ctx.setLineDash([]);\n        ctx.lineDashOffset = 0;\n    }\n    const { filter } = ctx;\n    if (filter !== \"none\" && filter !== \"\") {\n        ctx.filter = \"none\";\n    }\n}\nfunction getImageSmoothingEnabled(transform, interpolate) {\n    if (interpolate) {\n        return true;\n    }\n    Util.singularValueDecompose2dScale(transform, XY);\n    const actualScale = Math.fround(OutputScale.pixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n    return XY[0] <= actualScale && XY[1] <= actualScale;\n}\nconst LINE_CAP_STYLES = [\n    \"butt\",\n    \"round\",\n    \"square\"\n];\nconst LINE_JOIN_STYLES = [\n    \"miter\",\n    \"round\",\n    \"bevel\"\n];\nconst NORMAL_CLIP = {};\nconst EO_CLIP = {};\nclass CanvasGraphics {\n    constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, { optionalContentConfig, markedContentStack = null }, annotationCanvasMap, pageColors){\n        this.ctx = canvasCtx;\n        this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n        this.stateStack = [];\n        this.pendingClip = null;\n        this.pendingEOFill = false;\n        this.res = null;\n        this.xobjs = null;\n        this.commonObjs = commonObjs;\n        this.objs = objs;\n        this.canvasFactory = canvasFactory;\n        this.filterFactory = filterFactory;\n        this.groupStack = [];\n        this.baseTransform = null;\n        this.baseTransformStack = [];\n        this.groupLevel = 0;\n        this.smaskStack = [];\n        this.smaskCounter = 0;\n        this.tempSMask = null;\n        this.suspendedCtx = null;\n        this.contentVisible = true;\n        this.markedContentStack = markedContentStack || [];\n        this.optionalContentConfig = optionalContentConfig;\n        this.cachedCanvases = new CachedCanvases(this.canvasFactory);\n        this.cachedPatterns = new Map();\n        this.annotationCanvasMap = annotationCanvasMap;\n        this.viewportScale = 1;\n        this.outputScaleX = 1;\n        this.outputScaleY = 1;\n        this.pageColors = pageColors;\n        this._cachedScaleForStroking = [\n            -1,\n            0\n        ];\n        this._cachedGetSinglePixelWidth = null;\n        this._cachedBitmapsMap = new Map();\n    }\n    getObject(data, fallback = null) {\n        if (typeof data === \"string\") {\n            return data.startsWith(\"g_\") ? this.commonObjs.get(data) : this.objs.get(data);\n        }\n        return fallback;\n    }\n    beginDrawing({ transform, viewport, transparency = false, background = null }) {\n        const width = this.ctx.canvas.width;\n        const height = this.ctx.canvas.height;\n        const savedFillStyle = this.ctx.fillStyle;\n        this.ctx.fillStyle = background || \"#ffffff\";\n        this.ctx.fillRect(0, 0, width, height);\n        this.ctx.fillStyle = savedFillStyle;\n        if (transparency) {\n            const transparentCanvas = this.cachedCanvases.getCanvas(\"transparent\", width, height);\n            this.compositeCtx = this.ctx;\n            this.transparentCanvas = transparentCanvas.canvas;\n            this.ctx = transparentCanvas.context;\n            this.ctx.save();\n            this.ctx.transform(...getCurrentTransform(this.compositeCtx));\n        }\n        this.ctx.save();\n        resetCtxToDefault(this.ctx);\n        if (transform) {\n            this.ctx.transform(...transform);\n            this.outputScaleX = transform[0];\n            this.outputScaleY = transform[0];\n        }\n        this.ctx.transform(...viewport.transform);\n        this.viewportScale = viewport.scale;\n        this.baseTransform = getCurrentTransform(this.ctx);\n    }\n    executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {\n        const argsArray = operatorList.argsArray;\n        const fnArray = operatorList.fnArray;\n        let i = executionStartIdx || 0;\n        const argsArrayLen = argsArray.length;\n        if (argsArrayLen === i) {\n            return i;\n        }\n        const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === \"function\";\n        const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n        let steps = 0;\n        const commonObjs = this.commonObjs;\n        const objs = this.objs;\n        let fnId;\n        while(true){\n            if (stepper !== undefined && i === stepper.nextBreakPoint) {\n                stepper.breakIt(i, continueCallback);\n                return i;\n            }\n            fnId = fnArray[i];\n            if (fnId !== OPS.dependency) {\n                this[fnId].apply(this, argsArray[i]);\n            } else {\n                for (const depObjId of argsArray[i]){\n                    const objsPool = depObjId.startsWith(\"g_\") ? commonObjs : objs;\n                    if (!objsPool.has(depObjId)) {\n                        objsPool.get(depObjId, continueCallback);\n                        return i;\n                    }\n                }\n            }\n            i++;\n            if (i === argsArrayLen) {\n                return i;\n            }\n            if (chunkOperations && ++steps > EXECUTION_STEPS) {\n                if (Date.now() > endTime) {\n                    continueCallback();\n                    return i;\n                }\n                steps = 0;\n            }\n        }\n    }\n    #restoreInitialState() {\n        while(this.stateStack.length || this.inSMaskMode){\n            this.restore();\n        }\n        this.current.activeSMask = null;\n        this.ctx.restore();\n        if (this.transparentCanvas) {\n            this.ctx = this.compositeCtx;\n            this.ctx.save();\n            this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n            this.ctx.drawImage(this.transparentCanvas, 0, 0);\n            this.ctx.restore();\n            this.transparentCanvas = null;\n        }\n    }\n    endDrawing() {\n        this.#restoreInitialState();\n        this.cachedCanvases.clear();\n        this.cachedPatterns.clear();\n        for (const cache of this._cachedBitmapsMap.values()){\n            for (const canvas of cache.values()){\n                if (typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement) {\n                    canvas.width = canvas.height = 0;\n                }\n            }\n            cache.clear();\n        }\n        this._cachedBitmapsMap.clear();\n        this.#drawFilter();\n    }\n    #drawFilter() {\n        if (this.pageColors) {\n            const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);\n            if (hcmFilterId !== \"none\") {\n                const savedFilter = this.ctx.filter;\n                this.ctx.filter = hcmFilterId;\n                this.ctx.drawImage(this.ctx.canvas, 0, 0);\n                this.ctx.filter = savedFilter;\n            }\n        }\n    }\n    _scaleImage(img, inverseTransform) {\n        const width = img.width ?? img.displayWidth;\n        const height = img.height ?? img.displayHeight;\n        let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);\n        let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);\n        let paintWidth = width, paintHeight = height;\n        let tmpCanvasId = \"prescale1\";\n        let tmpCanvas, tmpCtx;\n        while(widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1){\n            let newWidth = paintWidth, newHeight = paintHeight;\n            if (widthScale > 2 && paintWidth > 1) {\n                newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);\n                widthScale /= paintWidth / newWidth;\n            }\n            if (heightScale > 2 && paintHeight > 1) {\n                newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;\n                heightScale /= paintHeight / newHeight;\n            }\n            tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\n            tmpCtx = tmpCanvas.context;\n            tmpCtx.clearRect(0, 0, newWidth, newHeight);\n            tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\n            img = tmpCanvas.canvas;\n            paintWidth = newWidth;\n            paintHeight = newHeight;\n            tmpCanvasId = tmpCanvasId === \"prescale1\" ? \"prescale2\" : \"prescale1\";\n        }\n        return {\n            img,\n            paintWidth,\n            paintHeight\n        };\n    }\n    _createMaskCanvas(img) {\n        const ctx = this.ctx;\n        const { width, height } = img;\n        const fillColor = this.current.fillColor;\n        const isPatternFill = this.current.patternFill;\n        const currentTransform = getCurrentTransform(ctx);\n        let cache, cacheKey, scaled, maskCanvas;\n        if ((img.bitmap || img.data) && img.count > 1) {\n            const mainKey = img.bitmap || img.data.buffer;\n            cacheKey = JSON.stringify(isPatternFill ? currentTransform : [\n                currentTransform.slice(0, 4),\n                fillColor\n            ]);\n            cache = this._cachedBitmapsMap.get(mainKey);\n            if (!cache) {\n                cache = new Map();\n                this._cachedBitmapsMap.set(mainKey, cache);\n            }\n            const cachedImage = cache.get(cacheKey);\n            if (cachedImage && !isPatternFill) {\n                const offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);\n                const offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);\n                return {\n                    canvas: cachedImage,\n                    offsetX,\n                    offsetY\n                };\n            }\n            scaled = cachedImage;\n        }\n        if (!scaled) {\n            maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n            putBinaryImageMask(maskCanvas.context, img);\n        }\n        let maskToCanvas = Util.transform(currentTransform, [\n            1 / width,\n            0,\n            0,\n            -1 / height,\n            0,\n            0\n        ]);\n        maskToCanvas = Util.transform(maskToCanvas, [\n            1,\n            0,\n            0,\n            1,\n            0,\n            -height\n        ]);\n        const minMax = MIN_MAX_INIT.slice();\n        Util.axialAlignedBoundingBox([\n            0,\n            0,\n            width,\n            height\n        ], maskToCanvas, minMax);\n        const [minX, minY, maxX, maxY] = minMax;\n        const drawnWidth = Math.round(maxX - minX) || 1;\n        const drawnHeight = Math.round(maxY - minY) || 1;\n        const fillCanvas = this.cachedCanvases.getCanvas(\"fillCanvas\", drawnWidth, drawnHeight);\n        const fillCtx = fillCanvas.context;\n        const offsetX = minX;\n        const offsetY = minY;\n        fillCtx.translate(-offsetX, -offsetY);\n        fillCtx.transform(...maskToCanvas);\n        if (!scaled) {\n            scaled = this._scaleImage(maskCanvas.canvas, getCurrentTransformInverse(fillCtx));\n            scaled = scaled.img;\n            if (cache && isPatternFill) {\n                cache.set(cacheKey, scaled);\n            }\n        }\n        fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(fillCtx), img.interpolate);\n        drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);\n        fillCtx.globalCompositeOperation = \"source-in\";\n        const inverse = Util.transform(getCurrentTransformInverse(fillCtx), [\n            1,\n            0,\n            0,\n            1,\n            -offsetX,\n            -offsetY\n        ]);\n        fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, PathType.FILL) : fillColor;\n        fillCtx.fillRect(0, 0, width, height);\n        if (cache && !isPatternFill) {\n            this.cachedCanvases.delete(\"fillCanvas\");\n            cache.set(cacheKey, fillCanvas.canvas);\n        }\n        return {\n            canvas: fillCanvas.canvas,\n            offsetX: Math.round(offsetX),\n            offsetY: Math.round(offsetY)\n        };\n    }\n    setLineWidth(width) {\n        if (width !== this.current.lineWidth) {\n            this._cachedScaleForStroking[0] = -1;\n        }\n        this.current.lineWidth = width;\n        this.ctx.lineWidth = width;\n    }\n    setLineCap(style) {\n        this.ctx.lineCap = LINE_CAP_STYLES[style];\n    }\n    setLineJoin(style) {\n        this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n    }\n    setMiterLimit(limit) {\n        this.ctx.miterLimit = limit;\n    }\n    setDash(dashArray, dashPhase) {\n        const ctx = this.ctx;\n        if (ctx.setLineDash !== undefined) {\n            ctx.setLineDash(dashArray);\n            ctx.lineDashOffset = dashPhase;\n        }\n    }\n    setRenderingIntent(intent) {}\n    setFlatness(flatness) {}\n    setGState(states) {\n        for (const [key, value] of states){\n            switch(key){\n                case \"LW\":\n                    this.setLineWidth(value);\n                    break;\n                case \"LC\":\n                    this.setLineCap(value);\n                    break;\n                case \"LJ\":\n                    this.setLineJoin(value);\n                    break;\n                case \"ML\":\n                    this.setMiterLimit(value);\n                    break;\n                case \"D\":\n                    this.setDash(value[0], value[1]);\n                    break;\n                case \"RI\":\n                    this.setRenderingIntent(value);\n                    break;\n                case \"FL\":\n                    this.setFlatness(value);\n                    break;\n                case \"Font\":\n                    this.setFont(value[0], value[1]);\n                    break;\n                case \"CA\":\n                    this.current.strokeAlpha = value;\n                    break;\n                case \"ca\":\n                    this.ctx.globalAlpha = this.current.fillAlpha = value;\n                    break;\n                case \"BM\":\n                    this.ctx.globalCompositeOperation = value;\n                    break;\n                case \"SMask\":\n                    this.current.activeSMask = value ? this.tempSMask : null;\n                    this.tempSMask = null;\n                    this.checkSMaskState();\n                    break;\n                case \"TR\":\n                    this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);\n                    break;\n            }\n        }\n    }\n    get inSMaskMode() {\n        return !!this.suspendedCtx;\n    }\n    checkSMaskState() {\n        const inSMaskMode = this.inSMaskMode;\n        if (this.current.activeSMask && !inSMaskMode) {\n            this.beginSMaskMode();\n        } else if (!this.current.activeSMask && inSMaskMode) {\n            this.endSMaskMode();\n        }\n    }\n    beginSMaskMode() {\n        if (this.inSMaskMode) {\n            throw new Error(\"beginSMaskMode called while already in smask mode\");\n        }\n        const drawnWidth = this.ctx.canvas.width;\n        const drawnHeight = this.ctx.canvas.height;\n        const cacheId = \"smaskGroupAt\" + this.groupLevel;\n        const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n        this.suspendedCtx = this.ctx;\n        const ctx = this.ctx = scratchCanvas.context;\n        ctx.setTransform(this.suspendedCtx.getTransform());\n        copyCtxState(this.suspendedCtx, ctx);\n        mirrorContextOperations(ctx, this.suspendedCtx);\n        this.setGState([\n            [\n                \"BM\",\n                \"source-over\"\n            ]\n        ]);\n    }\n    endSMaskMode() {\n        if (!this.inSMaskMode) {\n            throw new Error(\"endSMaskMode called while not in smask mode\");\n        }\n        this.ctx._removeMirroring();\n        copyCtxState(this.ctx, this.suspendedCtx);\n        this.ctx = this.suspendedCtx;\n        this.suspendedCtx = null;\n    }\n    compose(dirtyBox) {\n        if (!this.current.activeSMask) {\n            return;\n        }\n        if (!dirtyBox) {\n            dirtyBox = [\n                0,\n                0,\n                this.ctx.canvas.width,\n                this.ctx.canvas.height\n            ];\n        } else {\n            dirtyBox[0] = Math.floor(dirtyBox[0]);\n            dirtyBox[1] = Math.floor(dirtyBox[1]);\n            dirtyBox[2] = Math.ceil(dirtyBox[2]);\n            dirtyBox[3] = Math.ceil(dirtyBox[3]);\n        }\n        const smask = this.current.activeSMask;\n        const suspendedCtx = this.suspendedCtx;\n        this.composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);\n        this.ctx.save();\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n        this.ctx.restore();\n    }\n    composeSMask(ctx, smask, layerCtx, layerBox) {\n        const layerOffsetX = layerBox[0];\n        const layerOffsetY = layerBox[1];\n        const layerWidth = layerBox[2] - layerOffsetX;\n        const layerHeight = layerBox[3] - layerOffsetY;\n        if (layerWidth === 0 || layerHeight === 0) {\n            return;\n        }\n        this.genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);\n        ctx.save();\n        ctx.globalAlpha = 1;\n        ctx.globalCompositeOperation = \"source-over\";\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.drawImage(layerCtx.canvas, 0, 0);\n        ctx.restore();\n    }\n    genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {\n        let maskCanvas = maskCtx.canvas;\n        let maskX = layerOffsetX - maskOffsetX;\n        let maskY = layerOffsetY - maskOffsetY;\n        if (backdrop) {\n            const backdropRGB = Util.makeHexColor(...backdrop);\n            if (maskX < 0 || maskY < 0 || maskX + width > maskCanvas.width || maskY + height > maskCanvas.height) {\n                const canvas = this.cachedCanvases.getCanvas(\"maskExtension\", width, height);\n                const ctx = canvas.context;\n                ctx.drawImage(maskCanvas, -maskX, -maskY);\n                ctx.globalCompositeOperation = \"destination-atop\";\n                ctx.fillStyle = backdropRGB;\n                ctx.fillRect(0, 0, width, height);\n                ctx.globalCompositeOperation = \"source-over\";\n                maskCanvas = canvas.canvas;\n                maskX = maskY = 0;\n            } else {\n                maskCtx.save();\n                maskCtx.globalAlpha = 1;\n                maskCtx.setTransform(1, 0, 0, 1, 0, 0);\n                const clip = new Path2D();\n                clip.rect(maskX, maskY, width, height);\n                maskCtx.clip(clip);\n                maskCtx.globalCompositeOperation = \"destination-atop\";\n                maskCtx.fillStyle = backdropRGB;\n                maskCtx.fillRect(maskX, maskY, width, height);\n                maskCtx.restore();\n            }\n        }\n        layerCtx.save();\n        layerCtx.globalAlpha = 1;\n        layerCtx.setTransform(1, 0, 0, 1, 0, 0);\n        if (subtype === \"Alpha\" && transferMap) {\n            layerCtx.filter = this.filterFactory.addAlphaFilter(transferMap);\n        } else if (subtype === \"Luminosity\") {\n            layerCtx.filter = this.filterFactory.addLuminosityFilter(transferMap);\n        }\n        const clip = new Path2D();\n        clip.rect(layerOffsetX, layerOffsetY, width, height);\n        layerCtx.clip(clip);\n        layerCtx.globalCompositeOperation = \"destination-in\";\n        layerCtx.drawImage(maskCanvas, maskX, maskY, width, height, layerOffsetX, layerOffsetY, width, height);\n        layerCtx.restore();\n    }\n    save() {\n        if (this.inSMaskMode) {\n            copyCtxState(this.ctx, this.suspendedCtx);\n        }\n        this.ctx.save();\n        const old = this.current;\n        this.stateStack.push(old);\n        this.current = old.clone();\n    }\n    restore() {\n        if (this.stateStack.length === 0) {\n            if (this.inSMaskMode) {\n                this.endSMaskMode();\n            }\n            return;\n        }\n        this.current = this.stateStack.pop();\n        this.ctx.restore();\n        if (this.inSMaskMode) {\n            copyCtxState(this.suspendedCtx, this.ctx);\n        }\n        this.checkSMaskState();\n        this.pendingClip = null;\n        this._cachedScaleForStroking[0] = -1;\n        this._cachedGetSinglePixelWidth = null;\n    }\n    transform(a, b, c, d, e, f) {\n        this.ctx.transform(a, b, c, d, e, f);\n        this._cachedScaleForStroking[0] = -1;\n        this._cachedGetSinglePixelWidth = null;\n    }\n    constructPath(op, data, minMax) {\n        let [path] = data;\n        if (!minMax) {\n            path ||= data[0] = new Path2D();\n            this[op](path);\n            return;\n        }\n        if (!(path instanceof Path2D)) {\n            const path2d = data[0] = new Path2D();\n            for(let i = 0, ii = path.length; i < ii;){\n                switch(path[i++]){\n                    case DrawOPS.moveTo:\n                        path2d.moveTo(path[i++], path[i++]);\n                        break;\n                    case DrawOPS.lineTo:\n                        path2d.lineTo(path[i++], path[i++]);\n                        break;\n                    case DrawOPS.curveTo:\n                        path2d.bezierCurveTo(path[i++], path[i++], path[i++], path[i++], path[i++], path[i++]);\n                        break;\n                    case DrawOPS.closePath:\n                        path2d.closePath();\n                        break;\n                    default:\n                        warn(`Unrecognized drawing path operator: ${path[i - 1]}`);\n                        break;\n                }\n            }\n            path = path2d;\n        }\n        Util.axialAlignedBoundingBox(minMax, getCurrentTransform(this.ctx), this.current.minMax);\n        this[op](path);\n    }\n    closePath() {\n        this.ctx.closePath();\n    }\n    stroke(path, consumePath = true) {\n        const ctx = this.ctx;\n        const strokeColor = this.current.strokeColor;\n        ctx.globalAlpha = this.current.strokeAlpha;\n        if (this.contentVisible) {\n            if (typeof strokeColor === \"object\" && strokeColor?.getPattern) {\n                const baseTransform = strokeColor.isModifyingCurrentTransform() ? ctx.getTransform() : null;\n                ctx.save();\n                ctx.strokeStyle = strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE);\n                if (baseTransform) {\n                    const newPath = new Path2D();\n                    newPath.addPath(path, ctx.getTransform().invertSelf().multiplySelf(baseTransform));\n                    path = newPath;\n                }\n                this.rescaleAndStroke(path, false);\n                ctx.restore();\n            } else {\n                this.rescaleAndStroke(path, true);\n            }\n        }\n        if (consumePath) {\n            this.consumePath(path, this.current.getClippedPathBoundingBox(PathType.STROKE, getCurrentTransform(this.ctx)));\n        }\n        ctx.globalAlpha = this.current.fillAlpha;\n    }\n    closeStroke(path) {\n        this.stroke(path);\n    }\n    fill(path, consumePath = true) {\n        const ctx = this.ctx;\n        const fillColor = this.current.fillColor;\n        const isPatternFill = this.current.patternFill;\n        let needRestore = false;\n        if (isPatternFill) {\n            const baseTransform = fillColor.isModifyingCurrentTransform() ? ctx.getTransform() : null;\n            ctx.save();\n            ctx.fillStyle = fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL);\n            if (baseTransform) {\n                const newPath = new Path2D();\n                newPath.addPath(path, ctx.getTransform().invertSelf().multiplySelf(baseTransform));\n                path = newPath;\n            }\n            needRestore = true;\n        }\n        const intersect = this.current.getClippedPathBoundingBox();\n        if (this.contentVisible && intersect !== null) {\n            if (this.pendingEOFill) {\n                ctx.fill(path, \"evenodd\");\n                this.pendingEOFill = false;\n            } else {\n                ctx.fill(path);\n            }\n        }\n        if (needRestore) {\n            ctx.restore();\n        }\n        if (consumePath) {\n            this.consumePath(path, intersect);\n        }\n    }\n    eoFill(path) {\n        this.pendingEOFill = true;\n        this.fill(path);\n    }\n    fillStroke(path) {\n        this.fill(path, false);\n        this.stroke(path, false);\n        this.consumePath(path);\n    }\n    eoFillStroke(path) {\n        this.pendingEOFill = true;\n        this.fillStroke(path);\n    }\n    closeFillStroke(path) {\n        this.fillStroke(path);\n    }\n    closeEOFillStroke(path) {\n        this.pendingEOFill = true;\n        this.fillStroke(path);\n    }\n    endPath(path) {\n        this.consumePath(path);\n    }\n    rawFillPath(path) {\n        this.ctx.fill(path);\n    }\n    clip() {\n        this.pendingClip = NORMAL_CLIP;\n    }\n    eoClip() {\n        this.pendingClip = EO_CLIP;\n    }\n    beginText() {\n        this.current.textMatrix = null;\n        this.current.textMatrixScale = 1;\n        this.current.x = this.current.lineX = 0;\n        this.current.y = this.current.lineY = 0;\n    }\n    endText() {\n        const paths = this.pendingTextPaths;\n        const ctx = this.ctx;\n        if (paths === undefined) {\n            return;\n        }\n        const newPath = new Path2D();\n        const invTransf = ctx.getTransform().invertSelf();\n        for (const { transform, x, y, fontSize, path } of paths){\n            newPath.addPath(path, new DOMMatrix(transform).preMultiplySelf(invTransf).translate(x, y).scale(fontSize, -fontSize));\n        }\n        ctx.clip(newPath);\n        delete this.pendingTextPaths;\n    }\n    setCharSpacing(spacing) {\n        this.current.charSpacing = spacing;\n    }\n    setWordSpacing(spacing) {\n        this.current.wordSpacing = spacing;\n    }\n    setHScale(scale) {\n        this.current.textHScale = scale / 100;\n    }\n    setLeading(leading) {\n        this.current.leading = -leading;\n    }\n    setFont(fontRefName, size) {\n        const fontObj = this.commonObjs.get(fontRefName);\n        const current = this.current;\n        if (!fontObj) {\n            throw new Error(`Can't find font for ${fontRefName}`);\n        }\n        current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;\n        if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\n            warn(\"Invalid font matrix for font \" + fontRefName);\n        }\n        if (size < 0) {\n            size = -size;\n            current.fontDirection = -1;\n        } else {\n            current.fontDirection = 1;\n        }\n        this.current.font = fontObj;\n        this.current.fontSize = size;\n        if (fontObj.isType3Font) {\n            return;\n        }\n        const name = fontObj.loadedName || \"sans-serif\";\n        const typeface = fontObj.systemFontInfo?.css || `\"${name}\", ${fontObj.fallbackName}`;\n        let bold = \"normal\";\n        if (fontObj.black) {\n            bold = \"900\";\n        } else if (fontObj.bold) {\n            bold = \"bold\";\n        }\n        const italic = fontObj.italic ? \"italic\" : \"normal\";\n        let browserFontSize = size;\n        if (size < MIN_FONT_SIZE) {\n            browserFontSize = MIN_FONT_SIZE;\n        } else if (size > MAX_FONT_SIZE) {\n            browserFontSize = MAX_FONT_SIZE;\n        }\n        this.current.fontSizeScale = size / browserFontSize;\n        this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;\n    }\n    setTextRenderingMode(mode) {\n        this.current.textRenderingMode = mode;\n    }\n    setTextRise(rise) {\n        this.current.textRise = rise;\n    }\n    moveText(x, y) {\n        this.current.x = this.current.lineX += x;\n        this.current.y = this.current.lineY += y;\n    }\n    setLeadingMoveText(x, y) {\n        this.setLeading(-y);\n        this.moveText(x, y);\n    }\n    setTextMatrix(matrix) {\n        const { current } = this;\n        current.textMatrix = matrix;\n        current.textMatrixScale = Math.hypot(matrix[0], matrix[1]);\n        current.x = current.lineX = 0;\n        current.y = current.lineY = 0;\n    }\n    nextLine() {\n        this.moveText(0, this.current.leading);\n    }\n    #getScaledPath(path, currentTransform, transform) {\n        const newPath = new Path2D();\n        newPath.addPath(path, new DOMMatrix(transform).invertSelf().multiplySelf(currentTransform));\n        return newPath;\n    }\n    paintChar(character, x, y, patternFillTransform, patternStrokeTransform) {\n        const ctx = this.ctx;\n        const current = this.current;\n        const font = current.font;\n        const textRenderingMode = current.textRenderingMode;\n        const fontSize = current.fontSize / current.fontSizeScale;\n        const fillStrokeMode = textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;\n        const isAddToPathSet = !!(textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG);\n        const patternFill = current.patternFill && !font.missingFile;\n        const patternStroke = current.patternStroke && !font.missingFile;\n        let path;\n        if (font.disableFontFace || isAddToPathSet || patternFill || patternStroke) {\n            path = font.getPathGenerator(this.commonObjs, character);\n        }\n        if (font.disableFontFace || patternFill || patternStroke) {\n            ctx.save();\n            ctx.translate(x, y);\n            ctx.scale(fontSize, -fontSize);\n            let currentTransform;\n            if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                if (patternFillTransform) {\n                    currentTransform = ctx.getTransform();\n                    ctx.setTransform(...patternFillTransform);\n                    ctx.fill(this.#getScaledPath(path, currentTransform, patternFillTransform));\n                } else {\n                    ctx.fill(path);\n                }\n            }\n            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                if (patternStrokeTransform) {\n                    currentTransform ||= ctx.getTransform();\n                    ctx.setTransform(...patternStrokeTransform);\n                    const { a, b, c, d } = currentTransform;\n                    const invPatternTransform = Util.inverseTransform(patternStrokeTransform);\n                    const transf = Util.transform([\n                        a,\n                        b,\n                        c,\n                        d,\n                        0,\n                        0\n                    ], invPatternTransform);\n                    Util.singularValueDecompose2dScale(transf, XY);\n                    ctx.lineWidth *= Math.max(XY[0], XY[1]) / fontSize;\n                    ctx.stroke(this.#getScaledPath(path, currentTransform, patternStrokeTransform));\n                } else {\n                    ctx.lineWidth /= fontSize;\n                    ctx.stroke(path);\n                }\n            }\n            ctx.restore();\n        } else {\n            if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                ctx.fillText(character, x, y);\n            }\n            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                ctx.strokeText(character, x, y);\n            }\n        }\n        if (isAddToPathSet) {\n            const paths = this.pendingTextPaths ||= [];\n            paths.push({\n                transform: getCurrentTransform(ctx),\n                x,\n                y,\n                fontSize,\n                path\n            });\n        }\n    }\n    get isFontSubpixelAAEnabled() {\n        const { context: ctx } = this.cachedCanvases.getCanvas(\"isFontSubpixelAAEnabled\", 10, 10);\n        ctx.scale(1.5, 1);\n        ctx.fillText(\"I\", 0, 10);\n        const data = ctx.getImageData(0, 0, 10, 10).data;\n        let enabled = false;\n        for(let i = 3; i < data.length; i += 4){\n            if (data[i] > 0 && data[i] < 255) {\n                enabled = true;\n                break;\n            }\n        }\n        return shadow(this, \"isFontSubpixelAAEnabled\", enabled);\n    }\n    showText(glyphs) {\n        const current = this.current;\n        const font = current.font;\n        if (font.isType3Font) {\n            return this.showType3Text(glyphs);\n        }\n        const fontSize = current.fontSize;\n        if (fontSize === 0) {\n            return undefined;\n        }\n        const ctx = this.ctx;\n        const fontSizeScale = current.fontSizeScale;\n        const charSpacing = current.charSpacing;\n        const wordSpacing = current.wordSpacing;\n        const fontDirection = current.fontDirection;\n        const textHScale = current.textHScale * fontDirection;\n        const glyphsLength = glyphs.length;\n        const vertical = font.vertical;\n        const spacingDir = vertical ? 1 : -1;\n        const defaultVMetrics = font.defaultVMetrics;\n        const widthAdvanceScale = fontSize * current.fontMatrix[0];\n        const simpleFillText = current.textRenderingMode === TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;\n        ctx.save();\n        if (current.textMatrix) {\n            ctx.transform(...current.textMatrix);\n        }\n        ctx.translate(current.x, current.y + current.textRise);\n        if (fontDirection > 0) {\n            ctx.scale(textHScale, -1);\n        } else {\n            ctx.scale(textHScale, 1);\n        }\n        let patternFillTransform, patternStrokeTransform;\n        if (current.patternFill) {\n            ctx.save();\n            const pattern = current.fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL);\n            patternFillTransform = getCurrentTransform(ctx);\n            ctx.restore();\n            ctx.fillStyle = pattern;\n        }\n        if (current.patternStroke) {\n            ctx.save();\n            const pattern = current.strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE);\n            patternStrokeTransform = getCurrentTransform(ctx);\n            ctx.restore();\n            ctx.strokeStyle = pattern;\n        }\n        let lineWidth = current.lineWidth;\n        const scale = current.textMatrixScale;\n        if (scale === 0 || lineWidth === 0) {\n            const fillStrokeMode = current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;\n            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                lineWidth = this.getSinglePixelWidth();\n            }\n        } else {\n            lineWidth /= scale;\n        }\n        if (fontSizeScale !== 1.0) {\n            ctx.scale(fontSizeScale, fontSizeScale);\n            lineWidth /= fontSizeScale;\n        }\n        ctx.lineWidth = lineWidth;\n        if (font.isInvalidPDFjsFont) {\n            const chars = [];\n            let width = 0;\n            for (const glyph of glyphs){\n                chars.push(glyph.unicode);\n                width += glyph.width;\n            }\n            ctx.fillText(chars.join(\"\"), 0, 0);\n            current.x += width * widthAdvanceScale * textHScale;\n            ctx.restore();\n            this.compose();\n            return undefined;\n        }\n        let x = 0, i;\n        for(i = 0; i < glyphsLength; ++i){\n            const glyph = glyphs[i];\n            if (typeof glyph === \"number\") {\n                x += spacingDir * glyph * fontSize / 1000;\n                continue;\n            }\n            let restoreNeeded = false;\n            const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n            const character = glyph.fontChar;\n            const accent = glyph.accent;\n            let scaledX, scaledY;\n            let width = glyph.width;\n            if (vertical) {\n                const vmetric = glyph.vmetric || defaultVMetrics;\n                const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;\n                const vy = vmetric[2] * widthAdvanceScale;\n                width = vmetric ? -vmetric[0] : width;\n                scaledX = vx / fontSizeScale;\n                scaledY = (x + vy) / fontSizeScale;\n            } else {\n                scaledX = x / fontSizeScale;\n                scaledY = 0;\n            }\n            if (font.remeasure && width > 0) {\n                const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;\n                if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\n                    const characterScaleX = width / measuredWidth;\n                    restoreNeeded = true;\n                    ctx.save();\n                    ctx.scale(characterScaleX, 1);\n                    scaledX /= characterScaleX;\n                } else if (width !== measuredWidth) {\n                    scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;\n                }\n            }\n            if (this.contentVisible && (glyph.isInFont || font.missingFile)) {\n                if (simpleFillText && !accent) {\n                    ctx.fillText(character, scaledX, scaledY);\n                } else {\n                    this.paintChar(character, scaledX, scaledY, patternFillTransform, patternStrokeTransform);\n                    if (accent) {\n                        const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;\n                        const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;\n                        this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternFillTransform, patternStrokeTransform);\n                    }\n                }\n            }\n            const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;\n            x += charWidth;\n            if (restoreNeeded) {\n                ctx.restore();\n            }\n        }\n        if (vertical) {\n            current.y -= x;\n        } else {\n            current.x += x * textHScale;\n        }\n        ctx.restore();\n        this.compose();\n        return undefined;\n    }\n    showType3Text(glyphs) {\n        const ctx = this.ctx;\n        const current = this.current;\n        const font = current.font;\n        const fontSize = current.fontSize;\n        const fontDirection = current.fontDirection;\n        const spacingDir = font.vertical ? 1 : -1;\n        const charSpacing = current.charSpacing;\n        const wordSpacing = current.wordSpacing;\n        const textHScale = current.textHScale * fontDirection;\n        const fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;\n        const glyphsLength = glyphs.length;\n        const isTextInvisible = current.textRenderingMode === TextRenderingMode.INVISIBLE;\n        let i, glyph, width, spacingLength;\n        if (isTextInvisible || fontSize === 0) {\n            return;\n        }\n        this._cachedScaleForStroking[0] = -1;\n        this._cachedGetSinglePixelWidth = null;\n        ctx.save();\n        if (current.textMatrix) {\n            ctx.transform(...current.textMatrix);\n        }\n        ctx.translate(current.x, current.y + current.textRise);\n        ctx.scale(textHScale, fontDirection);\n        for(i = 0; i < glyphsLength; ++i){\n            glyph = glyphs[i];\n            if (typeof glyph === \"number\") {\n                spacingLength = spacingDir * glyph * fontSize / 1000;\n                this.ctx.translate(spacingLength, 0);\n                current.x += spacingLength * textHScale;\n                continue;\n            }\n            const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n            const operatorList = font.charProcOperatorList[glyph.operatorListId];\n            if (!operatorList) {\n                warn(`Type3 character \"${glyph.operatorListId}\" is not available.`);\n            } else if (this.contentVisible) {\n                this.save();\n                ctx.scale(fontSize, fontSize);\n                ctx.transform(...fontMatrix);\n                this.executeOperatorList(operatorList);\n                this.restore();\n            }\n            const p = [\n                glyph.width,\n                0\n            ];\n            Util.applyTransform(p, fontMatrix);\n            width = p[0] * fontSize + spacing;\n            ctx.translate(width, 0);\n            current.x += width * textHScale;\n        }\n        ctx.restore();\n    }\n    setCharWidth(xWidth, yWidth) {}\n    setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {\n        const clip = new Path2D();\n        clip.rect(llx, lly, urx - llx, ury - lly);\n        this.ctx.clip(clip);\n        this.endPath();\n    }\n    getColorN_Pattern(IR) {\n        let pattern;\n        if (IR[0] === \"TilingPattern\") {\n            const baseTransform = this.baseTransform || getCurrentTransform(this.ctx);\n            const canvasGraphicsFactory = {\n                createCanvasGraphics: (ctx)=>new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n                        optionalContentConfig: this.optionalContentConfig,\n                        markedContentStack: this.markedContentStack\n                    })\n            };\n            pattern = new TilingPattern(IR, this.ctx, canvasGraphicsFactory, baseTransform);\n        } else {\n            pattern = this._getPattern(IR[1], IR[2]);\n        }\n        return pattern;\n    }\n    setStrokeColorN() {\n        this.current.strokeColor = this.getColorN_Pattern(arguments);\n        this.current.patternStroke = true;\n    }\n    setFillColorN() {\n        this.current.fillColor = this.getColorN_Pattern(arguments);\n        this.current.patternFill = true;\n    }\n    setStrokeRGBColor(r, g, b) {\n        this.ctx.strokeStyle = this.current.strokeColor = Util.makeHexColor(r, g, b);\n        this.current.patternStroke = false;\n    }\n    setStrokeTransparent() {\n        this.ctx.strokeStyle = this.current.strokeColor = \"transparent\";\n        this.current.patternStroke = false;\n    }\n    setFillRGBColor(r, g, b) {\n        this.ctx.fillStyle = this.current.fillColor = Util.makeHexColor(r, g, b);\n        this.current.patternFill = false;\n    }\n    setFillTransparent() {\n        this.ctx.fillStyle = this.current.fillColor = \"transparent\";\n        this.current.patternFill = false;\n    }\n    _getPattern(objId, matrix = null) {\n        let pattern;\n        if (this.cachedPatterns.has(objId)) {\n            pattern = this.cachedPatterns.get(objId);\n        } else {\n            pattern = getShadingPattern(this.getObject(objId));\n            this.cachedPatterns.set(objId, pattern);\n        }\n        if (matrix) {\n            pattern.matrix = matrix;\n        }\n        return pattern;\n    }\n    shadingFill(objId) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const ctx = this.ctx;\n        this.save();\n        const pattern = this._getPattern(objId);\n        ctx.fillStyle = pattern.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.SHADING);\n        const inv = getCurrentTransformInverse(ctx);\n        if (inv) {\n            const { width, height } = ctx.canvas;\n            const minMax = MIN_MAX_INIT.slice();\n            Util.axialAlignedBoundingBox([\n                0,\n                0,\n                width,\n                height\n            ], inv, minMax);\n            const [x0, y0, x1, y1] = minMax;\n            this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n        } else {\n            this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n        }\n        this.compose(this.current.getClippedPathBoundingBox());\n        this.restore();\n    }\n    beginInlineImage() {\n        unreachable(\"Should not call beginInlineImage\");\n    }\n    beginImageData() {\n        unreachable(\"Should not call beginImageData\");\n    }\n    paintFormXObjectBegin(matrix, bbox) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.save();\n        this.baseTransformStack.push(this.baseTransform);\n        if (matrix) {\n            this.transform(...matrix);\n        }\n        this.baseTransform = getCurrentTransform(this.ctx);\n        if (bbox) {\n            Util.axialAlignedBoundingBox(bbox, this.baseTransform, this.current.minMax);\n            const [x0, y0, x1, y1] = bbox;\n            const clip = new Path2D();\n            clip.rect(x0, y0, x1 - x0, y1 - y0);\n            this.ctx.clip(clip);\n            this.endPath();\n        }\n    }\n    paintFormXObjectEnd() {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.restore();\n        this.baseTransform = this.baseTransformStack.pop();\n    }\n    beginGroup(group) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.save();\n        if (this.inSMaskMode) {\n            this.endSMaskMode();\n            this.current.activeSMask = null;\n        }\n        const currentCtx = this.ctx;\n        if (!group.isolated) {\n            info(\"TODO: Support non-isolated groups.\");\n        }\n        if (group.knockout) {\n            warn(\"Knockout groups not supported.\");\n        }\n        const currentTransform = getCurrentTransform(currentCtx);\n        if (group.matrix) {\n            currentCtx.transform(...group.matrix);\n        }\n        if (!group.bbox) {\n            throw new Error(\"Bounding box is required.\");\n        }\n        let bounds = MIN_MAX_INIT.slice();\n        Util.axialAlignedBoundingBox(group.bbox, getCurrentTransform(currentCtx), bounds);\n        const canvasBounds = [\n            0,\n            0,\n            currentCtx.canvas.width,\n            currentCtx.canvas.height\n        ];\n        bounds = Util.intersect(bounds, canvasBounds) || [\n            0,\n            0,\n            0,\n            0\n        ];\n        const offsetX = Math.floor(bounds[0]);\n        const offsetY = Math.floor(bounds[1]);\n        const drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n        const drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n        this.current.startNewPathAndClipBox([\n            0,\n            0,\n            drawnWidth,\n            drawnHeight\n        ]);\n        let cacheId = \"groupAt\" + this.groupLevel;\n        if (group.smask) {\n            cacheId += \"_smask_\" + this.smaskCounter++ % 2;\n        }\n        const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n        const groupCtx = scratchCanvas.context;\n        groupCtx.translate(-offsetX, -offsetY);\n        groupCtx.transform(...currentTransform);\n        let clip = new Path2D();\n        const [x0, y0, x1, y1] = group.bbox;\n        clip.rect(x0, y0, x1 - x0, y1 - y0);\n        if (group.matrix) {\n            const path = new Path2D();\n            path.addPath(clip, new DOMMatrix(group.matrix));\n            clip = path;\n        }\n        groupCtx.clip(clip);\n        if (group.smask) {\n            this.smaskStack.push({\n                canvas: scratchCanvas.canvas,\n                context: groupCtx,\n                offsetX,\n                offsetY,\n                subtype: group.smask.subtype,\n                backdrop: group.smask.backdrop,\n                transferMap: group.smask.transferMap || null,\n                startTransformInverse: null\n            });\n        } else {\n            currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n            currentCtx.translate(offsetX, offsetY);\n            currentCtx.save();\n        }\n        copyCtxState(currentCtx, groupCtx);\n        this.ctx = groupCtx;\n        this.setGState([\n            [\n                \"BM\",\n                \"source-over\"\n            ],\n            [\n                \"ca\",\n                1\n            ],\n            [\n                \"CA\",\n                1\n            ]\n        ]);\n        this.groupStack.push(currentCtx);\n        this.groupLevel++;\n    }\n    endGroup(group) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.groupLevel--;\n        const groupCtx = this.ctx;\n        const ctx = this.groupStack.pop();\n        this.ctx = ctx;\n        this.ctx.imageSmoothingEnabled = false;\n        if (group.smask) {\n            this.tempSMask = this.smaskStack.pop();\n            this.restore();\n        } else {\n            this.ctx.restore();\n            const currentMtx = getCurrentTransform(this.ctx);\n            this.restore();\n            this.ctx.save();\n            this.ctx.setTransform(...currentMtx);\n            const dirtyBox = MIN_MAX_INIT.slice();\n            Util.axialAlignedBoundingBox([\n                0,\n                0,\n                groupCtx.canvas.width,\n                groupCtx.canvas.height\n            ], currentMtx, dirtyBox);\n            this.ctx.drawImage(groupCtx.canvas, 0, 0);\n            this.ctx.restore();\n            this.compose(dirtyBox);\n        }\n    }\n    beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {\n        this.#restoreInitialState();\n        resetCtxToDefault(this.ctx);\n        this.ctx.save();\n        this.save();\n        if (this.baseTransform) {\n            this.ctx.setTransform(...this.baseTransform);\n        }\n        if (rect) {\n            const width = rect[2] - rect[0];\n            const height = rect[3] - rect[1];\n            if (hasOwnCanvas && this.annotationCanvasMap) {\n                transform = transform.slice();\n                transform[4] -= rect[0];\n                transform[5] -= rect[1];\n                rect = rect.slice();\n                rect[0] = rect[1] = 0;\n                rect[2] = width;\n                rect[3] = height;\n                Util.singularValueDecompose2dScale(getCurrentTransform(this.ctx), XY);\n                const { viewportScale } = this;\n                const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);\n                const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);\n                this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);\n                const { canvas, context } = this.annotationCanvas;\n                this.annotationCanvasMap.set(id, canvas);\n                this.annotationCanvas.savedCtx = this.ctx;\n                this.ctx = context;\n                this.ctx.save();\n                this.ctx.setTransform(XY[0], 0, 0, -XY[1], 0, height * XY[1]);\n                resetCtxToDefault(this.ctx);\n            } else {\n                resetCtxToDefault(this.ctx);\n                this.endPath();\n                const clip = new Path2D();\n                clip.rect(rect[0], rect[1], width, height);\n                this.ctx.clip(clip);\n            }\n        }\n        this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n        this.transform(...transform);\n        this.transform(...matrix);\n    }\n    endAnnotation() {\n        if (this.annotationCanvas) {\n            this.ctx.restore();\n            this.#drawFilter();\n            this.ctx = this.annotationCanvas.savedCtx;\n            delete this.annotationCanvas.savedCtx;\n            delete this.annotationCanvas;\n        }\n    }\n    paintImageMaskXObject(img) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const count = img.count;\n        img = this.getObject(img.data, img);\n        img.count = count;\n        const ctx = this.ctx;\n        const mask = this._createMaskCanvas(img);\n        const maskCanvas = mask.canvas;\n        ctx.save();\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);\n        ctx.restore();\n        this.compose();\n    }\n    paintImageMaskXObjectRepeat(img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {\n        if (!this.contentVisible) {\n            return;\n        }\n        img = this.getObject(img.data, img);\n        const ctx = this.ctx;\n        ctx.save();\n        const currentTransform = getCurrentTransform(ctx);\n        ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);\n        const mask = this._createMaskCanvas(img);\n        ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);\n        for(let i = 0, ii = positions.length; i < ii; i += 2){\n            const trans = Util.transform(currentTransform, [\n                scaleX,\n                skewX,\n                skewY,\n                scaleY,\n                positions[i],\n                positions[i + 1]\n            ]);\n            ctx.drawImage(mask.canvas, trans[4], trans[5]);\n        }\n        ctx.restore();\n        this.compose();\n    }\n    paintImageMaskXObjectGroup(images) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const ctx = this.ctx;\n        const fillColor = this.current.fillColor;\n        const isPatternFill = this.current.patternFill;\n        for (const image of images){\n            const { data, width, height, transform } = image;\n            const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n            const maskCtx = maskCanvas.context;\n            maskCtx.save();\n            const img = this.getObject(data, image);\n            putBinaryImageMask(maskCtx, img);\n            maskCtx.globalCompositeOperation = \"source-in\";\n            maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, getCurrentTransformInverse(ctx), PathType.FILL) : fillColor;\n            maskCtx.fillRect(0, 0, width, height);\n            maskCtx.restore();\n            ctx.save();\n            ctx.transform(...transform);\n            ctx.scale(1, -1);\n            drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n            ctx.restore();\n        }\n        this.compose();\n    }\n    paintImageXObject(objId) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const imgData = this.getObject(objId);\n        if (!imgData) {\n            warn(\"Dependent image isn't ready yet\");\n            return;\n        }\n        this.paintInlineImageXObject(imgData);\n    }\n    paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const imgData = this.getObject(objId);\n        if (!imgData) {\n            warn(\"Dependent image isn't ready yet\");\n            return;\n        }\n        const width = imgData.width;\n        const height = imgData.height;\n        const map = [];\n        for(let i = 0, ii = positions.length; i < ii; i += 2){\n            map.push({\n                transform: [\n                    scaleX,\n                    0,\n                    0,\n                    scaleY,\n                    positions[i],\n                    positions[i + 1]\n                ],\n                x: 0,\n                y: 0,\n                w: width,\n                h: height\n            });\n        }\n        this.paintInlineImageXObjectGroup(imgData, map);\n    }\n    applyTransferMapsToCanvas(ctx) {\n        if (this.current.transferMaps !== \"none\") {\n            ctx.filter = this.current.transferMaps;\n            ctx.drawImage(ctx.canvas, 0, 0);\n            ctx.filter = \"none\";\n        }\n        return ctx.canvas;\n    }\n    applyTransferMapsToBitmap(imgData) {\n        if (this.current.transferMaps === \"none\") {\n            return imgData.bitmap;\n        }\n        const { bitmap, width, height } = imgData;\n        const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n        const tmpCtx = tmpCanvas.context;\n        tmpCtx.filter = this.current.transferMaps;\n        tmpCtx.drawImage(bitmap, 0, 0);\n        tmpCtx.filter = \"none\";\n        return tmpCanvas.canvas;\n    }\n    paintInlineImageXObject(imgData) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const width = imgData.width;\n        const height = imgData.height;\n        const ctx = this.ctx;\n        this.save();\n        const { filter } = ctx;\n        if (filter !== \"none\" && filter !== \"\") {\n            ctx.filter = \"none\";\n        }\n        ctx.scale(1 / width, -1 / height);\n        let imgToPaint;\n        if (imgData.bitmap) {\n            imgToPaint = this.applyTransferMapsToBitmap(imgData);\n        } else if (typeof HTMLElement === \"function\" && imgData instanceof HTMLElement || !imgData.data) {\n            imgToPaint = imgData;\n        } else {\n            const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n            const tmpCtx = tmpCanvas.context;\n            putBinaryImageData(tmpCtx, imgData);\n            imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n        }\n        const scaled = this._scaleImage(imgToPaint, getCurrentTransformInverse(ctx));\n        ctx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(ctx), imgData.interpolate);\n        drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);\n        this.compose();\n        this.restore();\n    }\n    paintInlineImageXObjectGroup(imgData, map) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const ctx = this.ctx;\n        let imgToPaint;\n        if (imgData.bitmap) {\n            imgToPaint = imgData.bitmap;\n        } else {\n            const w = imgData.width;\n            const h = imgData.height;\n            const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", w, h);\n            const tmpCtx = tmpCanvas.context;\n            putBinaryImageData(tmpCtx, imgData);\n            imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n        }\n        for (const entry of map){\n            ctx.save();\n            ctx.transform(...entry.transform);\n            ctx.scale(1, -1);\n            drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\n            ctx.restore();\n        }\n        this.compose();\n    }\n    paintSolidColorImageMask() {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.ctx.fillRect(0, 0, 1, 1);\n        this.compose();\n    }\n    markPoint(tag) {}\n    markPointProps(tag, properties) {}\n    beginMarkedContent(tag) {\n        this.markedContentStack.push({\n            visible: true\n        });\n    }\n    beginMarkedContentProps(tag, properties) {\n        if (tag === \"OC\") {\n            this.markedContentStack.push({\n                visible: this.optionalContentConfig.isVisible(properties)\n            });\n        } else {\n            this.markedContentStack.push({\n                visible: true\n            });\n        }\n        this.contentVisible = this.isContentVisible();\n    }\n    endMarkedContent() {\n        this.markedContentStack.pop();\n        this.contentVisible = this.isContentVisible();\n    }\n    beginCompat() {}\n    endCompat() {}\n    consumePath(path, clipBox) {\n        const isEmpty = this.current.isEmptyClip();\n        if (this.pendingClip) {\n            this.current.updateClipFromPath();\n        }\n        if (!this.pendingClip) {\n            this.compose(clipBox);\n        }\n        const ctx = this.ctx;\n        if (this.pendingClip) {\n            if (!isEmpty) {\n                if (this.pendingClip === EO_CLIP) {\n                    ctx.clip(path, \"evenodd\");\n                } else {\n                    ctx.clip(path);\n                }\n            }\n            this.pendingClip = null;\n        }\n        this.current.startNewPathAndClipBox(this.current.clipBox);\n    }\n    getSinglePixelWidth() {\n        if (!this._cachedGetSinglePixelWidth) {\n            const m = getCurrentTransform(this.ctx);\n            if (m[1] === 0 && m[2] === 0) {\n                this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));\n            } else {\n                const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);\n                const normX = Math.hypot(m[0], m[2]);\n                const normY = Math.hypot(m[1], m[3]);\n                this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;\n            }\n        }\n        return this._cachedGetSinglePixelWidth;\n    }\n    getScaleForStroking() {\n        if (this._cachedScaleForStroking[0] === -1) {\n            const { lineWidth } = this.current;\n            const { a, b, c, d } = this.ctx.getTransform();\n            let scaleX, scaleY;\n            if (b === 0 && c === 0) {\n                const normX = Math.abs(a);\n                const normY = Math.abs(d);\n                if (normX === normY) {\n                    if (lineWidth === 0) {\n                        scaleX = scaleY = 1 / normX;\n                    } else {\n                        const scaledLineWidth = normX * lineWidth;\n                        scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;\n                    }\n                } else if (lineWidth === 0) {\n                    scaleX = 1 / normX;\n                    scaleY = 1 / normY;\n                } else {\n                    const scaledXLineWidth = normX * lineWidth;\n                    const scaledYLineWidth = normY * lineWidth;\n                    scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;\n                    scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;\n                }\n            } else {\n                const absDet = Math.abs(a * d - b * c);\n                const normX = Math.hypot(a, b);\n                const normY = Math.hypot(c, d);\n                if (lineWidth === 0) {\n                    scaleX = normY / absDet;\n                    scaleY = normX / absDet;\n                } else {\n                    const baseArea = lineWidth * absDet;\n                    scaleX = normY > baseArea ? normY / baseArea : 1;\n                    scaleY = normX > baseArea ? normX / baseArea : 1;\n                }\n            }\n            this._cachedScaleForStroking[0] = scaleX;\n            this._cachedScaleForStroking[1] = scaleY;\n        }\n        return this._cachedScaleForStroking;\n    }\n    rescaleAndStroke(path, saveRestore) {\n        const { ctx, current: { lineWidth } } = this;\n        const [scaleX, scaleY] = this.getScaleForStroking();\n        if (scaleX === scaleY) {\n            ctx.lineWidth = (lineWidth || 1) * scaleX;\n            ctx.stroke(path);\n            return;\n        }\n        const dashes = ctx.getLineDash();\n        if (saveRestore) {\n            ctx.save();\n        }\n        ctx.scale(scaleX, scaleY);\n        SCALE_MATRIX.a = 1 / scaleX;\n        SCALE_MATRIX.d = 1 / scaleY;\n        const newPath = new Path2D();\n        newPath.addPath(path, SCALE_MATRIX);\n        if (dashes.length > 0) {\n            const scale = Math.max(scaleX, scaleY);\n            ctx.setLineDash(dashes.map((x)=>x / scale));\n            ctx.lineDashOffset /= scale;\n        }\n        ctx.lineWidth = lineWidth || 1;\n        ctx.stroke(newPath);\n        if (saveRestore) {\n            ctx.restore();\n        }\n    }\n    isContentVisible() {\n        for(let i = this.markedContentStack.length - 1; i >= 0; i--){\n            if (!this.markedContentStack[i].visible) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nfor(const op in OPS){\n    if (CanvasGraphics.prototype[op] !== undefined) {\n        CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];\n    }\n}\n; // ./src/display/worker_options.js\nclass GlobalWorkerOptions {\n    static #port = null;\n    static #src = \"\";\n    static get workerPort() {\n        return this.#port;\n    }\n    static set workerPort(val) {\n        if (!(typeof Worker !== \"undefined\" && val instanceof Worker) && val !== null) {\n            throw new Error(\"Invalid `workerPort` type.\");\n        }\n        this.#port = val;\n    }\n    static get workerSrc() {\n        return this.#src;\n    }\n    static set workerSrc(val) {\n        if (typeof val !== \"string\") {\n            throw new Error(\"Invalid `workerSrc` type.\");\n        }\n        this.#src = val;\n    }\n}\n; // ./src/display/metadata.js\nclass Metadata {\n    #map;\n    #data;\n    constructor({ parsedData, rawData }){\n        this.#map = parsedData;\n        this.#data = rawData;\n    }\n    getRaw() {\n        return this.#data;\n    }\n    get(name) {\n        return this.#map.get(name) ?? null;\n    }\n    [Symbol.iterator]() {\n        return this.#map.entries();\n    }\n}\n; // ./src/display/optional_content_config.js\nconst INTERNAL = Symbol(\"INTERNAL\");\nclass OptionalContentGroup {\n    #isDisplay;\n    #isPrint;\n    #userSet;\n    #visible;\n    constructor(renderingIntent, { name, intent, usage, rbGroups }){\n        this.#isDisplay = false;\n        this.#isPrint = false;\n        this.#userSet = false;\n        this.#visible = true;\n        this.#isDisplay = !!(renderingIntent & RenderingIntentFlag.DISPLAY);\n        this.#isPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);\n        this.name = name;\n        this.intent = intent;\n        this.usage = usage;\n        this.rbGroups = rbGroups;\n    }\n    get visible() {\n        if (this.#userSet) {\n            return this.#visible;\n        }\n        if (!this.#visible) {\n            return false;\n        }\n        const { print, view } = this.usage;\n        if (this.#isDisplay) {\n            return view?.viewState !== \"OFF\";\n        } else if (this.#isPrint) {\n            return print?.printState !== \"OFF\";\n        }\n        return true;\n    }\n    _setVisible(internal, visible, userSet = false) {\n        if (internal !== INTERNAL) {\n            unreachable(\"Internal method `_setVisible` called.\");\n        }\n        this.#userSet = userSet;\n        this.#visible = visible;\n    }\n}\nclass OptionalContentConfig {\n    #cachedGetHash;\n    #groups;\n    #initialHash;\n    #order;\n    constructor(data, renderingIntent = RenderingIntentFlag.DISPLAY){\n        this.#cachedGetHash = null;\n        this.#groups = new Map();\n        this.#initialHash = null;\n        this.#order = null;\n        this.renderingIntent = renderingIntent;\n        this.name = null;\n        this.creator = null;\n        if (data === null) {\n            return;\n        }\n        this.name = data.name;\n        this.creator = data.creator;\n        this.#order = data.order;\n        for (const group of data.groups){\n            this.#groups.set(group.id, new OptionalContentGroup(renderingIntent, group));\n        }\n        if (data.baseState === \"OFF\") {\n            for (const group of this.#groups.values()){\n                group._setVisible(INTERNAL, false);\n            }\n        }\n        for (const on of data.on){\n            this.#groups.get(on)._setVisible(INTERNAL, true);\n        }\n        for (const off of data.off){\n            this.#groups.get(off)._setVisible(INTERNAL, false);\n        }\n        this.#initialHash = this.getHash();\n    }\n    #evaluateVisibilityExpression(array) {\n        const length = array.length;\n        if (length < 2) {\n            return true;\n        }\n        const operator = array[0];\n        for(let i = 1; i < length; i++){\n            const element = array[i];\n            let state;\n            if (Array.isArray(element)) {\n                state = this.#evaluateVisibilityExpression(element);\n            } else if (this.#groups.has(element)) {\n                state = this.#groups.get(element).visible;\n            } else {\n                warn(`Optional content group not found: ${element}`);\n                return true;\n            }\n            switch(operator){\n                case \"And\":\n                    if (!state) {\n                        return false;\n                    }\n                    break;\n                case \"Or\":\n                    if (state) {\n                        return true;\n                    }\n                    break;\n                case \"Not\":\n                    return !state;\n                default:\n                    return true;\n            }\n        }\n        return operator === \"And\";\n    }\n    isVisible(group) {\n        if (this.#groups.size === 0) {\n            return true;\n        }\n        if (!group) {\n            info(\"Optional content group not defined.\");\n            return true;\n        }\n        if (group.type === \"OCG\") {\n            if (!this.#groups.has(group.id)) {\n                warn(`Optional content group not found: ${group.id}`);\n                return true;\n            }\n            return this.#groups.get(group.id).visible;\n        } else if (group.type === \"OCMD\") {\n            if (group.expression) {\n                return this.#evaluateVisibilityExpression(group.expression);\n            }\n            if (!group.policy || group.policy === \"AnyOn\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (this.#groups.get(id).visible) {\n                        return true;\n                    }\n                }\n                return false;\n            } else if (group.policy === \"AllOn\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (!this.#groups.get(id).visible) {\n                        return false;\n                    }\n                }\n                return true;\n            } else if (group.policy === \"AnyOff\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (!this.#groups.get(id).visible) {\n                        return true;\n                    }\n                }\n                return false;\n            } else if (group.policy === \"AllOff\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (this.#groups.get(id).visible) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            warn(`Unknown optional content policy ${group.policy}.`);\n            return true;\n        }\n        warn(`Unknown group type ${group.type}.`);\n        return true;\n    }\n    setVisibility(id, visible = true, preserveRB = true) {\n        const group = this.#groups.get(id);\n        if (!group) {\n            warn(`Optional content group not found: ${id}`);\n            return;\n        }\n        if (preserveRB && visible && group.rbGroups.length) {\n            for (const rbGroup of group.rbGroups){\n                for (const otherId of rbGroup){\n                    if (otherId !== id) {\n                        this.#groups.get(otherId)?._setVisible(INTERNAL, false, true);\n                    }\n                }\n            }\n        }\n        group._setVisible(INTERNAL, !!visible, true);\n        this.#cachedGetHash = null;\n    }\n    setOCGState({ state, preserveRB }) {\n        let operator;\n        for (const elem of state){\n            switch(elem){\n                case \"ON\":\n                case \"OFF\":\n                case \"Toggle\":\n                    operator = elem;\n                    continue;\n            }\n            const group = this.#groups.get(elem);\n            if (!group) {\n                continue;\n            }\n            switch(operator){\n                case \"ON\":\n                    this.setVisibility(elem, true, preserveRB);\n                    break;\n                case \"OFF\":\n                    this.setVisibility(elem, false, preserveRB);\n                    break;\n                case \"Toggle\":\n                    this.setVisibility(elem, !group.visible, preserveRB);\n                    break;\n            }\n        }\n        this.#cachedGetHash = null;\n    }\n    get hasInitialVisibility() {\n        return this.#initialHash === null || this.getHash() === this.#initialHash;\n    }\n    getOrder() {\n        if (!this.#groups.size) {\n            return null;\n        }\n        if (this.#order) {\n            return this.#order.slice();\n        }\n        return [\n            ...this.#groups.keys()\n        ];\n    }\n    getGroup(id) {\n        return this.#groups.get(id) || null;\n    }\n    getHash() {\n        if (this.#cachedGetHash !== null) {\n            return this.#cachedGetHash;\n        }\n        const hash = new MurmurHash3_64();\n        for (const [id, group] of this.#groups){\n            hash.update(`${id}:${group.visible}`);\n        }\n        return this.#cachedGetHash = hash.hexdigest();\n    }\n    [Symbol.iterator]() {\n        return this.#groups.entries();\n    }\n}\n; // ./src/display/transport_stream.js\nclass PDFDataTransportStream {\n    constructor(pdfDataRangeTransport, { disableRange = false, disableStream = false }){\n        assert(pdfDataRangeTransport, 'PDFDataTransportStream - missing required \"pdfDataRangeTransport\" argument.');\n        const { length, initialData, progressiveDone, contentDispositionFilename } = pdfDataRangeTransport;\n        this._queuedChunks = [];\n        this._progressiveDone = progressiveDone;\n        this._contentDispositionFilename = contentDispositionFilename;\n        if (initialData?.length > 0) {\n            const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;\n            this._queuedChunks.push(buffer);\n        }\n        this._pdfDataRangeTransport = pdfDataRangeTransport;\n        this._isStreamingSupported = !disableStream;\n        this._isRangeSupported = !disableRange;\n        this._contentLength = length;\n        this._fullRequestReader = null;\n        this._rangeReaders = [];\n        pdfDataRangeTransport.addRangeListener((begin, chunk)=>{\n            this._onReceiveData({\n                begin,\n                chunk\n            });\n        });\n        pdfDataRangeTransport.addProgressListener((loaded, total)=>{\n            this._onProgress({\n                loaded,\n                total\n            });\n        });\n        pdfDataRangeTransport.addProgressiveReadListener((chunk)=>{\n            this._onReceiveData({\n                chunk\n            });\n        });\n        pdfDataRangeTransport.addProgressiveDoneListener(()=>{\n            this._onProgressiveDone();\n        });\n        pdfDataRangeTransport.transportReady();\n    }\n    _onReceiveData({ begin, chunk }) {\n        const buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;\n        if (begin === undefined) {\n            if (this._fullRequestReader) {\n                this._fullRequestReader._enqueue(buffer);\n            } else {\n                this._queuedChunks.push(buffer);\n            }\n        } else {\n            const found = this._rangeReaders.some(function(rangeReader) {\n                if (rangeReader._begin !== begin) {\n                    return false;\n                }\n                rangeReader._enqueue(buffer);\n                return true;\n            });\n            assert(found, \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\");\n        }\n    }\n    get _progressiveDataLength() {\n        return this._fullRequestReader?._loaded ?? 0;\n    }\n    _onProgress(evt) {\n        if (evt.total === undefined) {\n            this._rangeReaders[0]?.onProgress?.({\n                loaded: evt.loaded\n            });\n        } else {\n            this._fullRequestReader?.onProgress?.({\n                loaded: evt.loaded,\n                total: evt.total\n            });\n        }\n    }\n    _onProgressiveDone() {\n        this._fullRequestReader?.progressiveDone();\n        this._progressiveDone = true;\n    }\n    _removeRangeReader(reader) {\n        const i = this._rangeReaders.indexOf(reader);\n        if (i >= 0) {\n            this._rangeReaders.splice(i, 1);\n        }\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFDataTransportStream.getFullReader can only be called once.\");\n        const queuedChunks = this._queuedChunks;\n        this._queuedChunks = null;\n        return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);\n    }\n    getRangeReader(begin, end) {\n        if (end <= this._progressiveDataLength) {\n            return null;\n        }\n        const reader = new PDFDataTransportStreamRangeReader(this, begin, end);\n        this._pdfDataRangeTransport.requestDataRange(begin, end);\n        this._rangeReaders.push(reader);\n        return reader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeReaders.slice(0)){\n            reader.cancel(reason);\n        }\n        this._pdfDataRangeTransport.abort();\n    }\n}\nclass PDFDataTransportStreamReader {\n    constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null){\n        this._stream = stream;\n        this._done = progressiveDone || false;\n        this._filename = isPdfFile(contentDispositionFilename) ? contentDispositionFilename : null;\n        this._queuedChunks = queuedChunks || [];\n        this._loaded = 0;\n        for (const chunk of this._queuedChunks){\n            this._loaded += chunk.byteLength;\n        }\n        this._requests = [];\n        this._headersReady = Promise.resolve();\n        stream._fullRequestReader = this;\n        this.onProgress = null;\n    }\n    _enqueue(chunk) {\n        if (this._done) {\n            return;\n        }\n        if (this._requests.length > 0) {\n            const requestCapability = this._requests.shift();\n            requestCapability.resolve({\n                value: chunk,\n                done: false\n            });\n        } else {\n            this._queuedChunks.push(chunk);\n        }\n        this._loaded += chunk.byteLength;\n    }\n    get headersReady() {\n        return this._headersReady;\n    }\n    get filename() {\n        return this._filename;\n    }\n    get isRangeSupported() {\n        return this._stream._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._stream._isStreamingSupported;\n    }\n    get contentLength() {\n        return this._stream._contentLength;\n    }\n    async read() {\n        if (this._queuedChunks.length > 0) {\n            const chunk = this._queuedChunks.shift();\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n    }\n    progressiveDone() {\n        if (this._done) {\n            return;\n        }\n        this._done = true;\n    }\n}\nclass PDFDataTransportStreamRangeReader {\n    constructor(stream, begin, end){\n        this._stream = stream;\n        this._begin = begin;\n        this._end = end;\n        this._queuedChunk = null;\n        this._requests = [];\n        this._done = false;\n        this.onProgress = null;\n    }\n    _enqueue(chunk) {\n        if (this._done) {\n            return;\n        }\n        if (this._requests.length === 0) {\n            this._queuedChunk = chunk;\n        } else {\n            const requestsCapability = this._requests.shift();\n            requestsCapability.resolve({\n                value: chunk,\n                done: false\n            });\n            for (const requestCapability of this._requests){\n                requestCapability.resolve({\n                    value: undefined,\n                    done: true\n                });\n            }\n            this._requests.length = 0;\n        }\n        this._done = true;\n        this._stream._removeRangeReader(this);\n    }\n    get isStreamingSupported() {\n        return false;\n    }\n    async read() {\n        if (this._queuedChunk) {\n            const chunk = this._queuedChunk;\n            this._queuedChunk = null;\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        this._stream._removeRangeReader(this);\n    }\n}\n; // ./src/display/content_disposition.js\nfunction getFilenameFromContentDispositionHeader(contentDisposition) {\n    let needsEncodingFixup = true;\n    let tmp = toParamRegExp(\"filename\\\\*\", \"i\").exec(contentDisposition);\n    if (tmp) {\n        tmp = tmp[1];\n        let filename = rfc2616unquote(tmp);\n        filename = unescape(filename);\n        filename = rfc5987decode(filename);\n        filename = rfc2047decode(filename);\n        return fixupEncoding(filename);\n    }\n    tmp = rfc2231getparam(contentDisposition);\n    if (tmp) {\n        const filename = rfc2047decode(tmp);\n        return fixupEncoding(filename);\n    }\n    tmp = toParamRegExp(\"filename\", \"i\").exec(contentDisposition);\n    if (tmp) {\n        tmp = tmp[1];\n        let filename = rfc2616unquote(tmp);\n        filename = rfc2047decode(filename);\n        return fixupEncoding(filename);\n    }\n    function toParamRegExp(attributePattern, flags) {\n        return new RegExp(\"(?:^|;)\\\\s*\" + attributePattern + \"\\\\s*=\\\\s*\" + \"(\" + '[^\";\\\\s][^;\\\\s]*' + \"|\" + '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' + \")\", flags);\n    }\n    function textdecode(encoding, value) {\n        if (encoding) {\n            if (!/^[\\x00-\\xFF]+$/.test(value)) {\n                return value;\n            }\n            try {\n                const decoder = new TextDecoder(encoding, {\n                    fatal: true\n                });\n                const buffer = stringToBytes(value);\n                value = decoder.decode(buffer);\n                needsEncodingFixup = false;\n            } catch  {}\n        }\n        return value;\n    }\n    function fixupEncoding(value) {\n        if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) {\n            value = textdecode(\"utf-8\", value);\n            if (needsEncodingFixup) {\n                value = textdecode(\"iso-8859-1\", value);\n            }\n        }\n        return value;\n    }\n    function rfc2231getparam(contentDispositionStr) {\n        const matches = [];\n        let match;\n        const iter = toParamRegExp(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\");\n        while((match = iter.exec(contentDispositionStr)) !== null){\n            let [, n, quot, part] = match;\n            n = parseInt(n, 10);\n            if (n in matches) {\n                if (n === 0) {\n                    break;\n                }\n                continue;\n            }\n            matches[n] = [\n                quot,\n                part\n            ];\n        }\n        const parts = [];\n        for(let n = 0; n < matches.length; ++n){\n            if (!(n in matches)) {\n                break;\n            }\n            let [quot, part] = matches[n];\n            part = rfc2616unquote(part);\n            if (quot) {\n                part = unescape(part);\n                if (n === 0) {\n                    part = rfc5987decode(part);\n                }\n            }\n            parts.push(part);\n        }\n        return parts.join(\"\");\n    }\n    function rfc2616unquote(value) {\n        if (value.startsWith('\"')) {\n            const parts = value.slice(1).split('\\\\\"');\n            for(let i = 0; i < parts.length; ++i){\n                const quotindex = parts[i].indexOf('\"');\n                if (quotindex !== -1) {\n                    parts[i] = parts[i].slice(0, quotindex);\n                    parts.length = i + 1;\n                }\n                parts[i] = parts[i].replaceAll(/\\\\(.)/g, \"$1\");\n            }\n            value = parts.join('\"');\n        }\n        return value;\n    }\n    function rfc5987decode(extvalue) {\n        const encodingend = extvalue.indexOf(\"'\");\n        if (encodingend === -1) {\n            return extvalue;\n        }\n        const encoding = extvalue.slice(0, encodingend);\n        const langvalue = extvalue.slice(encodingend + 1);\n        const value = langvalue.replace(/^[^']*'/, \"\");\n        return textdecode(encoding, value);\n    }\n    function rfc2047decode(value) {\n        if (!value.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value)) {\n            return value;\n        }\n        return value.replaceAll(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function(matches, charset, encoding, text) {\n            if (encoding === \"q\" || encoding === \"Q\") {\n                text = text.replaceAll(\"_\", \" \");\n                text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function(match, hex) {\n                    return String.fromCharCode(parseInt(hex, 16));\n                });\n                return textdecode(charset, text);\n            }\n            try {\n                text = atob(text);\n            } catch  {}\n            return textdecode(charset, text);\n        });\n    }\n    return \"\";\n}\n; // ./src/display/network_utils.js\nfunction createHeaders(isHttp, httpHeaders) {\n    const headers = new Headers();\n    if (!isHttp || !httpHeaders || typeof httpHeaders !== \"object\") {\n        return headers;\n    }\n    for(const key in httpHeaders){\n        const val = httpHeaders[key];\n        if (val !== undefined) {\n            headers.append(key, val);\n        }\n    }\n    return headers;\n}\nfunction getResponseOrigin(url) {\n    return URL.parse(url)?.origin ?? null;\n}\nfunction validateRangeRequestCapabilities({ responseHeaders, isHttp, rangeChunkSize, disableRange }) {\n    const returnValues = {\n        allowRangeRequests: false,\n        suggestedLength: undefined\n    };\n    const length = parseInt(responseHeaders.get(\"Content-Length\"), 10);\n    if (!Number.isInteger(length)) {\n        return returnValues;\n    }\n    returnValues.suggestedLength = length;\n    if (length <= 2 * rangeChunkSize) {\n        return returnValues;\n    }\n    if (disableRange || !isHttp) {\n        return returnValues;\n    }\n    if (responseHeaders.get(\"Accept-Ranges\") !== \"bytes\") {\n        return returnValues;\n    }\n    const contentEncoding = responseHeaders.get(\"Content-Encoding\") || \"identity\";\n    if (contentEncoding !== \"identity\") {\n        return returnValues;\n    }\n    returnValues.allowRangeRequests = true;\n    return returnValues;\n}\nfunction extractFilenameFromHeader(responseHeaders) {\n    const contentDisposition = responseHeaders.get(\"Content-Disposition\");\n    if (contentDisposition) {\n        let filename = getFilenameFromContentDispositionHeader(contentDisposition);\n        if (filename.includes(\"%\")) {\n            try {\n                filename = decodeURIComponent(filename);\n            } catch  {}\n        }\n        if (isPdfFile(filename)) {\n            return filename;\n        }\n    }\n    return null;\n}\nfunction createResponseError(status, url) {\n    return new ResponseException(`Unexpected server response (${status}) while retrieving PDF \"${url}\".`, status, status === 404 || status === 0 && url.startsWith(\"file:\"));\n}\nfunction validateResponseStatus(status) {\n    return status === 200 || status === 206;\n}\n; // ./src/display/fetch_stream.js\nfunction createFetchOptions(headers, withCredentials, abortController) {\n    return {\n        method: \"GET\",\n        headers,\n        signal: abortController.signal,\n        mode: \"cors\",\n        credentials: withCredentials ? \"include\" : \"same-origin\",\n        redirect: \"follow\"\n    };\n}\nfunction getArrayBuffer(val) {\n    if (val instanceof Uint8Array) {\n        return val.buffer;\n    }\n    if (val instanceof ArrayBuffer) {\n        return val;\n    }\n    warn(`getArrayBuffer - unexpected data format: ${val}`);\n    return new Uint8Array(val).buffer;\n}\nclass PDFFetchStream {\n    constructor(source){\n        this._responseOrigin = null;\n        this.source = source;\n        this.isHttp = /^https?:/i.test(source.url);\n        this.headers = createHeaders(this.isHttp, source.httpHeaders);\n        this._fullRequestReader = null;\n        this._rangeRequestReaders = [];\n    }\n    get _progressiveDataLength() {\n        return this._fullRequestReader?._loaded ?? 0;\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFFetchStream.getFullReader can only be called once.\");\n        this._fullRequestReader = new PDFFetchStreamReader(this);\n        return this._fullRequestReader;\n    }\n    getRangeReader(begin, end) {\n        if (end <= this._progressiveDataLength) {\n            return null;\n        }\n        const reader = new PDFFetchStreamRangeReader(this, begin, end);\n        this._rangeRequestReaders.push(reader);\n        return reader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeRequestReaders.slice(0)){\n            reader.cancel(reason);\n        }\n    }\n}\nclass PDFFetchStreamReader {\n    constructor(stream){\n        this._stream = stream;\n        this._reader = null;\n        this._loaded = 0;\n        this._filename = null;\n        const source = stream.source;\n        this._withCredentials = source.withCredentials || false;\n        this._contentLength = source.length;\n        this._headersCapability = Promise.withResolvers();\n        this._disableRange = source.disableRange || false;\n        this._rangeChunkSize = source.rangeChunkSize;\n        if (!this._rangeChunkSize && !this._disableRange) {\n            this._disableRange = true;\n        }\n        this._abortController = new AbortController();\n        this._isStreamingSupported = !source.disableStream;\n        this._isRangeSupported = !source.disableRange;\n        const headers = new Headers(stream.headers);\n        const url = source.url;\n        fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then((response)=>{\n            stream._responseOrigin = getResponseOrigin(response.url);\n            if (!validateResponseStatus(response.status)) {\n                throw createResponseError(response.status, url);\n            }\n            this._reader = response.body.getReader();\n            this._headersCapability.resolve();\n            const responseHeaders = response.headers;\n            const { allowRangeRequests, suggestedLength } = validateRangeRequestCapabilities({\n                responseHeaders,\n                isHttp: stream.isHttp,\n                rangeChunkSize: this._rangeChunkSize,\n                disableRange: this._disableRange\n            });\n            this._isRangeSupported = allowRangeRequests;\n            this._contentLength = suggestedLength || this._contentLength;\n            this._filename = extractFilenameFromHeader(responseHeaders);\n            if (!this._isStreamingSupported && this._isRangeSupported) {\n                this.cancel(new AbortException(\"Streaming is disabled.\"));\n            }\n        }).catch(this._headersCapability.reject);\n        this.onProgress = null;\n    }\n    get headersReady() {\n        return this._headersCapability.promise;\n    }\n    get filename() {\n        return this._filename;\n    }\n    get contentLength() {\n        return this._contentLength;\n    }\n    get isRangeSupported() {\n        return this._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._headersCapability.promise;\n        const { value, done } = await this._reader.read();\n        if (done) {\n            return {\n                value,\n                done\n            };\n        }\n        this._loaded += value.byteLength;\n        this.onProgress?.({\n            loaded: this._loaded,\n            total: this._contentLength\n        });\n        return {\n            value: getArrayBuffer(value),\n            done: false\n        };\n    }\n    cancel(reason) {\n        this._reader?.cancel(reason);\n        this._abortController.abort();\n    }\n}\nclass PDFFetchStreamRangeReader {\n    constructor(stream, begin, end){\n        this._stream = stream;\n        this._reader = null;\n        this._loaded = 0;\n        const source = stream.source;\n        this._withCredentials = source.withCredentials || false;\n        this._readCapability = Promise.withResolvers();\n        this._isStreamingSupported = !source.disableStream;\n        this._abortController = new AbortController();\n        const headers = new Headers(stream.headers);\n        headers.append(\"Range\", `bytes=${begin}-${end - 1}`);\n        const url = source.url;\n        fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then((response)=>{\n            const responseOrigin = getResponseOrigin(response.url);\n            if (responseOrigin !== stream._responseOrigin) {\n                throw new Error(`Expected range response-origin \"${responseOrigin}\" to match \"${stream._responseOrigin}\".`);\n            }\n            if (!validateResponseStatus(response.status)) {\n                throw createResponseError(response.status, url);\n            }\n            this._readCapability.resolve();\n            this._reader = response.body.getReader();\n        }).catch(this._readCapability.reject);\n        this.onProgress = null;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._readCapability.promise;\n        const { value, done } = await this._reader.read();\n        if (done) {\n            return {\n                value,\n                done\n            };\n        }\n        this._loaded += value.byteLength;\n        this.onProgress?.({\n            loaded: this._loaded\n        });\n        return {\n            value: getArrayBuffer(value),\n            done: false\n        };\n    }\n    cancel(reason) {\n        this._reader?.cancel(reason);\n        this._abortController.abort();\n    }\n}\n; // ./src/display/network.js\nconst OK_RESPONSE = 200;\nconst PARTIAL_CONTENT_RESPONSE = 206;\nfunction network_getArrayBuffer(xhr) {\n    const data = xhr.response;\n    if (typeof data !== \"string\") {\n        return data;\n    }\n    return stringToBytes(data).buffer;\n}\nclass NetworkManager {\n    constructor({ url, httpHeaders, withCredentials }){\n        this._responseOrigin = null;\n        this.url = url;\n        this.isHttp = /^https?:/i.test(url);\n        this.headers = createHeaders(this.isHttp, httpHeaders);\n        this.withCredentials = withCredentials || false;\n        this.currXhrId = 0;\n        this.pendingRequests = Object.create(null);\n    }\n    request(args) {\n        const xhr = new XMLHttpRequest();\n        const xhrId = this.currXhrId++;\n        const pendingRequest = this.pendingRequests[xhrId] = {\n            xhr\n        };\n        xhr.open(\"GET\", this.url);\n        xhr.withCredentials = this.withCredentials;\n        for (const [key, val] of this.headers){\n            xhr.setRequestHeader(key, val);\n        }\n        if (this.isHttp && \"begin\" in args && \"end\" in args) {\n            xhr.setRequestHeader(\"Range\", `bytes=${args.begin}-${args.end - 1}`);\n            pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\n        } else {\n            pendingRequest.expectedStatus = OK_RESPONSE;\n        }\n        xhr.responseType = \"arraybuffer\";\n        assert(args.onError, \"Expected `onError` callback to be provided.\");\n        xhr.onerror = ()=>{\n            args.onError(xhr.status);\n        };\n        xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\n        xhr.onprogress = this.onProgress.bind(this, xhrId);\n        pendingRequest.onHeadersReceived = args.onHeadersReceived;\n        pendingRequest.onDone = args.onDone;\n        pendingRequest.onError = args.onError;\n        pendingRequest.onProgress = args.onProgress;\n        xhr.send(null);\n        return xhrId;\n    }\n    onProgress(xhrId, evt) {\n        const pendingRequest = this.pendingRequests[xhrId];\n        if (!pendingRequest) {\n            return;\n        }\n        pendingRequest.onProgress?.(evt);\n    }\n    onStateChange(xhrId, evt) {\n        const pendingRequest = this.pendingRequests[xhrId];\n        if (!pendingRequest) {\n            return;\n        }\n        const xhr = pendingRequest.xhr;\n        if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\n            pendingRequest.onHeadersReceived();\n            delete pendingRequest.onHeadersReceived;\n        }\n        if (xhr.readyState !== 4) {\n            return;\n        }\n        if (!(xhrId in this.pendingRequests)) {\n            return;\n        }\n        delete this.pendingRequests[xhrId];\n        if (xhr.status === 0 && this.isHttp) {\n            pendingRequest.onError(xhr.status);\n            return;\n        }\n        const xhrStatus = xhr.status || OK_RESPONSE;\n        const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\n        if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\n            pendingRequest.onError(xhr.status);\n            return;\n        }\n        const chunk = network_getArrayBuffer(xhr);\n        if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\n            const rangeHeader = xhr.getResponseHeader(\"Content-Range\");\n            const matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\n            if (matches) {\n                pendingRequest.onDone({\n                    begin: parseInt(matches[1], 10),\n                    chunk\n                });\n            } else {\n                warn(`Missing or invalid \"Content-Range\" header.`);\n                pendingRequest.onError(0);\n            }\n        } else if (chunk) {\n            pendingRequest.onDone({\n                begin: 0,\n                chunk\n            });\n        } else {\n            pendingRequest.onError(xhr.status);\n        }\n    }\n    getRequestXhr(xhrId) {\n        return this.pendingRequests[xhrId].xhr;\n    }\n    isPendingRequest(xhrId) {\n        return xhrId in this.pendingRequests;\n    }\n    abortRequest(xhrId) {\n        const xhr = this.pendingRequests[xhrId].xhr;\n        delete this.pendingRequests[xhrId];\n        xhr.abort();\n    }\n}\nclass PDFNetworkStream {\n    constructor(source){\n        this._source = source;\n        this._manager = new NetworkManager(source);\n        this._rangeChunkSize = source.rangeChunkSize;\n        this._fullRequestReader = null;\n        this._rangeRequestReaders = [];\n    }\n    _onRangeRequestReaderClosed(reader) {\n        const i = this._rangeRequestReaders.indexOf(reader);\n        if (i >= 0) {\n            this._rangeRequestReaders.splice(i, 1);\n        }\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\");\n        this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\n        return this._fullRequestReader;\n    }\n    getRangeReader(begin, end) {\n        const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\n        reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\n        this._rangeRequestReaders.push(reader);\n        return reader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeRequestReaders.slice(0)){\n            reader.cancel(reason);\n        }\n    }\n}\nclass PDFNetworkStreamFullRequestReader {\n    constructor(manager, source){\n        this._manager = manager;\n        this._url = source.url;\n        this._fullRequestId = manager.request({\n            onHeadersReceived: this._onHeadersReceived.bind(this),\n            onDone: this._onDone.bind(this),\n            onError: this._onError.bind(this),\n            onProgress: this._onProgress.bind(this)\n        });\n        this._headersCapability = Promise.withResolvers();\n        this._disableRange = source.disableRange || false;\n        this._contentLength = source.length;\n        this._rangeChunkSize = source.rangeChunkSize;\n        if (!this._rangeChunkSize && !this._disableRange) {\n            this._disableRange = true;\n        }\n        this._isStreamingSupported = false;\n        this._isRangeSupported = false;\n        this._cachedChunks = [];\n        this._requests = [];\n        this._done = false;\n        this._storedError = undefined;\n        this._filename = null;\n        this.onProgress = null;\n    }\n    _onHeadersReceived() {\n        const fullRequestXhrId = this._fullRequestId;\n        const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\n        this._manager._responseOrigin = getResponseOrigin(fullRequestXhr.responseURL);\n        const rawResponseHeaders = fullRequestXhr.getAllResponseHeaders();\n        const responseHeaders = new Headers(rawResponseHeaders ? rawResponseHeaders.trimStart().replace(/[^\\S ]+$/, \"\").split(/[\\r\\n]+/).map((x)=>{\n            const [key, ...val] = x.split(\": \");\n            return [\n                key,\n                val.join(\": \")\n            ];\n        }) : []);\n        const { allowRangeRequests, suggestedLength } = validateRangeRequestCapabilities({\n            responseHeaders,\n            isHttp: this._manager.isHttp,\n            rangeChunkSize: this._rangeChunkSize,\n            disableRange: this._disableRange\n        });\n        if (allowRangeRequests) {\n            this._isRangeSupported = true;\n        }\n        this._contentLength = suggestedLength || this._contentLength;\n        this._filename = extractFilenameFromHeader(responseHeaders);\n        if (this._isRangeSupported) {\n            this._manager.abortRequest(fullRequestXhrId);\n        }\n        this._headersCapability.resolve();\n    }\n    _onDone(data) {\n        if (data) {\n            if (this._requests.length > 0) {\n                const requestCapability = this._requests.shift();\n                requestCapability.resolve({\n                    value: data.chunk,\n                    done: false\n                });\n            } else {\n                this._cachedChunks.push(data.chunk);\n            }\n        }\n        this._done = true;\n        if (this._cachedChunks.length > 0) {\n            return;\n        }\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n    }\n    _onError(status) {\n        this._storedError = createResponseError(status, this._url);\n        this._headersCapability.reject(this._storedError);\n        for (const requestCapability of this._requests){\n            requestCapability.reject(this._storedError);\n        }\n        this._requests.length = 0;\n        this._cachedChunks.length = 0;\n    }\n    _onProgress(evt) {\n        this.onProgress?.({\n            loaded: evt.loaded,\n            total: evt.lengthComputable ? evt.total : this._contentLength\n        });\n    }\n    get filename() {\n        return this._filename;\n    }\n    get isRangeSupported() {\n        return this._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    get contentLength() {\n        return this._contentLength;\n    }\n    get headersReady() {\n        return this._headersCapability.promise;\n    }\n    async read() {\n        await this._headersCapability.promise;\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        if (this._cachedChunks.length > 0) {\n            const chunk = this._cachedChunks.shift();\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        this._headersCapability.reject(reason);\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        if (this._manager.isPendingRequest(this._fullRequestId)) {\n            this._manager.abortRequest(this._fullRequestId);\n        }\n        this._fullRequestReader = null;\n    }\n}\nclass PDFNetworkStreamRangeRequestReader {\n    constructor(manager, begin, end){\n        this._manager = manager;\n        this._url = manager.url;\n        this._requestId = manager.request({\n            begin,\n            end,\n            onHeadersReceived: this._onHeadersReceived.bind(this),\n            onDone: this._onDone.bind(this),\n            onError: this._onError.bind(this),\n            onProgress: this._onProgress.bind(this)\n        });\n        this._requests = [];\n        this._queuedChunk = null;\n        this._done = false;\n        this._storedError = undefined;\n        this.onProgress = null;\n        this.onClosed = null;\n    }\n    _onHeadersReceived() {\n        const responseOrigin = getResponseOrigin(this._manager.getRequestXhr(this._requestId)?.responseURL);\n        if (responseOrigin !== this._manager._responseOrigin) {\n            this._storedError = new Error(`Expected range response-origin \"${responseOrigin}\" to match \"${this._manager._responseOrigin}\".`);\n            this._onError(0);\n        }\n    }\n    _close() {\n        this.onClosed?.(this);\n    }\n    _onDone(data) {\n        const chunk = data.chunk;\n        if (this._requests.length > 0) {\n            const requestCapability = this._requests.shift();\n            requestCapability.resolve({\n                value: chunk,\n                done: false\n            });\n        } else {\n            this._queuedChunk = chunk;\n        }\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        this._close();\n    }\n    _onError(status) {\n        this._storedError ??= createResponseError(status, this._url);\n        for (const requestCapability of this._requests){\n            requestCapability.reject(this._storedError);\n        }\n        this._requests.length = 0;\n        this._queuedChunk = null;\n    }\n    _onProgress(evt) {\n        if (!this.isStreamingSupported) {\n            this.onProgress?.({\n                loaded: evt.loaded\n            });\n        }\n    }\n    get isStreamingSupported() {\n        return false;\n    }\n    async read() {\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        if (this._queuedChunk !== null) {\n            const chunk = this._queuedChunk;\n            this._queuedChunk = null;\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        if (this._manager.isPendingRequest(this._requestId)) {\n            this._manager.abortRequest(this._requestId);\n        }\n        this._close();\n    }\n}\n; // ./src/display/node_stream.js\nconst urlRegex = /^[a-z][a-z0-9\\-+.]+:/i;\nfunction parseUrlOrPath(sourceUrl) {\n    if (urlRegex.test(sourceUrl)) {\n        return new URL(sourceUrl);\n    }\n    const url = process.getBuiltinModule(\"url\");\n    return new URL(url.pathToFileURL(sourceUrl));\n}\nclass PDFNodeStream {\n    constructor(source){\n        this.source = source;\n        this.url = parseUrlOrPath(source.url);\n        assert(this.url.protocol === \"file:\", \"PDFNodeStream only supports file:// URLs.\");\n        this._fullRequestReader = null;\n        this._rangeRequestReaders = [];\n    }\n    get _progressiveDataLength() {\n        return this._fullRequestReader?._loaded ?? 0;\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFNodeStream.getFullReader can only be called once.\");\n        this._fullRequestReader = new PDFNodeStreamFsFullReader(this);\n        return this._fullRequestReader;\n    }\n    getRangeReader(start, end) {\n        if (end <= this._progressiveDataLength) {\n            return null;\n        }\n        const rangeReader = new PDFNodeStreamFsRangeReader(this, start, end);\n        this._rangeRequestReaders.push(rangeReader);\n        return rangeReader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeRequestReaders.slice(0)){\n            reader.cancel(reason);\n        }\n    }\n}\nclass PDFNodeStreamFsFullReader {\n    constructor(stream){\n        this._url = stream.url;\n        this._done = false;\n        this._storedError = null;\n        this.onProgress = null;\n        const source = stream.source;\n        this._contentLength = source.length;\n        this._loaded = 0;\n        this._filename = null;\n        this._disableRange = source.disableRange || false;\n        this._rangeChunkSize = source.rangeChunkSize;\n        if (!this._rangeChunkSize && !this._disableRange) {\n            this._disableRange = true;\n        }\n        this._isStreamingSupported = !source.disableStream;\n        this._isRangeSupported = !source.disableRange;\n        this._readableStream = null;\n        this._readCapability = Promise.withResolvers();\n        this._headersCapability = Promise.withResolvers();\n        const fs = process.getBuiltinModule(\"fs\");\n        fs.promises.lstat(this._url).then((stat)=>{\n            this._contentLength = stat.size;\n            this._setReadableStream(fs.createReadStream(this._url));\n            this._headersCapability.resolve();\n        }, (error)=>{\n            if (error.code === \"ENOENT\") {\n                error = createResponseError(0, this._url.href);\n            }\n            this._storedError = error;\n            this._headersCapability.reject(error);\n        });\n    }\n    get headersReady() {\n        return this._headersCapability.promise;\n    }\n    get filename() {\n        return this._filename;\n    }\n    get contentLength() {\n        return this._contentLength;\n    }\n    get isRangeSupported() {\n        return this._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._readCapability.promise;\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        const chunk = this._readableStream.read();\n        if (chunk === null) {\n            this._readCapability = Promise.withResolvers();\n            return this.read();\n        }\n        this._loaded += chunk.length;\n        this.onProgress?.({\n            loaded: this._loaded,\n            total: this._contentLength\n        });\n        const buffer = new Uint8Array(chunk).buffer;\n        return {\n            value: buffer,\n            done: false\n        };\n    }\n    cancel(reason) {\n        if (!this._readableStream) {\n            this._error(reason);\n            return;\n        }\n        this._readableStream.destroy(reason);\n    }\n    _error(reason) {\n        this._storedError = reason;\n        this._readCapability.resolve();\n    }\n    _setReadableStream(readableStream) {\n        this._readableStream = readableStream;\n        readableStream.on(\"readable\", ()=>{\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"end\", ()=>{\n            readableStream.destroy();\n            this._done = true;\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"error\", (reason)=>{\n            this._error(reason);\n        });\n        if (!this._isStreamingSupported && this._isRangeSupported) {\n            this._error(new AbortException(\"streaming is disabled\"));\n        }\n        if (this._storedError) {\n            this._readableStream.destroy(this._storedError);\n        }\n    }\n}\nclass PDFNodeStreamFsRangeReader {\n    constructor(stream, start, end){\n        this._url = stream.url;\n        this._done = false;\n        this._storedError = null;\n        this.onProgress = null;\n        this._loaded = 0;\n        this._readableStream = null;\n        this._readCapability = Promise.withResolvers();\n        const source = stream.source;\n        this._isStreamingSupported = !source.disableStream;\n        const fs = process.getBuiltinModule(\"fs\");\n        this._setReadableStream(fs.createReadStream(this._url, {\n            start,\n            end: end - 1\n        }));\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._readCapability.promise;\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        const chunk = this._readableStream.read();\n        if (chunk === null) {\n            this._readCapability = Promise.withResolvers();\n            return this.read();\n        }\n        this._loaded += chunk.length;\n        this.onProgress?.({\n            loaded: this._loaded\n        });\n        const buffer = new Uint8Array(chunk).buffer;\n        return {\n            value: buffer,\n            done: false\n        };\n    }\n    cancel(reason) {\n        if (!this._readableStream) {\n            this._error(reason);\n            return;\n        }\n        this._readableStream.destroy(reason);\n    }\n    _error(reason) {\n        this._storedError = reason;\n        this._readCapability.resolve();\n    }\n    _setReadableStream(readableStream) {\n        this._readableStream = readableStream;\n        readableStream.on(\"readable\", ()=>{\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"end\", ()=>{\n            readableStream.destroy();\n            this._done = true;\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"error\", (reason)=>{\n            this._error(reason);\n        });\n        if (this._storedError) {\n            this._readableStream.destroy(this._storedError);\n        }\n    }\n}\n; // ./src/display/text_layer.js\nconst MAX_TEXT_DIVS_TO_RENDER = 100000;\nconst DEFAULT_FONT_SIZE = 30;\nclass TextLayer {\n    #capability;\n    #container;\n    #disableProcessItems;\n    #fontInspectorEnabled;\n    #lang;\n    #layoutTextParams;\n    #pageHeight;\n    #pageWidth;\n    #reader;\n    #rootContainer;\n    #rotation;\n    #scale;\n    #styleCache;\n    #textContentItemsStr;\n    #textContentSource;\n    #textDivs;\n    #textDivProperties;\n    #transform;\n    static #ascentCache = new Map();\n    static #canvasContexts = new Map();\n    static #canvasCtxFonts = new WeakMap();\n    static #minFontSize = null;\n    static #pendingTextLayers = new Set();\n    constructor({ textContentSource, container, viewport }){\n        this.#capability = Promise.withResolvers();\n        this.#container = null;\n        this.#disableProcessItems = false;\n        this.#fontInspectorEnabled = !!globalThis.FontInspector?.enabled;\n        this.#lang = null;\n        this.#layoutTextParams = null;\n        this.#pageHeight = 0;\n        this.#pageWidth = 0;\n        this.#reader = null;\n        this.#rootContainer = null;\n        this.#rotation = 0;\n        this.#scale = 0;\n        this.#styleCache = Object.create(null);\n        this.#textContentItemsStr = [];\n        this.#textContentSource = null;\n        this.#textDivs = [];\n        this.#textDivProperties = new WeakMap();\n        this.#transform = null;\n        if (textContentSource instanceof ReadableStream) {\n            this.#textContentSource = textContentSource;\n        } else if (typeof textContentSource === \"object\") {\n            this.#textContentSource = new ReadableStream({\n                start (controller) {\n                    controller.enqueue(textContentSource);\n                    controller.close();\n                }\n            });\n        } else {\n            throw new Error('No \"textContentSource\" parameter specified.');\n        }\n        this.#container = this.#rootContainer = container;\n        this.#scale = viewport.scale * OutputScale.pixelRatio;\n        this.#rotation = viewport.rotation;\n        this.#layoutTextParams = {\n            div: null,\n            properties: null,\n            ctx: null\n        };\n        const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims;\n        this.#transform = [\n            1,\n            0,\n            0,\n            -1,\n            -pageX,\n            pageY + pageHeight\n        ];\n        this.#pageWidth = pageWidth;\n        this.#pageHeight = pageHeight;\n        TextLayer.#ensureMinFontSizeComputed();\n        setLayerDimensions(container, viewport);\n        this.#capability.promise.finally(()=>{\n            TextLayer.#pendingTextLayers.delete(this);\n            this.#layoutTextParams = null;\n            this.#styleCache = null;\n        }).catch(()=>{});\n    }\n    static get fontFamilyMap() {\n        const { isWindows, isFirefox } = util_FeatureTest.platform;\n        return shadow(this, \"fontFamilyMap\", new Map([\n            [\n                \"sans-serif\",\n                `${isWindows && isFirefox ? \"Calibri, \" : \"\"}sans-serif`\n            ],\n            [\n                \"monospace\",\n                `${isWindows && isFirefox ? \"Lucida Console, \" : \"\"}monospace`\n            ]\n        ]));\n    }\n    render() {\n        const pump = ()=>{\n            this.#reader.read().then(({ value, done })=>{\n                if (done) {\n                    this.#capability.resolve();\n                    return;\n                }\n                this.#lang ??= value.lang;\n                Object.assign(this.#styleCache, value.styles);\n                this.#processItems(value.items);\n                pump();\n            }, this.#capability.reject);\n        };\n        this.#reader = this.#textContentSource.getReader();\n        TextLayer.#pendingTextLayers.add(this);\n        pump();\n        return this.#capability.promise;\n    }\n    update({ viewport, onBefore = null }) {\n        const scale = viewport.scale * OutputScale.pixelRatio;\n        const rotation = viewport.rotation;\n        if (rotation !== this.#rotation) {\n            onBefore?.();\n            this.#rotation = rotation;\n            setLayerDimensions(this.#rootContainer, {\n                rotation\n            });\n        }\n        if (scale !== this.#scale) {\n            onBefore?.();\n            this.#scale = scale;\n            const params = {\n                div: null,\n                properties: null,\n                ctx: TextLayer.#getCtx(this.#lang)\n            };\n            for (const div of this.#textDivs){\n                params.properties = this.#textDivProperties.get(div);\n                params.div = div;\n                this.#layout(params);\n            }\n        }\n    }\n    cancel() {\n        const abortEx = new AbortException(\"TextLayer task cancelled.\");\n        this.#reader?.cancel(abortEx).catch(()=>{});\n        this.#reader = null;\n        this.#capability.reject(abortEx);\n    }\n    get textDivs() {\n        return this.#textDivs;\n    }\n    get textContentItemsStr() {\n        return this.#textContentItemsStr;\n    }\n    #processItems(items) {\n        if (this.#disableProcessItems) {\n            return;\n        }\n        this.#layoutTextParams.ctx ??= TextLayer.#getCtx(this.#lang);\n        const textDivs = this.#textDivs, textContentItemsStr = this.#textContentItemsStr;\n        for (const item of items){\n            if (textDivs.length > MAX_TEXT_DIVS_TO_RENDER) {\n                warn(\"Ignoring additional textDivs for performance reasons.\");\n                this.#disableProcessItems = true;\n                return;\n            }\n            if (item.str === undefined) {\n                if (item.type === \"beginMarkedContentProps\" || item.type === \"beginMarkedContent\") {\n                    const parent = this.#container;\n                    this.#container = document.createElement(\"span\");\n                    this.#container.classList.add(\"markedContent\");\n                    if (item.id !== null) {\n                        this.#container.setAttribute(\"id\", `${item.id}`);\n                    }\n                    parent.append(this.#container);\n                } else if (item.type === \"endMarkedContent\") {\n                    this.#container = this.#container.parentNode;\n                }\n                continue;\n            }\n            textContentItemsStr.push(item.str);\n            this.#appendText(item);\n        }\n    }\n    #appendText(geom) {\n        const textDiv = document.createElement(\"span\");\n        const textDivProperties = {\n            angle: 0,\n            canvasWidth: 0,\n            hasText: geom.str !== \"\",\n            hasEOL: geom.hasEOL,\n            fontSize: 0\n        };\n        this.#textDivs.push(textDiv);\n        const tx = Util.transform(this.#transform, geom.transform);\n        let angle = Math.atan2(tx[1], tx[0]);\n        const style = this.#styleCache[geom.fontName];\n        if (style.vertical) {\n            angle += Math.PI / 2;\n        }\n        let fontFamily = this.#fontInspectorEnabled && style.fontSubstitution || style.fontFamily;\n        fontFamily = TextLayer.fontFamilyMap.get(fontFamily) || fontFamily;\n        const fontHeight = Math.hypot(tx[2], tx[3]);\n        const fontAscent = fontHeight * TextLayer.#getAscent(fontFamily, style, this.#lang);\n        let left, top;\n        if (angle === 0) {\n            left = tx[4];\n            top = tx[5] - fontAscent;\n        } else {\n            left = tx[4] + fontAscent * Math.sin(angle);\n            top = tx[5] - fontAscent * Math.cos(angle);\n        }\n        const scaleFactorStr = \"calc(var(--total-scale-factor) *\";\n        const divStyle = textDiv.style;\n        if (this.#container === this.#rootContainer) {\n            divStyle.left = `${(100 * left / this.#pageWidth).toFixed(2)}%`;\n            divStyle.top = `${(100 * top / this.#pageHeight).toFixed(2)}%`;\n        } else {\n            divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;\n            divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;\n        }\n        divStyle.fontSize = `${scaleFactorStr}${(TextLayer.#minFontSize * fontHeight).toFixed(2)}px)`;\n        divStyle.fontFamily = fontFamily;\n        textDivProperties.fontSize = fontHeight;\n        textDiv.setAttribute(\"role\", \"presentation\");\n        textDiv.textContent = geom.str;\n        textDiv.dir = geom.dir;\n        if (this.#fontInspectorEnabled) {\n            textDiv.dataset.fontName = style.fontSubstitutionLoadedName || geom.fontName;\n        }\n        if (angle !== 0) {\n            textDivProperties.angle = angle * (180 / Math.PI);\n        }\n        let shouldScaleText = false;\n        if (geom.str.length > 1) {\n            shouldScaleText = true;\n        } else if (geom.str !== \" \" && geom.transform[0] !== geom.transform[3]) {\n            const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]);\n            if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {\n                shouldScaleText = true;\n            }\n        }\n        if (shouldScaleText) {\n            textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;\n        }\n        this.#textDivProperties.set(textDiv, textDivProperties);\n        this.#layoutTextParams.div = textDiv;\n        this.#layoutTextParams.properties = textDivProperties;\n        this.#layout(this.#layoutTextParams);\n        if (textDivProperties.hasText) {\n            this.#container.append(textDiv);\n        }\n        if (textDivProperties.hasEOL) {\n            const br = document.createElement(\"br\");\n            br.setAttribute(\"role\", \"presentation\");\n            this.#container.append(br);\n        }\n    }\n    #layout(params) {\n        const { div, properties, ctx } = params;\n        const { style } = div;\n        let transform = \"\";\n        if (TextLayer.#minFontSize > 1) {\n            transform = `scale(${1 / TextLayer.#minFontSize})`;\n        }\n        if (properties.canvasWidth !== 0 && properties.hasText) {\n            const { fontFamily } = style;\n            const { canvasWidth, fontSize } = properties;\n            TextLayer.#ensureCtxFont(ctx, fontSize * this.#scale, fontFamily);\n            const { width } = ctx.measureText(div.textContent);\n            if (width > 0) {\n                transform = `scaleX(${canvasWidth * this.#scale / width}) ${transform}`;\n            }\n        }\n        if (properties.angle !== 0) {\n            transform = `rotate(${properties.angle}deg) ${transform}`;\n        }\n        if (transform.length > 0) {\n            style.transform = transform;\n        }\n    }\n    static cleanup() {\n        if (this.#pendingTextLayers.size > 0) {\n            return;\n        }\n        this.#ascentCache.clear();\n        for (const { canvas } of this.#canvasContexts.values()){\n            canvas.remove();\n        }\n        this.#canvasContexts.clear();\n    }\n    static #getCtx(lang = null) {\n        let ctx = this.#canvasContexts.get(lang ||= \"\");\n        if (!ctx) {\n            const canvas = document.createElement(\"canvas\");\n            canvas.className = \"hiddenCanvasElement\";\n            canvas.lang = lang;\n            document.body.append(canvas);\n            ctx = canvas.getContext(\"2d\", {\n                alpha: false,\n                willReadFrequently: true\n            });\n            this.#canvasContexts.set(lang, ctx);\n            this.#canvasCtxFonts.set(ctx, {\n                size: 0,\n                family: \"\"\n            });\n        }\n        return ctx;\n    }\n    static #ensureCtxFont(ctx, size, family) {\n        const cached = this.#canvasCtxFonts.get(ctx);\n        if (size === cached.size && family === cached.family) {\n            return;\n        }\n        ctx.font = `${size}px ${family}`;\n        cached.size = size;\n        cached.family = family;\n    }\n    static #ensureMinFontSizeComputed() {\n        if (this.#minFontSize !== null) {\n            return;\n        }\n        const div = document.createElement(\"div\");\n        div.style.opacity = 0;\n        div.style.lineHeight = 1;\n        div.style.fontSize = \"1px\";\n        div.style.position = \"absolute\";\n        div.textContent = \"X\";\n        document.body.append(div);\n        this.#minFontSize = div.getBoundingClientRect().height;\n        div.remove();\n    }\n    static #getAscent(fontFamily, style, lang) {\n        const cachedAscent = this.#ascentCache.get(fontFamily);\n        if (cachedAscent) {\n            return cachedAscent;\n        }\n        const ctx = this.#getCtx(lang);\n        ctx.canvas.width = ctx.canvas.height = DEFAULT_FONT_SIZE;\n        this.#ensureCtxFont(ctx, DEFAULT_FONT_SIZE, fontFamily);\n        const metrics = ctx.measureText(\"\");\n        const ascent = metrics.fontBoundingBoxAscent;\n        const descent = Math.abs(metrics.fontBoundingBoxDescent);\n        ctx.canvas.width = ctx.canvas.height = 0;\n        let ratio = 0.8;\n        if (ascent) {\n            ratio = ascent / (ascent + descent);\n        } else {\n            if (util_FeatureTest.platform.isFirefox) {\n                warn(\"Enable the `dom.textMetrics.fontBoundingBox.enabled` preference \" + \"in `about:config` to improve TextLayer rendering.\");\n            }\n            if (style.ascent) {\n                ratio = style.ascent;\n            } else if (style.descent) {\n                ratio = 1 + style.descent;\n            }\n        }\n        this.#ascentCache.set(fontFamily, ratio);\n        return ratio;\n    }\n}\n; // ./src/display/xfa_text.js\nclass XfaText {\n    static textContent(xfa) {\n        const items = [];\n        const output = {\n            items,\n            styles: Object.create(null)\n        };\n        function walk(node) {\n            if (!node) {\n                return;\n            }\n            let str = null;\n            const name = node.name;\n            if (name === \"#text\") {\n                str = node.value;\n            } else if (!XfaText.shouldBuildText(name)) {\n                return;\n            } else if (node?.attributes?.textContent) {\n                str = node.attributes.textContent;\n            } else if (node.value) {\n                str = node.value;\n            }\n            if (str !== null) {\n                items.push({\n                    str\n                });\n            }\n            if (!node.children) {\n                return;\n            }\n            for (const child of node.children){\n                walk(child);\n            }\n        }\n        walk(xfa);\n        return output;\n    }\n    static shouldBuildText(name) {\n        return !(name === \"textarea\" || name === \"input\" || name === \"option\" || name === \"select\");\n    }\n}\n; // ./src/display/api.js\nconst DEFAULT_RANGE_CHUNK_SIZE = 65536;\nconst RENDERING_CANCELLED_TIMEOUT = 100;\nfunction getDocument(src = {}) {\n    if (typeof src === \"string\" || src instanceof URL) {\n        src = {\n            url: src\n        };\n    } else if (src instanceof ArrayBuffer || ArrayBuffer.isView(src)) {\n        src = {\n            data: src\n        };\n    }\n    const task = new PDFDocumentLoadingTask();\n    const { docId } = task;\n    const url = src.url ? getUrlProp(src.url) : null;\n    const data = src.data ? getDataProp(src.data) : null;\n    const httpHeaders = src.httpHeaders || null;\n    const withCredentials = src.withCredentials === true;\n    const password = src.password ?? null;\n    const rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;\n    const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;\n    let worker = src.worker instanceof PDFWorker ? src.worker : null;\n    const verbosity = src.verbosity;\n    const docBaseUrl = typeof src.docBaseUrl === \"string\" && !isDataScheme(src.docBaseUrl) ? src.docBaseUrl : null;\n    const cMapUrl = getFactoryUrlProp(src.cMapUrl);\n    const cMapPacked = src.cMapPacked !== false;\n    const CMapReaderFactory = src.CMapReaderFactory || (isNodeJS ? NodeCMapReaderFactory : DOMCMapReaderFactory);\n    const iccUrl = getFactoryUrlProp(src.iccUrl);\n    const standardFontDataUrl = getFactoryUrlProp(src.standardFontDataUrl);\n    const StandardFontDataFactory = src.StandardFontDataFactory || (isNodeJS ? NodeStandardFontDataFactory : DOMStandardFontDataFactory);\n    const wasmUrl = getFactoryUrlProp(src.wasmUrl);\n    const WasmFactory = src.WasmFactory || (isNodeJS ? NodeWasmFactory : DOMWasmFactory);\n    const ignoreErrors = src.stopAtErrors !== true;\n    const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;\n    const isEvalSupported = src.isEvalSupported !== false;\n    const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === \"boolean\" ? src.isOffscreenCanvasSupported : !isNodeJS;\n    const isImageDecoderSupported = typeof src.isImageDecoderSupported === \"boolean\" ? src.isImageDecoderSupported : !isNodeJS && (util_FeatureTest.platform.isFirefox || !globalThis.chrome);\n    const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;\n    const disableFontFace = typeof src.disableFontFace === \"boolean\" ? src.disableFontFace : isNodeJS;\n    const fontExtraProperties = src.fontExtraProperties === true;\n    const enableXfa = src.enableXfa === true;\n    const ownerDocument = src.ownerDocument || globalThis.document;\n    const disableRange = src.disableRange === true;\n    const disableStream = src.disableStream === true;\n    const disableAutoFetch = src.disableAutoFetch === true;\n    const pdfBug = src.pdfBug === true;\n    const CanvasFactory = src.CanvasFactory || (isNodeJS ? NodeCanvasFactory : DOMCanvasFactory);\n    const FilterFactory = src.FilterFactory || (isNodeJS ? NodeFilterFactory : DOMFilterFactory);\n    const enableHWA = src.enableHWA === true;\n    const useWasm = src.useWasm !== false;\n    const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;\n    const useSystemFonts = typeof src.useSystemFonts === \"boolean\" ? src.useSystemFonts : !isNodeJS && !disableFontFace;\n    const useWorkerFetch = typeof src.useWorkerFetch === \"boolean\" ? src.useWorkerFetch : !!(CMapReaderFactory === DOMCMapReaderFactory && StandardFontDataFactory === DOMStandardFontDataFactory && WasmFactory === DOMWasmFactory && cMapUrl && standardFontDataUrl && wasmUrl && isValidFetchUrl(cMapUrl, document.baseURI) && isValidFetchUrl(standardFontDataUrl, document.baseURI) && isValidFetchUrl(wasmUrl, document.baseURI));\n    const styleElement = null;\n    setVerbosityLevel(verbosity);\n    const transportFactory = {\n        canvasFactory: new CanvasFactory({\n            ownerDocument,\n            enableHWA\n        }),\n        filterFactory: new FilterFactory({\n            docId,\n            ownerDocument\n        }),\n        cMapReaderFactory: useWorkerFetch ? null : new CMapReaderFactory({\n            baseUrl: cMapUrl,\n            isCompressed: cMapPacked\n        }),\n        standardFontDataFactory: useWorkerFetch ? null : new StandardFontDataFactory({\n            baseUrl: standardFontDataUrl\n        }),\n        wasmFactory: useWorkerFetch ? null : new WasmFactory({\n            baseUrl: wasmUrl\n        })\n    };\n    if (!worker) {\n        const workerParams = {\n            verbosity,\n            port: GlobalWorkerOptions.workerPort\n        };\n        worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);\n        task._worker = worker;\n    }\n    const docParams = {\n        docId,\n        apiVersion: \"5.2.133\",\n        data,\n        password,\n        disableAutoFetch,\n        rangeChunkSize,\n        length,\n        docBaseUrl,\n        enableXfa,\n        evaluatorOptions: {\n            maxImageSize,\n            disableFontFace,\n            ignoreErrors,\n            isEvalSupported,\n            isOffscreenCanvasSupported,\n            isImageDecoderSupported,\n            canvasMaxAreaInBytes,\n            fontExtraProperties,\n            useSystemFonts,\n            useWasm,\n            useWorkerFetch,\n            cMapUrl,\n            iccUrl,\n            standardFontDataUrl,\n            wasmUrl\n        }\n    };\n    const transportParams = {\n        ownerDocument,\n        pdfBug,\n        styleElement,\n        loadingParams: {\n            disableAutoFetch,\n            enableXfa\n        }\n    };\n    worker.promise.then(function() {\n        if (task.destroyed) {\n            throw new Error(\"Loading aborted\");\n        }\n        if (worker.destroyed) {\n            throw new Error(\"Worker was destroyed\");\n        }\n        const workerIdPromise = worker.messageHandler.sendWithPromise(\"GetDocRequest\", docParams, data ? [\n            data.buffer\n        ] : null);\n        let networkStream;\n        if (rangeTransport) {\n            networkStream = new PDFDataTransportStream(rangeTransport, {\n                disableRange,\n                disableStream\n            });\n        } else if (!data) {\n            if (!url) {\n                throw new Error(\"getDocument - no `url` parameter provided.\");\n            }\n            let NetworkStream;\n            if (isNodeJS) {\n                if (isValidFetchUrl(url)) {\n                    if (typeof fetch === \"undefined\" || typeof Response === \"undefined\" || !(\"body\" in Response.prototype)) {\n                        throw new Error(\"getDocument - the Fetch API was disabled in Node.js, see `--no-experimental-fetch`.\");\n                    }\n                    NetworkStream = PDFFetchStream;\n                } else {\n                    NetworkStream = PDFNodeStream;\n                }\n            } else {\n                NetworkStream = isValidFetchUrl(url) ? PDFFetchStream : PDFNetworkStream;\n            }\n            networkStream = new NetworkStream({\n                url,\n                length,\n                httpHeaders,\n                withCredentials,\n                rangeChunkSize,\n                disableRange,\n                disableStream\n            });\n        }\n        return workerIdPromise.then((workerId)=>{\n            if (task.destroyed) {\n                throw new Error(\"Loading aborted\");\n            }\n            if (worker.destroyed) {\n                throw new Error(\"Worker was destroyed\");\n            }\n            const messageHandler = new MessageHandler(docId, workerId, worker.port);\n            const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory);\n            task._transport = transport;\n            messageHandler.send(\"Ready\", null);\n        });\n    }).catch(task._capability.reject);\n    return task;\n}\nfunction getUrlProp(val) {\n    if (val instanceof URL) {\n        return val.href;\n    }\n    if (typeof val === \"string\") {\n        if (isNodeJS) {\n            return val;\n        }\n        const url = URL.parse(val, window.location);\n        if (url) {\n            return url.href;\n        }\n    }\n    throw new Error(\"Invalid PDF url data: \" + \"either string or URL-object is expected in the url property.\");\n}\nfunction getDataProp(val) {\n    if (isNodeJS && typeof Buffer !== \"undefined\" && val instanceof Buffer) {\n        throw new Error(\"Please provide binary data as `Uint8Array`, rather than `Buffer`.\");\n    }\n    if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {\n        return val;\n    }\n    if (typeof val === \"string\") {\n        return stringToBytes(val);\n    }\n    if (val instanceof ArrayBuffer || ArrayBuffer.isView(val) || typeof val === \"object\" && !isNaN(val?.length)) {\n        return new Uint8Array(val);\n    }\n    throw new Error(\"Invalid PDF binary data: either TypedArray, \" + \"string, or array-like object is expected in the data property.\");\n}\nfunction getFactoryUrlProp(val) {\n    if (typeof val !== \"string\") {\n        return null;\n    }\n    if (val.endsWith(\"/\")) {\n        return val;\n    }\n    throw new Error(`Invalid factory url: \"${val}\" must include trailing slash.`);\n}\nconst isRefProxy = (v)=>typeof v === \"object\" && Number.isInteger(v?.num) && v.num >= 0 && Number.isInteger(v?.gen) && v.gen >= 0;\nconst isNameProxy = (v)=>typeof v === \"object\" && typeof v?.name === \"string\";\nconst isValidExplicitDest = _isValidExplicitDest.bind(null, isRefProxy, isNameProxy);\nclass PDFDocumentLoadingTask {\n    static #docId = 0;\n    get promise() {\n        return this._capability.promise;\n    }\n    async destroy() {\n        this.destroyed = true;\n        try {\n            if (this._worker?.port) {\n                this._worker._pendingDestroy = true;\n            }\n            await this._transport?.destroy();\n        } catch (ex) {\n            if (this._worker?.port) {\n                delete this._worker._pendingDestroy;\n            }\n            throw ex;\n        }\n        this._transport = null;\n        this._worker?.destroy();\n        this._worker = null;\n    }\n    async getData() {\n        return this._transport.getData();\n    }\n    constructor(){\n        this._capability = Promise.withResolvers();\n        this._transport = null;\n        this._worker = null;\n        this.docId = `d${PDFDocumentLoadingTask.#docId++}`;\n        this.destroyed = false;\n        this.onPassword = null;\n        this.onProgress = null;\n    }\n}\nclass PDFDataRangeTransport {\n    constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null){\n        this.length = length;\n        this.initialData = initialData;\n        this.progressiveDone = progressiveDone;\n        this.contentDispositionFilename = contentDispositionFilename;\n        this._rangeListeners = [];\n        this._progressListeners = [];\n        this._progressiveReadListeners = [];\n        this._progressiveDoneListeners = [];\n        this._readyCapability = Promise.withResolvers();\n    }\n    addRangeListener(listener) {\n        this._rangeListeners.push(listener);\n    }\n    addProgressListener(listener) {\n        this._progressListeners.push(listener);\n    }\n    addProgressiveReadListener(listener) {\n        this._progressiveReadListeners.push(listener);\n    }\n    addProgressiveDoneListener(listener) {\n        this._progressiveDoneListeners.push(listener);\n    }\n    onDataRange(begin, chunk) {\n        for (const listener of this._rangeListeners){\n            listener(begin, chunk);\n        }\n    }\n    onDataProgress(loaded, total) {\n        this._readyCapability.promise.then(()=>{\n            for (const listener of this._progressListeners){\n                listener(loaded, total);\n            }\n        });\n    }\n    onDataProgressiveRead(chunk) {\n        this._readyCapability.promise.then(()=>{\n            for (const listener of this._progressiveReadListeners){\n                listener(chunk);\n            }\n        });\n    }\n    onDataProgressiveDone() {\n        this._readyCapability.promise.then(()=>{\n            for (const listener of this._progressiveDoneListeners){\n                listener();\n            }\n        });\n    }\n    transportReady() {\n        this._readyCapability.resolve();\n    }\n    requestDataRange(begin, end) {\n        unreachable(\"Abstract method PDFDataRangeTransport.requestDataRange\");\n    }\n    abort() {}\n}\nclass PDFDocumentProxy {\n    constructor(pdfInfo, transport){\n        this._pdfInfo = pdfInfo;\n        this._transport = transport;\n    }\n    get annotationStorage() {\n        return this._transport.annotationStorage;\n    }\n    get canvasFactory() {\n        return this._transport.canvasFactory;\n    }\n    get filterFactory() {\n        return this._transport.filterFactory;\n    }\n    get numPages() {\n        return this._pdfInfo.numPages;\n    }\n    get fingerprints() {\n        return this._pdfInfo.fingerprints;\n    }\n    get isPureXfa() {\n        return shadow(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n    }\n    get allXfaHtml() {\n        return this._transport._htmlForXfa;\n    }\n    getPage(pageNumber) {\n        return this._transport.getPage(pageNumber);\n    }\n    getPageIndex(ref) {\n        return this._transport.getPageIndex(ref);\n    }\n    getDestinations() {\n        return this._transport.getDestinations();\n    }\n    getDestination(id) {\n        return this._transport.getDestination(id);\n    }\n    getPageLabels() {\n        return this._transport.getPageLabels();\n    }\n    getPageLayout() {\n        return this._transport.getPageLayout();\n    }\n    getPageMode() {\n        return this._transport.getPageMode();\n    }\n    getViewerPreferences() {\n        return this._transport.getViewerPreferences();\n    }\n    getOpenAction() {\n        return this._transport.getOpenAction();\n    }\n    getAttachments() {\n        return this._transport.getAttachments();\n    }\n    getJSActions() {\n        return this._transport.getDocJSActions();\n    }\n    getOutline() {\n        return this._transport.getOutline();\n    }\n    getOptionalContentConfig({ intent = \"display\" } = {}) {\n        const { renderingIntent } = this._transport.getRenderingIntent(intent);\n        return this._transport.getOptionalContentConfig(renderingIntent);\n    }\n    getPermissions() {\n        return this._transport.getPermissions();\n    }\n    getMetadata() {\n        return this._transport.getMetadata();\n    }\n    getMarkInfo() {\n        return this._transport.getMarkInfo();\n    }\n    getData() {\n        return this._transport.getData();\n    }\n    saveDocument() {\n        return this._transport.saveDocument();\n    }\n    getDownloadInfo() {\n        return this._transport.downloadInfoCapability.promise;\n    }\n    cleanup(keepLoadedFonts = false) {\n        return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);\n    }\n    destroy() {\n        return this.loadingTask.destroy();\n    }\n    cachedPageNumber(ref) {\n        return this._transport.cachedPageNumber(ref);\n    }\n    get loadingParams() {\n        return this._transport.loadingParams;\n    }\n    get loadingTask() {\n        return this._transport.loadingTask;\n    }\n    getFieldObjects() {\n        return this._transport.getFieldObjects();\n    }\n    hasJSActions() {\n        return this._transport.hasJSActions();\n    }\n    getCalculationOrderIds() {\n        return this._transport.getCalculationOrderIds();\n    }\n}\nclass PDFPageProxy {\n    #pendingCleanup;\n    constructor(pageIndex, pageInfo, transport, pdfBug = false){\n        this.#pendingCleanup = false;\n        this._pageIndex = pageIndex;\n        this._pageInfo = pageInfo;\n        this._transport = transport;\n        this._stats = pdfBug ? new StatTimer() : null;\n        this._pdfBug = pdfBug;\n        this.commonObjs = transport.commonObjs;\n        this.objs = new PDFObjects();\n        this._intentStates = new Map();\n        this.destroyed = false;\n    }\n    get pageNumber() {\n        return this._pageIndex + 1;\n    }\n    get rotate() {\n        return this._pageInfo.rotate;\n    }\n    get ref() {\n        return this._pageInfo.ref;\n    }\n    get userUnit() {\n        return this._pageInfo.userUnit;\n    }\n    get view() {\n        return this._pageInfo.view;\n    }\n    getViewport({ scale, rotation = this.rotate, offsetX = 0, offsetY = 0, dontFlip = false } = {}) {\n        return new PageViewport({\n            viewBox: this.view,\n            userUnit: this.userUnit,\n            scale,\n            rotation,\n            offsetX,\n            offsetY,\n            dontFlip\n        });\n    }\n    getAnnotations({ intent = \"display\" } = {}) {\n        const { renderingIntent } = this._transport.getRenderingIntent(intent);\n        return this._transport.getAnnotations(this._pageIndex, renderingIntent);\n    }\n    getJSActions() {\n        return this._transport.getPageJSActions(this._pageIndex);\n    }\n    get filterFactory() {\n        return this._transport.filterFactory;\n    }\n    get isPureXfa() {\n        return shadow(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n    }\n    async getXfa() {\n        return this._transport._htmlForXfa?.children[this._pageIndex] || null;\n    }\n    render({ canvasContext, viewport, intent = \"display\", annotationMode = AnnotationMode.ENABLE, transform = null, background = null, optionalContentConfigPromise = null, annotationCanvasMap = null, pageColors = null, printAnnotationStorage = null, isEditing = false }) {\n        this._stats?.time(\"Overall\");\n        const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing);\n        const { renderingIntent, cacheKey } = intentArgs;\n        this.#pendingCleanup = false;\n        optionalContentConfigPromise ||= this._transport.getOptionalContentConfig(renderingIntent);\n        let intentState = this._intentStates.get(cacheKey);\n        if (!intentState) {\n            intentState = Object.create(null);\n            this._intentStates.set(cacheKey, intentState);\n        }\n        if (intentState.streamReaderCancelTimeout) {\n            clearTimeout(intentState.streamReaderCancelTimeout);\n            intentState.streamReaderCancelTimeout = null;\n        }\n        const intentPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);\n        if (!intentState.displayReadyCapability) {\n            intentState.displayReadyCapability = Promise.withResolvers();\n            intentState.operatorList = {\n                fnArray: [],\n                argsArray: [],\n                lastChunk: false,\n                separateAnnots: null\n            };\n            this._stats?.time(\"Page Request\");\n            this._pumpOperatorList(intentArgs);\n        }\n        const complete = (error)=>{\n            intentState.renderTasks.delete(internalRenderTask);\n            if (intentPrint) {\n                this.#pendingCleanup = true;\n            }\n            this.#tryCleanup();\n            if (error) {\n                internalRenderTask.capability.reject(error);\n                this._abortOperatorList({\n                    intentState,\n                    reason: error instanceof Error ? error : new Error(error)\n                });\n            } else {\n                internalRenderTask.capability.resolve();\n            }\n            if (this._stats) {\n                this._stats.timeEnd(\"Rendering\");\n                this._stats.timeEnd(\"Overall\");\n                if (globalThis.Stats?.enabled) {\n                    globalThis.Stats.add(this.pageNumber, this._stats);\n                }\n            }\n        };\n        const internalRenderTask = new InternalRenderTask({\n            callback: complete,\n            params: {\n                canvasContext,\n                viewport,\n                transform,\n                background\n            },\n            objs: this.objs,\n            commonObjs: this.commonObjs,\n            annotationCanvasMap,\n            operatorList: intentState.operatorList,\n            pageIndex: this._pageIndex,\n            canvasFactory: this._transport.canvasFactory,\n            filterFactory: this._transport.filterFactory,\n            useRequestAnimationFrame: !intentPrint,\n            pdfBug: this._pdfBug,\n            pageColors\n        });\n        (intentState.renderTasks ||= new Set()).add(internalRenderTask);\n        const renderTask = internalRenderTask.task;\n        Promise.all([\n            intentState.displayReadyCapability.promise,\n            optionalContentConfigPromise\n        ]).then(([transparency, optionalContentConfig])=>{\n            if (this.destroyed) {\n                complete();\n                return;\n            }\n            this._stats?.time(\"Rendering\");\n            if (!(optionalContentConfig.renderingIntent & renderingIntent)) {\n                throw new Error(\"Must use the same `intent`-argument when calling the `PDFPageProxy.render` \" + \"and `PDFDocumentProxy.getOptionalContentConfig` methods.\");\n            }\n            internalRenderTask.initializeGraphics({\n                transparency,\n                optionalContentConfig\n            });\n            internalRenderTask.operatorListChanged();\n        }).catch(complete);\n        return renderTask;\n    }\n    getOperatorList({ intent = \"display\", annotationMode = AnnotationMode.ENABLE, printAnnotationStorage = null, isEditing = false } = {}) {\n        function operatorListChanged() {\n            if (intentState.operatorList.lastChunk) {\n                intentState.opListReadCapability.resolve(intentState.operatorList);\n                intentState.renderTasks.delete(opListTask);\n            }\n        }\n        const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing, true);\n        let intentState = this._intentStates.get(intentArgs.cacheKey);\n        if (!intentState) {\n            intentState = Object.create(null);\n            this._intentStates.set(intentArgs.cacheKey, intentState);\n        }\n        let opListTask;\n        if (!intentState.opListReadCapability) {\n            opListTask = Object.create(null);\n            opListTask.operatorListChanged = operatorListChanged;\n            intentState.opListReadCapability = Promise.withResolvers();\n            (intentState.renderTasks ||= new Set()).add(opListTask);\n            intentState.operatorList = {\n                fnArray: [],\n                argsArray: [],\n                lastChunk: false,\n                separateAnnots: null\n            };\n            this._stats?.time(\"Page Request\");\n            this._pumpOperatorList(intentArgs);\n        }\n        return intentState.opListReadCapability.promise;\n    }\n    streamTextContent({ includeMarkedContent = false, disableNormalization = false } = {}) {\n        const TEXT_CONTENT_CHUNK_SIZE = 100;\n        return this._transport.messageHandler.sendWithStream(\"GetTextContent\", {\n            pageIndex: this._pageIndex,\n            includeMarkedContent: includeMarkedContent === true,\n            disableNormalization: disableNormalization === true\n        }, {\n            highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\n            size (textContent) {\n                return textContent.items.length;\n            }\n        });\n    }\n    getTextContent(params = {}) {\n        if (this._transport._htmlForXfa) {\n            return this.getXfa().then((xfa)=>XfaText.textContent(xfa));\n        }\n        const readableStream = this.streamTextContent(params);\n        return new Promise(function(resolve, reject) {\n            function pump() {\n                reader.read().then(function({ value, done }) {\n                    if (done) {\n                        resolve(textContent);\n                        return;\n                    }\n                    textContent.lang ??= value.lang;\n                    Object.assign(textContent.styles, value.styles);\n                    textContent.items.push(...value.items);\n                    pump();\n                }, reject);\n            }\n            const reader = readableStream.getReader();\n            const textContent = {\n                items: [],\n                styles: Object.create(null),\n                lang: null\n            };\n            pump();\n        });\n    }\n    getStructTree() {\n        return this._transport.getStructTree(this._pageIndex);\n    }\n    _destroy() {\n        this.destroyed = true;\n        const waitOn = [];\n        for (const intentState of this._intentStates.values()){\n            this._abortOperatorList({\n                intentState,\n                reason: new Error(\"Page was destroyed.\"),\n                force: true\n            });\n            if (intentState.opListReadCapability) {\n                continue;\n            }\n            for (const internalRenderTask of intentState.renderTasks){\n                waitOn.push(internalRenderTask.completed);\n                internalRenderTask.cancel();\n            }\n        }\n        this.objs.clear();\n        this.#pendingCleanup = false;\n        return Promise.all(waitOn);\n    }\n    cleanup(resetStats = false) {\n        this.#pendingCleanup = true;\n        const success = this.#tryCleanup();\n        if (resetStats && success) {\n            this._stats &&= new StatTimer();\n        }\n        return success;\n    }\n    #tryCleanup() {\n        if (!this.#pendingCleanup || this.destroyed) {\n            return false;\n        }\n        for (const { renderTasks, operatorList } of this._intentStates.values()){\n            if (renderTasks.size > 0 || !operatorList.lastChunk) {\n                return false;\n            }\n        }\n        this._intentStates.clear();\n        this.objs.clear();\n        this.#pendingCleanup = false;\n        return true;\n    }\n    _startRenderPage(transparency, cacheKey) {\n        const intentState = this._intentStates.get(cacheKey);\n        if (!intentState) {\n            return;\n        }\n        this._stats?.timeEnd(\"Page Request\");\n        intentState.displayReadyCapability?.resolve(transparency);\n    }\n    _renderPageChunk(operatorListChunk, intentState) {\n        for(let i = 0, ii = operatorListChunk.length; i < ii; i++){\n            intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n            intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\n        }\n        intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n        intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;\n        for (const internalRenderTask of intentState.renderTasks){\n            internalRenderTask.operatorListChanged();\n        }\n        if (operatorListChunk.lastChunk) {\n            this.#tryCleanup();\n        }\n    }\n    _pumpOperatorList({ renderingIntent, cacheKey, annotationStorageSerializable, modifiedIds }) {\n        const { map, transfer } = annotationStorageSerializable;\n        const readableStream = this._transport.messageHandler.sendWithStream(\"GetOperatorList\", {\n            pageIndex: this._pageIndex,\n            intent: renderingIntent,\n            cacheKey,\n            annotationStorage: map,\n            modifiedIds\n        }, transfer);\n        const reader = readableStream.getReader();\n        const intentState = this._intentStates.get(cacheKey);\n        intentState.streamReader = reader;\n        const pump = ()=>{\n            reader.read().then(({ value, done })=>{\n                if (done) {\n                    intentState.streamReader = null;\n                    return;\n                }\n                if (this._transport.destroyed) {\n                    return;\n                }\n                this._renderPageChunk(value, intentState);\n                pump();\n            }, (reason)=>{\n                intentState.streamReader = null;\n                if (this._transport.destroyed) {\n                    return;\n                }\n                if (intentState.operatorList) {\n                    intentState.operatorList.lastChunk = true;\n                    for (const internalRenderTask of intentState.renderTasks){\n                        internalRenderTask.operatorListChanged();\n                    }\n                    this.#tryCleanup();\n                }\n                if (intentState.displayReadyCapability) {\n                    intentState.displayReadyCapability.reject(reason);\n                } else if (intentState.opListReadCapability) {\n                    intentState.opListReadCapability.reject(reason);\n                } else {\n                    throw reason;\n                }\n            });\n        };\n        pump();\n    }\n    _abortOperatorList({ intentState, reason, force = false }) {\n        if (!intentState.streamReader) {\n            return;\n        }\n        if (intentState.streamReaderCancelTimeout) {\n            clearTimeout(intentState.streamReaderCancelTimeout);\n            intentState.streamReaderCancelTimeout = null;\n        }\n        if (!force) {\n            if (intentState.renderTasks.size > 0) {\n                return;\n            }\n            if (reason instanceof RenderingCancelledException) {\n                let delay = RENDERING_CANCELLED_TIMEOUT;\n                if (reason.extraDelay > 0 && reason.extraDelay < 1000) {\n                    delay += reason.extraDelay;\n                }\n                intentState.streamReaderCancelTimeout = setTimeout(()=>{\n                    intentState.streamReaderCancelTimeout = null;\n                    this._abortOperatorList({\n                        intentState,\n                        reason,\n                        force: true\n                    });\n                }, delay);\n                return;\n            }\n        }\n        intentState.streamReader.cancel(new AbortException(reason.message)).catch(()=>{});\n        intentState.streamReader = null;\n        if (this._transport.destroyed) {\n            return;\n        }\n        for (const [curCacheKey, curIntentState] of this._intentStates){\n            if (curIntentState === intentState) {\n                this._intentStates.delete(curCacheKey);\n                break;\n            }\n        }\n        this.cleanup();\n    }\n    get stats() {\n        return this._stats;\n    }\n}\nclass LoopbackPort {\n    #listeners;\n    #deferred;\n    postMessage(obj, transfer) {\n        const event = {\n            data: structuredClone(obj, transfer ? {\n                transfer\n            } : null)\n        };\n        this.#deferred.then(()=>{\n            for (const [listener] of this.#listeners){\n                listener.call(this, event);\n            }\n        });\n    }\n    addEventListener(name, listener, options = null) {\n        let rmAbort = null;\n        if (options?.signal instanceof AbortSignal) {\n            const { signal } = options;\n            if (signal.aborted) {\n                warn(\"LoopbackPort - cannot use an `aborted` signal.\");\n                return;\n            }\n            const onAbort = ()=>this.removeEventListener(name, listener);\n            rmAbort = ()=>signal.removeEventListener(\"abort\", onAbort);\n            signal.addEventListener(\"abort\", onAbort);\n        }\n        this.#listeners.set(listener, rmAbort);\n    }\n    removeEventListener(name, listener) {\n        const rmAbort = this.#listeners.get(listener);\n        rmAbort?.();\n        this.#listeners.delete(listener);\n    }\n    terminate() {\n        for (const [, rmAbort] of this.#listeners){\n            rmAbort?.();\n        }\n        this.#listeners.clear();\n    }\n    constructor(){\n        this.#listeners = new Map();\n        this.#deferred = Promise.resolve();\n    }\n}\nclass PDFWorker {\n    static #fakeWorkerId = 0;\n    static #isWorkerDisabled = false;\n    static #workerPorts;\n    static{\n        if (isNodeJS) {\n            this.#isWorkerDisabled = true;\n            GlobalWorkerOptions.workerSrc ||= \"./pdf.worker.mjs\";\n        }\n        this._isSameOrigin = (baseUrl, otherUrl)=>{\n            const base = URL.parse(baseUrl);\n            if (!base?.origin || base.origin === \"null\") {\n                return false;\n            }\n            const other = new URL(otherUrl, base);\n            return base.origin === other.origin;\n        };\n        this._createCDNWrapper = (url)=>{\n            const wrapper = `await import(\"${url}\");`;\n            return URL.createObjectURL(new Blob([\n                wrapper\n            ], {\n                type: \"text/javascript\"\n            }));\n        };\n    }\n    constructor({ name = null, port = null, verbosity = getVerbosityLevel() } = {}){\n        this.name = name;\n        this.destroyed = false;\n        this.verbosity = verbosity;\n        this._readyCapability = Promise.withResolvers();\n        this._port = null;\n        this._webWorker = null;\n        this._messageHandler = null;\n        if (port) {\n            if (PDFWorker.#workerPorts?.has(port)) {\n                throw new Error(\"Cannot use more than one PDFWorker per port.\");\n            }\n            (PDFWorker.#workerPorts ||= new WeakMap()).set(port, this);\n            this._initializeFromPort(port);\n            return;\n        }\n        this._initialize();\n    }\n    get promise() {\n        return this._readyCapability.promise;\n    }\n    #resolve() {\n        this._readyCapability.resolve();\n        this._messageHandler.send(\"configure\", {\n            verbosity: this.verbosity\n        });\n    }\n    get port() {\n        return this._port;\n    }\n    get messageHandler() {\n        return this._messageHandler;\n    }\n    _initializeFromPort(port) {\n        this._port = port;\n        this._messageHandler = new MessageHandler(\"main\", \"worker\", port);\n        this._messageHandler.on(\"ready\", function() {});\n        this.#resolve();\n    }\n    _initialize() {\n        if (PDFWorker.#isWorkerDisabled || PDFWorker.#mainThreadWorkerMessageHandler) {\n            this._setupFakeWorker();\n            return;\n        }\n        let { workerSrc } = PDFWorker;\n        try {\n            if (!PDFWorker._isSameOrigin(window.location, workerSrc)) {\n                workerSrc = PDFWorker._createCDNWrapper(new URL(workerSrc, window.location).href);\n            }\n            const worker = new Worker(workerSrc, {\n                type: \"module\"\n            });\n            const messageHandler = new MessageHandler(\"main\", \"worker\", worker);\n            const terminateEarly = ()=>{\n                ac.abort();\n                messageHandler.destroy();\n                worker.terminate();\n                if (this.destroyed) {\n                    this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n                } else {\n                    this._setupFakeWorker();\n                }\n            };\n            const ac = new AbortController();\n            worker.addEventListener(\"error\", ()=>{\n                if (!this._webWorker) {\n                    terminateEarly();\n                }\n            }, {\n                signal: ac.signal\n            });\n            messageHandler.on(\"test\", (data)=>{\n                ac.abort();\n                if (this.destroyed || !data) {\n                    terminateEarly();\n                    return;\n                }\n                this._messageHandler = messageHandler;\n                this._port = worker;\n                this._webWorker = worker;\n                this.#resolve();\n            });\n            messageHandler.on(\"ready\", (data)=>{\n                ac.abort();\n                if (this.destroyed) {\n                    terminateEarly();\n                    return;\n                }\n                try {\n                    sendTest();\n                } catch  {\n                    this._setupFakeWorker();\n                }\n            });\n            const sendTest = ()=>{\n                const testObj = new Uint8Array();\n                messageHandler.send(\"test\", testObj, [\n                    testObj.buffer\n                ]);\n            };\n            sendTest();\n            return;\n        } catch  {\n            info(\"The worker has been disabled.\");\n        }\n        this._setupFakeWorker();\n    }\n    _setupFakeWorker() {\n        if (!PDFWorker.#isWorkerDisabled) {\n            warn(\"Setting up fake worker.\");\n            PDFWorker.#isWorkerDisabled = true;\n        }\n        PDFWorker._setupFakeWorkerGlobal.then((WorkerMessageHandler)=>{\n            if (this.destroyed) {\n                this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n                return;\n            }\n            const port = new LoopbackPort();\n            this._port = port;\n            const id = `fake${PDFWorker.#fakeWorkerId++}`;\n            const workerHandler = new MessageHandler(id + \"_worker\", id, port);\n            WorkerMessageHandler.setup(workerHandler, port);\n            this._messageHandler = new MessageHandler(id, id + \"_worker\", port);\n            this.#resolve();\n        }).catch((reason)=>{\n            this._readyCapability.reject(new Error(`Setting up fake worker failed: \"${reason.message}\".`));\n        });\n    }\n    destroy() {\n        this.destroyed = true;\n        this._webWorker?.terminate();\n        this._webWorker = null;\n        PDFWorker.#workerPorts?.delete(this._port);\n        this._port = null;\n        this._messageHandler?.destroy();\n        this._messageHandler = null;\n    }\n    static fromPort(params) {\n        if (!params?.port) {\n            throw new Error(\"PDFWorker.fromPort - invalid method signature.\");\n        }\n        const cachedPort = this.#workerPorts?.get(params.port);\n        if (cachedPort) {\n            if (cachedPort._pendingDestroy) {\n                throw new Error(\"PDFWorker.fromPort - the worker is being destroyed.\\n\" + \"Please remember to await `PDFDocumentLoadingTask.destroy()`-calls.\");\n            }\n            return cachedPort;\n        }\n        return new PDFWorker(params);\n    }\n    static get workerSrc() {\n        if (GlobalWorkerOptions.workerSrc) {\n            return GlobalWorkerOptions.workerSrc;\n        }\n        throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\n    }\n    static get #mainThreadWorkerMessageHandler() {\n        try {\n            return globalThis.pdfjsWorker?.WorkerMessageHandler || null;\n        } catch  {\n            return null;\n        }\n    }\n    static get _setupFakeWorkerGlobal() {\n        const loader = async ()=>{\n            if (this.#mainThreadWorkerMessageHandler) {\n                return this.#mainThreadWorkerMessageHandler;\n            }\n            const worker = await import(/*webpackIgnore: true*/ /*@vite-ignore*/ this.workerSrc);\n            return worker.WorkerMessageHandler;\n        };\n        return shadow(this, \"_setupFakeWorkerGlobal\", loader());\n    }\n}\nclass WorkerTransport {\n    #methodPromises;\n    #pageCache;\n    #pagePromises;\n    #pageRefCache;\n    #passwordCapability;\n    constructor(messageHandler, loadingTask, networkStream, params, factory){\n        this.#methodPromises = new Map();\n        this.#pageCache = new Map();\n        this.#pagePromises = new Map();\n        this.#pageRefCache = new Map();\n        this.#passwordCapability = null;\n        this.messageHandler = messageHandler;\n        this.loadingTask = loadingTask;\n        this.commonObjs = new PDFObjects();\n        this.fontLoader = new FontLoader({\n            ownerDocument: params.ownerDocument,\n            styleElement: params.styleElement\n        });\n        this.loadingParams = params.loadingParams;\n        this._params = params;\n        this.canvasFactory = factory.canvasFactory;\n        this.filterFactory = factory.filterFactory;\n        this.cMapReaderFactory = factory.cMapReaderFactory;\n        this.standardFontDataFactory = factory.standardFontDataFactory;\n        this.wasmFactory = factory.wasmFactory;\n        this.destroyed = false;\n        this.destroyCapability = null;\n        this._networkStream = networkStream;\n        this._fullReader = null;\n        this._lastProgress = null;\n        this.downloadInfoCapability = Promise.withResolvers();\n        this.setupMessageHandler();\n    }\n    #cacheSimpleMethod(name, data = null) {\n        const cachedPromise = this.#methodPromises.get(name);\n        if (cachedPromise) {\n            return cachedPromise;\n        }\n        const promise = this.messageHandler.sendWithPromise(name, data);\n        this.#methodPromises.set(name, promise);\n        return promise;\n    }\n    get annotationStorage() {\n        return shadow(this, \"annotationStorage\", new AnnotationStorage());\n    }\n    getRenderingIntent(intent, annotationMode = AnnotationMode.ENABLE, printAnnotationStorage = null, isEditing = false, isOpList = false) {\n        let renderingIntent = RenderingIntentFlag.DISPLAY;\n        let annotationStorageSerializable = SerializableEmpty;\n        switch(intent){\n            case \"any\":\n                renderingIntent = RenderingIntentFlag.ANY;\n                break;\n            case \"display\":\n                break;\n            case \"print\":\n                renderingIntent = RenderingIntentFlag.PRINT;\n                break;\n            default:\n                warn(`getRenderingIntent - invalid intent: ${intent}`);\n        }\n        const annotationStorage = renderingIntent & RenderingIntentFlag.PRINT && printAnnotationStorage instanceof PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;\n        switch(annotationMode){\n            case AnnotationMode.DISABLE:\n                renderingIntent += RenderingIntentFlag.ANNOTATIONS_DISABLE;\n                break;\n            case AnnotationMode.ENABLE:\n                break;\n            case AnnotationMode.ENABLE_FORMS:\n                renderingIntent += RenderingIntentFlag.ANNOTATIONS_FORMS;\n                break;\n            case AnnotationMode.ENABLE_STORAGE:\n                renderingIntent += RenderingIntentFlag.ANNOTATIONS_STORAGE;\n                annotationStorageSerializable = annotationStorage.serializable;\n                break;\n            default:\n                warn(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);\n        }\n        if (isEditing) {\n            renderingIntent += RenderingIntentFlag.IS_EDITING;\n        }\n        if (isOpList) {\n            renderingIntent += RenderingIntentFlag.OPLIST;\n        }\n        const { ids: modifiedIds, hash: modifiedIdsHash } = annotationStorage.modifiedIds;\n        const cacheKeyBuf = [\n            renderingIntent,\n            annotationStorageSerializable.hash,\n            modifiedIdsHash\n        ];\n        return {\n            renderingIntent,\n            cacheKey: cacheKeyBuf.join(\"_\"),\n            annotationStorageSerializable,\n            modifiedIds\n        };\n    }\n    destroy() {\n        if (this.destroyCapability) {\n            return this.destroyCapability.promise;\n        }\n        this.destroyed = true;\n        this.destroyCapability = Promise.withResolvers();\n        this.#passwordCapability?.reject(new Error(\"Worker was destroyed during onPassword callback\"));\n        const waitOn = [];\n        for (const page of this.#pageCache.values()){\n            waitOn.push(page._destroy());\n        }\n        this.#pageCache.clear();\n        this.#pagePromises.clear();\n        this.#pageRefCache.clear();\n        if (this.hasOwnProperty(\"annotationStorage\")) {\n            this.annotationStorage.resetModified();\n        }\n        const terminated = this.messageHandler.sendWithPromise(\"Terminate\", null);\n        waitOn.push(terminated);\n        Promise.all(waitOn).then(()=>{\n            this.commonObjs.clear();\n            this.fontLoader.clear();\n            this.#methodPromises.clear();\n            this.filterFactory.destroy();\n            TextLayer.cleanup();\n            this._networkStream?.cancelAllRequests(new AbortException(\"Worker was terminated.\"));\n            this.messageHandler?.destroy();\n            this.messageHandler = null;\n            this.destroyCapability.resolve();\n        }, this.destroyCapability.reject);\n        return this.destroyCapability.promise;\n    }\n    setupMessageHandler() {\n        const { messageHandler, loadingTask } = this;\n        messageHandler.on(\"GetReader\", (data, sink)=>{\n            assert(this._networkStream, \"GetReader - no `IPDFStream` instance available.\");\n            this._fullReader = this._networkStream.getFullReader();\n            this._fullReader.onProgress = (evt)=>{\n                this._lastProgress = {\n                    loaded: evt.loaded,\n                    total: evt.total\n                };\n            };\n            sink.onPull = ()=>{\n                this._fullReader.read().then(function({ value, done }) {\n                    if (done) {\n                        sink.close();\n                        return;\n                    }\n                    assert(value instanceof ArrayBuffer, \"GetReader - expected an ArrayBuffer.\");\n                    sink.enqueue(new Uint8Array(value), 1, [\n                        value\n                    ]);\n                }).catch((reason)=>{\n                    sink.error(reason);\n                });\n            };\n            sink.onCancel = (reason)=>{\n                this._fullReader.cancel(reason);\n                sink.ready.catch((readyReason)=>{\n                    if (this.destroyed) {\n                        return;\n                    }\n                    throw readyReason;\n                });\n            };\n        });\n        messageHandler.on(\"ReaderHeadersReady\", async (data)=>{\n            await this._fullReader.headersReady;\n            const { isStreamingSupported, isRangeSupported, contentLength } = this._fullReader;\n            if (!isStreamingSupported || !isRangeSupported) {\n                if (this._lastProgress) {\n                    loadingTask.onProgress?.(this._lastProgress);\n                }\n                this._fullReader.onProgress = (evt)=>{\n                    loadingTask.onProgress?.({\n                        loaded: evt.loaded,\n                        total: evt.total\n                    });\n                };\n            }\n            return {\n                isStreamingSupported,\n                isRangeSupported,\n                contentLength\n            };\n        });\n        messageHandler.on(\"GetRangeReader\", (data, sink)=>{\n            assert(this._networkStream, \"GetRangeReader - no `IPDFStream` instance available.\");\n            const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);\n            if (!rangeReader) {\n                sink.close();\n                return;\n            }\n            sink.onPull = ()=>{\n                rangeReader.read().then(function({ value, done }) {\n                    if (done) {\n                        sink.close();\n                        return;\n                    }\n                    assert(value instanceof ArrayBuffer, \"GetRangeReader - expected an ArrayBuffer.\");\n                    sink.enqueue(new Uint8Array(value), 1, [\n                        value\n                    ]);\n                }).catch((reason)=>{\n                    sink.error(reason);\n                });\n            };\n            sink.onCancel = (reason)=>{\n                rangeReader.cancel(reason);\n                sink.ready.catch((readyReason)=>{\n                    if (this.destroyed) {\n                        return;\n                    }\n                    throw readyReason;\n                });\n            };\n        });\n        messageHandler.on(\"GetDoc\", ({ pdfInfo })=>{\n            this._numPages = pdfInfo.numPages;\n            this._htmlForXfa = pdfInfo.htmlForXfa;\n            delete pdfInfo.htmlForXfa;\n            loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));\n        });\n        messageHandler.on(\"DocException\", (ex)=>{\n            loadingTask._capability.reject(wrapReason(ex));\n        });\n        messageHandler.on(\"PasswordRequest\", (ex)=>{\n            this.#passwordCapability = Promise.withResolvers();\n            try {\n                if (!loadingTask.onPassword) {\n                    throw wrapReason(ex);\n                }\n                const updatePassword = (password)=>{\n                    if (password instanceof Error) {\n                        this.#passwordCapability.reject(password);\n                    } else {\n                        this.#passwordCapability.resolve({\n                            password\n                        });\n                    }\n                };\n                loadingTask.onPassword(updatePassword, ex.code);\n            } catch (err) {\n                this.#passwordCapability.reject(err);\n            }\n            return this.#passwordCapability.promise;\n        });\n        messageHandler.on(\"DataLoaded\", (data)=>{\n            loadingTask.onProgress?.({\n                loaded: data.length,\n                total: data.length\n            });\n            this.downloadInfoCapability.resolve(data);\n        });\n        messageHandler.on(\"StartRenderPage\", (data)=>{\n            if (this.destroyed) {\n                return;\n            }\n            const page = this.#pageCache.get(data.pageIndex);\n            page._startRenderPage(data.transparency, data.cacheKey);\n        });\n        messageHandler.on(\"commonobj\", ([id, type, exportedData])=>{\n            if (this.destroyed) {\n                return null;\n            }\n            if (this.commonObjs.has(id)) {\n                return null;\n            }\n            switch(type){\n                case \"Font\":\n                    if (\"error\" in exportedData) {\n                        const exportedError = exportedData.error;\n                        warn(`Error during font loading: ${exportedError}`);\n                        this.commonObjs.resolve(id, exportedError);\n                        break;\n                    }\n                    const inspectFont = this._params.pdfBug && globalThis.FontInspector?.enabled ? (font, url)=>globalThis.FontInspector.fontAdded(font, url) : null;\n                    const font = new FontFaceObject(exportedData, inspectFont);\n                    this.fontLoader.bind(font).catch(()=>messageHandler.sendWithPromise(\"FontFallback\", {\n                            id\n                        })).finally(()=>{\n                        if (!font.fontExtraProperties && font.data) {\n                            font.data = null;\n                        }\n                        this.commonObjs.resolve(id, font);\n                    });\n                    break;\n                case \"CopyLocalImage\":\n                    const { imageRef } = exportedData;\n                    assert(imageRef, \"The imageRef must be defined.\");\n                    for (const pageProxy of this.#pageCache.values()){\n                        for (const [, data] of pageProxy.objs){\n                            if (data?.ref !== imageRef) {\n                                continue;\n                            }\n                            if (!data.dataLen) {\n                                return null;\n                            }\n                            this.commonObjs.resolve(id, structuredClone(data));\n                            return data.dataLen;\n                        }\n                    }\n                    break;\n                case \"FontPath\":\n                case \"Image\":\n                case \"Pattern\":\n                    this.commonObjs.resolve(id, exportedData);\n                    break;\n                default:\n                    throw new Error(`Got unknown common object type ${type}`);\n            }\n            return null;\n        });\n        messageHandler.on(\"obj\", ([id, pageIndex, type, imageData])=>{\n            if (this.destroyed) {\n                return;\n            }\n            const pageProxy = this.#pageCache.get(pageIndex);\n            if (pageProxy.objs.has(id)) {\n                return;\n            }\n            if (pageProxy._intentStates.size === 0) {\n                imageData?.bitmap?.close();\n                return;\n            }\n            switch(type){\n                case \"Image\":\n                case \"Pattern\":\n                    pageProxy.objs.resolve(id, imageData);\n                    break;\n                default:\n                    throw new Error(`Got unknown object type ${type}`);\n            }\n        });\n        messageHandler.on(\"DocProgress\", (data)=>{\n            if (this.destroyed) {\n                return;\n            }\n            loadingTask.onProgress?.({\n                loaded: data.loaded,\n                total: data.total\n            });\n        });\n        messageHandler.on(\"FetchBinaryData\", async (data)=>{\n            if (this.destroyed) {\n                throw new Error(\"Worker was destroyed.\");\n            }\n            const factory = this[data.type];\n            if (!factory) {\n                throw new Error(`${data.type} not initialized, see the \\`useWorkerFetch\\` parameter.`);\n            }\n            return factory.fetch(data);\n        });\n    }\n    getData() {\n        return this.messageHandler.sendWithPromise(\"GetData\", null);\n    }\n    saveDocument() {\n        if (this.annotationStorage.size <= 0) {\n            warn(\"saveDocument called while `annotationStorage` is empty, \" + \"please use the getData-method instead.\");\n        }\n        const { map, transfer } = this.annotationStorage.serializable;\n        return this.messageHandler.sendWithPromise(\"SaveDocument\", {\n            isPureXfa: !!this._htmlForXfa,\n            numPages: this._numPages,\n            annotationStorage: map,\n            filename: this._fullReader?.filename ?? null\n        }, transfer).finally(()=>{\n            this.annotationStorage.resetModified();\n        });\n    }\n    getPage(pageNumber) {\n        if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {\n            return Promise.reject(new Error(\"Invalid page request.\"));\n        }\n        const pageIndex = pageNumber - 1, cachedPromise = this.#pagePromises.get(pageIndex);\n        if (cachedPromise) {\n            return cachedPromise;\n        }\n        const promise = this.messageHandler.sendWithPromise(\"GetPage\", {\n            pageIndex\n        }).then((pageInfo)=>{\n            if (this.destroyed) {\n                throw new Error(\"Transport destroyed\");\n            }\n            if (pageInfo.refStr) {\n                this.#pageRefCache.set(pageInfo.refStr, pageNumber);\n            }\n            const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);\n            this.#pageCache.set(pageIndex, page);\n            return page;\n        });\n        this.#pagePromises.set(pageIndex, promise);\n        return promise;\n    }\n    getPageIndex(ref) {\n        if (!isRefProxy(ref)) {\n            return Promise.reject(new Error(\"Invalid pageIndex request.\"));\n        }\n        return this.messageHandler.sendWithPromise(\"GetPageIndex\", {\n            num: ref.num,\n            gen: ref.gen\n        });\n    }\n    getAnnotations(pageIndex, intent) {\n        return this.messageHandler.sendWithPromise(\"GetAnnotations\", {\n            pageIndex,\n            intent\n        });\n    }\n    getFieldObjects() {\n        return this.#cacheSimpleMethod(\"GetFieldObjects\");\n    }\n    hasJSActions() {\n        return this.#cacheSimpleMethod(\"HasJSActions\");\n    }\n    getCalculationOrderIds() {\n        return this.messageHandler.sendWithPromise(\"GetCalculationOrderIds\", null);\n    }\n    getDestinations() {\n        return this.messageHandler.sendWithPromise(\"GetDestinations\", null);\n    }\n    getDestination(id) {\n        if (typeof id !== \"string\") {\n            return Promise.reject(new Error(\"Invalid destination request.\"));\n        }\n        return this.messageHandler.sendWithPromise(\"GetDestination\", {\n            id\n        });\n    }\n    getPageLabels() {\n        return this.messageHandler.sendWithPromise(\"GetPageLabels\", null);\n    }\n    getPageLayout() {\n        return this.messageHandler.sendWithPromise(\"GetPageLayout\", null);\n    }\n    getPageMode() {\n        return this.messageHandler.sendWithPromise(\"GetPageMode\", null);\n    }\n    getViewerPreferences() {\n        return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null);\n    }\n    getOpenAction() {\n        return this.messageHandler.sendWithPromise(\"GetOpenAction\", null);\n    }\n    getAttachments() {\n        return this.messageHandler.sendWithPromise(\"GetAttachments\", null);\n    }\n    getDocJSActions() {\n        return this.#cacheSimpleMethod(\"GetDocJSActions\");\n    }\n    getPageJSActions(pageIndex) {\n        return this.messageHandler.sendWithPromise(\"GetPageJSActions\", {\n            pageIndex\n        });\n    }\n    getStructTree(pageIndex) {\n        return this.messageHandler.sendWithPromise(\"GetStructTree\", {\n            pageIndex\n        });\n    }\n    getOutline() {\n        return this.messageHandler.sendWithPromise(\"GetOutline\", null);\n    }\n    getOptionalContentConfig(renderingIntent) {\n        return this.#cacheSimpleMethod(\"GetOptionalContentConfig\").then((data)=>new OptionalContentConfig(data, renderingIntent));\n    }\n    getPermissions() {\n        return this.messageHandler.sendWithPromise(\"GetPermissions\", null);\n    }\n    getMetadata() {\n        const name = \"GetMetadata\", cachedPromise = this.#methodPromises.get(name);\n        if (cachedPromise) {\n            return cachedPromise;\n        }\n        const promise = this.messageHandler.sendWithPromise(name, null).then((results)=>({\n                info: results[0],\n                metadata: results[1] ? new Metadata(results[1]) : null,\n                contentDispositionFilename: this._fullReader?.filename ?? null,\n                contentLength: this._fullReader?.contentLength ?? null\n            }));\n        this.#methodPromises.set(name, promise);\n        return promise;\n    }\n    getMarkInfo() {\n        return this.messageHandler.sendWithPromise(\"GetMarkInfo\", null);\n    }\n    async startCleanup(keepLoadedFonts = false) {\n        if (this.destroyed) {\n            return;\n        }\n        await this.messageHandler.sendWithPromise(\"Cleanup\", null);\n        for (const page of this.#pageCache.values()){\n            const cleanupSuccessful = page.cleanup();\n            if (!cleanupSuccessful) {\n                throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);\n            }\n        }\n        this.commonObjs.clear();\n        if (!keepLoadedFonts) {\n            this.fontLoader.clear();\n        }\n        this.#methodPromises.clear();\n        this.filterFactory.destroy(true);\n        TextLayer.cleanup();\n    }\n    cachedPageNumber(ref) {\n        if (!isRefProxy(ref)) {\n            return null;\n        }\n        const refStr = ref.gen === 0 ? `${ref.num}R` : `${ref.num}R${ref.gen}`;\n        return this.#pageRefCache.get(refStr) ?? null;\n    }\n}\nconst INITIAL_DATA = Symbol(\"INITIAL_DATA\");\nclass PDFObjects {\n    #objs;\n    #ensureObj(objId) {\n        return this.#objs[objId] ||= {\n            ...Promise.withResolvers(),\n            data: INITIAL_DATA\n        };\n    }\n    get(objId, callback = null) {\n        if (callback) {\n            const obj = this.#ensureObj(objId);\n            obj.promise.then(()=>callback(obj.data));\n            return null;\n        }\n        const obj = this.#objs[objId];\n        if (!obj || obj.data === INITIAL_DATA) {\n            throw new Error(`Requesting object that isn't resolved yet ${objId}.`);\n        }\n        return obj.data;\n    }\n    has(objId) {\n        const obj = this.#objs[objId];\n        return !!obj && obj.data !== INITIAL_DATA;\n    }\n    delete(objId) {\n        const obj = this.#objs[objId];\n        if (!obj || obj.data === INITIAL_DATA) {\n            return false;\n        }\n        delete this.#objs[objId];\n        return true;\n    }\n    resolve(objId, data = null) {\n        const obj = this.#ensureObj(objId);\n        obj.data = data;\n        obj.resolve();\n    }\n    clear() {\n        for(const objId in this.#objs){\n            const { data } = this.#objs[objId];\n            data?.bitmap?.close();\n        }\n        this.#objs = Object.create(null);\n    }\n    *[Symbol.iterator]() {\n        for(const objId in this.#objs){\n            const { data } = this.#objs[objId];\n            if (data === INITIAL_DATA) {\n                continue;\n            }\n            yield [\n                objId,\n                data\n            ];\n        }\n    }\n    constructor(){\n        this.#objs = Object.create(null);\n    }\n}\nclass RenderTask {\n    #internalRenderTask;\n    constructor(internalRenderTask){\n        this.#internalRenderTask = null;\n        this.onContinue = null;\n        this.onError = null;\n        this.#internalRenderTask = internalRenderTask;\n    }\n    get promise() {\n        return this.#internalRenderTask.capability.promise;\n    }\n    cancel(extraDelay = 0) {\n        this.#internalRenderTask.cancel(null, extraDelay);\n    }\n    get separateAnnots() {\n        const { separateAnnots } = this.#internalRenderTask.operatorList;\n        if (!separateAnnots) {\n            return false;\n        }\n        const { annotationCanvasMap } = this.#internalRenderTask;\n        return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;\n    }\n}\nclass InternalRenderTask {\n    #rAF;\n    static #canvasInUse = new WeakSet();\n    constructor({ callback, params, objs, commonObjs, annotationCanvasMap, operatorList, pageIndex, canvasFactory, filterFactory, useRequestAnimationFrame = false, pdfBug = false, pageColors = null }){\n        this.#rAF = null;\n        this.callback = callback;\n        this.params = params;\n        this.objs = objs;\n        this.commonObjs = commonObjs;\n        this.annotationCanvasMap = annotationCanvasMap;\n        this.operatorListIdx = null;\n        this.operatorList = operatorList;\n        this._pageIndex = pageIndex;\n        this.canvasFactory = canvasFactory;\n        this.filterFactory = filterFactory;\n        this._pdfBug = pdfBug;\n        this.pageColors = pageColors;\n        this.running = false;\n        this.graphicsReadyCallback = null;\n        this.graphicsReady = false;\n        this._useRequestAnimationFrame = useRequestAnimationFrame === true && \"undefined\" !== \"undefined\";\n        this.cancelled = false;\n        this.capability = Promise.withResolvers();\n        this.task = new RenderTask(this);\n        this._cancelBound = this.cancel.bind(this);\n        this._continueBound = this._continue.bind(this);\n        this._scheduleNextBound = this._scheduleNext.bind(this);\n        this._nextBound = this._next.bind(this);\n        this._canvas = params.canvasContext.canvas;\n    }\n    get completed() {\n        return this.capability.promise.catch(function() {});\n    }\n    initializeGraphics({ transparency = false, optionalContentConfig }) {\n        if (this.cancelled) {\n            return;\n        }\n        if (this._canvas) {\n            if (InternalRenderTask.#canvasInUse.has(this._canvas)) {\n                throw new Error(\"Cannot use the same canvas during multiple render() operations. \" + \"Use different canvas or ensure previous operations were \" + \"cancelled or completed.\");\n            }\n            InternalRenderTask.#canvasInUse.add(this._canvas);\n        }\n        if (this._pdfBug && globalThis.StepperManager?.enabled) {\n            this.stepper = globalThis.StepperManager.create(this._pageIndex);\n            this.stepper.init(this.operatorList);\n            this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n        }\n        const { canvasContext, viewport, transform, background } = this.params;\n        this.gfx = new CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n            optionalContentConfig\n        }, this.annotationCanvasMap, this.pageColors);\n        this.gfx.beginDrawing({\n            transform,\n            viewport,\n            transparency,\n            background\n        });\n        this.operatorListIdx = 0;\n        this.graphicsReady = true;\n        this.graphicsReadyCallback?.();\n    }\n    cancel(error = null, extraDelay = 0) {\n        this.running = false;\n        this.cancelled = true;\n        this.gfx?.endDrawing();\n        if (this.#rAF) {\n            window.cancelAnimationFrame(this.#rAF);\n            this.#rAF = null;\n        }\n        InternalRenderTask.#canvasInUse.delete(this._canvas);\n        error ||= new RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay);\n        this.callback(error);\n        this.task.onError?.(error);\n    }\n    operatorListChanged() {\n        if (!this.graphicsReady) {\n            this.graphicsReadyCallback ||= this._continueBound;\n            return;\n        }\n        this.stepper?.updateOperatorList(this.operatorList);\n        if (this.running) {\n            return;\n        }\n        this._continue();\n    }\n    _continue() {\n        this.running = true;\n        if (this.cancelled) {\n            return;\n        }\n        if (this.task.onContinue) {\n            this.task.onContinue(this._scheduleNextBound);\n        } else {\n            this._scheduleNext();\n        }\n    }\n    _scheduleNext() {\n        if (this._useRequestAnimationFrame) {\n            this.#rAF = window.requestAnimationFrame(()=>{\n                this.#rAF = null;\n                this._nextBound().catch(this._cancelBound);\n            });\n        } else {\n            Promise.resolve().then(this._nextBound).catch(this._cancelBound);\n        }\n    }\n    async _next() {\n        if (this.cancelled) {\n            return;\n        }\n        this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);\n        if (this.operatorListIdx === this.operatorList.argsArray.length) {\n            this.running = false;\n            if (this.operatorList.lastChunk) {\n                this.gfx.endDrawing();\n                InternalRenderTask.#canvasInUse.delete(this._canvas);\n                this.callback();\n            }\n        }\n    }\n}\nconst version = \"5.2.133\";\nconst build = \"4f7761353\";\n; // ./src/shared/scripting_utils.js\nfunction makeColorComp(n) {\n    return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, \"0\");\n}\nfunction scaleAndClamp(x) {\n    return Math.max(0, Math.min(255, 255 * x));\n}\nclass ColorConverters {\n    static CMYK_G([c, y, m, k]) {\n        return [\n            \"G\",\n            1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)\n        ];\n    }\n    static G_CMYK([g]) {\n        return [\n            \"CMYK\",\n            0,\n            0,\n            0,\n            1 - g\n        ];\n    }\n    static G_RGB([g]) {\n        return [\n            \"RGB\",\n            g,\n            g,\n            g\n        ];\n    }\n    static G_rgb([g]) {\n        g = scaleAndClamp(g);\n        return [\n            g,\n            g,\n            g\n        ];\n    }\n    static G_HTML([g]) {\n        const G = makeColorComp(g);\n        return `#${G}${G}${G}`;\n    }\n    static RGB_G([r, g, b]) {\n        return [\n            \"G\",\n            0.3 * r + 0.59 * g + 0.11 * b\n        ];\n    }\n    static RGB_rgb(color) {\n        return color.map(scaleAndClamp);\n    }\n    static RGB_HTML(color) {\n        return `#${color.map(makeColorComp).join(\"\")}`;\n    }\n    static T_HTML() {\n        return \"#00000000\";\n    }\n    static T_rgb() {\n        return [\n            null\n        ];\n    }\n    static CMYK_RGB([c, y, m, k]) {\n        return [\n            \"RGB\",\n            1 - Math.min(1, c + k),\n            1 - Math.min(1, m + k),\n            1 - Math.min(1, y + k)\n        ];\n    }\n    static CMYK_rgb([c, y, m, k]) {\n        return [\n            scaleAndClamp(1 - Math.min(1, c + k)),\n            scaleAndClamp(1 - Math.min(1, m + k)),\n            scaleAndClamp(1 - Math.min(1, y + k))\n        ];\n    }\n    static CMYK_HTML(components) {\n        const rgb = this.CMYK_RGB(components).slice(1);\n        return this.RGB_HTML(rgb);\n    }\n    static RGB_CMYK([r, g, b]) {\n        const c = 1 - r;\n        const m = 1 - g;\n        const y = 1 - b;\n        const k = Math.min(c, m, y);\n        return [\n            \"CMYK\",\n            c,\n            m,\n            y,\n            k\n        ];\n    }\n}\n; // ./src/display/svg_factory.js\nclass BaseSVGFactory {\n    create(width, height, skipDimensions = false) {\n        if (width <= 0 || height <= 0) {\n            throw new Error(\"Invalid SVG dimensions\");\n        }\n        const svg = this._createSVG(\"svg:svg\");\n        svg.setAttribute(\"version\", \"1.1\");\n        if (!skipDimensions) {\n            svg.setAttribute(\"width\", `${width}px`);\n            svg.setAttribute(\"height\", `${height}px`);\n        }\n        svg.setAttribute(\"preserveAspectRatio\", \"none\");\n        svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n        return svg;\n    }\n    createElement(type) {\n        if (typeof type !== \"string\") {\n            throw new Error(\"Invalid SVG element type\");\n        }\n        return this._createSVG(type);\n    }\n    _createSVG(type) {\n        unreachable(\"Abstract method `_createSVG` called.\");\n    }\n}\nclass DOMSVGFactory extends BaseSVGFactory {\n    _createSVG(type) {\n        return document.createElementNS(SVG_NS, type);\n    }\n}\n; // ./src/display/xfa_layer.js\nclass XfaLayer {\n    static setupStorage(html, id, element, storage, intent) {\n        const storedData = storage.getValue(id, {\n            value: null\n        });\n        switch(element.name){\n            case \"textarea\":\n                if (storedData.value !== null) {\n                    html.textContent = storedData.value;\n                }\n                if (intent === \"print\") {\n                    break;\n                }\n                html.addEventListener(\"input\", (event)=>{\n                    storage.setValue(id, {\n                        value: event.target.value\n                    });\n                });\n                break;\n            case \"input\":\n                if (element.attributes.type === \"radio\" || element.attributes.type === \"checkbox\") {\n                    if (storedData.value === element.attributes.xfaOn) {\n                        html.setAttribute(\"checked\", true);\n                    } else if (storedData.value === element.attributes.xfaOff) {\n                        html.removeAttribute(\"checked\");\n                    }\n                    if (intent === \"print\") {\n                        break;\n                    }\n                    html.addEventListener(\"change\", (event)=>{\n                        storage.setValue(id, {\n                            value: event.target.checked ? event.target.getAttribute(\"xfaOn\") : event.target.getAttribute(\"xfaOff\")\n                        });\n                    });\n                } else {\n                    if (storedData.value !== null) {\n                        html.setAttribute(\"value\", storedData.value);\n                    }\n                    if (intent === \"print\") {\n                        break;\n                    }\n                    html.addEventListener(\"input\", (event)=>{\n                        storage.setValue(id, {\n                            value: event.target.value\n                        });\n                    });\n                }\n                break;\n            case \"select\":\n                if (storedData.value !== null) {\n                    html.setAttribute(\"value\", storedData.value);\n                    for (const option of element.children){\n                        if (option.attributes.value === storedData.value) {\n                            option.attributes.selected = true;\n                        } else if (option.attributes.hasOwnProperty(\"selected\")) {\n                            delete option.attributes.selected;\n                        }\n                    }\n                }\n                html.addEventListener(\"input\", (event)=>{\n                    const options = event.target.options;\n                    const value = options.selectedIndex === -1 ? \"\" : options[options.selectedIndex].value;\n                    storage.setValue(id, {\n                        value\n                    });\n                });\n                break;\n        }\n    }\n    static setAttributes({ html, element, storage = null, intent, linkService }) {\n        const { attributes } = element;\n        const isHTMLAnchorElement = html instanceof HTMLAnchorElement;\n        if (attributes.type === \"radio\") {\n            attributes.name = `${attributes.name}-${intent}`;\n        }\n        for (const [key, value] of Object.entries(attributes)){\n            if (value === null || value === undefined) {\n                continue;\n            }\n            switch(key){\n                case \"class\":\n                    if (value.length) {\n                        html.setAttribute(key, value.join(\" \"));\n                    }\n                    break;\n                case \"dataId\":\n                    break;\n                case \"id\":\n                    html.setAttribute(\"data-element-id\", value);\n                    break;\n                case \"style\":\n                    Object.assign(html.style, value);\n                    break;\n                case \"textContent\":\n                    html.textContent = value;\n                    break;\n                default:\n                    if (!isHTMLAnchorElement || key !== \"href\" && key !== \"newWindow\") {\n                        html.setAttribute(key, value);\n                    }\n            }\n        }\n        if (isHTMLAnchorElement) {\n            linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);\n        }\n        if (storage && attributes.dataId) {\n            this.setupStorage(html, attributes.dataId, element, storage);\n        }\n    }\n    static render(parameters) {\n        const storage = parameters.annotationStorage;\n        const linkService = parameters.linkService;\n        const root = parameters.xfaHtml;\n        const intent = parameters.intent || \"display\";\n        const rootHtml = document.createElement(root.name);\n        if (root.attributes) {\n            this.setAttributes({\n                html: rootHtml,\n                element: root,\n                intent,\n                linkService\n            });\n        }\n        const isNotForRichText = intent !== \"richText\";\n        const rootDiv = parameters.div;\n        rootDiv.append(rootHtml);\n        if (parameters.viewport) {\n            const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n            rootDiv.style.transform = transform;\n        }\n        if (isNotForRichText) {\n            rootDiv.setAttribute(\"class\", \"xfaLayer xfaFont\");\n        }\n        const textDivs = [];\n        if (root.children.length === 0) {\n            if (root.value) {\n                const node = document.createTextNode(root.value);\n                rootHtml.append(node);\n                if (isNotForRichText && XfaText.shouldBuildText(root.name)) {\n                    textDivs.push(node);\n                }\n            }\n            return {\n                textDivs\n            };\n        }\n        const stack = [\n            [\n                root,\n                -1,\n                rootHtml\n            ]\n        ];\n        while(stack.length > 0){\n            const [parent, i, html] = stack.at(-1);\n            if (i + 1 === parent.children.length) {\n                stack.pop();\n                continue;\n            }\n            const child = parent.children[++stack.at(-1)[1]];\n            if (child === null) {\n                continue;\n            }\n            const { name } = child;\n            if (name === \"#text\") {\n                const node = document.createTextNode(child.value);\n                textDivs.push(node);\n                html.append(node);\n                continue;\n            }\n            const childHtml = child?.attributes?.xmlns ? document.createElementNS(child.attributes.xmlns, name) : document.createElement(name);\n            html.append(childHtml);\n            if (child.attributes) {\n                this.setAttributes({\n                    html: childHtml,\n                    element: child,\n                    storage,\n                    intent,\n                    linkService\n                });\n            }\n            if (child.children?.length > 0) {\n                stack.push([\n                    child,\n                    -1,\n                    childHtml\n                ]);\n            } else if (child.value) {\n                const node = document.createTextNode(child.value);\n                if (isNotForRichText && XfaText.shouldBuildText(name)) {\n                    textDivs.push(node);\n                }\n                childHtml.append(node);\n            }\n        }\n        for (const el of rootDiv.querySelectorAll(\".xfaNonInteractive input, .xfaNonInteractive textarea\")){\n            el.setAttribute(\"readOnly\", true);\n        }\n        return {\n            textDivs\n        };\n    }\n    static update(parameters) {\n        const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n        parameters.div.style.transform = transform;\n        parameters.div.hidden = false;\n    }\n}\n; // ./src/display/annotation_layer.js\nconst DEFAULT_TAB_INDEX = 1000;\nconst annotation_layer_DEFAULT_FONT_SIZE = 9;\nconst GetElementsByNameSet = new WeakSet();\nclass AnnotationElementFactory {\n    static create(parameters) {\n        const subtype = parameters.data.annotationType;\n        switch(subtype){\n            case AnnotationType.LINK:\n                return new LinkAnnotationElement(parameters);\n            case AnnotationType.TEXT:\n                return new TextAnnotationElement(parameters);\n            case AnnotationType.WIDGET:\n                const fieldType = parameters.data.fieldType;\n                switch(fieldType){\n                    case \"Tx\":\n                        return new TextWidgetAnnotationElement(parameters);\n                    case \"Btn\":\n                        if (parameters.data.radioButton) {\n                            return new RadioButtonWidgetAnnotationElement(parameters);\n                        } else if (parameters.data.checkBox) {\n                            return new CheckboxWidgetAnnotationElement(parameters);\n                        }\n                        return new PushButtonWidgetAnnotationElement(parameters);\n                    case \"Ch\":\n                        return new ChoiceWidgetAnnotationElement(parameters);\n                    case \"Sig\":\n                        return new SignatureWidgetAnnotationElement(parameters);\n                }\n                return new WidgetAnnotationElement(parameters);\n            case AnnotationType.POPUP:\n                return new PopupAnnotationElement(parameters);\n            case AnnotationType.FREETEXT:\n                return new FreeTextAnnotationElement(parameters);\n            case AnnotationType.LINE:\n                return new LineAnnotationElement(parameters);\n            case AnnotationType.SQUARE:\n                return new SquareAnnotationElement(parameters);\n            case AnnotationType.CIRCLE:\n                return new CircleAnnotationElement(parameters);\n            case AnnotationType.POLYLINE:\n                return new PolylineAnnotationElement(parameters);\n            case AnnotationType.CARET:\n                return new CaretAnnotationElement(parameters);\n            case AnnotationType.INK:\n                return new InkAnnotationElement(parameters);\n            case AnnotationType.POLYGON:\n                return new PolygonAnnotationElement(parameters);\n            case AnnotationType.HIGHLIGHT:\n                return new HighlightAnnotationElement(parameters);\n            case AnnotationType.UNDERLINE:\n                return new UnderlineAnnotationElement(parameters);\n            case AnnotationType.SQUIGGLY:\n                return new SquigglyAnnotationElement(parameters);\n            case AnnotationType.STRIKEOUT:\n                return new StrikeOutAnnotationElement(parameters);\n            case AnnotationType.STAMP:\n                return new StampAnnotationElement(parameters);\n            case AnnotationType.FILEATTACHMENT:\n                return new FileAttachmentAnnotationElement(parameters);\n            default:\n                return new AnnotationElement(parameters);\n        }\n    }\n}\nclass AnnotationElement {\n    #updates;\n    #hasBorder;\n    #popupElement;\n    constructor(parameters, { isRenderable = false, ignoreBorder = false, createQuadrilaterals = false } = {}){\n        this.#updates = null;\n        this.#hasBorder = false;\n        this.#popupElement = null;\n        this.isRenderable = isRenderable;\n        this.data = parameters.data;\n        this.layer = parameters.layer;\n        this.linkService = parameters.linkService;\n        this.downloadManager = parameters.downloadManager;\n        this.imageResourcesPath = parameters.imageResourcesPath;\n        this.renderForms = parameters.renderForms;\n        this.svgFactory = parameters.svgFactory;\n        this.annotationStorage = parameters.annotationStorage;\n        this.enableScripting = parameters.enableScripting;\n        this.hasJSActions = parameters.hasJSActions;\n        this._fieldObjects = parameters.fieldObjects;\n        this.parent = parameters.parent;\n        if (isRenderable) {\n            this.container = this._createContainer(ignoreBorder);\n        }\n        if (createQuadrilaterals) {\n            this._createQuadrilaterals();\n        }\n    }\n    static _hasPopupData({ titleObj, contentsObj, richText }) {\n        return !!(titleObj?.str || contentsObj?.str || richText?.str);\n    }\n    get _isEditable() {\n        return this.data.isEditable;\n    }\n    get hasPopupData() {\n        return AnnotationElement._hasPopupData(this.data);\n    }\n    updateEdited(params) {\n        if (!this.container) {\n            return;\n        }\n        this.#updates ||= {\n            rect: this.data.rect.slice(0)\n        };\n        const { rect } = params;\n        if (rect) {\n            this.#setRectEdited(rect);\n        }\n        this.#popupElement?.popup.updateEdited(params);\n    }\n    resetEdited() {\n        if (!this.#updates) {\n            return;\n        }\n        this.#setRectEdited(this.#updates.rect);\n        this.#popupElement?.popup.resetEdited();\n        this.#updates = null;\n    }\n    #setRectEdited(rect) {\n        const { container: { style }, data: { rect: currentRect, rotation }, parent: { viewport: { rawDims: { pageWidth, pageHeight, pageX, pageY } } } } = this;\n        currentRect?.splice(0, 4, ...rect);\n        style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;\n        style.top = `${100 * (pageHeight - rect[3] + pageY) / pageHeight}%`;\n        if (rotation === 0) {\n            style.width = `${100 * (rect[2] - rect[0]) / pageWidth}%`;\n            style.height = `${100 * (rect[3] - rect[1]) / pageHeight}%`;\n        } else {\n            this.setRotation(rotation);\n        }\n    }\n    _createContainer(ignoreBorder) {\n        const { data, parent: { page, viewport } } = this;\n        const container = document.createElement(\"section\");\n        container.setAttribute(\"data-annotation-id\", data.id);\n        if (!(this instanceof WidgetAnnotationElement)) {\n            container.tabIndex = DEFAULT_TAB_INDEX;\n        }\n        const { style } = container;\n        style.zIndex = this.parent.zIndex++;\n        if (data.alternativeText) {\n            container.title = data.alternativeText;\n        }\n        if (data.noRotate) {\n            container.classList.add(\"norotate\");\n        }\n        if (!data.rect || this instanceof PopupAnnotationElement) {\n            const { rotation } = data;\n            if (!data.hasOwnCanvas && rotation !== 0) {\n                this.setRotation(rotation, container);\n            }\n            return container;\n        }\n        const { width, height } = this;\n        if (!ignoreBorder && data.borderStyle.width > 0) {\n            style.borderWidth = `${data.borderStyle.width}px`;\n            const horizontalRadius = data.borderStyle.horizontalCornerRadius;\n            const verticalRadius = data.borderStyle.verticalCornerRadius;\n            if (horizontalRadius > 0 || verticalRadius > 0) {\n                const radius = `calc(${horizontalRadius}px * var(--total-scale-factor)) / calc(${verticalRadius}px * var(--total-scale-factor))`;\n                style.borderRadius = radius;\n            } else if (this instanceof RadioButtonWidgetAnnotationElement) {\n                const radius = `calc(${width}px * var(--total-scale-factor)) / calc(${height}px * var(--total-scale-factor))`;\n                style.borderRadius = radius;\n            }\n            switch(data.borderStyle.style){\n                case AnnotationBorderStyleType.SOLID:\n                    style.borderStyle = \"solid\";\n                    break;\n                case AnnotationBorderStyleType.DASHED:\n                    style.borderStyle = \"dashed\";\n                    break;\n                case AnnotationBorderStyleType.BEVELED:\n                    warn(\"Unimplemented border style: beveled\");\n                    break;\n                case AnnotationBorderStyleType.INSET:\n                    warn(\"Unimplemented border style: inset\");\n                    break;\n                case AnnotationBorderStyleType.UNDERLINE:\n                    style.borderBottomStyle = \"solid\";\n                    break;\n                default:\n                    break;\n            }\n            const borderColor = data.borderColor || null;\n            if (borderColor) {\n                this.#hasBorder = true;\n                style.borderColor = Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);\n            } else {\n                style.borderWidth = 0;\n            }\n        }\n        const rect = Util.normalizeRect([\n            data.rect[0],\n            page.view[3] - data.rect[1] + page.view[1],\n            data.rect[2],\n            page.view[3] - data.rect[3] + page.view[1]\n        ]);\n        const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims;\n        style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;\n        style.top = `${100 * (rect[1] - pageY) / pageHeight}%`;\n        const { rotation } = data;\n        if (data.hasOwnCanvas || rotation === 0) {\n            style.width = `${100 * width / pageWidth}%`;\n            style.height = `${100 * height / pageHeight}%`;\n        } else {\n            this.setRotation(rotation, container);\n        }\n        return container;\n    }\n    setRotation(angle, container = this.container) {\n        if (!this.data.rect) {\n            return;\n        }\n        const { pageWidth, pageHeight } = this.parent.viewport.rawDims;\n        let { width, height } = this;\n        if (angle % 180 !== 0) {\n            [width, height] = [\n                height,\n                width\n            ];\n        }\n        container.style.width = `${100 * width / pageWidth}%`;\n        container.style.height = `${100 * height / pageHeight}%`;\n        container.setAttribute(\"data-main-rotation\", (360 - angle) % 360);\n    }\n    get _commonActions() {\n        const setColor = (jsName, styleName, event)=>{\n            const color = event.detail[jsName];\n            const colorType = color[0];\n            const colorArray = color.slice(1);\n            event.target.style[styleName] = ColorConverters[`${colorType}_HTML`](colorArray);\n            this.annotationStorage.setValue(this.data.id, {\n                [styleName]: ColorConverters[`${colorType}_rgb`](colorArray)\n            });\n        };\n        return shadow(this, \"_commonActions\", {\n            display: (event)=>{\n                const { display } = event.detail;\n                const hidden = display % 2 === 1;\n                this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n                this.annotationStorage.setValue(this.data.id, {\n                    noView: hidden,\n                    noPrint: display === 1 || display === 2\n                });\n            },\n            print: (event)=>{\n                this.annotationStorage.setValue(this.data.id, {\n                    noPrint: !event.detail.print\n                });\n            },\n            hidden: (event)=>{\n                const { hidden } = event.detail;\n                this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n                this.annotationStorage.setValue(this.data.id, {\n                    noPrint: hidden,\n                    noView: hidden\n                });\n            },\n            focus: (event)=>{\n                setTimeout(()=>event.target.focus({\n                        preventScroll: false\n                    }), 0);\n            },\n            userName: (event)=>{\n                event.target.title = event.detail.userName;\n            },\n            readonly: (event)=>{\n                event.target.disabled = event.detail.readonly;\n            },\n            required: (event)=>{\n                this._setRequired(event.target, event.detail.required);\n            },\n            bgColor: (event)=>{\n                setColor(\"bgColor\", \"backgroundColor\", event);\n            },\n            fillColor: (event)=>{\n                setColor(\"fillColor\", \"backgroundColor\", event);\n            },\n            fgColor: (event)=>{\n                setColor(\"fgColor\", \"color\", event);\n            },\n            textColor: (event)=>{\n                setColor(\"textColor\", \"color\", event);\n            },\n            borderColor: (event)=>{\n                setColor(\"borderColor\", \"borderColor\", event);\n            },\n            strokeColor: (event)=>{\n                setColor(\"strokeColor\", \"borderColor\", event);\n            },\n            rotation: (event)=>{\n                const angle = event.detail.rotation;\n                this.setRotation(angle);\n                this.annotationStorage.setValue(this.data.id, {\n                    rotation: angle\n                });\n            }\n        });\n    }\n    _dispatchEventFromSandbox(actions, jsEvent) {\n        const commonActions = this._commonActions;\n        for (const name of Object.keys(jsEvent.detail)){\n            const action = actions[name] || commonActions[name];\n            action?.(jsEvent);\n        }\n    }\n    _setDefaultPropertiesFromJS(element) {\n        if (!this.enableScripting) {\n            return;\n        }\n        const storedData = this.annotationStorage.getRawValue(this.data.id);\n        if (!storedData) {\n            return;\n        }\n        const commonActions = this._commonActions;\n        for (const [actionName, detail] of Object.entries(storedData)){\n            const action = commonActions[actionName];\n            if (action) {\n                const eventProxy = {\n                    detail: {\n                        [actionName]: detail\n                    },\n                    target: element\n                };\n                action(eventProxy);\n                delete storedData[actionName];\n            }\n        }\n    }\n    _createQuadrilaterals() {\n        if (!this.container) {\n            return;\n        }\n        const { quadPoints } = this.data;\n        if (!quadPoints) {\n            return;\n        }\n        const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect.map((x)=>Math.fround(x));\n        if (quadPoints.length === 8) {\n            const [trX, trY, blX, blY] = quadPoints.subarray(2, 6);\n            if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) {\n                return;\n            }\n        }\n        const { style } = this.container;\n        let svgBuffer;\n        if (this.#hasBorder) {\n            const { borderColor, borderWidth } = style;\n            style.borderWidth = 0;\n            svgBuffer = [\n                \"url('data:image/svg+xml;utf8,\",\n                `<svg xmlns=\"http://www.w3.org/2000/svg\"`,\n                ` preserveAspectRatio=\"none\" viewBox=\"0 0 1 1\">`,\n                `<g fill=\"transparent\" stroke=\"${borderColor}\" stroke-width=\"${borderWidth}\">`\n            ];\n            this.container.classList.add(\"hasBorder\");\n        }\n        const width = rectTrX - rectBlX;\n        const height = rectTrY - rectBlY;\n        const { svgFactory } = this;\n        const svg = svgFactory.createElement(\"svg\");\n        svg.classList.add(\"quadrilateralsContainer\");\n        svg.setAttribute(\"width\", 0);\n        svg.setAttribute(\"height\", 0);\n        const defs = svgFactory.createElement(\"defs\");\n        svg.append(defs);\n        const clipPath = svgFactory.createElement(\"clipPath\");\n        const id = `clippath_${this.data.id}`;\n        clipPath.setAttribute(\"id\", id);\n        clipPath.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n        defs.append(clipPath);\n        for(let i = 2, ii = quadPoints.length; i < ii; i += 8){\n            const trX = quadPoints[i];\n            const trY = quadPoints[i + 1];\n            const blX = quadPoints[i + 2];\n            const blY = quadPoints[i + 3];\n            const rect = svgFactory.createElement(\"rect\");\n            const x = (blX - rectBlX) / width;\n            const y = (rectTrY - trY) / height;\n            const rectWidth = (trX - blX) / width;\n            const rectHeight = (trY - blY) / height;\n            rect.setAttribute(\"x\", x);\n            rect.setAttribute(\"y\", y);\n            rect.setAttribute(\"width\", rectWidth);\n            rect.setAttribute(\"height\", rectHeight);\n            clipPath.append(rect);\n            svgBuffer?.push(`<rect vector-effect=\"non-scaling-stroke\" x=\"${x}\" y=\"${y}\" width=\"${rectWidth}\" height=\"${rectHeight}\"/>`);\n        }\n        if (this.#hasBorder) {\n            svgBuffer.push(`</g></svg>')`);\n            style.backgroundImage = svgBuffer.join(\"\");\n        }\n        this.container.append(svg);\n        this.container.style.clipPath = `url(#${id})`;\n    }\n    _createPopup() {\n        const { data } = this;\n        const popup = this.#popupElement = new PopupAnnotationElement({\n            data: {\n                color: data.color,\n                titleObj: data.titleObj,\n                modificationDate: data.modificationDate,\n                contentsObj: data.contentsObj,\n                richText: data.richText,\n                parentRect: data.rect,\n                borderStyle: 0,\n                id: `popup_${data.id}`,\n                rotation: data.rotation\n            },\n            parent: this.parent,\n            elements: [\n                this\n            ]\n        });\n        this.parent.div.append(popup.render());\n    }\n    render() {\n        unreachable(\"Abstract method `AnnotationElement.render` called\");\n    }\n    _getElementsByName(name, skipId = null) {\n        const fields = [];\n        if (this._fieldObjects) {\n            const fieldObj = this._fieldObjects[name];\n            if (fieldObj) {\n                for (const { page, id, exportValues } of fieldObj){\n                    if (page === -1) {\n                        continue;\n                    }\n                    if (id === skipId) {\n                        continue;\n                    }\n                    const exportValue = typeof exportValues === \"string\" ? exportValues : null;\n                    const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n                    if (domElement && !GetElementsByNameSet.has(domElement)) {\n                        warn(`_getElementsByName - element not allowed: ${id}`);\n                        continue;\n                    }\n                    fields.push({\n                        id,\n                        exportValue,\n                        domElement\n                    });\n                }\n            }\n            return fields;\n        }\n        for (const domElement of document.getElementsByName(name)){\n            const { exportValue } = domElement;\n            const id = domElement.getAttribute(\"data-element-id\");\n            if (id === skipId) {\n                continue;\n            }\n            if (!GetElementsByNameSet.has(domElement)) {\n                continue;\n            }\n            fields.push({\n                id,\n                exportValue,\n                domElement\n            });\n        }\n        return fields;\n    }\n    show() {\n        if (this.container) {\n            this.container.hidden = false;\n        }\n        this.popup?.maybeShow();\n    }\n    hide() {\n        if (this.container) {\n            this.container.hidden = true;\n        }\n        this.popup?.forceHide();\n    }\n    getElementsToTriggerPopup() {\n        return this.container;\n    }\n    addHighlightArea() {\n        const triggers = this.getElementsToTriggerPopup();\n        if (Array.isArray(triggers)) {\n            for (const element of triggers){\n                element.classList.add(\"highlightArea\");\n            }\n        } else {\n            triggers.classList.add(\"highlightArea\");\n        }\n    }\n    _editOnDoubleClick() {\n        if (!this._isEditable) {\n            return;\n        }\n        const { annotationEditorType: mode, data: { id: editId } } = this;\n        this.container.addEventListener(\"dblclick\", ()=>{\n            this.linkService.eventBus?.dispatch(\"switchannotationeditormode\", {\n                source: this,\n                mode,\n                editId\n            });\n        });\n    }\n    get width() {\n        return this.data.rect[2] - this.data.rect[0];\n    }\n    get height() {\n        return this.data.rect[3] - this.data.rect[1];\n    }\n}\nclass LinkAnnotationElement extends AnnotationElement {\n    constructor(parameters, options = null){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: !!options?.ignoreBorder,\n            createQuadrilaterals: true\n        });\n        this.isTooltipOnly = parameters.data.isTooltipOnly;\n    }\n    render() {\n        const { data, linkService } = this;\n        const link = document.createElement(\"a\");\n        link.setAttribute(\"data-element-id\", data.id);\n        let isBound = false;\n        if (data.url) {\n            linkService.addLinkAttributes(link, data.url, data.newWindow);\n            isBound = true;\n        } else if (data.action) {\n            this._bindNamedAction(link, data.action);\n            isBound = true;\n        } else if (data.attachment) {\n            this.#bindAttachment(link, data.attachment, data.attachmentDest);\n            isBound = true;\n        } else if (data.setOCGState) {\n            this.#bindSetOCGState(link, data.setOCGState);\n            isBound = true;\n        } else if (data.dest) {\n            this._bindLink(link, data.dest);\n            isBound = true;\n        } else {\n            if (data.actions && (data.actions.Action || data.actions[\"Mouse Up\"] || data.actions[\"Mouse Down\"]) && this.enableScripting && this.hasJSActions) {\n                this._bindJSAction(link, data);\n                isBound = true;\n            }\n            if (data.resetForm) {\n                this._bindResetFormAction(link, data.resetForm);\n                isBound = true;\n            } else if (this.isTooltipOnly && !isBound) {\n                this._bindLink(link, \"\");\n                isBound = true;\n            }\n        }\n        this.container.classList.add(\"linkAnnotation\");\n        if (isBound) {\n            this.container.append(link);\n        }\n        return this.container;\n    }\n    #setInternalLink() {\n        this.container.setAttribute(\"data-internal-link\", \"\");\n    }\n    _bindLink(link, destination) {\n        link.href = this.linkService.getDestinationHash(destination);\n        link.onclick = ()=>{\n            if (destination) {\n                this.linkService.goToDestination(destination);\n            }\n            return false;\n        };\n        if (destination || destination === \"\") {\n            this.#setInternalLink();\n        }\n    }\n    _bindNamedAction(link, action) {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        link.onclick = ()=>{\n            this.linkService.executeNamedAction(action);\n            return false;\n        };\n        this.#setInternalLink();\n    }\n    #bindAttachment(link, attachment, dest = null) {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        if (attachment.description) {\n            link.title = attachment.description;\n        }\n        link.onclick = ()=>{\n            this.downloadManager?.openOrDownloadData(attachment.content, attachment.filename, dest);\n            return false;\n        };\n        this.#setInternalLink();\n    }\n    #bindSetOCGState(link, action) {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        link.onclick = ()=>{\n            this.linkService.executeSetOCGState(action);\n            return false;\n        };\n        this.#setInternalLink();\n    }\n    _bindJSAction(link, data) {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        const map = new Map([\n            [\n                \"Action\",\n                \"onclick\"\n            ],\n            [\n                \"Mouse Up\",\n                \"onmouseup\"\n            ],\n            [\n                \"Mouse Down\",\n                \"onmousedown\"\n            ]\n        ]);\n        for (const name of Object.keys(data.actions)){\n            const jsName = map.get(name);\n            if (!jsName) {\n                continue;\n            }\n            link[jsName] = ()=>{\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: data.id,\n                        name\n                    }\n                });\n                return false;\n            };\n        }\n        if (!link.onclick) {\n            link.onclick = ()=>false;\n        }\n        this.#setInternalLink();\n    }\n    _bindResetFormAction(link, resetForm) {\n        const otherClickAction = link.onclick;\n        if (!otherClickAction) {\n            link.href = this.linkService.getAnchorUrl(\"\");\n        }\n        this.#setInternalLink();\n        if (!this._fieldObjects) {\n            warn(`_bindResetFormAction - \"resetForm\" action not supported, ` + \"ensure that the `fieldObjects` parameter is provided.\");\n            if (!otherClickAction) {\n                link.onclick = ()=>false;\n            }\n            return;\n        }\n        link.onclick = ()=>{\n            otherClickAction?.();\n            const { fields: resetFormFields, refs: resetFormRefs, include } = resetForm;\n            const allFields = [];\n            if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {\n                const fieldIds = new Set(resetFormRefs);\n                for (const fieldName of resetFormFields){\n                    const fields = this._fieldObjects[fieldName] || [];\n                    for (const { id } of fields){\n                        fieldIds.add(id);\n                    }\n                }\n                for (const fields of Object.values(this._fieldObjects)){\n                    for (const field of fields){\n                        if (fieldIds.has(field.id) === include) {\n                            allFields.push(field);\n                        }\n                    }\n                }\n            } else {\n                for (const fields of Object.values(this._fieldObjects)){\n                    allFields.push(...fields);\n                }\n            }\n            const storage = this.annotationStorage;\n            const allIds = [];\n            for (const field of allFields){\n                const { id } = field;\n                allIds.push(id);\n                switch(field.type){\n                    case \"text\":\n                        {\n                            const value = field.defaultValue || \"\";\n                            storage.setValue(id, {\n                                value\n                            });\n                            break;\n                        }\n                    case \"checkbox\":\n                    case \"radiobutton\":\n                        {\n                            const value = field.defaultValue === field.exportValues;\n                            storage.setValue(id, {\n                                value\n                            });\n                            break;\n                        }\n                    case \"combobox\":\n                    case \"listbox\":\n                        {\n                            const value = field.defaultValue || \"\";\n                            storage.setValue(id, {\n                                value\n                            });\n                            break;\n                        }\n                    default:\n                        continue;\n                }\n                const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n                if (!domElement) {\n                    continue;\n                } else if (!GetElementsByNameSet.has(domElement)) {\n                    warn(`_bindResetFormAction - element not allowed: ${id}`);\n                    continue;\n                }\n                domElement.dispatchEvent(new Event(\"resetform\"));\n            }\n            if (this.enableScripting) {\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: \"app\",\n                        ids: allIds,\n                        name: \"ResetForm\"\n                    }\n                });\n            }\n            return false;\n        };\n    }\n}\nclass TextAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true\n        });\n    }\n    render() {\n        this.container.classList.add(\"textAnnotation\");\n        const image = document.createElement(\"img\");\n        image.src = this.imageResourcesPath + \"annotation-\" + this.data.name.toLowerCase() + \".svg\";\n        image.setAttribute(\"data-l10n-id\", \"pdfjs-text-annotation-type\");\n        image.setAttribute(\"data-l10n-args\", JSON.stringify({\n            type: this.data.name\n        }));\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.append(image);\n        return this.container;\n    }\n}\nclass WidgetAnnotationElement extends AnnotationElement {\n    render() {\n        return this.container;\n    }\n    showElementAndHideCanvas(element) {\n        if (this.data.hasOwnCanvas) {\n            if (element.previousSibling?.nodeName === \"CANVAS\") {\n                element.previousSibling.hidden = true;\n            }\n            element.hidden = false;\n        }\n    }\n    _getKeyModifier(event) {\n        return util_FeatureTest.platform.isMac ? event.metaKey : event.ctrlKey;\n    }\n    _setEventListener(element, elementData, baseName, eventName, valueGetter) {\n        if (baseName.includes(\"mouse\")) {\n            element.addEventListener(baseName, (event)=>{\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: this.data.id,\n                        name: eventName,\n                        value: valueGetter(event),\n                        shift: event.shiftKey,\n                        modifier: this._getKeyModifier(event)\n                    }\n                });\n            });\n        } else {\n            element.addEventListener(baseName, (event)=>{\n                if (baseName === \"blur\") {\n                    if (!elementData.focused || !event.relatedTarget) {\n                        return;\n                    }\n                    elementData.focused = false;\n                } else if (baseName === \"focus\") {\n                    if (elementData.focused) {\n                        return;\n                    }\n                    elementData.focused = true;\n                }\n                if (!valueGetter) {\n                    return;\n                }\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: this.data.id,\n                        name: eventName,\n                        value: valueGetter(event)\n                    }\n                });\n            });\n        }\n    }\n    _setEventListeners(element, elementData, names, getter) {\n        for (const [baseName, eventName] of names){\n            if (eventName === \"Action\" || this.data.actions?.[eventName]) {\n                if (eventName === \"Focus\" || eventName === \"Blur\") {\n                    elementData ||= {\n                        focused: false\n                    };\n                }\n                this._setEventListener(element, elementData, baseName, eventName, getter);\n                if (eventName === \"Focus\" && !this.data.actions?.Blur) {\n                    this._setEventListener(element, elementData, \"blur\", \"Blur\", null);\n                } else if (eventName === \"Blur\" && !this.data.actions?.Focus) {\n                    this._setEventListener(element, elementData, \"focus\", \"Focus\", null);\n                }\n            }\n        }\n    }\n    _setBackgroundColor(element) {\n        const color = this.data.backgroundColor || null;\n        element.style.backgroundColor = color === null ? \"transparent\" : Util.makeHexColor(color[0], color[1], color[2]);\n    }\n    _setTextStyle(element) {\n        const TEXT_ALIGNMENT = [\n            \"left\",\n            \"center\",\n            \"right\"\n        ];\n        const { fontColor } = this.data.defaultAppearanceData;\n        const fontSize = this.data.defaultAppearanceData.fontSize || annotation_layer_DEFAULT_FONT_SIZE;\n        const style = element.style;\n        let computedFontSize;\n        const BORDER_SIZE = 2;\n        const roundToOneDecimal = (x)=>Math.round(10 * x) / 10;\n        if (this.data.multiLine) {\n            const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n            const numberOfLines = Math.round(height / (LINE_FACTOR * fontSize)) || 1;\n            const lineHeight = height / numberOfLines;\n            computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / LINE_FACTOR));\n        } else {\n            const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n            computedFontSize = Math.min(fontSize, roundToOneDecimal(height / LINE_FACTOR));\n        }\n        style.fontSize = `calc(${computedFontSize}px * var(--total-scale-factor))`;\n        style.color = Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);\n        if (this.data.textAlignment !== null) {\n            style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\n        }\n    }\n    _setRequired(element, isRequired) {\n        if (isRequired) {\n            element.setAttribute(\"required\", true);\n        } else {\n            element.removeAttribute(\"required\");\n        }\n        element.setAttribute(\"aria-required\", isRequired);\n    }\n}\nclass TextWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        const isRenderable = parameters.renderForms || parameters.data.hasOwnCanvas || !parameters.data.hasAppearance && !!parameters.data.fieldValue;\n        super(parameters, {\n            isRenderable\n        });\n    }\n    setPropertyOnSiblings(base, key, value, keyInStorage) {\n        const storage = this.annotationStorage;\n        for (const element of this._getElementsByName(base.name, base.id)){\n            if (element.domElement) {\n                element.domElement[key] = value;\n            }\n            storage.setValue(element.id, {\n                [keyInStorage]: value\n            });\n        }\n    }\n    render() {\n        const storage = this.annotationStorage;\n        const id = this.data.id;\n        this.container.classList.add(\"textWidgetAnnotation\");\n        let element = null;\n        if (this.renderForms) {\n            const storedData = storage.getValue(id, {\n                value: this.data.fieldValue\n            });\n            let textContent = storedData.value || \"\";\n            const maxLen = storage.getValue(id, {\n                charLimit: this.data.maxLen\n            }).charLimit;\n            if (maxLen && textContent.length > maxLen) {\n                textContent = textContent.slice(0, maxLen);\n            }\n            let fieldFormattedValues = storedData.formattedValue || this.data.textContent?.join(\"\\n\") || null;\n            if (fieldFormattedValues && this.data.comb) {\n                fieldFormattedValues = fieldFormattedValues.replaceAll(/\\s+/g, \"\");\n            }\n            const elementData = {\n                userValue: textContent,\n                formattedValue: fieldFormattedValues,\n                lastCommittedValue: null,\n                commitKey: 1,\n                focused: false\n            };\n            if (this.data.multiLine) {\n                element = document.createElement(\"textarea\");\n                element.textContent = fieldFormattedValues ?? textContent;\n                if (this.data.doNotScroll) {\n                    element.style.overflowY = \"hidden\";\n                }\n            } else {\n                element = document.createElement(\"input\");\n                element.type = this.data.password ? \"password\" : \"text\";\n                element.setAttribute(\"value\", fieldFormattedValues ?? textContent);\n                if (this.data.doNotScroll) {\n                    element.style.overflowX = \"hidden\";\n                }\n            }\n            if (this.data.hasOwnCanvas) {\n                element.hidden = true;\n            }\n            GetElementsByNameSet.add(element);\n            element.setAttribute(\"data-element-id\", id);\n            element.disabled = this.data.readOnly;\n            element.name = this.data.fieldName;\n            element.tabIndex = DEFAULT_TAB_INDEX;\n            this._setRequired(element, this.data.required);\n            if (maxLen) {\n                element.maxLength = maxLen;\n            }\n            element.addEventListener(\"input\", (event)=>{\n                storage.setValue(id, {\n                    value: event.target.value\n                });\n                this.setPropertyOnSiblings(element, \"value\", event.target.value, \"value\");\n                elementData.formattedValue = null;\n            });\n            element.addEventListener(\"resetform\", (event)=>{\n                const defaultValue = this.data.defaultFieldValue ?? \"\";\n                element.value = elementData.userValue = defaultValue;\n                elementData.formattedValue = null;\n            });\n            let blurListener = (event)=>{\n                const { formattedValue } = elementData;\n                if (formattedValue !== null && formattedValue !== undefined) {\n                    event.target.value = formattedValue;\n                }\n                event.target.scrollLeft = 0;\n            };\n            if (this.enableScripting && this.hasJSActions) {\n                element.addEventListener(\"focus\", (event)=>{\n                    if (elementData.focused) {\n                        return;\n                    }\n                    const { target } = event;\n                    if (elementData.userValue) {\n                        target.value = elementData.userValue;\n                    }\n                    elementData.lastCommittedValue = target.value;\n                    elementData.commitKey = 1;\n                    if (!this.data.actions?.Focus) {\n                        elementData.focused = true;\n                    }\n                });\n                element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                    this.showElementAndHideCanvas(jsEvent.target);\n                    const actions = {\n                        value (event) {\n                            elementData.userValue = event.detail.value ?? \"\";\n                            storage.setValue(id, {\n                                value: elementData.userValue.toString()\n                            });\n                            event.target.value = elementData.userValue;\n                        },\n                        formattedValue (event) {\n                            const { formattedValue } = event.detail;\n                            elementData.formattedValue = formattedValue;\n                            if (formattedValue !== null && formattedValue !== undefined && event.target !== document.activeElement) {\n                                event.target.value = formattedValue;\n                            }\n                            storage.setValue(id, {\n                                formattedValue\n                            });\n                        },\n                        selRange (event) {\n                            event.target.setSelectionRange(...event.detail.selRange);\n                        },\n                        charLimit: (event)=>{\n                            const { charLimit } = event.detail;\n                            const { target } = event;\n                            if (charLimit === 0) {\n                                target.removeAttribute(\"maxLength\");\n                                return;\n                            }\n                            target.setAttribute(\"maxLength\", charLimit);\n                            let value = elementData.userValue;\n                            if (!value || value.length <= charLimit) {\n                                return;\n                            }\n                            value = value.slice(0, charLimit);\n                            target.value = elementData.userValue = value;\n                            storage.setValue(id, {\n                                value\n                            });\n                            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                source: this,\n                                detail: {\n                                    id,\n                                    name: \"Keystroke\",\n                                    value,\n                                    willCommit: true,\n                                    commitKey: 1,\n                                    selStart: target.selectionStart,\n                                    selEnd: target.selectionEnd\n                                }\n                            });\n                        }\n                    };\n                    this._dispatchEventFromSandbox(actions, jsEvent);\n                });\n                element.addEventListener(\"keydown\", (event)=>{\n                    elementData.commitKey = 1;\n                    let commitKey = -1;\n                    if (event.key === \"Escape\") {\n                        commitKey = 0;\n                    } else if (event.key === \"Enter\" && !this.data.multiLine) {\n                        commitKey = 2;\n                    } else if (event.key === \"Tab\") {\n                        elementData.commitKey = 3;\n                    }\n                    if (commitKey === -1) {\n                        return;\n                    }\n                    const { value } = event.target;\n                    if (elementData.lastCommittedValue === value) {\n                        return;\n                    }\n                    elementData.lastCommittedValue = value;\n                    elementData.userValue = value;\n                    this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                        source: this,\n                        detail: {\n                            id,\n                            name: \"Keystroke\",\n                            value,\n                            willCommit: true,\n                            commitKey,\n                            selStart: event.target.selectionStart,\n                            selEnd: event.target.selectionEnd\n                        }\n                    });\n                });\n                const _blurListener = blurListener;\n                blurListener = null;\n                element.addEventListener(\"blur\", (event)=>{\n                    if (!elementData.focused || !event.relatedTarget) {\n                        return;\n                    }\n                    if (!this.data.actions?.Blur) {\n                        elementData.focused = false;\n                    }\n                    const { value } = event.target;\n                    elementData.userValue = value;\n                    if (elementData.lastCommittedValue !== value) {\n                        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                            source: this,\n                            detail: {\n                                id,\n                                name: \"Keystroke\",\n                                value,\n                                willCommit: true,\n                                commitKey: elementData.commitKey,\n                                selStart: event.target.selectionStart,\n                                selEnd: event.target.selectionEnd\n                            }\n                        });\n                    }\n                    _blurListener(event);\n                });\n                if (this.data.actions?.Keystroke) {\n                    element.addEventListener(\"beforeinput\", (event)=>{\n                        elementData.lastCommittedValue = null;\n                        const { data, target } = event;\n                        const { value, selectionStart, selectionEnd } = target;\n                        let selStart = selectionStart, selEnd = selectionEnd;\n                        switch(event.inputType){\n                            case \"deleteWordBackward\":\n                                {\n                                    const match = value.substring(0, selectionStart).match(/\\w*[^\\w]*$/);\n                                    if (match) {\n                                        selStart -= match[0].length;\n                                    }\n                                    break;\n                                }\n                            case \"deleteWordForward\":\n                                {\n                                    const match = value.substring(selectionStart).match(/^[^\\w]*\\w*/);\n                                    if (match) {\n                                        selEnd += match[0].length;\n                                    }\n                                    break;\n                                }\n                            case \"deleteContentBackward\":\n                                if (selectionStart === selectionEnd) {\n                                    selStart -= 1;\n                                }\n                                break;\n                            case \"deleteContentForward\":\n                                if (selectionStart === selectionEnd) {\n                                    selEnd += 1;\n                                }\n                                break;\n                        }\n                        event.preventDefault();\n                        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                            source: this,\n                            detail: {\n                                id,\n                                name: \"Keystroke\",\n                                value,\n                                change: data || \"\",\n                                willCommit: false,\n                                selStart,\n                                selEnd\n                            }\n                        });\n                    });\n                }\n                this._setEventListeners(element, elementData, [\n                    [\n                        \"focus\",\n                        \"Focus\"\n                    ],\n                    [\n                        \"blur\",\n                        \"Blur\"\n                    ],\n                    [\n                        \"mousedown\",\n                        \"Mouse Down\"\n                    ],\n                    [\n                        \"mouseenter\",\n                        \"Mouse Enter\"\n                    ],\n                    [\n                        \"mouseleave\",\n                        \"Mouse Exit\"\n                    ],\n                    [\n                        \"mouseup\",\n                        \"Mouse Up\"\n                    ]\n                ], (event)=>event.target.value);\n            }\n            if (blurListener) {\n                element.addEventListener(\"blur\", blurListener);\n            }\n            if (this.data.comb) {\n                const fieldWidth = this.data.rect[2] - this.data.rect[0];\n                const combWidth = fieldWidth / maxLen;\n                element.classList.add(\"comb\");\n                element.style.letterSpacing = `calc(${combWidth}px * var(--total-scale-factor) - 1ch)`;\n            }\n        } else {\n            element = document.createElement(\"div\");\n            element.textContent = this.data.fieldValue;\n            element.style.verticalAlign = \"middle\";\n            element.style.display = \"table-cell\";\n            if (this.data.hasOwnCanvas) {\n                element.hidden = true;\n            }\n        }\n        this._setTextStyle(element);\n        this._setBackgroundColor(element);\n        this._setDefaultPropertiesFromJS(element);\n        this.container.append(element);\n        return this.container;\n    }\n}\nclass SignatureWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: !!parameters.data.hasOwnCanvas\n        });\n    }\n}\nclass CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: parameters.renderForms\n        });\n    }\n    render() {\n        const storage = this.annotationStorage;\n        const data = this.data;\n        const id = data.id;\n        let value = storage.getValue(id, {\n            value: data.exportValue === data.fieldValue\n        }).value;\n        if (typeof value === \"string\") {\n            value = value !== \"Off\";\n            storage.setValue(id, {\n                value\n            });\n        }\n        this.container.classList.add(\"buttonWidgetAnnotation\", \"checkBox\");\n        const element = document.createElement(\"input\");\n        GetElementsByNameSet.add(element);\n        element.setAttribute(\"data-element-id\", id);\n        element.disabled = data.readOnly;\n        this._setRequired(element, this.data.required);\n        element.type = \"checkbox\";\n        element.name = data.fieldName;\n        if (value) {\n            element.setAttribute(\"checked\", true);\n        }\n        element.setAttribute(\"exportValue\", data.exportValue);\n        element.tabIndex = DEFAULT_TAB_INDEX;\n        element.addEventListener(\"change\", (event)=>{\n            const { name, checked } = event.target;\n            for (const checkbox of this._getElementsByName(name, id)){\n                const curChecked = checked && checkbox.exportValue === data.exportValue;\n                if (checkbox.domElement) {\n                    checkbox.domElement.checked = curChecked;\n                }\n                storage.setValue(checkbox.id, {\n                    value: curChecked\n                });\n            }\n            storage.setValue(id, {\n                value: checked\n            });\n        });\n        element.addEventListener(\"resetform\", (event)=>{\n            const defaultValue = data.defaultFieldValue || \"Off\";\n            event.target.checked = defaultValue === data.exportValue;\n        });\n        if (this.enableScripting && this.hasJSActions) {\n            element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                const actions = {\n                    value (event) {\n                        event.target.checked = event.detail.value !== \"Off\";\n                        storage.setValue(id, {\n                            value: event.target.checked\n                        });\n                    }\n                };\n                this._dispatchEventFromSandbox(actions, jsEvent);\n            });\n            this._setEventListeners(element, null, [\n                [\n                    \"change\",\n                    \"Validate\"\n                ],\n                [\n                    \"change\",\n                    \"Action\"\n                ],\n                [\n                    \"focus\",\n                    \"Focus\"\n                ],\n                [\n                    \"blur\",\n                    \"Blur\"\n                ],\n                [\n                    \"mousedown\",\n                    \"Mouse Down\"\n                ],\n                [\n                    \"mouseenter\",\n                    \"Mouse Enter\"\n                ],\n                [\n                    \"mouseleave\",\n                    \"Mouse Exit\"\n                ],\n                [\n                    \"mouseup\",\n                    \"Mouse Up\"\n                ]\n            ], (event)=>event.target.checked);\n        }\n        this._setBackgroundColor(element);\n        this._setDefaultPropertiesFromJS(element);\n        this.container.append(element);\n        return this.container;\n    }\n}\nclass RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: parameters.renderForms\n        });\n    }\n    render() {\n        this.container.classList.add(\"buttonWidgetAnnotation\", \"radioButton\");\n        const storage = this.annotationStorage;\n        const data = this.data;\n        const id = data.id;\n        let value = storage.getValue(id, {\n            value: data.fieldValue === data.buttonValue\n        }).value;\n        if (typeof value === \"string\") {\n            value = value !== data.buttonValue;\n            storage.setValue(id, {\n                value\n            });\n        }\n        if (value) {\n            for (const radio of this._getElementsByName(data.fieldName, id)){\n                storage.setValue(radio.id, {\n                    value: false\n                });\n            }\n        }\n        const element = document.createElement(\"input\");\n        GetElementsByNameSet.add(element);\n        element.setAttribute(\"data-element-id\", id);\n        element.disabled = data.readOnly;\n        this._setRequired(element, this.data.required);\n        element.type = \"radio\";\n        element.name = data.fieldName;\n        if (value) {\n            element.setAttribute(\"checked\", true);\n        }\n        element.tabIndex = DEFAULT_TAB_INDEX;\n        element.addEventListener(\"change\", (event)=>{\n            const { name, checked } = event.target;\n            for (const radio of this._getElementsByName(name, id)){\n                storage.setValue(radio.id, {\n                    value: false\n                });\n            }\n            storage.setValue(id, {\n                value: checked\n            });\n        });\n        element.addEventListener(\"resetform\", (event)=>{\n            const defaultValue = data.defaultFieldValue;\n            event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;\n        });\n        if (this.enableScripting && this.hasJSActions) {\n            const pdfButtonValue = data.buttonValue;\n            element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                const actions = {\n                    value: (event)=>{\n                        const checked = pdfButtonValue === event.detail.value;\n                        for (const radio of this._getElementsByName(event.target.name)){\n                            const curChecked = checked && radio.id === id;\n                            if (radio.domElement) {\n                                radio.domElement.checked = curChecked;\n                            }\n                            storage.setValue(radio.id, {\n                                value: curChecked\n                            });\n                        }\n                    }\n                };\n                this._dispatchEventFromSandbox(actions, jsEvent);\n            });\n            this._setEventListeners(element, null, [\n                [\n                    \"change\",\n                    \"Validate\"\n                ],\n                [\n                    \"change\",\n                    \"Action\"\n                ],\n                [\n                    \"focus\",\n                    \"Focus\"\n                ],\n                [\n                    \"blur\",\n                    \"Blur\"\n                ],\n                [\n                    \"mousedown\",\n                    \"Mouse Down\"\n                ],\n                [\n                    \"mouseenter\",\n                    \"Mouse Enter\"\n                ],\n                [\n                    \"mouseleave\",\n                    \"Mouse Exit\"\n                ],\n                [\n                    \"mouseup\",\n                    \"Mouse Up\"\n                ]\n            ], (event)=>event.target.checked);\n        }\n        this._setBackgroundColor(element);\n        this._setDefaultPropertiesFromJS(element);\n        this.container.append(element);\n        return this.container;\n    }\n}\nclass PushButtonWidgetAnnotationElement extends LinkAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            ignoreBorder: parameters.data.hasAppearance\n        });\n    }\n    render() {\n        const container = super.render();\n        container.classList.add(\"buttonWidgetAnnotation\", \"pushButton\");\n        const linkElement = container.lastChild;\n        if (this.enableScripting && this.hasJSActions && linkElement) {\n            this._setDefaultPropertiesFromJS(linkElement);\n            linkElement.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                this._dispatchEventFromSandbox({}, jsEvent);\n            });\n        }\n        return container;\n    }\n}\nclass ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: parameters.renderForms\n        });\n    }\n    render() {\n        this.container.classList.add(\"choiceWidgetAnnotation\");\n        const storage = this.annotationStorage;\n        const id = this.data.id;\n        const storedData = storage.getValue(id, {\n            value: this.data.fieldValue\n        });\n        const selectElement = document.createElement(\"select\");\n        GetElementsByNameSet.add(selectElement);\n        selectElement.setAttribute(\"data-element-id\", id);\n        selectElement.disabled = this.data.readOnly;\n        this._setRequired(selectElement, this.data.required);\n        selectElement.name = this.data.fieldName;\n        selectElement.tabIndex = DEFAULT_TAB_INDEX;\n        let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;\n        if (!this.data.combo) {\n            selectElement.size = this.data.options.length;\n            if (this.data.multiSelect) {\n                selectElement.multiple = true;\n            }\n        }\n        selectElement.addEventListener(\"resetform\", (event)=>{\n            const defaultValue = this.data.defaultFieldValue;\n            for (const option of selectElement.options){\n                option.selected = option.value === defaultValue;\n            }\n        });\n        for (const option of this.data.options){\n            const optionElement = document.createElement(\"option\");\n            optionElement.textContent = option.displayValue;\n            optionElement.value = option.exportValue;\n            if (storedData.value.includes(option.exportValue)) {\n                optionElement.setAttribute(\"selected\", true);\n                addAnEmptyEntry = false;\n            }\n            selectElement.append(optionElement);\n        }\n        let removeEmptyEntry = null;\n        if (addAnEmptyEntry) {\n            const noneOptionElement = document.createElement(\"option\");\n            noneOptionElement.value = \" \";\n            noneOptionElement.setAttribute(\"hidden\", true);\n            noneOptionElement.setAttribute(\"selected\", true);\n            selectElement.prepend(noneOptionElement);\n            removeEmptyEntry = ()=>{\n                noneOptionElement.remove();\n                selectElement.removeEventListener(\"input\", removeEmptyEntry);\n                removeEmptyEntry = null;\n            };\n            selectElement.addEventListener(\"input\", removeEmptyEntry);\n        }\n        const getValue = (isExport)=>{\n            const name = isExport ? \"value\" : \"textContent\";\n            const { options, multiple } = selectElement;\n            if (!multiple) {\n                return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];\n            }\n            return Array.prototype.filter.call(options, (option)=>option.selected).map((option)=>option[name]);\n        };\n        let selectedValues = getValue(false);\n        const getItems = (event)=>{\n            const options = event.target.options;\n            return Array.prototype.map.call(options, (option)=>({\n                    displayValue: option.textContent,\n                    exportValue: option.value\n                }));\n        };\n        if (this.enableScripting && this.hasJSActions) {\n            selectElement.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                const actions = {\n                    value (event) {\n                        removeEmptyEntry?.();\n                        const value = event.detail.value;\n                        const values = new Set(Array.isArray(value) ? value : [\n                            value\n                        ]);\n                        for (const option of selectElement.options){\n                            option.selected = values.has(option.value);\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    multipleSelection (event) {\n                        selectElement.multiple = true;\n                    },\n                    remove (event) {\n                        const options = selectElement.options;\n                        const index = event.detail.remove;\n                        options[index].selected = false;\n                        selectElement.remove(index);\n                        if (options.length > 0) {\n                            const i = Array.prototype.findIndex.call(options, (option)=>option.selected);\n                            if (i === -1) {\n                                options[0].selected = true;\n                            }\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true),\n                            items: getItems(event)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    clear (event) {\n                        while(selectElement.length !== 0){\n                            selectElement.remove(0);\n                        }\n                        storage.setValue(id, {\n                            value: null,\n                            items: []\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    insert (event) {\n                        const { index, displayValue, exportValue } = event.detail.insert;\n                        const selectChild = selectElement.children[index];\n                        const optionElement = document.createElement(\"option\");\n                        optionElement.textContent = displayValue;\n                        optionElement.value = exportValue;\n                        if (selectChild) {\n                            selectChild.before(optionElement);\n                        } else {\n                            selectElement.append(optionElement);\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true),\n                            items: getItems(event)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    items (event) {\n                        const { items } = event.detail;\n                        while(selectElement.length !== 0){\n                            selectElement.remove(0);\n                        }\n                        for (const item of items){\n                            const { displayValue, exportValue } = item;\n                            const optionElement = document.createElement(\"option\");\n                            optionElement.textContent = displayValue;\n                            optionElement.value = exportValue;\n                            selectElement.append(optionElement);\n                        }\n                        if (selectElement.options.length > 0) {\n                            selectElement.options[0].selected = true;\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true),\n                            items: getItems(event)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    indices (event) {\n                        const indices = new Set(event.detail.indices);\n                        for (const option of event.target.options){\n                            option.selected = indices.has(option.index);\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    editable (event) {\n                        event.target.disabled = !event.detail.editable;\n                    }\n                };\n                this._dispatchEventFromSandbox(actions, jsEvent);\n            });\n            selectElement.addEventListener(\"input\", (event)=>{\n                const exportValue = getValue(true);\n                const change = getValue(false);\n                storage.setValue(id, {\n                    value: exportValue\n                });\n                event.preventDefault();\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id,\n                        name: \"Keystroke\",\n                        value: selectedValues,\n                        change,\n                        changeEx: exportValue,\n                        willCommit: false,\n                        commitKey: 1,\n                        keyDown: false\n                    }\n                });\n            });\n            this._setEventListeners(selectElement, null, [\n                [\n                    \"focus\",\n                    \"Focus\"\n                ],\n                [\n                    \"blur\",\n                    \"Blur\"\n                ],\n                [\n                    \"mousedown\",\n                    \"Mouse Down\"\n                ],\n                [\n                    \"mouseenter\",\n                    \"Mouse Enter\"\n                ],\n                [\n                    \"mouseleave\",\n                    \"Mouse Exit\"\n                ],\n                [\n                    \"mouseup\",\n                    \"Mouse Up\"\n                ],\n                [\n                    \"input\",\n                    \"Action\"\n                ],\n                [\n                    \"input\",\n                    \"Validate\"\n                ]\n            ], (event)=>event.target.value);\n        } else {\n            selectElement.addEventListener(\"input\", function(event) {\n                storage.setValue(id, {\n                    value: getValue(true)\n                });\n            });\n        }\n        if (this.data.combo) {\n            this._setTextStyle(selectElement);\n        } else {}\n        this._setBackgroundColor(selectElement);\n        this._setDefaultPropertiesFromJS(selectElement);\n        this.container.append(selectElement);\n        return this.container;\n    }\n}\nclass PopupAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        const { data, elements } = parameters;\n        super(parameters, {\n            isRenderable: AnnotationElement._hasPopupData(data)\n        });\n        this.elements = elements;\n        this.popup = null;\n    }\n    render() {\n        this.container.classList.add(\"popupAnnotation\");\n        const popup = this.popup = new PopupElement({\n            container: this.container,\n            color: this.data.color,\n            titleObj: this.data.titleObj,\n            modificationDate: this.data.modificationDate,\n            contentsObj: this.data.contentsObj,\n            richText: this.data.richText,\n            rect: this.data.rect,\n            parentRect: this.data.parentRect || null,\n            parent: this.parent,\n            elements: this.elements,\n            open: this.data.open\n        });\n        const elementIds = [];\n        for (const element of this.elements){\n            element.popup = popup;\n            element.container.ariaHasPopup = \"dialog\";\n            elementIds.push(element.data.id);\n            element.addHighlightArea();\n        }\n        this.container.setAttribute(\"aria-controls\", elementIds.map((id)=>`${AnnotationPrefix}${id}`).join(\",\"));\n        return this.container;\n    }\n}\nclass PopupElement {\n    #boundKeyDown;\n    #boundHide;\n    #boundShow;\n    #boundToggle;\n    #color;\n    #container;\n    #contentsObj;\n    #dateObj;\n    #elements;\n    #parent;\n    #parentRect;\n    #pinned;\n    #popup;\n    #position;\n    #rect;\n    #richText;\n    #titleObj;\n    #updates;\n    #wasVisible;\n    constructor({ container, color, elements, titleObj, modificationDate, contentsObj, richText, parent, rect, parentRect, open }){\n        this.#boundKeyDown = this.#keyDown.bind(this);\n        this.#boundHide = this.#hide.bind(this);\n        this.#boundShow = this.#show.bind(this);\n        this.#boundToggle = this.#toggle.bind(this);\n        this.#color = null;\n        this.#container = null;\n        this.#contentsObj = null;\n        this.#dateObj = null;\n        this.#elements = null;\n        this.#parent = null;\n        this.#parentRect = null;\n        this.#pinned = false;\n        this.#popup = null;\n        this.#position = null;\n        this.#rect = null;\n        this.#richText = null;\n        this.#titleObj = null;\n        this.#updates = null;\n        this.#wasVisible = false;\n        this.#container = container;\n        this.#titleObj = titleObj;\n        this.#contentsObj = contentsObj;\n        this.#richText = richText;\n        this.#parent = parent;\n        this.#color = color;\n        this.#rect = rect;\n        this.#parentRect = parentRect;\n        this.#elements = elements;\n        this.#dateObj = PDFDateString.toDateObject(modificationDate);\n        this.trigger = elements.flatMap((e)=>e.getElementsToTriggerPopup());\n        for (const element of this.trigger){\n            element.addEventListener(\"click\", this.#boundToggle);\n            element.addEventListener(\"mouseenter\", this.#boundShow);\n            element.addEventListener(\"mouseleave\", this.#boundHide);\n            element.classList.add(\"popupTriggerArea\");\n        }\n        for (const element of elements){\n            element.container?.addEventListener(\"keydown\", this.#boundKeyDown);\n        }\n        this.#container.hidden = true;\n        if (open) {\n            this.#toggle();\n        }\n    }\n    render() {\n        if (this.#popup) {\n            return;\n        }\n        const popup = this.#popup = document.createElement(\"div\");\n        popup.className = \"popup\";\n        if (this.#color) {\n            const baseColor = popup.style.outlineColor = Util.makeHexColor(...this.#color);\n            popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;\n        }\n        const header = document.createElement(\"span\");\n        header.className = \"header\";\n        const title = document.createElement(\"h1\");\n        header.append(title);\n        ({ dir: title.dir, str: title.textContent } = this.#titleObj);\n        popup.append(header);\n        if (this.#dateObj) {\n            const modificationDate = document.createElement(\"span\");\n            modificationDate.classList.add(\"popupDate\");\n            modificationDate.setAttribute(\"data-l10n-id\", \"pdfjs-annotation-date-time-string\");\n            modificationDate.setAttribute(\"data-l10n-args\", JSON.stringify({\n                dateObj: this.#dateObj.valueOf()\n            }));\n            header.append(modificationDate);\n        }\n        const html = this.#html;\n        if (html) {\n            XfaLayer.render({\n                xfaHtml: html,\n                intent: \"richText\",\n                div: popup\n            });\n            popup.lastChild.classList.add(\"richText\", \"popupContent\");\n        } else {\n            const contents = this._formatContents(this.#contentsObj);\n            popup.append(contents);\n        }\n        this.#container.append(popup);\n    }\n    get #html() {\n        const richText = this.#richText;\n        const contentsObj = this.#contentsObj;\n        if (richText?.str && (!contentsObj?.str || contentsObj.str === richText.str)) {\n            return this.#richText.html || null;\n        }\n        return null;\n    }\n    get #fontSize() {\n        return this.#html?.attributes?.style?.fontSize || 0;\n    }\n    get #fontColor() {\n        return this.#html?.attributes?.style?.color || null;\n    }\n    #makePopupContent(text) {\n        const popupLines = [];\n        const popupContent = {\n            str: text,\n            html: {\n                name: \"div\",\n                attributes: {\n                    dir: \"auto\"\n                },\n                children: [\n                    {\n                        name: \"p\",\n                        children: popupLines\n                    }\n                ]\n            }\n        };\n        const lineAttributes = {\n            style: {\n                color: this.#fontColor,\n                fontSize: this.#fontSize ? `calc(${this.#fontSize}px * var(--total-scale-factor))` : \"\"\n            }\n        };\n        for (const line of text.split(\"\\n\")){\n            popupLines.push({\n                name: \"span\",\n                value: line,\n                attributes: lineAttributes\n            });\n        }\n        return popupContent;\n    }\n    _formatContents({ str, dir }) {\n        const p = document.createElement(\"p\");\n        p.classList.add(\"popupContent\");\n        p.dir = dir;\n        const lines = str.split(/(?:\\r\\n?|\\n)/);\n        for(let i = 0, ii = lines.length; i < ii; ++i){\n            const line = lines[i];\n            p.append(document.createTextNode(line));\n            if (i < ii - 1) {\n                p.append(document.createElement(\"br\"));\n            }\n        }\n        return p;\n    }\n    #keyDown(event) {\n        if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {\n            return;\n        }\n        if (event.key === \"Enter\" || event.key === \"Escape\" && this.#pinned) {\n            this.#toggle();\n        }\n    }\n    updateEdited({ rect, popupContent }) {\n        this.#updates ||= {\n            contentsObj: this.#contentsObj,\n            richText: this.#richText\n        };\n        if (rect) {\n            this.#position = null;\n        }\n        if (popupContent) {\n            this.#richText = this.#makePopupContent(popupContent);\n            this.#contentsObj = null;\n        }\n        this.#popup?.remove();\n        this.#popup = null;\n    }\n    resetEdited() {\n        if (!this.#updates) {\n            return;\n        }\n        ({ contentsObj: this.#contentsObj, richText: this.#richText } = this.#updates);\n        this.#updates = null;\n        this.#popup?.remove();\n        this.#popup = null;\n        this.#position = null;\n    }\n    #setPosition() {\n        if (this.#position !== null) {\n            return;\n        }\n        const { page: { view }, viewport: { rawDims: { pageWidth, pageHeight, pageX, pageY } } } = this.#parent;\n        let useParentRect = !!this.#parentRect;\n        let rect = useParentRect ? this.#parentRect : this.#rect;\n        for (const element of this.#elements){\n            if (!rect || Util.intersect(element.data.rect, rect) !== null) {\n                rect = element.data.rect;\n                useParentRect = true;\n                break;\n            }\n        }\n        const normalizedRect = Util.normalizeRect([\n            rect[0],\n            view[3] - rect[1] + view[1],\n            rect[2],\n            view[3] - rect[3] + view[1]\n        ]);\n        const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;\n        const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;\n        const popupLeft = normalizedRect[0] + parentWidth;\n        const popupTop = normalizedRect[1];\n        this.#position = [\n            100 * (popupLeft - pageX) / pageWidth,\n            100 * (popupTop - pageY) / pageHeight\n        ];\n        const { style } = this.#container;\n        style.left = `${this.#position[0]}%`;\n        style.top = `${this.#position[1]}%`;\n    }\n    #toggle() {\n        this.#pinned = !this.#pinned;\n        if (this.#pinned) {\n            this.#show();\n            this.#container.addEventListener(\"click\", this.#boundToggle);\n            this.#container.addEventListener(\"keydown\", this.#boundKeyDown);\n        } else {\n            this.#hide();\n            this.#container.removeEventListener(\"click\", this.#boundToggle);\n            this.#container.removeEventListener(\"keydown\", this.#boundKeyDown);\n        }\n    }\n    #show() {\n        if (!this.#popup) {\n            this.render();\n        }\n        if (!this.isVisible) {\n            this.#setPosition();\n            this.#container.hidden = false;\n            this.#container.style.zIndex = parseInt(this.#container.style.zIndex) + 1000;\n        } else if (this.#pinned) {\n            this.#container.classList.add(\"focused\");\n        }\n    }\n    #hide() {\n        this.#container.classList.remove(\"focused\");\n        if (this.#pinned || !this.isVisible) {\n            return;\n        }\n        this.#container.hidden = true;\n        this.#container.style.zIndex = parseInt(this.#container.style.zIndex) - 1000;\n    }\n    forceHide() {\n        this.#wasVisible = this.isVisible;\n        if (!this.#wasVisible) {\n            return;\n        }\n        this.#container.hidden = true;\n    }\n    maybeShow() {\n        if (!this.#wasVisible) {\n            return;\n        }\n        if (!this.#popup) {\n            this.#show();\n        }\n        this.#wasVisible = false;\n        this.#container.hidden = false;\n    }\n    get isVisible() {\n        return this.#container.hidden === false;\n    }\n}\nclass FreeTextAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.textContent = parameters.data.textContent;\n        this.textPosition = parameters.data.textPosition;\n        this.annotationEditorType = AnnotationEditorType.FREETEXT;\n    }\n    render() {\n        this.container.classList.add(\"freeTextAnnotation\");\n        if (this.textContent) {\n            const content = document.createElement(\"div\");\n            content.classList.add(\"annotationTextContent\");\n            content.setAttribute(\"role\", \"comment\");\n            for (const line of this.textContent){\n                const lineSpan = document.createElement(\"span\");\n                lineSpan.textContent = line;\n                content.append(lineSpan);\n            }\n            this.container.append(content);\n        }\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this._editOnDoubleClick();\n        return this.container;\n    }\n}\nclass LineAnnotationElement extends AnnotationElement {\n    #line;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#line = null;\n    }\n    render() {\n        this.container.classList.add(\"lineAnnotation\");\n        const { data, width, height } = this;\n        const svg = this.svgFactory.create(width, height, true);\n        const line = this.#line = this.svgFactory.createElement(\"svg:line\");\n        line.setAttribute(\"x1\", data.rect[2] - data.lineCoordinates[0]);\n        line.setAttribute(\"y1\", data.rect[3] - data.lineCoordinates[1]);\n        line.setAttribute(\"x2\", data.rect[2] - data.lineCoordinates[2]);\n        line.setAttribute(\"y2\", data.rect[3] - data.lineCoordinates[3]);\n        line.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n        line.setAttribute(\"stroke\", \"transparent\");\n        line.setAttribute(\"fill\", \"transparent\");\n        svg.append(line);\n        this.container.append(svg);\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#line;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass SquareAnnotationElement extends AnnotationElement {\n    #square;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#square = null;\n    }\n    render() {\n        this.container.classList.add(\"squareAnnotation\");\n        const { data, width, height } = this;\n        const svg = this.svgFactory.create(width, height, true);\n        const borderWidth = data.borderStyle.width;\n        const square = this.#square = this.svgFactory.createElement(\"svg:rect\");\n        square.setAttribute(\"x\", borderWidth / 2);\n        square.setAttribute(\"y\", borderWidth / 2);\n        square.setAttribute(\"width\", width - borderWidth);\n        square.setAttribute(\"height\", height - borderWidth);\n        square.setAttribute(\"stroke-width\", borderWidth || 1);\n        square.setAttribute(\"stroke\", \"transparent\");\n        square.setAttribute(\"fill\", \"transparent\");\n        svg.append(square);\n        this.container.append(svg);\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#square;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass CircleAnnotationElement extends AnnotationElement {\n    #circle;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#circle = null;\n    }\n    render() {\n        this.container.classList.add(\"circleAnnotation\");\n        const { data, width, height } = this;\n        const svg = this.svgFactory.create(width, height, true);\n        const borderWidth = data.borderStyle.width;\n        const circle = this.#circle = this.svgFactory.createElement(\"svg:ellipse\");\n        circle.setAttribute(\"cx\", width / 2);\n        circle.setAttribute(\"cy\", height / 2);\n        circle.setAttribute(\"rx\", width / 2 - borderWidth / 2);\n        circle.setAttribute(\"ry\", height / 2 - borderWidth / 2);\n        circle.setAttribute(\"stroke-width\", borderWidth || 1);\n        circle.setAttribute(\"stroke\", \"transparent\");\n        circle.setAttribute(\"fill\", \"transparent\");\n        svg.append(circle);\n        this.container.append(svg);\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#circle;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass PolylineAnnotationElement extends AnnotationElement {\n    #polyline;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#polyline = null;\n        this.containerClassName = \"polylineAnnotation\";\n        this.svgElementName = \"svg:polyline\";\n    }\n    render() {\n        this.container.classList.add(this.containerClassName);\n        const { data: { rect, vertices, borderStyle, popupRef }, width, height } = this;\n        if (!vertices) {\n            return this.container;\n        }\n        const svg = this.svgFactory.create(width, height, true);\n        let points = [];\n        for(let i = 0, ii = vertices.length; i < ii; i += 2){\n            const x = vertices[i] - rect[0];\n            const y = rect[3] - vertices[i + 1];\n            points.push(`${x},${y}`);\n        }\n        points = points.join(\" \");\n        const polyline = this.#polyline = this.svgFactory.createElement(this.svgElementName);\n        polyline.setAttribute(\"points\", points);\n        polyline.setAttribute(\"stroke-width\", borderStyle.width || 1);\n        polyline.setAttribute(\"stroke\", \"transparent\");\n        polyline.setAttribute(\"fill\", \"transparent\");\n        svg.append(polyline);\n        this.container.append(svg);\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#polyline;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass PolygonAnnotationElement extends PolylineAnnotationElement {\n    constructor(parameters){\n        super(parameters);\n        this.containerClassName = \"polygonAnnotation\";\n        this.svgElementName = \"svg:polygon\";\n    }\n}\nclass CaretAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n    }\n    render() {\n        this.container.classList.add(\"caretAnnotation\");\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n}\nclass InkAnnotationElement extends AnnotationElement {\n    #polylinesGroupElement;\n    #polylines;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#polylinesGroupElement = null;\n        this.#polylines = [];\n        this.containerClassName = \"inkAnnotation\";\n        this.svgElementName = \"svg:polyline\";\n        this.annotationEditorType = this.data.it === \"InkHighlight\" ? AnnotationEditorType.HIGHLIGHT : AnnotationEditorType.INK;\n    }\n    #getTransform(rotation, rect) {\n        switch(rotation){\n            case 90:\n                return {\n                    transform: `rotate(90) translate(${-rect[0]},${rect[1]}) scale(1,-1)`,\n                    width: rect[3] - rect[1],\n                    height: rect[2] - rect[0]\n                };\n            case 180:\n                return {\n                    transform: `rotate(180) translate(${-rect[2]},${rect[1]}) scale(1,-1)`,\n                    width: rect[2] - rect[0],\n                    height: rect[3] - rect[1]\n                };\n            case 270:\n                return {\n                    transform: `rotate(270) translate(${-rect[2]},${rect[3]}) scale(1,-1)`,\n                    width: rect[3] - rect[1],\n                    height: rect[2] - rect[0]\n                };\n            default:\n                return {\n                    transform: `translate(${-rect[0]},${rect[3]}) scale(1,-1)`,\n                    width: rect[2] - rect[0],\n                    height: rect[3] - rect[1]\n                };\n        }\n    }\n    render() {\n        this.container.classList.add(this.containerClassName);\n        const { data: { rect, rotation, inkLists, borderStyle, popupRef } } = this;\n        const { transform, width, height } = this.#getTransform(rotation, rect);\n        const svg = this.svgFactory.create(width, height, true);\n        const g = this.#polylinesGroupElement = this.svgFactory.createElement(\"svg:g\");\n        svg.append(g);\n        g.setAttribute(\"stroke-width\", borderStyle.width || 1);\n        g.setAttribute(\"stroke-linecap\", \"round\");\n        g.setAttribute(\"stroke-linejoin\", \"round\");\n        g.setAttribute(\"stroke-miterlimit\", 10);\n        g.setAttribute(\"stroke\", \"transparent\");\n        g.setAttribute(\"fill\", \"transparent\");\n        g.setAttribute(\"transform\", transform);\n        for(let i = 0, ii = inkLists.length; i < ii; i++){\n            const polyline = this.svgFactory.createElement(this.svgElementName);\n            this.#polylines.push(polyline);\n            polyline.setAttribute(\"points\", inkLists[i].join(\",\"));\n            g.append(polyline);\n        }\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.append(svg);\n        this._editOnDoubleClick();\n        return this.container;\n    }\n    updateEdited(params) {\n        super.updateEdited(params);\n        const { thickness, points, rect } = params;\n        const g = this.#polylinesGroupElement;\n        if (thickness >= 0) {\n            g.setAttribute(\"stroke-width\", thickness || 1);\n        }\n        if (points) {\n            for(let i = 0, ii = this.#polylines.length; i < ii; i++){\n                this.#polylines[i].setAttribute(\"points\", points[i].join(\",\"));\n            }\n        }\n        if (rect) {\n            const { transform, width, height } = this.#getTransform(this.data.rotation, rect);\n            const root = g.parentElement;\n            root.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n            g.setAttribute(\"transform\", transform);\n        }\n    }\n    getElementsToTriggerPopup() {\n        return this.#polylines;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass HighlightAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n        this.annotationEditorType = AnnotationEditorType.HIGHLIGHT;\n    }\n    render() {\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"highlightAnnotation\");\n        this._editOnDoubleClick();\n        return this.container;\n    }\n}\nclass UnderlineAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n    }\n    render() {\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"underlineAnnotation\");\n        return this.container;\n    }\n}\nclass SquigglyAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n    }\n    render() {\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"squigglyAnnotation\");\n        return this.container;\n    }\n}\nclass StrikeOutAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n    }\n    render() {\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"strikeoutAnnotation\");\n        return this.container;\n    }\n}\nclass StampAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.annotationEditorType = AnnotationEditorType.STAMP;\n    }\n    render() {\n        this.container.classList.add(\"stampAnnotation\");\n        this.container.setAttribute(\"role\", \"img\");\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this._editOnDoubleClick();\n        return this.container;\n    }\n}\nclass FileAttachmentAnnotationElement extends AnnotationElement {\n    #trigger;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true\n        });\n        this.#trigger = null;\n        const { file } = this.data;\n        this.filename = file.filename;\n        this.content = file.content;\n        this.linkService.eventBus?.dispatch(\"fileattachmentannotation\", {\n            source: this,\n            ...file\n        });\n    }\n    render() {\n        this.container.classList.add(\"fileAttachmentAnnotation\");\n        const { container, data } = this;\n        let trigger;\n        if (data.hasAppearance || data.fillAlpha === 0) {\n            trigger = document.createElement(\"div\");\n        } else {\n            trigger = document.createElement(\"img\");\n            trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data.name) ? \"paperclip\" : \"pushpin\"}.svg`;\n            if (data.fillAlpha && data.fillAlpha < 1) {\n                trigger.style = `filter: opacity(${Math.round(data.fillAlpha * 100)}%);`;\n            }\n        }\n        trigger.addEventListener(\"dblclick\", this.#download.bind(this));\n        this.#trigger = trigger;\n        const { isMac } = util_FeatureTest.platform;\n        container.addEventListener(\"keydown\", (evt)=>{\n            if (evt.key === \"Enter\" && (isMac ? evt.metaKey : evt.ctrlKey)) {\n                this.#download();\n            }\n        });\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        } else {\n            trigger.classList.add(\"popupTriggerArea\");\n        }\n        container.append(trigger);\n        return container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#trigger;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n    #download() {\n        this.downloadManager?.openOrDownloadData(this.content, this.filename);\n    }\n}\nclass AnnotationLayer {\n    #accessibilityManager;\n    #annotationCanvasMap;\n    #editableAnnotations;\n    #structTreeLayer;\n    constructor({ div, accessibilityManager, annotationCanvasMap, annotationEditorUIManager, page, viewport, structTreeLayer }){\n        this.#accessibilityManager = null;\n        this.#annotationCanvasMap = null;\n        this.#editableAnnotations = new Map();\n        this.#structTreeLayer = null;\n        this.div = div;\n        this.#accessibilityManager = accessibilityManager;\n        this.#annotationCanvasMap = annotationCanvasMap;\n        this.#structTreeLayer = structTreeLayer || null;\n        this.page = page;\n        this.viewport = viewport;\n        this.zIndex = 0;\n        this._annotationEditorUIManager = annotationEditorUIManager;\n    }\n    hasEditableAnnotations() {\n        return this.#editableAnnotations.size > 0;\n    }\n    async #appendElement(element, id) {\n        const contentElement = element.firstChild || element;\n        const annotationId = contentElement.id = `${AnnotationPrefix}${id}`;\n        const ariaAttributes = await this.#structTreeLayer?.getAriaAttributes(annotationId);\n        if (ariaAttributes) {\n            for (const [key, value] of ariaAttributes){\n                contentElement.setAttribute(key, value);\n            }\n        }\n        this.div.append(element);\n        this.#accessibilityManager?.moveElementInDOM(this.div, element, contentElement, false);\n    }\n    async render(params) {\n        const { annotations } = params;\n        const layer = this.div;\n        setLayerDimensions(layer, this.viewport);\n        const popupToElements = new Map();\n        const elementParams = {\n            data: null,\n            layer,\n            linkService: params.linkService,\n            downloadManager: params.downloadManager,\n            imageResourcesPath: params.imageResourcesPath || \"\",\n            renderForms: params.renderForms !== false,\n            svgFactory: new DOMSVGFactory(),\n            annotationStorage: params.annotationStorage || new AnnotationStorage(),\n            enableScripting: params.enableScripting === true,\n            hasJSActions: params.hasJSActions,\n            fieldObjects: params.fieldObjects,\n            parent: this,\n            elements: null\n        };\n        for (const data of annotations){\n            if (data.noHTML) {\n                continue;\n            }\n            const isPopupAnnotation = data.annotationType === AnnotationType.POPUP;\n            if (!isPopupAnnotation) {\n                if (data.rect[2] === data.rect[0] || data.rect[3] === data.rect[1]) {\n                    continue;\n                }\n            } else {\n                const elements = popupToElements.get(data.id);\n                if (!elements) {\n                    continue;\n                }\n                elementParams.elements = elements;\n            }\n            elementParams.data = data;\n            const element = AnnotationElementFactory.create(elementParams);\n            if (!element.isRenderable) {\n                continue;\n            }\n            if (!isPopupAnnotation && data.popupRef) {\n                const elements = popupToElements.get(data.popupRef);\n                if (!elements) {\n                    popupToElements.set(data.popupRef, [\n                        element\n                    ]);\n                } else {\n                    elements.push(element);\n                }\n            }\n            const rendered = element.render();\n            if (data.hidden) {\n                rendered.style.visibility = \"hidden\";\n            }\n            await this.#appendElement(rendered, data.id);\n            if (element._isEditable) {\n                this.#editableAnnotations.set(element.data.id, element);\n                this._annotationEditorUIManager?.renderAnnotationElement(element);\n            }\n        }\n        this.#setAnnotationCanvasMap();\n    }\n    async addLinkAnnotations(annotations, linkService) {\n        const elementParams = {\n            data: null,\n            layer: this.div,\n            linkService,\n            svgFactory: new DOMSVGFactory(),\n            parent: this\n        };\n        for (const data of annotations){\n            data.borderStyle ||= AnnotationLayer._defaultBorderStyle;\n            elementParams.data = data;\n            const element = AnnotationElementFactory.create(elementParams);\n            if (!element.isRenderable) {\n                continue;\n            }\n            const rendered = element.render();\n            await this.#appendElement(rendered, data.id);\n        }\n    }\n    update({ viewport }) {\n        const layer = this.div;\n        this.viewport = viewport;\n        setLayerDimensions(layer, {\n            rotation: viewport.rotation\n        });\n        this.#setAnnotationCanvasMap();\n        layer.hidden = false;\n    }\n    #setAnnotationCanvasMap() {\n        if (!this.#annotationCanvasMap) {\n            return;\n        }\n        const layer = this.div;\n        for (const [id, canvas] of this.#annotationCanvasMap){\n            const element = layer.querySelector(`[data-annotation-id=\"${id}\"]`);\n            if (!element) {\n                continue;\n            }\n            canvas.className = \"annotationContent\";\n            const { firstChild } = element;\n            if (!firstChild) {\n                element.append(canvas);\n            } else if (firstChild.nodeName === \"CANVAS\") {\n                firstChild.replaceWith(canvas);\n            } else if (!firstChild.classList.contains(\"annotationContent\")) {\n                firstChild.before(canvas);\n            } else {\n                firstChild.after(canvas);\n            }\n            const editableAnnotation = this.#editableAnnotations.get(id);\n            if (!editableAnnotation) {\n                continue;\n            }\n            if (editableAnnotation._hasNoCanvas) {\n                this._annotationEditorUIManager?.setMissingCanvas(id, element.id, canvas);\n                editableAnnotation._hasNoCanvas = false;\n            } else {\n                editableAnnotation.canvas = canvas;\n            }\n        }\n        this.#annotationCanvasMap.clear();\n    }\n    getEditableAnnotations() {\n        return Array.from(this.#editableAnnotations.values());\n    }\n    getEditableAnnotation(id) {\n        return this.#editableAnnotations.get(id);\n    }\n    static get _defaultBorderStyle() {\n        return shadow(this, \"_defaultBorderStyle\", Object.freeze({\n            width: 1,\n            rawWidth: 1,\n            style: AnnotationBorderStyleType.SOLID,\n            dashArray: [\n                3\n            ],\n            horizontalCornerRadius: 0,\n            verticalCornerRadius: 0\n        }));\n    }\n}\n; // ./src/display/editor/freetext.js\nconst EOL_PATTERN = /\\r\\n?|\\n/g;\nclass FreeTextEditor extends AnnotationEditor {\n    #color;\n    #content;\n    #editorDivId;\n    #editModeAC;\n    #fontSize;\n    static{\n        this._freeTextDefaultContent = \"\";\n    }\n    static{\n        this._internalPadding = 0;\n    }\n    static{\n        this._defaultColor = null;\n    }\n    static{\n        this._defaultFontSize = 10;\n    }\n    static get _keyboardManager() {\n        const proto = FreeTextEditor.prototype;\n        const arrowChecker = (self)=>self.isEmpty();\n        const small = AnnotationEditorUIManager.TRANSLATE_SMALL;\n        const big = AnnotationEditorUIManager.TRANSLATE_BIG;\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ctrl+s\",\n                    \"mac+meta+s\",\n                    \"ctrl+p\",\n                    \"mac+meta+p\"\n                ],\n                proto.commitOrRemove,\n                {\n                    bubbles: true\n                }\n            ],\n            [\n                [\n                    \"ctrl+Enter\",\n                    \"mac+meta+Enter\",\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                proto.commitOrRemove\n            ],\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        -small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowLeft\",\n                    \"mac+shift+ArrowLeft\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        -big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowRight\",\n                    \"mac+shift+ArrowRight\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        -small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowUp\",\n                    \"mac+shift+ArrowUp\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        -big\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowDown\",\n                    \"mac+shift+ArrowDown\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        big\n                    ],\n                    checker: arrowChecker\n                }\n            ]\n        ]));\n    }\n    static{\n        this._type = \"freetext\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.FREETEXT;\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"freeTextEditor\"\n        });\n        this.#content = \"\";\n        this.#editorDivId = `${this.id}-editor`;\n        this.#editModeAC = null;\n        this.#color = params.color || FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor;\n        this.#fontSize = params.fontSize || FreeTextEditor._defaultFontSize;\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n        const style = getComputedStyle(document.documentElement);\n        this._internalPadding = parseFloat(style.getPropertyValue(\"--freetext-padding\"));\n    }\n    static updateDefaultParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.FREETEXT_SIZE:\n                FreeTextEditor._defaultFontSize = value;\n                break;\n            case AnnotationEditorParamsType.FREETEXT_COLOR:\n                FreeTextEditor._defaultColor = value;\n                break;\n        }\n    }\n    updateParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.FREETEXT_SIZE:\n                this.#updateFontSize(value);\n                break;\n            case AnnotationEditorParamsType.FREETEXT_COLOR:\n                this.#updateColor(value);\n                break;\n        }\n    }\n    static get defaultPropertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.FREETEXT_SIZE,\n                FreeTextEditor._defaultFontSize\n            ],\n            [\n                AnnotationEditorParamsType.FREETEXT_COLOR,\n                FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor\n            ]\n        ];\n    }\n    get propertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.FREETEXT_SIZE,\n                this.#fontSize\n            ],\n            [\n                AnnotationEditorParamsType.FREETEXT_COLOR,\n                this.#color\n            ]\n        ];\n    }\n    #updateFontSize(fontSize) {\n        const setFontsize = (size)=>{\n            this.editorDiv.style.fontSize = `calc(${size}px * var(--total-scale-factor))`;\n            this.translate(0, -(size - this.#fontSize) * this.parentScale);\n            this.#fontSize = size;\n            this.#setEditorDimensions();\n        };\n        const savedFontsize = this.#fontSize;\n        this.addCommands({\n            cmd: setFontsize.bind(this, fontSize),\n            undo: setFontsize.bind(this, savedFontsize),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.FREETEXT_SIZE,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n    }\n    #updateColor(color) {\n        const setColor = (col)=>{\n            this.#color = this.editorDiv.style.color = col;\n        };\n        const savedColor = this.#color;\n        this.addCommands({\n            cmd: setColor.bind(this, color),\n            undo: setColor.bind(this, savedColor),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.FREETEXT_COLOR,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n    }\n    _translateEmpty(x, y) {\n        this._uiManager.translateSelectedEditors(x, y, true);\n    }\n    getInitialTranslation() {\n        const scale = this.parentScale;\n        return [\n            -FreeTextEditor._internalPadding * scale,\n            -(FreeTextEditor._internalPadding + this.#fontSize) * scale\n        ];\n    }\n    rebuild() {\n        if (!this.parent) {\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    enableEditMode() {\n        if (this.isInEditMode()) {\n            return;\n        }\n        this.parent.setEditingState(false);\n        this.parent.updateToolbar(AnnotationEditorType.FREETEXT);\n        super.enableEditMode();\n        this.overlayDiv.classList.remove(\"enabled\");\n        this.editorDiv.contentEditable = true;\n        this._isDraggable = false;\n        this.div.removeAttribute(\"aria-activedescendant\");\n        this.#editModeAC = new AbortController();\n        const signal = this._uiManager.combinedSignal(this.#editModeAC);\n        this.editorDiv.addEventListener(\"keydown\", this.editorDivKeydown.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"focus\", this.editorDivFocus.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"blur\", this.editorDivBlur.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"input\", this.editorDivInput.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"paste\", this.editorDivPaste.bind(this), {\n            signal\n        });\n    }\n    disableEditMode() {\n        if (!this.isInEditMode()) {\n            return;\n        }\n        this.parent.setEditingState(true);\n        super.disableEditMode();\n        this.overlayDiv.classList.add(\"enabled\");\n        this.editorDiv.contentEditable = false;\n        this.div.setAttribute(\"aria-activedescendant\", this.#editorDivId);\n        this._isDraggable = true;\n        this.#editModeAC?.abort();\n        this.#editModeAC = null;\n        this.div.focus({\n            preventScroll: true\n        });\n        this.isEditing = false;\n        this.parent.div.classList.add(\"freetextEditing\");\n    }\n    focusin(event) {\n        if (!this._focusEventsAllowed) {\n            return;\n        }\n        super.focusin(event);\n        if (event.target !== this.editorDiv) {\n            this.editorDiv.focus();\n        }\n    }\n    onceAdded(focus) {\n        if (this.width) {\n            return;\n        }\n        this.enableEditMode();\n        if (focus) {\n            this.editorDiv.focus();\n        }\n        if (this._initialOptions?.isCentered) {\n            this.center();\n        }\n        this._initialOptions = null;\n    }\n    isEmpty() {\n        return !this.editorDiv || this.editorDiv.innerText.trim() === \"\";\n    }\n    remove() {\n        this.isEditing = false;\n        if (this.parent) {\n            this.parent.setEditingState(true);\n            this.parent.div.classList.add(\"freetextEditing\");\n        }\n        super.remove();\n    }\n    #extractText() {\n        const buffer = [];\n        this.editorDiv.normalize();\n        let prevChild = null;\n        for (const child of this.editorDiv.childNodes){\n            if (prevChild?.nodeType === Node.TEXT_NODE && child.nodeName === \"BR\") {\n                continue;\n            }\n            buffer.push(FreeTextEditor.#getNodeContent(child));\n            prevChild = child;\n        }\n        return buffer.join(\"\\n\");\n    }\n    #setEditorDimensions() {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        let rect;\n        if (this.isAttachedToDOM) {\n            rect = this.div.getBoundingClientRect();\n        } else {\n            const { currentLayer, div } = this;\n            const savedDisplay = div.style.display;\n            const savedVisibility = div.classList.contains(\"hidden\");\n            div.classList.remove(\"hidden\");\n            div.style.display = \"hidden\";\n            currentLayer.div.append(this.div);\n            rect = div.getBoundingClientRect();\n            div.remove();\n            div.style.display = savedDisplay;\n            div.classList.toggle(\"hidden\", savedVisibility);\n        }\n        if (this.rotation % 180 === this.parentRotation % 180) {\n            this.width = rect.width / parentWidth;\n            this.height = rect.height / parentHeight;\n        } else {\n            this.width = rect.height / parentWidth;\n            this.height = rect.width / parentHeight;\n        }\n        this.fixAndSetPosition();\n    }\n    commit() {\n        if (!this.isInEditMode()) {\n            return;\n        }\n        super.commit();\n        this.disableEditMode();\n        const savedText = this.#content;\n        const newText = this.#content = this.#extractText().trimEnd();\n        if (savedText === newText) {\n            return;\n        }\n        const setText = (text)=>{\n            this.#content = text;\n            if (!text) {\n                this.remove();\n                return;\n            }\n            this.#setContent();\n            this._uiManager.rebuild(this);\n            this.#setEditorDimensions();\n        };\n        this.addCommands({\n            cmd: ()=>{\n                setText(newText);\n            },\n            undo: ()=>{\n                setText(savedText);\n            },\n            mustExec: false\n        });\n        this.#setEditorDimensions();\n    }\n    shouldGetKeyboardEvents() {\n        return this.isInEditMode();\n    }\n    enterInEditMode() {\n        this.enableEditMode();\n        this.editorDiv.focus();\n    }\n    dblclick(event) {\n        this.enterInEditMode();\n    }\n    keydown(event) {\n        if (event.target === this.div && event.key === \"Enter\") {\n            this.enterInEditMode();\n            event.preventDefault();\n        }\n    }\n    editorDivKeydown(event) {\n        FreeTextEditor._keyboardManager.exec(this, event);\n    }\n    editorDivFocus(event) {\n        this.isEditing = true;\n    }\n    editorDivBlur(event) {\n        this.isEditing = false;\n    }\n    editorDivInput(event) {\n        this.parent.div.classList.toggle(\"freetextEditing\", this.isEmpty());\n    }\n    disableEditing() {\n        this.editorDiv.setAttribute(\"role\", \"comment\");\n        this.editorDiv.removeAttribute(\"aria-multiline\");\n    }\n    enableEditing() {\n        this.editorDiv.setAttribute(\"role\", \"textbox\");\n        this.editorDiv.setAttribute(\"aria-multiline\", true);\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        let baseX, baseY;\n        if (this._isCopy || this.annotationElementId) {\n            baseX = this.x;\n            baseY = this.y;\n        }\n        super.render();\n        this.editorDiv = document.createElement(\"div\");\n        this.editorDiv.className = \"internal\";\n        this.editorDiv.setAttribute(\"id\", this.#editorDivId);\n        this.editorDiv.setAttribute(\"data-l10n-id\", \"pdfjs-free-text2\");\n        this.editorDiv.setAttribute(\"data-l10n-attrs\", \"default-content\");\n        this.enableEditing();\n        this.editorDiv.contentEditable = true;\n        const { style } = this.editorDiv;\n        style.fontSize = `calc(${this.#fontSize}px * var(--total-scale-factor))`;\n        style.color = this.#color;\n        this.div.append(this.editorDiv);\n        this.overlayDiv = document.createElement(\"div\");\n        this.overlayDiv.classList.add(\"overlay\", \"enabled\");\n        this.div.append(this.overlayDiv);\n        bindEvents(this, this.div, [\n            \"dblclick\",\n            \"keydown\"\n        ]);\n        if (this._isCopy || this.annotationElementId) {\n            const [parentWidth, parentHeight] = this.parentDimensions;\n            if (this.annotationElementId) {\n                const { position } = this._initialData;\n                let [tx, ty] = this.getInitialTranslation();\n                [tx, ty] = this.pageTranslationToScreen(tx, ty);\n                const [pageWidth, pageHeight] = this.pageDimensions;\n                const [pageX, pageY] = this.pageTranslation;\n                let posX, posY;\n                switch(this.rotation){\n                    case 0:\n                        posX = baseX + (position[0] - pageX) / pageWidth;\n                        posY = baseY + this.height - (position[1] - pageY) / pageHeight;\n                        break;\n                    case 90:\n                        posX = baseX + (position[0] - pageX) / pageWidth;\n                        posY = baseY - (position[1] - pageY) / pageHeight;\n                        [tx, ty] = [\n                            ty,\n                            -tx\n                        ];\n                        break;\n                    case 180:\n                        posX = baseX - this.width + (position[0] - pageX) / pageWidth;\n                        posY = baseY - (position[1] - pageY) / pageHeight;\n                        [tx, ty] = [\n                            -tx,\n                            -ty\n                        ];\n                        break;\n                    case 270:\n                        posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;\n                        posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;\n                        [tx, ty] = [\n                            -ty,\n                            tx\n                        ];\n                        break;\n                }\n                this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);\n            } else {\n                this._moveAfterPaste(baseX, baseY);\n            }\n            this.#setContent();\n            this._isDraggable = true;\n            this.editorDiv.contentEditable = false;\n        } else {\n            this._isDraggable = false;\n            this.editorDiv.contentEditable = true;\n        }\n        return this.div;\n    }\n    static #getNodeContent(node) {\n        return (node.nodeType === Node.TEXT_NODE ? node.nodeValue : node.innerText).replaceAll(EOL_PATTERN, \"\");\n    }\n    editorDivPaste(event) {\n        const clipboardData = event.clipboardData || window.clipboardData;\n        const { types } = clipboardData;\n        if (types.length === 1 && types[0] === \"text/plain\") {\n            return;\n        }\n        event.preventDefault();\n        const paste = FreeTextEditor.#deserializeContent(clipboardData.getData(\"text\") || \"\").replaceAll(EOL_PATTERN, \"\\n\");\n        if (!paste) {\n            return;\n        }\n        const selection = window.getSelection();\n        if (!selection.rangeCount) {\n            return;\n        }\n        this.editorDiv.normalize();\n        selection.deleteFromDocument();\n        const range = selection.getRangeAt(0);\n        if (!paste.includes(\"\\n\")) {\n            range.insertNode(document.createTextNode(paste));\n            this.editorDiv.normalize();\n            selection.collapseToStart();\n            return;\n        }\n        const { startContainer, startOffset } = range;\n        const bufferBefore = [];\n        const bufferAfter = [];\n        if (startContainer.nodeType === Node.TEXT_NODE) {\n            const parent = startContainer.parentElement;\n            bufferAfter.push(startContainer.nodeValue.slice(startOffset).replaceAll(EOL_PATTERN, \"\"));\n            if (parent !== this.editorDiv) {\n                let buffer = bufferBefore;\n                for (const child of this.editorDiv.childNodes){\n                    if (child === parent) {\n                        buffer = bufferAfter;\n                        continue;\n                    }\n                    buffer.push(FreeTextEditor.#getNodeContent(child));\n                }\n            }\n            bufferBefore.push(startContainer.nodeValue.slice(0, startOffset).replaceAll(EOL_PATTERN, \"\"));\n        } else if (startContainer === this.editorDiv) {\n            let buffer = bufferBefore;\n            let i = 0;\n            for (const child of this.editorDiv.childNodes){\n                if (i++ === startOffset) {\n                    buffer = bufferAfter;\n                }\n                buffer.push(FreeTextEditor.#getNodeContent(child));\n            }\n        }\n        this.#content = `${bufferBefore.join(\"\\n\")}${paste}${bufferAfter.join(\"\\n\")}`;\n        this.#setContent();\n        const newRange = new Range();\n        let beforeLength = Math.sumPrecise(bufferBefore.map((line)=>line.length));\n        for (const { firstChild } of this.editorDiv.childNodes){\n            if (firstChild.nodeType === Node.TEXT_NODE) {\n                const length = firstChild.nodeValue.length;\n                if (beforeLength <= length) {\n                    newRange.setStart(firstChild, beforeLength);\n                    newRange.setEnd(firstChild, beforeLength);\n                    break;\n                }\n                beforeLength -= length;\n            }\n        }\n        selection.removeAllRanges();\n        selection.addRange(newRange);\n    }\n    #setContent() {\n        this.editorDiv.replaceChildren();\n        if (!this.#content) {\n            return;\n        }\n        for (const line of this.#content.split(\"\\n\")){\n            const div = document.createElement(\"div\");\n            div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n            this.editorDiv.append(div);\n        }\n    }\n    #serializeContent() {\n        return this.#content.replaceAll(\"\\xa0\", \" \");\n    }\n    static #deserializeContent(content) {\n        return content.replaceAll(\" \", \"\\xa0\");\n    }\n    get contentDiv() {\n        return this.editorDiv;\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        if (data instanceof FreeTextAnnotationElement) {\n            const { data: { defaultAppearanceData: { fontSize, fontColor }, rect, rotation, id, popupRef }, textContent, textPosition, parent: { page: { pageNumber } } } = data;\n            if (!textContent || textContent.length === 0) {\n                return null;\n            }\n            initialData = data = {\n                annotationType: AnnotationEditorType.FREETEXT,\n                color: Array.from(fontColor),\n                fontSize,\n                value: textContent.join(\"\\n\"),\n                position: textPosition,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                id,\n                deleted: false,\n                popupRef\n            };\n        }\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.#fontSize = data.fontSize;\n        editor.#color = Util.makeHexColor(...data.color);\n        editor.#content = FreeTextEditor.#deserializeContent(data.value);\n        editor.annotationElementId = data.id || null;\n        editor._initialData = initialData;\n        return editor;\n    }\n    serialize(isForCopying = false) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const padding = FreeTextEditor._internalPadding * this.parentScale;\n        const rect = this.getRect(padding, padding);\n        const color = AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.#color);\n        const serialized = {\n            annotationType: AnnotationEditorType.FREETEXT,\n            color,\n            fontSize: this.#fontSize,\n            value: this.#serializeContent(),\n            pageIndex: this.pageIndex,\n            rect,\n            rotation: this.rotation,\n            structTreeParentId: this._structTreeParentId\n        };\n        if (isForCopying) {\n            serialized.isCopy = true;\n            return serialized;\n        }\n        if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n            return null;\n        }\n        serialized.id = this.annotationElementId;\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { value, fontSize, color, pageIndex } = this._initialData;\n        return this._hasBeenMoved || serialized.value !== value || serialized.fontSize !== fontSize || serialized.color.some((c, i)=>c !== color[i]) || serialized.pageIndex !== pageIndex;\n    }\n    renderAnnotationElement(annotation) {\n        const content = super.renderAnnotationElement(annotation);\n        if (this.deleted) {\n            return content;\n        }\n        const { style } = content;\n        style.fontSize = `calc(${this.#fontSize}px * var(--total-scale-factor))`;\n        style.color = this.#color;\n        content.replaceChildren();\n        for (const line of this.#content.split(\"\\n\")){\n            const div = document.createElement(\"div\");\n            div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n            content.append(div);\n        }\n        const padding = FreeTextEditor._internalPadding * this.parentScale;\n        annotation.updateEdited({\n            rect: this.getRect(padding, padding),\n            popupContent: this.#content\n        });\n        return content;\n    }\n    resetAnnotationElement(annotation) {\n        super.resetAnnotationElement(annotation);\n        annotation.resetEdited();\n    }\n}\n; // ./src/display/editor/drawers/outline.js\nclass Outline {\n    static{\n        this.PRECISION = 1e-4;\n    }\n    toSVGPath() {\n        unreachable(\"Abstract method `toSVGPath` must be implemented.\");\n    }\n    get box() {\n        unreachable(\"Abstract getter `box` must be implemented.\");\n    }\n    serialize(_bbox, _rotation) {\n        unreachable(\"Abstract method `serialize` must be implemented.\");\n    }\n    static _rescale(src, tx, ty, sx, sy, dest) {\n        dest ||= new Float32Array(src.length);\n        for(let i = 0, ii = src.length; i < ii; i += 2){\n            dest[i] = tx + src[i] * sx;\n            dest[i + 1] = ty + src[i + 1] * sy;\n        }\n        return dest;\n    }\n    static _rescaleAndSwap(src, tx, ty, sx, sy, dest) {\n        dest ||= new Float32Array(src.length);\n        for(let i = 0, ii = src.length; i < ii; i += 2){\n            dest[i] = tx + src[i + 1] * sx;\n            dest[i + 1] = ty + src[i] * sy;\n        }\n        return dest;\n    }\n    static _translate(src, tx, ty, dest) {\n        dest ||= new Float32Array(src.length);\n        for(let i = 0, ii = src.length; i < ii; i += 2){\n            dest[i] = tx + src[i];\n            dest[i + 1] = ty + src[i + 1];\n        }\n        return dest;\n    }\n    static svgRound(x) {\n        return Math.round(x * 10000);\n    }\n    static _normalizePoint(x, y, parentWidth, parentHeight, rotation) {\n        switch(rotation){\n            case 90:\n                return [\n                    1 - y / parentWidth,\n                    x / parentHeight\n                ];\n            case 180:\n                return [\n                    1 - x / parentWidth,\n                    1 - y / parentHeight\n                ];\n            case 270:\n                return [\n                    y / parentWidth,\n                    1 - x / parentHeight\n                ];\n            default:\n                return [\n                    x / parentWidth,\n                    y / parentHeight\n                ];\n        }\n    }\n    static _normalizePagePoint(x, y, rotation) {\n        switch(rotation){\n            case 90:\n                return [\n                    1 - y,\n                    x\n                ];\n            case 180:\n                return [\n                    1 - x,\n                    1 - y\n                ];\n            case 270:\n                return [\n                    y,\n                    1 - x\n                ];\n            default:\n                return [\n                    x,\n                    y\n                ];\n        }\n    }\n    static createBezierPoints(x1, y1, x2, y2, x3, y3) {\n        return [\n            (x1 + 5 * x2) / 6,\n            (y1 + 5 * y2) / 6,\n            (5 * x2 + x3) / 6,\n            (5 * y2 + y3) / 6,\n            (x2 + x3) / 2,\n            (y2 + y3) / 2\n        ];\n    }\n}\n; // ./src/display/editor/drawers/freedraw.js\nclass FreeDrawOutliner {\n    #box;\n    #bottom;\n    #innerMargin;\n    #isLTR;\n    #top;\n    #last;\n    #lastX;\n    #lastY;\n    #min;\n    #min_dist;\n    #scaleFactor;\n    #thickness;\n    #points;\n    static #MIN_DIST = 8;\n    static #MIN_DIFF = 2;\n    static #MIN = FreeDrawOutliner.#MIN_DIST + FreeDrawOutliner.#MIN_DIFF;\n    constructor({ x, y }, box, scaleFactor, thickness, isLTR, innerMargin = 0){\n        this.#bottom = [];\n        this.#top = [];\n        this.#last = new Float32Array(18);\n        this.#points = [];\n        this.#box = box;\n        this.#thickness = thickness * scaleFactor;\n        this.#isLTR = isLTR;\n        this.#last.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            x,\n            y\n        ], 6);\n        this.#innerMargin = innerMargin;\n        this.#min_dist = FreeDrawOutliner.#MIN_DIST * scaleFactor;\n        this.#min = FreeDrawOutliner.#MIN * scaleFactor;\n        this.#scaleFactor = scaleFactor;\n        this.#points.push(x, y);\n    }\n    isEmpty() {\n        return isNaN(this.#last[8]);\n    }\n    #getLastCoords() {\n        const lastTop = this.#last.subarray(4, 6);\n        const lastBottom = this.#last.subarray(16, 18);\n        const [x, y, width, height] = this.#box;\n        return [\n            (this.#lastX + (lastTop[0] - lastBottom[0]) / 2 - x) / width,\n            (this.#lastY + (lastTop[1] - lastBottom[1]) / 2 - y) / height,\n            (this.#lastX + (lastBottom[0] - lastTop[0]) / 2 - x) / width,\n            (this.#lastY + (lastBottom[1] - lastTop[1]) / 2 - y) / height\n        ];\n    }\n    add({ x, y }) {\n        this.#lastX = x;\n        this.#lastY = y;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        let [x1, y1, x2, y2] = this.#last.subarray(8, 12);\n        const diffX = x - x2;\n        const diffY = y - y2;\n        const d = Math.hypot(diffX, diffY);\n        if (d < this.#min) {\n            return false;\n        }\n        const diffD = d - this.#min_dist;\n        const K = diffD / d;\n        const shiftX = K * diffX;\n        const shiftY = K * diffY;\n        let x0 = x1;\n        let y0 = y1;\n        x1 = x2;\n        y1 = y2;\n        x2 += shiftX;\n        y2 += shiftY;\n        this.#points?.push(x, y);\n        const nX = -shiftY / diffD;\n        const nY = shiftX / diffD;\n        const thX = nX * this.#thickness;\n        const thY = nY * this.#thickness;\n        this.#last.set(this.#last.subarray(2, 8), 0);\n        this.#last.set([\n            x2 + thX,\n            y2 + thY\n        ], 4);\n        this.#last.set(this.#last.subarray(14, 18), 12);\n        this.#last.set([\n            x2 - thX,\n            y2 - thY\n        ], 16);\n        if (isNaN(this.#last[6])) {\n            if (this.#top.length === 0) {\n                this.#last.set([\n                    x1 + thX,\n                    y1 + thY\n                ], 2);\n                this.#top.push(NaN, NaN, NaN, NaN, (x1 + thX - layerX) / layerWidth, (y1 + thY - layerY) / layerHeight);\n                this.#last.set([\n                    x1 - thX,\n                    y1 - thY\n                ], 14);\n                this.#bottom.push(NaN, NaN, NaN, NaN, (x1 - thX - layerX) / layerWidth, (y1 - thY - layerY) / layerHeight);\n            }\n            this.#last.set([\n                x0,\n                y0,\n                x1,\n                y1,\n                x2,\n                y2\n            ], 6);\n            return !this.isEmpty();\n        }\n        this.#last.set([\n            x0,\n            y0,\n            x1,\n            y1,\n            x2,\n            y2\n        ], 6);\n        const angle = Math.abs(Math.atan2(y0 - y1, x0 - x1) - Math.atan2(shiftY, shiftX));\n        if (angle < Math.PI / 2) {\n            [x1, y1, x2, y2] = this.#last.subarray(2, 6);\n            this.#top.push(NaN, NaN, NaN, NaN, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n            [x1, y1, x0, y0] = this.#last.subarray(14, 18);\n            this.#bottom.push(NaN, NaN, NaN, NaN, ((x0 + x1) / 2 - layerX) / layerWidth, ((y0 + y1) / 2 - layerY) / layerHeight);\n            return true;\n        }\n        [x0, y0, x1, y1, x2, y2] = this.#last.subarray(0, 6);\n        this.#top.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n        [x2, y2, x1, y1, x0, y0] = this.#last.subarray(12, 18);\n        this.#bottom.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n        return true;\n    }\n    toSVGPath() {\n        if (this.isEmpty()) {\n            return \"\";\n        }\n        const top = this.#top;\n        const bottom = this.#bottom;\n        if (isNaN(this.#last[6]) && !this.isEmpty()) {\n            return this.#toSVGPathTwoPoints();\n        }\n        const buffer = [];\n        buffer.push(`M${top[4]} ${top[5]}`);\n        for(let i = 6; i < top.length; i += 6){\n            if (isNaN(top[i])) {\n                buffer.push(`L${top[i + 4]} ${top[i + 5]}`);\n            } else {\n                buffer.push(`C${top[i]} ${top[i + 1]} ${top[i + 2]} ${top[i + 3]} ${top[i + 4]} ${top[i + 5]}`);\n            }\n        }\n        this.#toSVGPathEnd(buffer);\n        for(let i = bottom.length - 6; i >= 6; i -= 6){\n            if (isNaN(bottom[i])) {\n                buffer.push(`L${bottom[i + 4]} ${bottom[i + 5]}`);\n            } else {\n                buffer.push(`C${bottom[i]} ${bottom[i + 1]} ${bottom[i + 2]} ${bottom[i + 3]} ${bottom[i + 4]} ${bottom[i + 5]}`);\n            }\n        }\n        this.#toSVGPathStart(buffer);\n        return buffer.join(\" \");\n    }\n    #toSVGPathTwoPoints() {\n        const [x, y, width, height] = this.#box;\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        return `M${(this.#last[2] - x) / width} ${(this.#last[3] - y) / height} L${(this.#last[4] - x) / width} ${(this.#last[5] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(this.#last[16] - x) / width} ${(this.#last[17] - y) / height} L${(this.#last[14] - x) / width} ${(this.#last[15] - y) / height} Z`;\n    }\n    #toSVGPathStart(buffer) {\n        const bottom = this.#bottom;\n        buffer.push(`L${bottom[4]} ${bottom[5]} Z`);\n    }\n    #toSVGPathEnd(buffer) {\n        const [x, y, width, height] = this.#box;\n        const lastTop = this.#last.subarray(4, 6);\n        const lastBottom = this.#last.subarray(16, 18);\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        buffer.push(`L${(lastTop[0] - x) / width} ${(lastTop[1] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(lastBottom[0] - x) / width} ${(lastBottom[1] - y) / height}`);\n    }\n    newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {\n        return new FreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR);\n    }\n    getOutlines() {\n        const top = this.#top;\n        const bottom = this.#bottom;\n        const last = this.#last;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const points = new Float32Array((this.#points?.length ?? 0) + 2);\n        for(let i = 0, ii = points.length - 2; i < ii; i += 2){\n            points[i] = (this.#points[i] - layerX) / layerWidth;\n            points[i + 1] = (this.#points[i + 1] - layerY) / layerHeight;\n        }\n        points[points.length - 2] = (this.#lastX - layerX) / layerWidth;\n        points[points.length - 1] = (this.#lastY - layerY) / layerHeight;\n        if (isNaN(last[6]) && !this.isEmpty()) {\n            return this.#getOutlineTwoPoints(points);\n        }\n        const outline = new Float32Array(this.#top.length + 24 + this.#bottom.length);\n        let N = top.length;\n        for(let i = 0; i < N; i += 2){\n            if (isNaN(top[i])) {\n                outline[i] = outline[i + 1] = NaN;\n                continue;\n            }\n            outline[i] = top[i];\n            outline[i + 1] = top[i + 1];\n        }\n        N = this.#getOutlineEnd(outline, N);\n        for(let i = bottom.length - 6; i >= 6; i -= 6){\n            for(let j = 0; j < 6; j += 2){\n                if (isNaN(bottom[i + j])) {\n                    outline[N] = outline[N + 1] = NaN;\n                    N += 2;\n                    continue;\n                }\n                outline[N] = bottom[i + j];\n                outline[N + 1] = bottom[i + j + 1];\n                N += 2;\n            }\n        }\n        this.#getOutlineStart(outline, N);\n        return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);\n    }\n    #getOutlineTwoPoints(points) {\n        const last = this.#last;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        const outline = new Float32Array(36);\n        outline.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[2] - layerX) / layerWidth,\n            (last[3] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[4] - layerX) / layerWidth,\n            (last[5] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastTopX,\n            lastTopY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastBottomX,\n            lastBottomY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[16] - layerX) / layerWidth,\n            (last[17] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[14] - layerX) / layerWidth,\n            (last[15] - layerY) / layerHeight\n        ], 0);\n        return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);\n    }\n    #getOutlineStart(outline, pos) {\n        const bottom = this.#bottom;\n        outline.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            bottom[4],\n            bottom[5]\n        ], pos);\n        return pos += 6;\n    }\n    #getOutlineEnd(outline, pos) {\n        const lastTop = this.#last.subarray(4, 6);\n        const lastBottom = this.#last.subarray(16, 18);\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        outline.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (lastTop[0] - layerX) / layerWidth,\n            (lastTop[1] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastTopX,\n            lastTopY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastBottomX,\n            lastBottomY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (lastBottom[0] - layerX) / layerWidth,\n            (lastBottom[1] - layerY) / layerHeight\n        ], pos);\n        return pos += 24;\n    }\n}\nclass FreeDrawOutline extends Outline {\n    #box;\n    #bbox;\n    #innerMargin;\n    #isLTR;\n    #points;\n    #scaleFactor;\n    #outline;\n    constructor(outline, points, box, scaleFactor, innerMargin, isLTR){\n        super();\n        this.#bbox = new Float32Array(4);\n        this.#outline = outline;\n        this.#points = points;\n        this.#box = box;\n        this.#scaleFactor = scaleFactor;\n        this.#innerMargin = innerMargin;\n        this.#isLTR = isLTR;\n        this.lastPoint = [\n            NaN,\n            NaN\n        ];\n        this.#computeMinMax(isLTR);\n        const [x, y, width, height] = this.#bbox;\n        for(let i = 0, ii = outline.length; i < ii; i += 2){\n            outline[i] = (outline[i] - x) / width;\n            outline[i + 1] = (outline[i + 1] - y) / height;\n        }\n        for(let i = 0, ii = points.length; i < ii; i += 2){\n            points[i] = (points[i] - x) / width;\n            points[i + 1] = (points[i + 1] - y) / height;\n        }\n    }\n    toSVGPath() {\n        const buffer = [\n            `M${this.#outline[4]} ${this.#outline[5]}`\n        ];\n        for(let i = 6, ii = this.#outline.length; i < ii; i += 6){\n            if (isNaN(this.#outline[i])) {\n                buffer.push(`L${this.#outline[i + 4]} ${this.#outline[i + 5]}`);\n                continue;\n            }\n            buffer.push(`C${this.#outline[i]} ${this.#outline[i + 1]} ${this.#outline[i + 2]} ${this.#outline[i + 3]} ${this.#outline[i + 4]} ${this.#outline[i + 5]}`);\n        }\n        buffer.push(\"Z\");\n        return buffer.join(\" \");\n    }\n    serialize([blX, blY, trX, trY], rotation) {\n        const width = trX - blX;\n        const height = trY - blY;\n        let outline;\n        let points;\n        switch(rotation){\n            case 0:\n                outline = Outline._rescale(this.#outline, blX, trY, width, -height);\n                points = Outline._rescale(this.#points, blX, trY, width, -height);\n                break;\n            case 90:\n                outline = Outline._rescaleAndSwap(this.#outline, blX, blY, width, height);\n                points = Outline._rescaleAndSwap(this.#points, blX, blY, width, height);\n                break;\n            case 180:\n                outline = Outline._rescale(this.#outline, trX, blY, -width, height);\n                points = Outline._rescale(this.#points, trX, blY, -width, height);\n                break;\n            case 270:\n                outline = Outline._rescaleAndSwap(this.#outline, trX, trY, -width, -height);\n                points = Outline._rescaleAndSwap(this.#points, trX, trY, -width, -height);\n                break;\n        }\n        return {\n            outline: Array.from(outline),\n            points: [\n                Array.from(points)\n            ]\n        };\n    }\n    #computeMinMax(isLTR) {\n        const outline = this.#outline;\n        let lastX = outline[4];\n        let lastY = outline[5];\n        const minMax = [\n            lastX,\n            lastY,\n            lastX,\n            lastY\n        ];\n        let lastPointX = lastX;\n        let lastPointY = lastY;\n        const ltrCallback = isLTR ? Math.max : Math.min;\n        for(let i = 6, ii = outline.length; i < ii; i += 6){\n            const x = outline[i + 4], y = outline[i + 5];\n            if (isNaN(outline[i])) {\n                Util.pointBoundingBox(x, y, minMax);\n                if (lastPointY < y) {\n                    lastPointX = x;\n                    lastPointY = y;\n                } else if (lastPointY === y) {\n                    lastPointX = ltrCallback(lastPointX, x);\n                }\n            } else {\n                const bbox = [\n                    Infinity,\n                    Infinity,\n                    -Infinity,\n                    -Infinity\n                ];\n                Util.bezierBoundingBox(lastX, lastY, ...outline.slice(i, i + 6), bbox);\n                Util.rectBoundingBox(...bbox, minMax);\n                if (lastPointY < bbox[3]) {\n                    lastPointX = bbox[2];\n                    lastPointY = bbox[3];\n                } else if (lastPointY === bbox[3]) {\n                    lastPointX = ltrCallback(lastPointX, bbox[2]);\n                }\n            }\n            lastX = x;\n            lastY = y;\n        }\n        const bbox = this.#bbox;\n        bbox[0] = minMax[0] - this.#innerMargin;\n        bbox[1] = minMax[1] - this.#innerMargin;\n        bbox[2] = minMax[2] - minMax[0] + 2 * this.#innerMargin;\n        bbox[3] = minMax[3] - minMax[1] + 2 * this.#innerMargin;\n        this.lastPoint = [\n            lastPointX,\n            lastPointY\n        ];\n    }\n    get box() {\n        return this.#bbox;\n    }\n    newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {\n        return new FreeDrawOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);\n    }\n    getNewOutline(thickness, innerMargin) {\n        const [x, y, width, height] = this.#bbox;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const sx = width * layerWidth;\n        const sy = height * layerHeight;\n        const tx = x * layerWidth + layerX;\n        const ty = y * layerHeight + layerY;\n        const outliner = this.newOutliner({\n            x: this.#points[0] * sx + tx,\n            y: this.#points[1] * sy + ty\n        }, this.#box, this.#scaleFactor, thickness, this.#isLTR, innerMargin ?? this.#innerMargin);\n        for(let i = 2; i < this.#points.length; i += 2){\n            outliner.add({\n                x: this.#points[i] * sx + tx,\n                y: this.#points[i + 1] * sy + ty\n            });\n        }\n        return outliner.getOutlines();\n    }\n}\n; // ./src/display/editor/drawers/highlight.js\nclass HighlightOutliner {\n    #box;\n    #lastPoint;\n    #verticalEdges;\n    #intervals;\n    constructor(boxes, borderWidth = 0, innerMargin = 0, isLTR = true){\n        this.#verticalEdges = [];\n        this.#intervals = [];\n        const minMax = [\n            Infinity,\n            Infinity,\n            -Infinity,\n            -Infinity\n        ];\n        const NUMBER_OF_DIGITS = 4;\n        const EPSILON = 10 ** -NUMBER_OF_DIGITS;\n        for (const { x, y, width, height } of boxes){\n            const x1 = Math.floor((x - borderWidth) / EPSILON) * EPSILON;\n            const x2 = Math.ceil((x + width + borderWidth) / EPSILON) * EPSILON;\n            const y1 = Math.floor((y - borderWidth) / EPSILON) * EPSILON;\n            const y2 = Math.ceil((y + height + borderWidth) / EPSILON) * EPSILON;\n            const left = [\n                x1,\n                y1,\n                y2,\n                true\n            ];\n            const right = [\n                x2,\n                y1,\n                y2,\n                false\n            ];\n            this.#verticalEdges.push(left, right);\n            Util.rectBoundingBox(x1, y1, x2, y2, minMax);\n        }\n        const bboxWidth = minMax[2] - minMax[0] + 2 * innerMargin;\n        const bboxHeight = minMax[3] - minMax[1] + 2 * innerMargin;\n        const shiftedMinX = minMax[0] - innerMargin;\n        const shiftedMinY = minMax[1] - innerMargin;\n        const lastEdge = this.#verticalEdges.at(isLTR ? -1 : -2);\n        const lastPoint = [\n            lastEdge[0],\n            lastEdge[2]\n        ];\n        for (const edge of this.#verticalEdges){\n            const [x, y1, y2] = edge;\n            edge[0] = (x - shiftedMinX) / bboxWidth;\n            edge[1] = (y1 - shiftedMinY) / bboxHeight;\n            edge[2] = (y2 - shiftedMinY) / bboxHeight;\n        }\n        this.#box = new Float32Array([\n            shiftedMinX,\n            shiftedMinY,\n            bboxWidth,\n            bboxHeight\n        ]);\n        this.#lastPoint = lastPoint;\n    }\n    getOutlines() {\n        this.#verticalEdges.sort((a, b)=>a[0] - b[0] || a[1] - b[1] || a[2] - b[2]);\n        const outlineVerticalEdges = [];\n        for (const edge of this.#verticalEdges){\n            if (edge[3]) {\n                outlineVerticalEdges.push(...this.#breakEdge(edge));\n                this.#insert(edge);\n            } else {\n                this.#remove(edge);\n                outlineVerticalEdges.push(...this.#breakEdge(edge));\n            }\n        }\n        return this.#getOutlines(outlineVerticalEdges);\n    }\n    #getOutlines(outlineVerticalEdges) {\n        const edges = [];\n        const allEdges = new Set();\n        for (const edge of outlineVerticalEdges){\n            const [x, y1, y2] = edge;\n            edges.push([\n                x,\n                y1,\n                edge\n            ], [\n                x,\n                y2,\n                edge\n            ]);\n        }\n        edges.sort((a, b)=>a[1] - b[1] || a[0] - b[0]);\n        for(let i = 0, ii = edges.length; i < ii; i += 2){\n            const edge1 = edges[i][2];\n            const edge2 = edges[i + 1][2];\n            edge1.push(edge2);\n            edge2.push(edge1);\n            allEdges.add(edge1);\n            allEdges.add(edge2);\n        }\n        const outlines = [];\n        let outline;\n        while(allEdges.size > 0){\n            const edge = allEdges.values().next().value;\n            let [x, y1, y2, edge1, edge2] = edge;\n            allEdges.delete(edge);\n            let lastPointX = x;\n            let lastPointY = y1;\n            outline = [\n                x,\n                y2\n            ];\n            outlines.push(outline);\n            while(true){\n                let e;\n                if (allEdges.has(edge1)) {\n                    e = edge1;\n                } else if (allEdges.has(edge2)) {\n                    e = edge2;\n                } else {\n                    break;\n                }\n                allEdges.delete(e);\n                [x, y1, y2, edge1, edge2] = e;\n                if (lastPointX !== x) {\n                    outline.push(lastPointX, lastPointY, x, lastPointY === y1 ? y1 : y2);\n                    lastPointX = x;\n                }\n                lastPointY = lastPointY === y1 ? y2 : y1;\n            }\n            outline.push(lastPointX, lastPointY);\n        }\n        return new HighlightOutline(outlines, this.#box, this.#lastPoint);\n    }\n    #binarySearch(y) {\n        const array = this.#intervals;\n        let start = 0;\n        let end = array.length - 1;\n        while(start <= end){\n            const middle = start + end >> 1;\n            const y1 = array[middle][0];\n            if (y1 === y) {\n                return middle;\n            }\n            if (y1 < y) {\n                start = middle + 1;\n            } else {\n                end = middle - 1;\n            }\n        }\n        return end + 1;\n    }\n    #insert([, y1, y2]) {\n        const index = this.#binarySearch(y1);\n        this.#intervals.splice(index, 0, [\n            y1,\n            y2\n        ]);\n    }\n    #remove([, y1, y2]) {\n        const index = this.#binarySearch(y1);\n        for(let i = index; i < this.#intervals.length; i++){\n            const [start, end] = this.#intervals[i];\n            if (start !== y1) {\n                break;\n            }\n            if (start === y1 && end === y2) {\n                this.#intervals.splice(i, 1);\n                return;\n            }\n        }\n        for(let i = index - 1; i >= 0; i--){\n            const [start, end] = this.#intervals[i];\n            if (start !== y1) {\n                break;\n            }\n            if (start === y1 && end === y2) {\n                this.#intervals.splice(i, 1);\n                return;\n            }\n        }\n    }\n    #breakEdge(edge) {\n        const [x, y1, y2] = edge;\n        const results = [\n            [\n                x,\n                y1,\n                y2\n            ]\n        ];\n        const index = this.#binarySearch(y2);\n        for(let i = 0; i < index; i++){\n            const [start, end] = this.#intervals[i];\n            for(let j = 0, jj = results.length; j < jj; j++){\n                const [, y3, y4] = results[j];\n                if (end <= y3 || y4 <= start) {\n                    continue;\n                }\n                if (y3 >= start) {\n                    if (y4 > end) {\n                        results[j][1] = end;\n                    } else {\n                        if (jj === 1) {\n                            return [];\n                        }\n                        results.splice(j, 1);\n                        j--;\n                        jj--;\n                    }\n                    continue;\n                }\n                results[j][2] = start;\n                if (y4 > end) {\n                    results.push([\n                        x,\n                        end,\n                        y4\n                    ]);\n                }\n            }\n        }\n        return results;\n    }\n}\nclass HighlightOutline extends Outline {\n    #box;\n    #outlines;\n    constructor(outlines, box, lastPoint){\n        super();\n        this.#outlines = outlines;\n        this.#box = box;\n        this.lastPoint = lastPoint;\n    }\n    toSVGPath() {\n        const buffer = [];\n        for (const polygon of this.#outlines){\n            let [prevX, prevY] = polygon;\n            buffer.push(`M${prevX} ${prevY}`);\n            for(let i = 2; i < polygon.length; i += 2){\n                const x = polygon[i];\n                const y = polygon[i + 1];\n                if (x === prevX) {\n                    buffer.push(`V${y}`);\n                    prevY = y;\n                } else if (y === prevY) {\n                    buffer.push(`H${x}`);\n                    prevX = x;\n                }\n            }\n            buffer.push(\"Z\");\n        }\n        return buffer.join(\" \");\n    }\n    serialize([blX, blY, trX, trY], _rotation) {\n        const outlines = [];\n        const width = trX - blX;\n        const height = trY - blY;\n        for (const outline of this.#outlines){\n            const points = new Array(outline.length);\n            for(let i = 0; i < outline.length; i += 2){\n                points[i] = blX + outline[i] * width;\n                points[i + 1] = trY - outline[i + 1] * height;\n            }\n            outlines.push(points);\n        }\n        return outlines;\n    }\n    get box() {\n        return this.#box;\n    }\n    get classNamesForOutlining() {\n        return [\n            \"highlightOutline\"\n        ];\n    }\n}\nclass FreeHighlightOutliner extends FreeDrawOutliner {\n    newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {\n        return new FreeHighlightOutline(outline, points, box, scaleFactor, innerMargin, isLTR);\n    }\n}\nclass FreeHighlightOutline extends FreeDrawOutline {\n    newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {\n        return new FreeHighlightOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);\n    }\n}\n; // ./src/display/editor/color_picker.js\nclass ColorPicker {\n    #button;\n    #buttonSwatch;\n    #defaultColor;\n    #dropdown;\n    #dropdownWasFromKeyboard;\n    #isMainColorPicker;\n    #editor;\n    #eventBus;\n    #openDropdownAC;\n    #uiManager;\n    #type;\n    static #l10nColor = null;\n    static get _keyboardManager() {\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                ColorPicker.prototype._hideDropdownFromKeyboard\n            ],\n            [\n                [\n                    \" \",\n                    \"mac+ \"\n                ],\n                ColorPicker.prototype._colorSelectFromKeyboard\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"ArrowRight\",\n                    \"mac+ArrowDown\",\n                    \"mac+ArrowRight\"\n                ],\n                ColorPicker.prototype._moveToNext\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"ArrowLeft\",\n                    \"mac+ArrowUp\",\n                    \"mac+ArrowLeft\"\n                ],\n                ColorPicker.prototype._moveToPrevious\n            ],\n            [\n                [\n                    \"Home\",\n                    \"mac+Home\"\n                ],\n                ColorPicker.prototype._moveToBeginning\n            ],\n            [\n                [\n                    \"End\",\n                    \"mac+End\"\n                ],\n                ColorPicker.prototype._moveToEnd\n            ]\n        ]));\n    }\n    constructor({ editor = null, uiManager = null }){\n        this.#button = null;\n        this.#buttonSwatch = null;\n        this.#dropdown = null;\n        this.#dropdownWasFromKeyboard = false;\n        this.#isMainColorPicker = false;\n        this.#editor = null;\n        this.#openDropdownAC = null;\n        this.#uiManager = null;\n        if (editor) {\n            this.#isMainColorPicker = false;\n            this.#type = AnnotationEditorParamsType.HIGHLIGHT_COLOR;\n            this.#editor = editor;\n        } else {\n            this.#isMainColorPicker = true;\n            this.#type = AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR;\n        }\n        this.#uiManager = editor?._uiManager || uiManager;\n        this.#eventBus = this.#uiManager._eventBus;\n        this.#defaultColor = editor?.color || this.#uiManager?.highlightColors.values().next().value || \"#FFFF98\";\n        ColorPicker.#l10nColor ||= Object.freeze({\n            blue: \"pdfjs-editor-colorpicker-blue\",\n            green: \"pdfjs-editor-colorpicker-green\",\n            pink: \"pdfjs-editor-colorpicker-pink\",\n            red: \"pdfjs-editor-colorpicker-red\",\n            yellow: \"pdfjs-editor-colorpicker-yellow\"\n        });\n    }\n    renderButton() {\n        const button = this.#button = document.createElement(\"button\");\n        button.className = \"colorPicker\";\n        button.tabIndex = \"0\";\n        button.setAttribute(\"data-l10n-id\", \"pdfjs-editor-colorpicker-button\");\n        button.setAttribute(\"aria-haspopup\", true);\n        const signal = this.#uiManager._signal;\n        button.addEventListener(\"click\", this.#openDropdown.bind(this), {\n            signal\n        });\n        button.addEventListener(\"keydown\", this.#keyDown.bind(this), {\n            signal\n        });\n        const swatch = this.#buttonSwatch = document.createElement(\"span\");\n        swatch.className = \"swatch\";\n        swatch.setAttribute(\"aria-hidden\", true);\n        swatch.style.backgroundColor = this.#defaultColor;\n        button.append(swatch);\n        return button;\n    }\n    renderMainDropdown() {\n        const dropdown = this.#dropdown = this.#getDropdownRoot();\n        dropdown.setAttribute(\"aria-orientation\", \"horizontal\");\n        dropdown.setAttribute(\"aria-labelledby\", \"highlightColorPickerLabel\");\n        return dropdown;\n    }\n    #getDropdownRoot() {\n        const div = document.createElement(\"div\");\n        const signal = this.#uiManager._signal;\n        div.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        div.className = \"dropdown\";\n        div.role = \"listbox\";\n        div.setAttribute(\"aria-multiselectable\", false);\n        div.setAttribute(\"aria-orientation\", \"vertical\");\n        div.setAttribute(\"data-l10n-id\", \"pdfjs-editor-colorpicker-dropdown\");\n        for (const [name, color] of this.#uiManager.highlightColors){\n            const button = document.createElement(\"button\");\n            button.tabIndex = \"0\";\n            button.role = \"option\";\n            button.setAttribute(\"data-color\", color);\n            button.title = name;\n            button.setAttribute(\"data-l10n-id\", ColorPicker.#l10nColor[name]);\n            const swatch = document.createElement(\"span\");\n            button.append(swatch);\n            swatch.className = \"swatch\";\n            swatch.style.backgroundColor = color;\n            button.setAttribute(\"aria-selected\", color === this.#defaultColor);\n            button.addEventListener(\"click\", this.#colorSelect.bind(this, color), {\n                signal\n            });\n            div.append(button);\n        }\n        div.addEventListener(\"keydown\", this.#keyDown.bind(this), {\n            signal\n        });\n        return div;\n    }\n    #colorSelect(color, event) {\n        event.stopPropagation();\n        this.#eventBus.dispatch(\"switchannotationeditorparams\", {\n            source: this,\n            type: this.#type,\n            value: color\n        });\n    }\n    _colorSelectFromKeyboard(event) {\n        if (event.target === this.#button) {\n            this.#openDropdown(event);\n            return;\n        }\n        const color = event.target.getAttribute(\"data-color\");\n        if (!color) {\n            return;\n        }\n        this.#colorSelect(color, event);\n    }\n    _moveToNext(event) {\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n            return;\n        }\n        if (event.target === this.#button) {\n            this.#dropdown.firstChild?.focus();\n            return;\n        }\n        event.target.nextSibling?.focus();\n    }\n    _moveToPrevious(event) {\n        if (event.target === this.#dropdown?.firstChild || event.target === this.#button) {\n            if (this.#isDropdownVisible) {\n                this._hideDropdownFromKeyboard();\n            }\n            return;\n        }\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n        }\n        event.target.previousSibling?.focus();\n    }\n    _moveToBeginning(event) {\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n            return;\n        }\n        this.#dropdown.firstChild?.focus();\n    }\n    _moveToEnd(event) {\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n            return;\n        }\n        this.#dropdown.lastChild?.focus();\n    }\n    #keyDown(event) {\n        ColorPicker._keyboardManager.exec(this, event);\n    }\n    #openDropdown(event) {\n        if (this.#isDropdownVisible) {\n            this.hideDropdown();\n            return;\n        }\n        this.#dropdownWasFromKeyboard = event.detail === 0;\n        if (!this.#openDropdownAC) {\n            this.#openDropdownAC = new AbortController();\n            window.addEventListener(\"pointerdown\", this.#pointerDown.bind(this), {\n                signal: this.#uiManager.combinedSignal(this.#openDropdownAC)\n            });\n        }\n        if (this.#dropdown) {\n            this.#dropdown.classList.remove(\"hidden\");\n            return;\n        }\n        const root = this.#dropdown = this.#getDropdownRoot();\n        this.#button.append(root);\n    }\n    #pointerDown(event) {\n        if (this.#dropdown?.contains(event.target)) {\n            return;\n        }\n        this.hideDropdown();\n    }\n    hideDropdown() {\n        this.#dropdown?.classList.add(\"hidden\");\n        this.#openDropdownAC?.abort();\n        this.#openDropdownAC = null;\n    }\n    get #isDropdownVisible() {\n        return this.#dropdown && !this.#dropdown.classList.contains(\"hidden\");\n    }\n    _hideDropdownFromKeyboard() {\n        if (this.#isMainColorPicker) {\n            return;\n        }\n        if (!this.#isDropdownVisible) {\n            this.#editor?.unselect();\n            return;\n        }\n        this.hideDropdown();\n        this.#button.focus({\n            preventScroll: true,\n            focusVisible: this.#dropdownWasFromKeyboard\n        });\n    }\n    updateColor(color) {\n        if (this.#buttonSwatch) {\n            this.#buttonSwatch.style.backgroundColor = color;\n        }\n        if (!this.#dropdown) {\n            return;\n        }\n        const i = this.#uiManager.highlightColors.values();\n        for (const child of this.#dropdown.children){\n            child.setAttribute(\"aria-selected\", i.next().value === color);\n        }\n    }\n    destroy() {\n        this.#button?.remove();\n        this.#button = null;\n        this.#buttonSwatch = null;\n        this.#dropdown?.remove();\n        this.#dropdown = null;\n    }\n}\n; // ./src/display/editor/highlight.js\nclass HighlightEditor extends AnnotationEditor {\n    #anchorNode;\n    #anchorOffset;\n    #boxes;\n    #clipPathId;\n    #colorPicker;\n    #focusOutlines;\n    #focusNode;\n    #focusOffset;\n    #highlightDiv;\n    #highlightOutlines;\n    #id;\n    #isFreeHighlight;\n    #lastPoint;\n    #opacity;\n    #outlineId;\n    #text;\n    #thickness;\n    #methodOfCreation;\n    static{\n        this._defaultColor = null;\n    }\n    static{\n        this._defaultOpacity = 1;\n    }\n    static{\n        this._defaultThickness = 12;\n    }\n    static{\n        this._type = \"highlight\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.HIGHLIGHT;\n    }\n    static{\n        this._freeHighlightId = -1;\n    }\n    static{\n        this._freeHighlight = null;\n    }\n    static{\n        this._freeHighlightClipId = \"\";\n    }\n    static get _keyboardManager() {\n        const proto = HighlightEditor.prototype;\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        1\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        2\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        3\n                    ]\n                }\n            ]\n        ]));\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"highlightEditor\"\n        });\n        this.#anchorNode = null;\n        this.#anchorOffset = 0;\n        this.#clipPathId = null;\n        this.#colorPicker = null;\n        this.#focusOutlines = null;\n        this.#focusNode = null;\n        this.#focusOffset = 0;\n        this.#highlightDiv = null;\n        this.#highlightOutlines = null;\n        this.#id = null;\n        this.#isFreeHighlight = false;\n        this.#lastPoint = null;\n        this.#outlineId = null;\n        this.#text = \"\";\n        this.#methodOfCreation = \"\";\n        this.color = params.color || HighlightEditor._defaultColor;\n        this.#thickness = params.thickness || HighlightEditor._defaultThickness;\n        this.#opacity = params.opacity || HighlightEditor._defaultOpacity;\n        this.#boxes = params.boxes || null;\n        this.#methodOfCreation = params.methodOfCreation || \"\";\n        this.#text = params.text || \"\";\n        this._isDraggable = false;\n        this.defaultL10nId = \"pdfjs-editor-highlight-editor\";\n        if (params.highlightId > -1) {\n            this.#isFreeHighlight = true;\n            this.#createFreeOutlines(params);\n            this.#addToDrawLayer();\n        } else if (this.#boxes) {\n            this.#anchorNode = params.anchorNode;\n            this.#anchorOffset = params.anchorOffset;\n            this.#focusNode = params.focusNode;\n            this.#focusOffset = params.focusOffset;\n            this.#createOutlines();\n            this.#addToDrawLayer();\n            this.rotate(this.rotation);\n        }\n    }\n    get telemetryInitialData() {\n        return {\n            action: \"added\",\n            type: this.#isFreeHighlight ? \"free_highlight\" : \"highlight\",\n            color: this._uiManager.highlightColorNames.get(this.color),\n            thickness: this.#thickness,\n            methodOfCreation: this.#methodOfCreation\n        };\n    }\n    get telemetryFinalData() {\n        return {\n            type: \"highlight\",\n            color: this._uiManager.highlightColorNames.get(this.color)\n        };\n    }\n    static computeTelemetryFinalData(data) {\n        return {\n            numberOfColors: data.get(\"color\").size\n        };\n    }\n    #createOutlines() {\n        const outliner = new HighlightOutliner(this.#boxes, 0.001);\n        this.#highlightOutlines = outliner.getOutlines();\n        [this.x, this.y, this.width, this.height] = this.#highlightOutlines.box;\n        const outlinerForOutline = new HighlightOutliner(this.#boxes, 0.0025, 0.001, this._uiManager.direction === \"ltr\");\n        this.#focusOutlines = outlinerForOutline.getOutlines();\n        const { lastPoint } = this.#focusOutlines;\n        this.#lastPoint = [\n            (lastPoint[0] - this.x) / this.width,\n            (lastPoint[1] - this.y) / this.height\n        ];\n    }\n    #createFreeOutlines({ highlightOutlines, highlightId, clipPathId }) {\n        this.#highlightOutlines = highlightOutlines;\n        const extraThickness = 1.5;\n        this.#focusOutlines = highlightOutlines.getNewOutline(this.#thickness / 2 + extraThickness, 0.0025);\n        if (highlightId >= 0) {\n            this.#id = highlightId;\n            this.#clipPathId = clipPathId;\n            this.parent.drawLayer.finalizeDraw(highlightId, {\n                bbox: highlightOutlines.box,\n                path: {\n                    d: highlightOutlines.toSVGPath()\n                }\n            });\n            this.#outlineId = this.parent.drawLayer.drawOutline({\n                rootClass: {\n                    highlightOutline: true,\n                    free: true\n                },\n                bbox: this.#focusOutlines.box,\n                path: {\n                    d: this.#focusOutlines.toSVGPath()\n                }\n            }, true);\n        } else if (this.parent) {\n            const angle = this.parent.viewport.rotation;\n            this.parent.drawLayer.updateProperties(this.#id, {\n                bbox: HighlightEditor.#rotateBbox(this.#highlightOutlines.box, (angle - this.rotation + 360) % 360),\n                path: {\n                    d: highlightOutlines.toSVGPath()\n                }\n            });\n            this.parent.drawLayer.updateProperties(this.#outlineId, {\n                bbox: HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle),\n                path: {\n                    d: this.#focusOutlines.toSVGPath()\n                }\n            });\n        }\n        const [x, y, width, height] = highlightOutlines.box;\n        switch(this.rotation){\n            case 0:\n                this.x = x;\n                this.y = y;\n                this.width = width;\n                this.height = height;\n                break;\n            case 90:\n                {\n                    const [pageWidth, pageHeight] = this.parentDimensions;\n                    this.x = y;\n                    this.y = 1 - x;\n                    this.width = width * pageHeight / pageWidth;\n                    this.height = height * pageWidth / pageHeight;\n                    break;\n                }\n            case 180:\n                this.x = 1 - x;\n                this.y = 1 - y;\n                this.width = width;\n                this.height = height;\n                break;\n            case 270:\n                {\n                    const [pageWidth, pageHeight] = this.parentDimensions;\n                    this.x = 1 - y;\n                    this.y = x;\n                    this.width = width * pageHeight / pageWidth;\n                    this.height = height * pageWidth / pageHeight;\n                    break;\n                }\n        }\n        const { lastPoint } = this.#focusOutlines;\n        this.#lastPoint = [\n            (lastPoint[0] - x) / width,\n            (lastPoint[1] - y) / height\n        ];\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n        HighlightEditor._defaultColor ||= uiManager.highlightColors?.values().next().value || \"#fff066\";\n    }\n    static updateDefaultParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR:\n                HighlightEditor._defaultColor = value;\n                break;\n            case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:\n                HighlightEditor._defaultThickness = value;\n                break;\n        }\n    }\n    translateInPage(x, y) {}\n    get toolbarPosition() {\n        return this.#lastPoint;\n    }\n    updateParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.HIGHLIGHT_COLOR:\n                this.#updateColor(value);\n                break;\n            case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:\n                this.#updateThickness(value);\n                break;\n        }\n    }\n    static get defaultPropertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR,\n                HighlightEditor._defaultColor\n            ],\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_THICKNESS,\n                HighlightEditor._defaultThickness\n            ]\n        ];\n    }\n    get propertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n                this.color || HighlightEditor._defaultColor\n            ],\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_THICKNESS,\n                this.#thickness || HighlightEditor._defaultThickness\n            ],\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_FREE,\n                this.#isFreeHighlight\n            ]\n        ];\n    }\n    #updateColor(color) {\n        const setColorAndOpacity = (col, opa)=>{\n            this.color = col;\n            this.#opacity = opa;\n            this.parent?.drawLayer.updateProperties(this.#id, {\n                root: {\n                    fill: col,\n                    \"fill-opacity\": opa\n                }\n            });\n            this.#colorPicker?.updateColor(col);\n        };\n        const savedColor = this.color;\n        const savedOpacity = this.#opacity;\n        this.addCommands({\n            cmd: setColorAndOpacity.bind(this, color, HighlightEditor._defaultOpacity),\n            undo: setColorAndOpacity.bind(this, savedColor, savedOpacity),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n        this._reportTelemetry({\n            action: \"color_changed\",\n            color: this._uiManager.highlightColorNames.get(color)\n        }, true);\n    }\n    #updateThickness(thickness) {\n        const savedThickness = this.#thickness;\n        const setThickness = (th)=>{\n            this.#thickness = th;\n            this.#changeThickness(th);\n        };\n        this.addCommands({\n            cmd: setThickness.bind(this, thickness),\n            undo: setThickness.bind(this, savedThickness),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.INK_THICKNESS,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n        this._reportTelemetry({\n            action: \"thickness_changed\",\n            thickness\n        }, true);\n    }\n    async addEditToolbar() {\n        const toolbar = await super.addEditToolbar();\n        if (!toolbar) {\n            return null;\n        }\n        if (this._uiManager.highlightColors) {\n            this.#colorPicker = new ColorPicker({\n                editor: this\n            });\n            toolbar.addColorPicker(this.#colorPicker);\n        }\n        return toolbar;\n    }\n    disableEditing() {\n        super.disableEditing();\n        this.div.classList.toggle(\"disabled\", true);\n    }\n    enableEditing() {\n        super.enableEditing();\n        this.div.classList.toggle(\"disabled\", false);\n    }\n    fixAndSetPosition() {\n        return super.fixAndSetPosition(this.#getRotation());\n    }\n    getBaseTranslation() {\n        return [\n            0,\n            0\n        ];\n    }\n    getRect(tx, ty) {\n        return super.getRect(tx, ty, this.#getRotation());\n    }\n    onceAdded(focus) {\n        if (!this.annotationElementId) {\n            this.parent.addUndoableEditor(this);\n        }\n        if (focus) {\n            this.div.focus();\n        }\n    }\n    remove() {\n        this.#cleanDrawLayer();\n        this._reportTelemetry({\n            action: \"deleted\"\n        });\n        super.remove();\n    }\n    rebuild() {\n        if (!this.parent) {\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        this.#addToDrawLayer();\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    setParent(parent) {\n        let mustBeSelected = false;\n        if (this.parent && !parent) {\n            this.#cleanDrawLayer();\n        } else if (parent) {\n            this.#addToDrawLayer(parent);\n            mustBeSelected = !this.parent && this.div?.classList.contains(\"selectedEditor\");\n        }\n        super.setParent(parent);\n        this.show(this._isVisible);\n        if (mustBeSelected) {\n            this.select();\n        }\n    }\n    #changeThickness(thickness) {\n        if (!this.#isFreeHighlight) {\n            return;\n        }\n        this.#createFreeOutlines({\n            highlightOutlines: this.#highlightOutlines.getNewOutline(thickness / 2)\n        });\n        this.fixAndSetPosition();\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setDims(this.width * parentWidth, this.height * parentHeight);\n    }\n    #cleanDrawLayer() {\n        if (this.#id === null || !this.parent) {\n            return;\n        }\n        this.parent.drawLayer.remove(this.#id);\n        this.#id = null;\n        this.parent.drawLayer.remove(this.#outlineId);\n        this.#outlineId = null;\n    }\n    #addToDrawLayer(parent = this.parent) {\n        if (this.#id !== null) {\n            return;\n        }\n        ({ id: this.#id, clipPathId: this.#clipPathId } = parent.drawLayer.draw({\n            bbox: this.#highlightOutlines.box,\n            root: {\n                viewBox: \"0 0 1 1\",\n                fill: this.color,\n                \"fill-opacity\": this.#opacity\n            },\n            rootClass: {\n                highlight: true,\n                free: this.#isFreeHighlight\n            },\n            path: {\n                d: this.#highlightOutlines.toSVGPath()\n            }\n        }, false, true));\n        this.#outlineId = parent.drawLayer.drawOutline({\n            rootClass: {\n                highlightOutline: true,\n                free: this.#isFreeHighlight\n            },\n            bbox: this.#focusOutlines.box,\n            path: {\n                d: this.#focusOutlines.toSVGPath()\n            }\n        }, this.#isFreeHighlight);\n        if (this.#highlightDiv) {\n            this.#highlightDiv.style.clipPath = this.#clipPathId;\n        }\n    }\n    static #rotateBbox([x, y, width, height], angle) {\n        switch(angle){\n            case 90:\n                return [\n                    1 - y - height,\n                    x,\n                    height,\n                    width\n                ];\n            case 180:\n                return [\n                    1 - x - width,\n                    1 - y - height,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    y,\n                    1 - x - width,\n                    height,\n                    width\n                ];\n        }\n        return [\n            x,\n            y,\n            width,\n            height\n        ];\n    }\n    rotate(angle) {\n        const { drawLayer } = this.parent;\n        let box;\n        if (this.#isFreeHighlight) {\n            angle = (angle - this.rotation + 360) % 360;\n            box = HighlightEditor.#rotateBbox(this.#highlightOutlines.box, angle);\n        } else {\n            box = HighlightEditor.#rotateBbox([\n                this.x,\n                this.y,\n                this.width,\n                this.height\n            ], angle);\n        }\n        drawLayer.updateProperties(this.#id, {\n            bbox: box,\n            root: {\n                \"data-main-rotation\": angle\n            }\n        });\n        drawLayer.updateProperties(this.#outlineId, {\n            bbox: HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle),\n            root: {\n                \"data-main-rotation\": angle\n            }\n        });\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        const div = super.render();\n        if (this.#text) {\n            div.setAttribute(\"aria-label\", this.#text);\n            div.setAttribute(\"role\", \"mark\");\n        }\n        if (this.#isFreeHighlight) {\n            div.classList.add(\"free\");\n        } else {\n            this.div.addEventListener(\"keydown\", this.#keydown.bind(this), {\n                signal: this._uiManager._signal\n            });\n        }\n        const highlightDiv = this.#highlightDiv = document.createElement(\"div\");\n        div.append(highlightDiv);\n        highlightDiv.setAttribute(\"aria-hidden\", \"true\");\n        highlightDiv.className = \"internal\";\n        highlightDiv.style.clipPath = this.#clipPathId;\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setDims(this.width * parentWidth, this.height * parentHeight);\n        bindEvents(this, this.#highlightDiv, [\n            \"pointerover\",\n            \"pointerleave\"\n        ]);\n        this.enableEditing();\n        return div;\n    }\n    pointerover() {\n        if (!this.isSelected) {\n            this.parent?.drawLayer.updateProperties(this.#outlineId, {\n                rootClass: {\n                    hovered: true\n                }\n            });\n        }\n    }\n    pointerleave() {\n        if (!this.isSelected) {\n            this.parent?.drawLayer.updateProperties(this.#outlineId, {\n                rootClass: {\n                    hovered: false\n                }\n            });\n        }\n    }\n    #keydown(event) {\n        HighlightEditor._keyboardManager.exec(this, event);\n    }\n    _moveCaret(direction) {\n        this.parent.unselect(this);\n        switch(direction){\n            case 0:\n            case 2:\n                this.#setCaret(true);\n                break;\n            case 1:\n            case 3:\n                this.#setCaret(false);\n                break;\n        }\n    }\n    #setCaret(start) {\n        if (!this.#anchorNode) {\n            return;\n        }\n        const selection = window.getSelection();\n        if (start) {\n            selection.setPosition(this.#anchorNode, this.#anchorOffset);\n        } else {\n            selection.setPosition(this.#focusNode, this.#focusOffset);\n        }\n    }\n    select() {\n        super.select();\n        if (!this.#outlineId) {\n            return;\n        }\n        this.parent?.drawLayer.updateProperties(this.#outlineId, {\n            rootClass: {\n                hovered: false,\n                selected: true\n            }\n        });\n    }\n    unselect() {\n        super.unselect();\n        if (!this.#outlineId) {\n            return;\n        }\n        this.parent?.drawLayer.updateProperties(this.#outlineId, {\n            rootClass: {\n                selected: false\n            }\n        });\n        if (!this.#isFreeHighlight) {\n            this.#setCaret(false);\n        }\n    }\n    get _mustFixPosition() {\n        return !this.#isFreeHighlight;\n    }\n    show(visible = this._isVisible) {\n        super.show(visible);\n        if (this.parent) {\n            this.parent.drawLayer.updateProperties(this.#id, {\n                rootClass: {\n                    hidden: !visible\n                }\n            });\n            this.parent.drawLayer.updateProperties(this.#outlineId, {\n                rootClass: {\n                    hidden: !visible\n                }\n            });\n        }\n    }\n    #getRotation() {\n        return this.#isFreeHighlight ? this.rotation : 0;\n    }\n    #serializeBoxes() {\n        if (this.#isFreeHighlight) {\n            return null;\n        }\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const [pageX, pageY] = this.pageTranslation;\n        const boxes = this.#boxes;\n        const quadPoints = new Float32Array(boxes.length * 8);\n        let i = 0;\n        for (const { x, y, width, height } of boxes){\n            const sx = x * pageWidth + pageX;\n            const sy = (1 - y) * pageHeight + pageY;\n            quadPoints[i] = quadPoints[i + 4] = sx;\n            quadPoints[i + 1] = quadPoints[i + 3] = sy;\n            quadPoints[i + 2] = quadPoints[i + 6] = sx + width * pageWidth;\n            quadPoints[i + 5] = quadPoints[i + 7] = sy - height * pageHeight;\n            i += 8;\n        }\n        return quadPoints;\n    }\n    #serializeOutlines(rect) {\n        return this.#highlightOutlines.serialize(rect, this.#getRotation());\n    }\n    static startHighlighting(parent, isLTR, { target: textLayer, x, y }) {\n        const { x: layerX, y: layerY, width: parentWidth, height: parentHeight } = textLayer.getBoundingClientRect();\n        const ac = new AbortController();\n        const signal = parent.combinedSignal(ac);\n        const pointerUpCallback = (e)=>{\n            ac.abort();\n            this.#endHighlight(parent, e);\n        };\n        window.addEventListener(\"blur\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"pointerup\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"pointerdown\", stopEvent, {\n            capture: true,\n            passive: false,\n            signal\n        });\n        window.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        textLayer.addEventListener(\"pointermove\", this.#highlightMove.bind(this, parent), {\n            signal\n        });\n        this._freeHighlight = new FreeHighlightOutliner({\n            x,\n            y\n        }, [\n            layerX,\n            layerY,\n            parentWidth,\n            parentHeight\n        ], parent.scale, this._defaultThickness / 2, isLTR, 0.001);\n        ({ id: this._freeHighlightId, clipPathId: this._freeHighlightClipId } = parent.drawLayer.draw({\n            bbox: [\n                0,\n                0,\n                1,\n                1\n            ],\n            root: {\n                viewBox: \"0 0 1 1\",\n                fill: this._defaultColor,\n                \"fill-opacity\": this._defaultOpacity\n            },\n            rootClass: {\n                highlight: true,\n                free: true\n            },\n            path: {\n                d: this._freeHighlight.toSVGPath()\n            }\n        }, true, true));\n    }\n    static #highlightMove(parent, event) {\n        if (this._freeHighlight.add(event)) {\n            parent.drawLayer.updateProperties(this._freeHighlightId, {\n                path: {\n                    d: this._freeHighlight.toSVGPath()\n                }\n            });\n        }\n    }\n    static #endHighlight(parent, event) {\n        if (!this._freeHighlight.isEmpty()) {\n            parent.createAndAddNewEditor(event, false, {\n                highlightId: this._freeHighlightId,\n                highlightOutlines: this._freeHighlight.getOutlines(),\n                clipPathId: this._freeHighlightClipId,\n                methodOfCreation: \"main_toolbar\"\n            });\n        } else {\n            parent.drawLayer.remove(this._freeHighlightId);\n        }\n        this._freeHighlightId = -1;\n        this._freeHighlight = null;\n        this._freeHighlightClipId = \"\";\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        if (data instanceof HighlightAnnotationElement) {\n            const { data: { quadPoints, rect, rotation, id, color, opacity, popupRef }, parent: { page: { pageNumber } } } = data;\n            initialData = data = {\n                annotationType: AnnotationEditorType.HIGHLIGHT,\n                color: Array.from(color),\n                opacity,\n                quadPoints,\n                boxes: null,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                id,\n                deleted: false,\n                popupRef\n            };\n        } else if (data instanceof InkAnnotationElement) {\n            const { data: { inkLists, rect, rotation, id, color, borderStyle: { rawWidth: thickness }, popupRef }, parent: { page: { pageNumber } } } = data;\n            initialData = data = {\n                annotationType: AnnotationEditorType.HIGHLIGHT,\n                color: Array.from(color),\n                thickness,\n                inkLists,\n                boxes: null,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                id,\n                deleted: false,\n                popupRef\n            };\n        }\n        const { color, quadPoints, inkLists, opacity } = data;\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.color = Util.makeHexColor(...color);\n        editor.#opacity = opacity || 1;\n        if (inkLists) {\n            editor.#thickness = data.thickness;\n        }\n        editor.annotationElementId = data.id || null;\n        editor._initialData = initialData;\n        const [pageWidth, pageHeight] = editor.pageDimensions;\n        const [pageX, pageY] = editor.pageTranslation;\n        if (quadPoints) {\n            const boxes = editor.#boxes = [];\n            for(let i = 0; i < quadPoints.length; i += 8){\n                boxes.push({\n                    x: (quadPoints[i] - pageX) / pageWidth,\n                    y: 1 - (quadPoints[i + 1] - pageY) / pageHeight,\n                    width: (quadPoints[i + 2] - quadPoints[i]) / pageWidth,\n                    height: (quadPoints[i + 1] - quadPoints[i + 5]) / pageHeight\n                });\n            }\n            editor.#createOutlines();\n            editor.#addToDrawLayer();\n            editor.rotate(editor.rotation);\n        } else if (inkLists) {\n            editor.#isFreeHighlight = true;\n            const points = inkLists[0];\n            const point = {\n                x: points[0] - pageX,\n                y: pageHeight - (points[1] - pageY)\n            };\n            const outliner = new FreeHighlightOutliner(point, [\n                0,\n                0,\n                pageWidth,\n                pageHeight\n            ], 1, editor.#thickness / 2, true, 0.001);\n            for(let i = 0, ii = points.length; i < ii; i += 2){\n                point.x = points[i] - pageX;\n                point.y = pageHeight - (points[i + 1] - pageY);\n                outliner.add(point);\n            }\n            const { id, clipPathId } = parent.drawLayer.draw({\n                bbox: [\n                    0,\n                    0,\n                    1,\n                    1\n                ],\n                root: {\n                    viewBox: \"0 0 1 1\",\n                    fill: editor.color,\n                    \"fill-opacity\": editor._defaultOpacity\n                },\n                rootClass: {\n                    highlight: true,\n                    free: true\n                },\n                path: {\n                    d: outliner.toSVGPath()\n                }\n            }, true, true);\n            editor.#createFreeOutlines({\n                highlightOutlines: outliner.getOutlines(),\n                highlightId: id,\n                clipPathId\n            });\n            editor.#addToDrawLayer();\n            editor.rotate(editor.parentRotation);\n        }\n        return editor;\n    }\n    serialize(isForCopying = false) {\n        if (this.isEmpty() || isForCopying) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const rect = this.getRect(0, 0);\n        const color = AnnotationEditor._colorManager.convert(this.color);\n        const serialized = {\n            annotationType: AnnotationEditorType.HIGHLIGHT,\n            color,\n            opacity: this.#opacity,\n            thickness: this.#thickness,\n            quadPoints: this.#serializeBoxes(),\n            outlines: this.#serializeOutlines(rect),\n            pageIndex: this.pageIndex,\n            rect,\n            rotation: this.#getRotation(),\n            structTreeParentId: this._structTreeParentId\n        };\n        if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n            return null;\n        }\n        serialized.id = this.annotationElementId;\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { color } = this._initialData;\n        return serialized.color.some((c, i)=>c !== color[i]);\n    }\n    renderAnnotationElement(annotation) {\n        annotation.updateEdited({\n            rect: this.getRect(0, 0)\n        });\n        return null;\n    }\n    static canCreateNewEmptyEditor() {\n        return false;\n    }\n}\n; // ./src/display/editor/draw.js\nclass DrawingOptions {\n    #svgProperties;\n    updateProperty(name, value) {\n        this[name] = value;\n        this.updateSVGProperty(name, value);\n    }\n    updateProperties(properties) {\n        if (!properties) {\n            return;\n        }\n        for (const [name, value] of Object.entries(properties)){\n            if (!name.startsWith(\"_\")) {\n                this.updateProperty(name, value);\n            }\n        }\n    }\n    updateSVGProperty(name, value) {\n        this.#svgProperties[name] = value;\n    }\n    toSVGProperties() {\n        const root = this.#svgProperties;\n        this.#svgProperties = Object.create(null);\n        return {\n            root\n        };\n    }\n    reset() {\n        this.#svgProperties = Object.create(null);\n    }\n    updateAll(options = this) {\n        this.updateProperties(options);\n    }\n    clone() {\n        unreachable(\"Not implemented\");\n    }\n    constructor(){\n        this.#svgProperties = Object.create(null);\n    }\n}\nclass DrawingEditor extends AnnotationEditor {\n    #drawOutlines;\n    #mustBeCommitted;\n    static{\n        this._currentDrawId = -1;\n    }\n    static{\n        this._currentParent = null;\n    }\n    static #currentDraw = null;\n    static #currentDrawingAC = null;\n    static #currentDrawingOptions = null;\n    static #currentPointerId = NaN;\n    static #currentPointerType = null;\n    static #currentPointerIds = null;\n    static #currentMoveTimestamp = NaN;\n    static{\n        this._INNER_MARGIN = 3;\n    }\n    constructor(params){\n        super(params);\n        this.#drawOutlines = null;\n        this._drawId = null;\n        this.#mustBeCommitted = params.mustBeCommitted || false;\n        this._addOutlines(params);\n    }\n    _addOutlines(params) {\n        if (params.drawOutlines) {\n            this.#createDrawOutlines(params);\n            this.#addToDrawLayer();\n        }\n    }\n    #createDrawOutlines({ drawOutlines, drawId, drawingOptions }) {\n        this.#drawOutlines = drawOutlines;\n        this._drawingOptions ||= drawingOptions;\n        if (drawId >= 0) {\n            this._drawId = drawId;\n            this.parent.drawLayer.finalizeDraw(drawId, drawOutlines.defaultProperties);\n        } else {\n            this._drawId = this.#createDrawing(drawOutlines, this.parent);\n        }\n        this.#updateBbox(drawOutlines.box);\n    }\n    #createDrawing(drawOutlines, parent) {\n        const { id } = parent.drawLayer.draw(DrawingEditor._mergeSVGProperties(this._drawingOptions.toSVGProperties(), drawOutlines.defaultSVGProperties), false, false);\n        return id;\n    }\n    static _mergeSVGProperties(p1, p2) {\n        const p1Keys = new Set(Object.keys(p1));\n        for (const [key, value] of Object.entries(p2)){\n            if (p1Keys.has(key)) {\n                Object.assign(p1[key], value);\n            } else {\n                p1[key] = value;\n            }\n        }\n        return p1;\n    }\n    static getDefaultDrawingOptions(_options) {\n        unreachable(\"Not implemented\");\n    }\n    static get typesMap() {\n        unreachable(\"Not implemented\");\n    }\n    static get isDrawer() {\n        return true;\n    }\n    static get supportMultipleDrawings() {\n        return false;\n    }\n    static updateDefaultParams(type, value) {\n        const propertyName = this.typesMap.get(type);\n        if (propertyName) {\n            this._defaultDrawingOptions.updateProperty(propertyName, value);\n        }\n        if (this._currentParent) {\n            DrawingEditor.#currentDraw.updateProperty(propertyName, value);\n            this._currentParent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());\n        }\n    }\n    updateParams(type, value) {\n        const propertyName = this.constructor.typesMap.get(type);\n        if (propertyName) {\n            this._updateProperty(type, propertyName, value);\n        }\n    }\n    static get defaultPropertiesToUpdate() {\n        const properties = [];\n        const options = this._defaultDrawingOptions;\n        for (const [type, name] of this.typesMap){\n            properties.push([\n                type,\n                options[name]\n            ]);\n        }\n        return properties;\n    }\n    get propertiesToUpdate() {\n        const properties = [];\n        const { _drawingOptions } = this;\n        for (const [type, name] of this.constructor.typesMap){\n            properties.push([\n                type,\n                _drawingOptions[name]\n            ]);\n        }\n        return properties;\n    }\n    _updateProperty(type, name, value) {\n        const options = this._drawingOptions;\n        const savedValue = options[name];\n        const setter = (val)=>{\n            options.updateProperty(name, val);\n            const bbox = this.#drawOutlines.updateProperty(name, val);\n            if (bbox) {\n                this.#updateBbox(bbox);\n            }\n            this.parent?.drawLayer.updateProperties(this._drawId, options.toSVGProperties());\n        };\n        this.addCommands({\n            cmd: setter.bind(this, value),\n            undo: setter.bind(this, savedValue),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n    }\n    _onResizing() {\n        this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathResizingSVGProperties(this.#convertToDrawSpace()), {\n            bbox: this.#rotateBox()\n        }));\n    }\n    _onResized() {\n        this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathResizedSVGProperties(this.#convertToDrawSpace()), {\n            bbox: this.#rotateBox()\n        }));\n    }\n    _onTranslating(_x, _y) {\n        this.parent?.drawLayer.updateProperties(this._drawId, {\n            bbox: this.#rotateBox()\n        });\n    }\n    _onTranslated() {\n        this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathTranslatedSVGProperties(this.#convertToDrawSpace(), this.parentDimensions), {\n            bbox: this.#rotateBox()\n        }));\n    }\n    _onStartDragging() {\n        this.parent?.drawLayer.updateProperties(this._drawId, {\n            rootClass: {\n                moving: true\n            }\n        });\n    }\n    _onStopDragging() {\n        this.parent?.drawLayer.updateProperties(this._drawId, {\n            rootClass: {\n                moving: false\n            }\n        });\n    }\n    commit() {\n        super.commit();\n        this.disableEditMode();\n        this.disableEditing();\n    }\n    disableEditing() {\n        super.disableEditing();\n        this.div.classList.toggle(\"disabled\", true);\n    }\n    enableEditing() {\n        super.enableEditing();\n        this.div.classList.toggle(\"disabled\", false);\n    }\n    getBaseTranslation() {\n        return [\n            0,\n            0\n        ];\n    }\n    get isResizable() {\n        return true;\n    }\n    onceAdded(focus) {\n        if (!this.annotationElementId) {\n            this.parent.addUndoableEditor(this);\n        }\n        this._isDraggable = true;\n        if (this.#mustBeCommitted) {\n            this.#mustBeCommitted = false;\n            this.commit();\n            this.parent.setSelected(this);\n            if (focus && this.isOnScreen) {\n                this.div.focus();\n            }\n        }\n    }\n    remove() {\n        this.#cleanDrawLayer();\n        super.remove();\n    }\n    rebuild() {\n        if (!this.parent) {\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        this.#addToDrawLayer();\n        this.#updateBbox(this.#drawOutlines.box);\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    setParent(parent) {\n        let mustBeSelected = false;\n        if (this.parent && !parent) {\n            this._uiManager.removeShouldRescale(this);\n            this.#cleanDrawLayer();\n        } else if (parent) {\n            this._uiManager.addShouldRescale(this);\n            this.#addToDrawLayer(parent);\n            mustBeSelected = !this.parent && this.div?.classList.contains(\"selectedEditor\");\n        }\n        super.setParent(parent);\n        if (mustBeSelected) {\n            this.select();\n        }\n    }\n    #cleanDrawLayer() {\n        if (this._drawId === null || !this.parent) {\n            return;\n        }\n        this.parent.drawLayer.remove(this._drawId);\n        this._drawId = null;\n        this._drawingOptions.reset();\n    }\n    #addToDrawLayer(parent = this.parent) {\n        if (this._drawId !== null && this.parent === parent) {\n            return;\n        }\n        if (this._drawId !== null) {\n            this.parent.drawLayer.updateParent(this._drawId, parent.drawLayer);\n            return;\n        }\n        this._drawingOptions.updateAll();\n        this._drawId = this.#createDrawing(this.#drawOutlines, parent);\n    }\n    #convertToParentSpace([x, y, width, height]) {\n        const { parentDimensions: [pW, pH], rotation } = this;\n        switch(rotation){\n            case 90:\n                return [\n                    y,\n                    1 - x,\n                    width * (pH / pW),\n                    height * (pW / pH)\n                ];\n            case 180:\n                return [\n                    1 - x,\n                    1 - y,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    1 - y,\n                    x,\n                    width * (pH / pW),\n                    height * (pW / pH)\n                ];\n            default:\n                return [\n                    x,\n                    y,\n                    width,\n                    height\n                ];\n        }\n    }\n    #convertToDrawSpace() {\n        const { x, y, width, height, parentDimensions: [pW, pH], rotation } = this;\n        switch(rotation){\n            case 90:\n                return [\n                    1 - y,\n                    x,\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            case 180:\n                return [\n                    1 - x,\n                    1 - y,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    y,\n                    1 - x,\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            default:\n                return [\n                    x,\n                    y,\n                    width,\n                    height\n                ];\n        }\n    }\n    #updateBbox(bbox) {\n        [this.x, this.y, this.width, this.height] = this.#convertToParentSpace(bbox);\n        if (this.div) {\n            this.fixAndSetPosition();\n            const [parentWidth, parentHeight] = this.parentDimensions;\n            this.setDims(this.width * parentWidth, this.height * parentHeight);\n        }\n        this._onResized();\n    }\n    #rotateBox() {\n        const { x, y, width, height, rotation, parentRotation, parentDimensions: [pW, pH] } = this;\n        switch((rotation * 4 + parentRotation) / 90){\n            case 1:\n                return [\n                    1 - y - height,\n                    x,\n                    height,\n                    width\n                ];\n            case 2:\n                return [\n                    1 - x - width,\n                    1 - y - height,\n                    width,\n                    height\n                ];\n            case 3:\n                return [\n                    y,\n                    1 - x - width,\n                    height,\n                    width\n                ];\n            case 4:\n                return [\n                    x,\n                    y - width * (pW / pH),\n                    height * (pH / pW),\n                    width * (pW / pH)\n                ];\n            case 5:\n                return [\n                    1 - y,\n                    x,\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            case 6:\n                return [\n                    1 - x - height * (pH / pW),\n                    1 - y,\n                    height * (pH / pW),\n                    width * (pW / pH)\n                ];\n            case 7:\n                return [\n                    y - width * (pW / pH),\n                    1 - x - height * (pH / pW),\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            case 8:\n                return [\n                    x - width,\n                    y - height,\n                    width,\n                    height\n                ];\n            case 9:\n                return [\n                    1 - y,\n                    x - width,\n                    height,\n                    width\n                ];\n            case 10:\n                return [\n                    1 - x,\n                    1 - y,\n                    width,\n                    height\n                ];\n            case 11:\n                return [\n                    y - height,\n                    1 - x,\n                    height,\n                    width\n                ];\n            case 12:\n                return [\n                    x - height * (pH / pW),\n                    y,\n                    height * (pH / pW),\n                    width * (pW / pH)\n                ];\n            case 13:\n                return [\n                    1 - y - width * (pW / pH),\n                    x - height * (pH / pW),\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            case 14:\n                return [\n                    1 - x,\n                    1 - y - width * (pW / pH),\n                    height * (pH / pW),\n                    width * (pW / pH)\n                ];\n            case 15:\n                return [\n                    y,\n                    1 - x,\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            default:\n                return [\n                    x,\n                    y,\n                    width,\n                    height\n                ];\n        }\n    }\n    rotate() {\n        if (!this.parent) {\n            return;\n        }\n        this.parent.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties({\n            bbox: this.#rotateBox()\n        }, this.#drawOutlines.updateRotation((this.parentRotation - this.rotation + 360) % 360)));\n    }\n    onScaleChanging() {\n        if (!this.parent) {\n            return;\n        }\n        this.#updateBbox(this.#drawOutlines.updateParentDimensions(this.parentDimensions, this.parent.scale));\n    }\n    static onScaleChangingWhenDrawing() {}\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        let baseX, baseY;\n        if (this._isCopy) {\n            baseX = this.x;\n            baseY = this.y;\n        }\n        const div = super.render();\n        div.classList.add(\"draw\");\n        const drawDiv = document.createElement(\"div\");\n        div.append(drawDiv);\n        drawDiv.setAttribute(\"aria-hidden\", \"true\");\n        drawDiv.className = \"internal\";\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setDims(this.width * parentWidth, this.height * parentHeight);\n        this._uiManager.addShouldRescale(this);\n        this.disableEditing();\n        if (this._isCopy) {\n            this._moveAfterPaste(baseX, baseY);\n        }\n        return div;\n    }\n    static createDrawerInstance(_x, _y, _parentWidth, _parentHeight, _rotation) {\n        unreachable(\"Not implemented\");\n    }\n    static startDrawing(parent, uiManager, _isLTR, event) {\n        const { target, offsetX: x, offsetY: y, pointerId, pointerType } = event;\n        if (DrawingEditor.#currentPointerType && DrawingEditor.#currentPointerType !== pointerType) {\n            return;\n        }\n        const { viewport: { rotation } } = parent;\n        const { width: parentWidth, height: parentHeight } = target.getBoundingClientRect();\n        const ac = DrawingEditor.#currentDrawingAC = new AbortController();\n        const signal = parent.combinedSignal(ac);\n        DrawingEditor.#currentPointerId ||= pointerId;\n        DrawingEditor.#currentPointerType ??= pointerType;\n        window.addEventListener(\"pointerup\", (e)=>{\n            if (DrawingEditor.#currentPointerId === e.pointerId) {\n                this._endDraw(e);\n            } else {\n                DrawingEditor.#currentPointerIds?.delete(e.pointerId);\n            }\n        }, {\n            signal\n        });\n        window.addEventListener(\"pointercancel\", (e)=>{\n            if (DrawingEditor.#currentPointerId === e.pointerId) {\n                this._currentParent.endDrawingSession();\n            } else {\n                DrawingEditor.#currentPointerIds?.delete(e.pointerId);\n            }\n        }, {\n            signal\n        });\n        window.addEventListener(\"pointerdown\", (e)=>{\n            if (DrawingEditor.#currentPointerType !== e.pointerType) {\n                return;\n            }\n            (DrawingEditor.#currentPointerIds ||= new Set()).add(e.pointerId);\n            if (DrawingEditor.#currentDraw.isCancellable()) {\n                DrawingEditor.#currentDraw.removeLastElement();\n                if (DrawingEditor.#currentDraw.isEmpty()) {\n                    this._currentParent.endDrawingSession(true);\n                } else {\n                    this._endDraw(null);\n                }\n            }\n        }, {\n            capture: true,\n            passive: false,\n            signal\n        });\n        window.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        target.addEventListener(\"pointermove\", this._drawMove.bind(this), {\n            signal\n        });\n        target.addEventListener(\"touchmove\", (e)=>{\n            if (e.timeStamp === DrawingEditor.#currentMoveTimestamp) {\n                stopEvent(e);\n            }\n        }, {\n            signal\n        });\n        parent.toggleDrawing();\n        uiManager._editorUndoBar?.hide();\n        if (DrawingEditor.#currentDraw) {\n            parent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.startNew(x, y, parentWidth, parentHeight, rotation));\n            return;\n        }\n        uiManager.updateUIForDefaultProperties(this);\n        DrawingEditor.#currentDraw = this.createDrawerInstance(x, y, parentWidth, parentHeight, rotation);\n        DrawingEditor.#currentDrawingOptions = this.getDefaultDrawingOptions();\n        this._currentParent = parent;\n        ({ id: this._currentDrawId } = parent.drawLayer.draw(this._mergeSVGProperties(DrawingEditor.#currentDrawingOptions.toSVGProperties(), DrawingEditor.#currentDraw.defaultSVGProperties), true, false));\n    }\n    static _drawMove(event) {\n        DrawingEditor.#currentMoveTimestamp = -1;\n        if (!DrawingEditor.#currentDraw) {\n            return;\n        }\n        const { offsetX, offsetY, pointerId } = event;\n        if (DrawingEditor.#currentPointerId !== pointerId) {\n            return;\n        }\n        if (DrawingEditor.#currentPointerIds?.size >= 1) {\n            this._endDraw(event);\n            return;\n        }\n        this._currentParent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.add(offsetX, offsetY));\n        DrawingEditor.#currentMoveTimestamp = event.timeStamp;\n        stopEvent(event);\n    }\n    static _cleanup(all) {\n        if (all) {\n            this._currentDrawId = -1;\n            this._currentParent = null;\n            DrawingEditor.#currentDraw = null;\n            DrawingEditor.#currentDrawingOptions = null;\n            DrawingEditor.#currentPointerType = null;\n            DrawingEditor.#currentMoveTimestamp = NaN;\n        }\n        if (DrawingEditor.#currentDrawingAC) {\n            DrawingEditor.#currentDrawingAC.abort();\n            DrawingEditor.#currentDrawingAC = null;\n            DrawingEditor.#currentPointerId = NaN;\n            DrawingEditor.#currentPointerIds = null;\n        }\n    }\n    static _endDraw(event) {\n        const parent = this._currentParent;\n        if (!parent) {\n            return;\n        }\n        parent.toggleDrawing(true);\n        this._cleanup(false);\n        if (event?.target === parent.div) {\n            parent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.end(event.offsetX, event.offsetY));\n        }\n        if (this.supportMultipleDrawings) {\n            const draw = DrawingEditor.#currentDraw;\n            const drawId = this._currentDrawId;\n            const lastElement = draw.getLastElement();\n            parent.addCommands({\n                cmd: ()=>{\n                    parent.drawLayer.updateProperties(drawId, draw.setLastElement(lastElement));\n                },\n                undo: ()=>{\n                    parent.drawLayer.updateProperties(drawId, draw.removeLastElement());\n                },\n                mustExec: false,\n                type: AnnotationEditorParamsType.DRAW_STEP\n            });\n            return;\n        }\n        this.endDrawing(false);\n    }\n    static endDrawing(isAborted) {\n        const parent = this._currentParent;\n        if (!parent) {\n            return null;\n        }\n        parent.toggleDrawing(true);\n        parent.cleanUndoStack(AnnotationEditorParamsType.DRAW_STEP);\n        if (!DrawingEditor.#currentDraw.isEmpty()) {\n            const { pageDimensions: [pageWidth, pageHeight], scale } = parent;\n            const editor = parent.createAndAddNewEditor({\n                offsetX: 0,\n                offsetY: 0\n            }, false, {\n                drawId: this._currentDrawId,\n                drawOutlines: DrawingEditor.#currentDraw.getOutlines(pageWidth * scale, pageHeight * scale, scale, this._INNER_MARGIN),\n                drawingOptions: DrawingEditor.#currentDrawingOptions,\n                mustBeCommitted: !isAborted\n            });\n            this._cleanup(true);\n            return editor;\n        }\n        parent.drawLayer.remove(this._currentDrawId);\n        this._cleanup(true);\n        return null;\n    }\n    createDrawingOptions(_data) {}\n    static deserializeDraw(_pageX, _pageY, _pageWidth, _pageHeight, _innerWidth, _data) {\n        unreachable(\"Not implemented\");\n    }\n    static async deserialize(data, parent, uiManager) {\n        const { rawDims: { pageWidth, pageHeight, pageX, pageY } } = parent.viewport;\n        const drawOutlines = this.deserializeDraw(pageX, pageY, pageWidth, pageHeight, this._INNER_MARGIN, data);\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.createDrawingOptions(data);\n        editor.#createDrawOutlines({\n            drawOutlines\n        });\n        editor.#addToDrawLayer();\n        editor.onScaleChanging();\n        editor.rotate();\n        return editor;\n    }\n    serializeDraw(isForCopying) {\n        const [pageX, pageY] = this.pageTranslation;\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        return this.#drawOutlines.serialize([\n            pageX,\n            pageY,\n            pageWidth,\n            pageHeight\n        ], isForCopying);\n    }\n    renderAnnotationElement(annotation) {\n        annotation.updateEdited({\n            rect: this.getRect(0, 0)\n        });\n        return null;\n    }\n    static canCreateNewEmptyEditor() {\n        return false;\n    }\n}\n; // ./src/display/editor/drawers/inkdraw.js\nclass InkDrawOutliner {\n    #last;\n    #line;\n    #lines;\n    #rotation;\n    #thickness;\n    #points;\n    #lastSVGPath;\n    #lastIndex;\n    #outlines;\n    #parentWidth;\n    #parentHeight;\n    constructor(x, y, parentWidth, parentHeight, rotation, thickness){\n        this.#last = new Float64Array(6);\n        this.#lastSVGPath = \"\";\n        this.#lastIndex = 0;\n        this.#outlines = new InkDrawOutline();\n        this.#parentWidth = parentWidth;\n        this.#parentHeight = parentHeight;\n        this.#rotation = rotation;\n        this.#thickness = thickness;\n        [x, y] = this.#normalizePoint(x, y);\n        const line = this.#line = [\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            x,\n            y\n        ];\n        this.#points = [\n            x,\n            y\n        ];\n        this.#lines = [\n            {\n                line,\n                points: this.#points\n            }\n        ];\n        this.#last.set(line, 0);\n    }\n    updateProperty(name, value) {\n        if (name === \"stroke-width\") {\n            this.#thickness = value;\n        }\n    }\n    #normalizePoint(x, y) {\n        return Outline._normalizePoint(x, y, this.#parentWidth, this.#parentHeight, this.#rotation);\n    }\n    isEmpty() {\n        return !this.#lines || this.#lines.length === 0;\n    }\n    isCancellable() {\n        return this.#points.length <= 10;\n    }\n    add(x, y) {\n        [x, y] = this.#normalizePoint(x, y);\n        const [x1, y1, x2, y2] = this.#last.subarray(2, 6);\n        const diffX = x - x2;\n        const diffY = y - y2;\n        const d = Math.hypot(this.#parentWidth * diffX, this.#parentHeight * diffY);\n        if (d <= 2) {\n            return null;\n        }\n        this.#points.push(x, y);\n        if (isNaN(x1)) {\n            this.#last.set([\n                x2,\n                y2,\n                x,\n                y\n            ], 2);\n            this.#line.push(NaN, NaN, NaN, NaN, x, y);\n            return {\n                path: {\n                    d: this.toSVGPath()\n                }\n            };\n        }\n        if (isNaN(this.#last[0])) {\n            this.#line.splice(6, 6);\n        }\n        this.#last.set([\n            x1,\n            y1,\n            x2,\n            y2,\n            x,\n            y\n        ], 0);\n        this.#line.push(...Outline.createBezierPoints(x1, y1, x2, y2, x, y));\n        return {\n            path: {\n                d: this.toSVGPath()\n            }\n        };\n    }\n    end(x, y) {\n        const change = this.add(x, y);\n        if (change) {\n            return change;\n        }\n        if (this.#points.length === 2) {\n            return {\n                path: {\n                    d: this.toSVGPath()\n                }\n            };\n        }\n        return null;\n    }\n    startNew(x, y, parentWidth, parentHeight, rotation) {\n        this.#parentWidth = parentWidth;\n        this.#parentHeight = parentHeight;\n        this.#rotation = rotation;\n        [x, y] = this.#normalizePoint(x, y);\n        const line = this.#line = [\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            x,\n            y\n        ];\n        this.#points = [\n            x,\n            y\n        ];\n        const last = this.#lines.at(-1);\n        if (last) {\n            last.line = new Float32Array(last.line);\n            last.points = new Float32Array(last.points);\n        }\n        this.#lines.push({\n            line,\n            points: this.#points\n        });\n        this.#last.set(line, 0);\n        this.#lastIndex = 0;\n        this.toSVGPath();\n        return null;\n    }\n    getLastElement() {\n        return this.#lines.at(-1);\n    }\n    setLastElement(element) {\n        if (!this.#lines) {\n            return this.#outlines.setLastElement(element);\n        }\n        this.#lines.push(element);\n        this.#line = element.line;\n        this.#points = element.points;\n        this.#lastIndex = 0;\n        return {\n            path: {\n                d: this.toSVGPath()\n            }\n        };\n    }\n    removeLastElement() {\n        if (!this.#lines) {\n            return this.#outlines.removeLastElement();\n        }\n        this.#lines.pop();\n        this.#lastSVGPath = \"\";\n        for(let i = 0, ii = this.#lines.length; i < ii; i++){\n            const { line, points } = this.#lines[i];\n            this.#line = line;\n            this.#points = points;\n            this.#lastIndex = 0;\n            this.toSVGPath();\n        }\n        return {\n            path: {\n                d: this.#lastSVGPath\n            }\n        };\n    }\n    toSVGPath() {\n        const firstX = Outline.svgRound(this.#line[4]);\n        const firstY = Outline.svgRound(this.#line[5]);\n        if (this.#points.length === 2) {\n            this.#lastSVGPath = `${this.#lastSVGPath} M ${firstX} ${firstY} Z`;\n            return this.#lastSVGPath;\n        }\n        if (this.#points.length <= 6) {\n            const i = this.#lastSVGPath.lastIndexOf(\"M\");\n            this.#lastSVGPath = `${this.#lastSVGPath.slice(0, i)} M ${firstX} ${firstY}`;\n            this.#lastIndex = 6;\n        }\n        if (this.#points.length === 4) {\n            const secondX = Outline.svgRound(this.#line[10]);\n            const secondY = Outline.svgRound(this.#line[11]);\n            this.#lastSVGPath = `${this.#lastSVGPath} L ${secondX} ${secondY}`;\n            this.#lastIndex = 12;\n            return this.#lastSVGPath;\n        }\n        const buffer = [];\n        if (this.#lastIndex === 0) {\n            buffer.push(`M ${firstX} ${firstY}`);\n            this.#lastIndex = 6;\n        }\n        for(let i = this.#lastIndex, ii = this.#line.length; i < ii; i += 6){\n            const [c1x, c1y, c2x, c2y, x, y] = this.#line.slice(i, i + 6).map(Outline.svgRound);\n            buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);\n        }\n        this.#lastSVGPath += buffer.join(\" \");\n        this.#lastIndex = this.#line.length;\n        return this.#lastSVGPath;\n    }\n    getOutlines(parentWidth, parentHeight, scale, innerMargin) {\n        const last = this.#lines.at(-1);\n        last.line = new Float32Array(last.line);\n        last.points = new Float32Array(last.points);\n        this.#outlines.build(this.#lines, parentWidth, parentHeight, scale, this.#rotation, this.#thickness, innerMargin);\n        this.#last = null;\n        this.#line = null;\n        this.#lines = null;\n        this.#lastSVGPath = null;\n        return this.#outlines;\n    }\n    get defaultSVGProperties() {\n        return {\n            root: {\n                viewBox: \"0 0 10000 10000\"\n            },\n            rootClass: {\n                draw: true\n            },\n            bbox: [\n                0,\n                0,\n                1,\n                1\n            ]\n        };\n    }\n}\nclass InkDrawOutline extends Outline {\n    #bbox;\n    #currentRotation;\n    #innerMargin;\n    #lines;\n    #parentWidth;\n    #parentHeight;\n    #parentScale;\n    #rotation;\n    #thickness;\n    build(lines, parentWidth, parentHeight, parentScale, rotation, thickness, innerMargin) {\n        this.#parentWidth = parentWidth;\n        this.#parentHeight = parentHeight;\n        this.#parentScale = parentScale;\n        this.#rotation = rotation;\n        this.#thickness = thickness;\n        this.#innerMargin = innerMargin ?? 0;\n        this.#lines = lines;\n        this.#computeBbox();\n    }\n    get thickness() {\n        return this.#thickness;\n    }\n    setLastElement(element) {\n        this.#lines.push(element);\n        return {\n            path: {\n                d: this.toSVGPath()\n            }\n        };\n    }\n    removeLastElement() {\n        this.#lines.pop();\n        return {\n            path: {\n                d: this.toSVGPath()\n            }\n        };\n    }\n    toSVGPath() {\n        const buffer = [];\n        for (const { line } of this.#lines){\n            buffer.push(`M${Outline.svgRound(line[4])} ${Outline.svgRound(line[5])}`);\n            if (line.length === 6) {\n                buffer.push(\"Z\");\n                continue;\n            }\n            if (line.length === 12 && isNaN(line[6])) {\n                buffer.push(`L${Outline.svgRound(line[10])} ${Outline.svgRound(line[11])}`);\n                continue;\n            }\n            for(let i = 6, ii = line.length; i < ii; i += 6){\n                const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6).map(Outline.svgRound);\n                buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);\n            }\n        }\n        return buffer.join(\"\");\n    }\n    serialize([pageX, pageY, pageWidth, pageHeight], isForCopying) {\n        const serializedLines = [];\n        const serializedPoints = [];\n        const [x, y, width, height] = this.#getBBoxWithNoMargin();\n        let tx, ty, sx, sy, x1, y1, x2, y2, rescaleFn;\n        switch(this.#rotation){\n            case 0:\n                rescaleFn = Outline._rescale;\n                tx = pageX;\n                ty = pageY + pageHeight;\n                sx = pageWidth;\n                sy = -pageHeight;\n                x1 = pageX + x * pageWidth;\n                y1 = pageY + (1 - y - height) * pageHeight;\n                x2 = pageX + (x + width) * pageWidth;\n                y2 = pageY + (1 - y) * pageHeight;\n                break;\n            case 90:\n                rescaleFn = Outline._rescaleAndSwap;\n                tx = pageX;\n                ty = pageY;\n                sx = pageWidth;\n                sy = pageHeight;\n                x1 = pageX + y * pageWidth;\n                y1 = pageY + x * pageHeight;\n                x2 = pageX + (y + height) * pageWidth;\n                y2 = pageY + (x + width) * pageHeight;\n                break;\n            case 180:\n                rescaleFn = Outline._rescale;\n                tx = pageX + pageWidth;\n                ty = pageY;\n                sx = -pageWidth;\n                sy = pageHeight;\n                x1 = pageX + (1 - x - width) * pageWidth;\n                y1 = pageY + y * pageHeight;\n                x2 = pageX + (1 - x) * pageWidth;\n                y2 = pageY + (y + height) * pageHeight;\n                break;\n            case 270:\n                rescaleFn = Outline._rescaleAndSwap;\n                tx = pageX + pageWidth;\n                ty = pageY + pageHeight;\n                sx = -pageWidth;\n                sy = -pageHeight;\n                x1 = pageX + (1 - y - height) * pageWidth;\n                y1 = pageY + (1 - x - width) * pageHeight;\n                x2 = pageX + (1 - y) * pageWidth;\n                y2 = pageY + (1 - x) * pageHeight;\n                break;\n        }\n        for (const { line, points } of this.#lines){\n            serializedLines.push(rescaleFn(line, tx, ty, sx, sy, isForCopying ? new Array(line.length) : null));\n            serializedPoints.push(rescaleFn(points, tx, ty, sx, sy, isForCopying ? new Array(points.length) : null));\n        }\n        return {\n            lines: serializedLines,\n            points: serializedPoints,\n            rect: [\n                x1,\n                y1,\n                x2,\n                y2\n            ]\n        };\n    }\n    static deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, { paths: { lines, points }, rotation, thickness }) {\n        const newLines = [];\n        let tx, ty, sx, sy, rescaleFn;\n        switch(rotation){\n            case 0:\n                rescaleFn = Outline._rescale;\n                tx = -pageX / pageWidth;\n                ty = pageY / pageHeight + 1;\n                sx = 1 / pageWidth;\n                sy = -1 / pageHeight;\n                break;\n            case 90:\n                rescaleFn = Outline._rescaleAndSwap;\n                tx = -pageY / pageHeight;\n                ty = -pageX / pageWidth;\n                sx = 1 / pageHeight;\n                sy = 1 / pageWidth;\n                break;\n            case 180:\n                rescaleFn = Outline._rescale;\n                tx = pageX / pageWidth + 1;\n                ty = -pageY / pageHeight;\n                sx = -1 / pageWidth;\n                sy = 1 / pageHeight;\n                break;\n            case 270:\n                rescaleFn = Outline._rescaleAndSwap;\n                tx = pageY / pageHeight + 1;\n                ty = pageX / pageWidth + 1;\n                sx = -1 / pageHeight;\n                sy = -1 / pageWidth;\n                break;\n        }\n        if (!lines) {\n            lines = [];\n            for (const point of points){\n                const len = point.length;\n                if (len === 2) {\n                    lines.push(new Float32Array([\n                        NaN,\n                        NaN,\n                        NaN,\n                        NaN,\n                        point[0],\n                        point[1]\n                    ]));\n                    continue;\n                }\n                if (len === 4) {\n                    lines.push(new Float32Array([\n                        NaN,\n                        NaN,\n                        NaN,\n                        NaN,\n                        point[0],\n                        point[1],\n                        NaN,\n                        NaN,\n                        NaN,\n                        NaN,\n                        point[2],\n                        point[3]\n                    ]));\n                    continue;\n                }\n                const line = new Float32Array(3 * (len - 2));\n                lines.push(line);\n                let [x1, y1, x2, y2] = point.subarray(0, 4);\n                line.set([\n                    NaN,\n                    NaN,\n                    NaN,\n                    NaN,\n                    x1,\n                    y1\n                ], 0);\n                for(let i = 4; i < len; i += 2){\n                    const x = point[i];\n                    const y = point[i + 1];\n                    line.set(Outline.createBezierPoints(x1, y1, x2, y2, x, y), (i - 2) * 3);\n                    [x1, y1, x2, y2] = [\n                        x2,\n                        y2,\n                        x,\n                        y\n                    ];\n                }\n            }\n        }\n        for(let i = 0, ii = lines.length; i < ii; i++){\n            newLines.push({\n                line: rescaleFn(lines[i].map((x)=>x ?? NaN), tx, ty, sx, sy),\n                points: rescaleFn(points[i].map((x)=>x ?? NaN), tx, ty, sx, sy)\n            });\n        }\n        const outlines = new this.prototype.constructor();\n        outlines.build(newLines, pageWidth, pageHeight, 1, rotation, thickness, innerMargin);\n        return outlines;\n    }\n    #getMarginComponents(thickness = this.#thickness) {\n        const margin = this.#innerMargin + thickness / 2 * this.#parentScale;\n        return this.#rotation % 180 === 0 ? [\n            margin / this.#parentWidth,\n            margin / this.#parentHeight\n        ] : [\n            margin / this.#parentHeight,\n            margin / this.#parentWidth\n        ];\n    }\n    #getBBoxWithNoMargin() {\n        const [x, y, width, height] = this.#bbox;\n        const [marginX, marginY] = this.#getMarginComponents(0);\n        return [\n            x + marginX,\n            y + marginY,\n            width - 2 * marginX,\n            height - 2 * marginY\n        ];\n    }\n    #computeBbox() {\n        const bbox = this.#bbox = new Float32Array([\n            Infinity,\n            Infinity,\n            -Infinity,\n            -Infinity\n        ]);\n        for (const { line } of this.#lines){\n            if (line.length <= 12) {\n                for(let i = 4, ii = line.length; i < ii; i += 6){\n                    Util.pointBoundingBox(line[i], line[i + 1], bbox);\n                }\n                continue;\n            }\n            let lastX = line[4], lastY = line[5];\n            for(let i = 6, ii = line.length; i < ii; i += 6){\n                const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6);\n                Util.bezierBoundingBox(lastX, lastY, c1x, c1y, c2x, c2y, x, y, bbox);\n                lastX = x;\n                lastY = y;\n            }\n        }\n        const [marginX, marginY] = this.#getMarginComponents();\n        bbox[0] = MathClamp(bbox[0] - marginX, 0, 1);\n        bbox[1] = MathClamp(bbox[1] - marginY, 0, 1);\n        bbox[2] = MathClamp(bbox[2] + marginX, 0, 1);\n        bbox[3] = MathClamp(bbox[3] + marginY, 0, 1);\n        bbox[2] -= bbox[0];\n        bbox[3] -= bbox[1];\n    }\n    get box() {\n        return this.#bbox;\n    }\n    updateProperty(name, value) {\n        if (name === \"stroke-width\") {\n            return this.#updateThickness(value);\n        }\n        return null;\n    }\n    #updateThickness(thickness) {\n        const [oldMarginX, oldMarginY] = this.#getMarginComponents();\n        this.#thickness = thickness;\n        const [newMarginX, newMarginY] = this.#getMarginComponents();\n        const [diffMarginX, diffMarginY] = [\n            newMarginX - oldMarginX,\n            newMarginY - oldMarginY\n        ];\n        const bbox = this.#bbox;\n        bbox[0] -= diffMarginX;\n        bbox[1] -= diffMarginY;\n        bbox[2] += 2 * diffMarginX;\n        bbox[3] += 2 * diffMarginY;\n        return bbox;\n    }\n    updateParentDimensions([width, height], scale) {\n        const [oldMarginX, oldMarginY] = this.#getMarginComponents();\n        this.#parentWidth = width;\n        this.#parentHeight = height;\n        this.#parentScale = scale;\n        const [newMarginX, newMarginY] = this.#getMarginComponents();\n        const diffMarginX = newMarginX - oldMarginX;\n        const diffMarginY = newMarginY - oldMarginY;\n        const bbox = this.#bbox;\n        bbox[0] -= diffMarginX;\n        bbox[1] -= diffMarginY;\n        bbox[2] += 2 * diffMarginX;\n        bbox[3] += 2 * diffMarginY;\n        return bbox;\n    }\n    updateRotation(rotation) {\n        this.#currentRotation = rotation;\n        return {\n            path: {\n                transform: this.rotationTransform\n            }\n        };\n    }\n    get viewBox() {\n        return this.#bbox.map(Outline.svgRound).join(\" \");\n    }\n    get defaultProperties() {\n        const [x, y] = this.#bbox;\n        return {\n            root: {\n                viewBox: this.viewBox\n            },\n            path: {\n                \"transform-origin\": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`\n            }\n        };\n    }\n    get rotationTransform() {\n        const [, , width, height] = this.#bbox;\n        let a = 0, b = 0, c = 0, d = 0, e = 0, f = 0;\n        switch(this.#currentRotation){\n            case 90:\n                b = height / width;\n                c = -width / height;\n                e = width;\n                break;\n            case 180:\n                a = -1;\n                d = -1;\n                e = width;\n                f = height;\n                break;\n            case 270:\n                b = -height / width;\n                c = width / height;\n                f = height;\n                break;\n            default:\n                return \"\";\n        }\n        return `matrix(${a} ${b} ${c} ${d} ${Outline.svgRound(e)} ${Outline.svgRound(f)})`;\n    }\n    getPathResizingSVGProperties([newX, newY, newWidth, newHeight]) {\n        const [marginX, marginY] = this.#getMarginComponents();\n        const [x, y, width, height] = this.#bbox;\n        if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {\n            const tx = newX + newWidth / 2 - (x + width / 2);\n            const ty = newY + newHeight / 2 - (y + height / 2);\n            return {\n                path: {\n                    \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,\n                    transform: `${this.rotationTransform} translate(${tx} ${ty})`\n                }\n            };\n        }\n        const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);\n        const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);\n        const s2x = width / newWidth;\n        const s2y = height / newHeight;\n        return {\n            path: {\n                \"transform-origin\": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`,\n                transform: `${this.rotationTransform} scale(${s2x} ${s2y}) ` + `translate(${Outline.svgRound(marginX)} ${Outline.svgRound(marginY)}) scale(${s1x} ${s1y}) ` + `translate(${Outline.svgRound(-marginX)} ${Outline.svgRound(-marginY)})`\n            }\n        };\n    }\n    getPathResizedSVGProperties([newX, newY, newWidth, newHeight]) {\n        const [marginX, marginY] = this.#getMarginComponents();\n        const bbox = this.#bbox;\n        const [x, y, width, height] = bbox;\n        bbox[0] = newX;\n        bbox[1] = newY;\n        bbox[2] = newWidth;\n        bbox[3] = newHeight;\n        if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {\n            const tx = newX + newWidth / 2 - (x + width / 2);\n            const ty = newY + newHeight / 2 - (y + height / 2);\n            for (const { line, points } of this.#lines){\n                Outline._translate(line, tx, ty, line);\n                Outline._translate(points, tx, ty, points);\n            }\n            return {\n                root: {\n                    viewBox: this.viewBox\n                },\n                path: {\n                    \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,\n                    transform: this.rotationTransform || null,\n                    d: this.toSVGPath()\n                }\n            };\n        }\n        const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);\n        const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);\n        const tx = -s1x * (x + marginX) + newX + marginX;\n        const ty = -s1y * (y + marginY) + newY + marginY;\n        if (s1x !== 1 || s1y !== 1 || tx !== 0 || ty !== 0) {\n            for (const { line, points } of this.#lines){\n                Outline._rescale(line, tx, ty, s1x, s1y, line);\n                Outline._rescale(points, tx, ty, s1x, s1y, points);\n            }\n        }\n        return {\n            root: {\n                viewBox: this.viewBox\n            },\n            path: {\n                \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,\n                transform: this.rotationTransform || null,\n                d: this.toSVGPath()\n            }\n        };\n    }\n    getPathTranslatedSVGProperties([newX, newY], parentDimensions) {\n        const [newParentWidth, newParentHeight] = parentDimensions;\n        const bbox = this.#bbox;\n        const tx = newX - bbox[0];\n        const ty = newY - bbox[1];\n        if (this.#parentWidth === newParentWidth && this.#parentHeight === newParentHeight) {\n            for (const { line, points } of this.#lines){\n                Outline._translate(line, tx, ty, line);\n                Outline._translate(points, tx, ty, points);\n            }\n        } else {\n            const sx = this.#parentWidth / newParentWidth;\n            const sy = this.#parentHeight / newParentHeight;\n            this.#parentWidth = newParentWidth;\n            this.#parentHeight = newParentHeight;\n            for (const { line, points } of this.#lines){\n                Outline._rescale(line, tx, ty, sx, sy, line);\n                Outline._rescale(points, tx, ty, sx, sy, points);\n            }\n            bbox[2] *= sx;\n            bbox[3] *= sy;\n        }\n        bbox[0] = newX;\n        bbox[1] = newY;\n        return {\n            root: {\n                viewBox: this.viewBox\n            },\n            path: {\n                d: this.toSVGPath(),\n                \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`\n            }\n        };\n    }\n    get defaultSVGProperties() {\n        const bbox = this.#bbox;\n        return {\n            root: {\n                viewBox: this.viewBox\n            },\n            rootClass: {\n                draw: true\n            },\n            path: {\n                d: this.toSVGPath(),\n                \"transform-origin\": `${Outline.svgRound(bbox[0])} ${Outline.svgRound(bbox[1])}`,\n                transform: this.rotationTransform || null\n            },\n            bbox\n        };\n    }\n    constructor(...args){\n        super(...args);\n        this.#currentRotation = 0;\n    }\n}\n; // ./src/display/editor/ink.js\nclass InkDrawingOptions extends DrawingOptions {\n    constructor(viewerParameters){\n        super();\n        this._viewParameters = viewerParameters;\n        super.updateProperties({\n            fill: \"none\",\n            stroke: AnnotationEditor._defaultLineColor,\n            \"stroke-opacity\": 1,\n            \"stroke-width\": 1,\n            \"stroke-linecap\": \"round\",\n            \"stroke-linejoin\": \"round\",\n            \"stroke-miterlimit\": 10\n        });\n    }\n    updateSVGProperty(name, value) {\n        if (name === \"stroke-width\") {\n            value ??= this[\"stroke-width\"];\n            value *= this._viewParameters.realScale;\n        }\n        super.updateSVGProperty(name, value);\n    }\n    clone() {\n        const clone = new InkDrawingOptions(this._viewParameters);\n        clone.updateAll(this);\n        return clone;\n    }\n}\nclass InkEditor extends DrawingEditor {\n    static{\n        this._type = \"ink\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.INK;\n    }\n    static{\n        this._defaultDrawingOptions = null;\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"inkEditor\"\n        });\n        this._willKeepAspectRatio = true;\n        this.defaultL10nId = \"pdfjs-editor-ink-editor\";\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n        this._defaultDrawingOptions = new InkDrawingOptions(uiManager.viewParameters);\n    }\n    static getDefaultDrawingOptions(options) {\n        const clone = this._defaultDrawingOptions.clone();\n        clone.updateProperties(options);\n        return clone;\n    }\n    static get supportMultipleDrawings() {\n        return true;\n    }\n    static get typesMap() {\n        return shadow(this, \"typesMap\", new Map([\n            [\n                AnnotationEditorParamsType.INK_THICKNESS,\n                \"stroke-width\"\n            ],\n            [\n                AnnotationEditorParamsType.INK_COLOR,\n                \"stroke\"\n            ],\n            [\n                AnnotationEditorParamsType.INK_OPACITY,\n                \"stroke-opacity\"\n            ]\n        ]));\n    }\n    static createDrawerInstance(x, y, parentWidth, parentHeight, rotation) {\n        return new InkDrawOutliner(x, y, parentWidth, parentHeight, rotation, this._defaultDrawingOptions[\"stroke-width\"]);\n    }\n    static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {\n        return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        if (data instanceof InkAnnotationElement) {\n            const { data: { inkLists, rect, rotation, id, color, opacity, borderStyle: { rawWidth: thickness }, popupRef }, parent: { page: { pageNumber } } } = data;\n            initialData = data = {\n                annotationType: AnnotationEditorType.INK,\n                color: Array.from(color),\n                thickness,\n                opacity,\n                paths: {\n                    points: inkLists\n                },\n                boxes: null,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                id,\n                deleted: false,\n                popupRef\n            };\n        }\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.annotationElementId = data.id || null;\n        editor._initialData = initialData;\n        return editor;\n    }\n    onScaleChanging() {\n        if (!this.parent) {\n            return;\n        }\n        super.onScaleChanging();\n        const { _drawId, _drawingOptions, parent } = this;\n        _drawingOptions.updateSVGProperty(\"stroke-width\");\n        parent.drawLayer.updateProperties(_drawId, _drawingOptions.toSVGProperties());\n    }\n    static onScaleChangingWhenDrawing() {\n        const parent = this._currentParent;\n        if (!parent) {\n            return;\n        }\n        super.onScaleChangingWhenDrawing();\n        this._defaultDrawingOptions.updateSVGProperty(\"stroke-width\");\n        parent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());\n    }\n    createDrawingOptions({ color, thickness, opacity }) {\n        this._drawingOptions = InkEditor.getDefaultDrawingOptions({\n            stroke: Util.makeHexColor(...color),\n            \"stroke-width\": thickness,\n            \"stroke-opacity\": opacity\n        });\n    }\n    serialize(isForCopying = false) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const { lines, points, rect } = this.serializeDraw(isForCopying);\n        const { _drawingOptions: { stroke, \"stroke-opacity\": opacity, \"stroke-width\": thickness } } = this;\n        const serialized = {\n            annotationType: AnnotationEditorType.INK,\n            color: AnnotationEditor._colorManager.convert(stroke),\n            opacity,\n            thickness,\n            paths: {\n                lines,\n                points\n            },\n            pageIndex: this.pageIndex,\n            rect,\n            rotation: this.rotation,\n            structTreeParentId: this._structTreeParentId\n        };\n        if (isForCopying) {\n            serialized.isCopy = true;\n            return serialized;\n        }\n        if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n            return null;\n        }\n        serialized.id = this.annotationElementId;\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { color, thickness, opacity, pageIndex } = this._initialData;\n        return this._hasBeenMoved || this._hasBeenResized || serialized.color.some((c, i)=>c !== color[i]) || serialized.thickness !== thickness || serialized.opacity !== opacity || serialized.pageIndex !== pageIndex;\n    }\n    renderAnnotationElement(annotation) {\n        const { points, rect } = this.serializeDraw(false);\n        annotation.updateEdited({\n            rect,\n            thickness: this._drawingOptions[\"stroke-width\"],\n            points\n        });\n        return null;\n    }\n}\n; // ./src/display/editor/drawers/contour.js\nclass ContourDrawOutline extends InkDrawOutline {\n    toSVGPath() {\n        let path = super.toSVGPath();\n        if (!path.endsWith(\"Z\")) {\n            path += \"Z\";\n        }\n        return path;\n    }\n}\n; // ./src/display/editor/drawers/signaturedraw.js\nconst BASE_HEADER_LENGTH = 8;\nconst POINTS_PROPERTIES_NUMBER = 3;\nclass SignatureExtractor {\n    static #PARAMETERS = {\n        maxDim: 512,\n        sigmaSFactor: 0.02,\n        sigmaR: 25,\n        kernelSize: 16\n    };\n    static #neighborIndexToId(i0, j0, i, j) {\n        i -= i0;\n        j -= j0;\n        if (i === 0) {\n            return j > 0 ? 0 : 4;\n        }\n        if (i === 1) {\n            return j + 6;\n        }\n        return 2 - j;\n    }\n    static #neighborIdToIndex = new Int32Array([\n        0,\n        1,\n        -1,\n        1,\n        -1,\n        0,\n        -1,\n        -1,\n        0,\n        -1,\n        1,\n        -1,\n        1,\n        0,\n        1,\n        1\n    ]);\n    static #clockwiseNonZero(buf, width, i0, j0, i, j, offset) {\n        const id = this.#neighborIndexToId(i0, j0, i, j);\n        for(let k = 0; k < 8; k++){\n            const kk = (-k + id - offset + 16) % 8;\n            const shiftI = this.#neighborIdToIndex[2 * kk];\n            const shiftJ = this.#neighborIdToIndex[2 * kk + 1];\n            if (buf[(i0 + shiftI) * width + (j0 + shiftJ)] !== 0) {\n                return kk;\n            }\n        }\n        return -1;\n    }\n    static #counterClockwiseNonZero(buf, width, i0, j0, i, j, offset) {\n        const id = this.#neighborIndexToId(i0, j0, i, j);\n        for(let k = 0; k < 8; k++){\n            const kk = (k + id + offset + 16) % 8;\n            const shiftI = this.#neighborIdToIndex[2 * kk];\n            const shiftJ = this.#neighborIdToIndex[2 * kk + 1];\n            if (buf[(i0 + shiftI) * width + (j0 + shiftJ)] !== 0) {\n                return kk;\n            }\n        }\n        return -1;\n    }\n    static #findContours(buf, width, height, threshold) {\n        const N = buf.length;\n        const types = new Int32Array(N);\n        for(let i = 0; i < N; i++){\n            types[i] = buf[i] <= threshold ? 1 : 0;\n        }\n        for(let i = 1; i < height - 1; i++){\n            types[i * width] = types[i * width + width - 1] = 0;\n        }\n        for(let i = 0; i < width; i++){\n            types[i] = types[width * height - 1 - i] = 0;\n        }\n        let nbd = 1;\n        let lnbd;\n        const contours = [];\n        for(let i = 1; i < height - 1; i++){\n            lnbd = 1;\n            for(let j = 1; j < width - 1; j++){\n                const ij = i * width + j;\n                const pix = types[ij];\n                if (pix === 0) {\n                    continue;\n                }\n                let i2 = i;\n                let j2 = j;\n                if (pix === 1 && types[ij - 1] === 0) {\n                    nbd += 1;\n                    j2 -= 1;\n                } else if (pix >= 1 && types[ij + 1] === 0) {\n                    nbd += 1;\n                    j2 += 1;\n                    if (pix > 1) {\n                        lnbd = pix;\n                    }\n                } else {\n                    if (pix !== 1) {\n                        lnbd = Math.abs(pix);\n                    }\n                    continue;\n                }\n                const points = [\n                    j,\n                    i\n                ];\n                const isHole = j2 === j + 1;\n                const contour = {\n                    isHole,\n                    points,\n                    id: nbd,\n                    parent: 0\n                };\n                contours.push(contour);\n                let contour0;\n                for (const c of contours){\n                    if (c.id === lnbd) {\n                        contour0 = c;\n                        break;\n                    }\n                }\n                if (!contour0) {\n                    contour.parent = isHole ? lnbd : 0;\n                } else if (contour0.isHole) {\n                    contour.parent = isHole ? contour0.parent : lnbd;\n                } else {\n                    contour.parent = isHole ? lnbd : contour0.parent;\n                }\n                const k = this.#clockwiseNonZero(types, width, i, j, i2, j2, 0);\n                if (k === -1) {\n                    types[ij] = -nbd;\n                    if (types[ij] !== 1) {\n                        lnbd = Math.abs(types[ij]);\n                    }\n                    continue;\n                }\n                let shiftI = this.#neighborIdToIndex[2 * k];\n                let shiftJ = this.#neighborIdToIndex[2 * k + 1];\n                const i1 = i + shiftI;\n                const j1 = j + shiftJ;\n                i2 = i1;\n                j2 = j1;\n                let i3 = i;\n                let j3 = j;\n                while(true){\n                    const kk = this.#counterClockwiseNonZero(types, width, i3, j3, i2, j2, 1);\n                    shiftI = this.#neighborIdToIndex[2 * kk];\n                    shiftJ = this.#neighborIdToIndex[2 * kk + 1];\n                    const i4 = i3 + shiftI;\n                    const j4 = j3 + shiftJ;\n                    points.push(j4, i4);\n                    const ij3 = i3 * width + j3;\n                    if (types[ij3 + 1] === 0) {\n                        types[ij3] = -nbd;\n                    } else if (types[ij3] === 1) {\n                        types[ij3] = nbd;\n                    }\n                    if (i4 === i && j4 === j && i3 === i1 && j3 === j1) {\n                        if (types[ij] !== 1) {\n                            lnbd = Math.abs(types[ij]);\n                        }\n                        break;\n                    } else {\n                        i2 = i3;\n                        j2 = j3;\n                        i3 = i4;\n                        j3 = j4;\n                    }\n                }\n            }\n        }\n        return contours;\n    }\n    static #douglasPeuckerHelper(points, start, end, output) {\n        if (end - start <= 4) {\n            for(let i = start; i < end - 2; i += 2){\n                output.push(points[i], points[i + 1]);\n            }\n            return;\n        }\n        const ax = points[start];\n        const ay = points[start + 1];\n        const abx = points[end - 4] - ax;\n        const aby = points[end - 3] - ay;\n        const dist = Math.hypot(abx, aby);\n        const nabx = abx / dist;\n        const naby = aby / dist;\n        const aa = nabx * ay - naby * ax;\n        const m = aby / abx;\n        const invS = 1 / dist;\n        const phi = Math.atan(m);\n        const cosPhi = Math.cos(phi);\n        const sinPhi = Math.sin(phi);\n        const tmax = invS * (Math.abs(cosPhi) + Math.abs(sinPhi));\n        const poly = invS * (1 - tmax + tmax ** 2);\n        const partialPhi = Math.max(Math.atan(Math.abs(sinPhi + cosPhi) * poly), Math.atan(Math.abs(sinPhi - cosPhi) * poly));\n        let dmax = 0;\n        let index = start;\n        for(let i = start + 2; i < end - 2; i += 2){\n            const d = Math.abs(aa - nabx * points[i + 1] + naby * points[i]);\n            if (d > dmax) {\n                index = i;\n                dmax = d;\n            }\n        }\n        if (dmax > (dist * partialPhi) ** 2) {\n            this.#douglasPeuckerHelper(points, start, index + 2, output);\n            this.#douglasPeuckerHelper(points, index, end, output);\n        } else {\n            output.push(ax, ay);\n        }\n    }\n    static #douglasPeucker(points) {\n        const output = [];\n        const len = points.length;\n        this.#douglasPeuckerHelper(points, 0, len, output);\n        output.push(points[len - 2], points[len - 1]);\n        return output.length <= 4 ? null : output;\n    }\n    static #bilateralFilter(buf, width, height, sigmaS, sigmaR, kernelSize) {\n        const kernel = new Float32Array(kernelSize ** 2);\n        const sigmaS2 = -2 * sigmaS ** 2;\n        const halfSize = kernelSize >> 1;\n        for(let i = 0; i < kernelSize; i++){\n            const x = (i - halfSize) ** 2;\n            for(let j = 0; j < kernelSize; j++){\n                kernel[i * kernelSize + j] = Math.exp((x + (j - halfSize) ** 2) / sigmaS2);\n            }\n        }\n        const rangeValues = new Float32Array(256);\n        const sigmaR2 = -2 * sigmaR ** 2;\n        for(let i = 0; i < 256; i++){\n            rangeValues[i] = Math.exp(i ** 2 / sigmaR2);\n        }\n        const N = buf.length;\n        const out = new Uint8Array(N);\n        const histogram = new Uint32Array(256);\n        for(let i = 0; i < height; i++){\n            for(let j = 0; j < width; j++){\n                const ij = i * width + j;\n                const center = buf[ij];\n                let sum = 0;\n                let norm = 0;\n                for(let k = 0; k < kernelSize; k++){\n                    const y = i + k - halfSize;\n                    if (y < 0 || y >= height) {\n                        continue;\n                    }\n                    for(let l = 0; l < kernelSize; l++){\n                        const x = j + l - halfSize;\n                        if (x < 0 || x >= width) {\n                            continue;\n                        }\n                        const neighbour = buf[y * width + x];\n                        const w = kernel[k * kernelSize + l] * rangeValues[Math.abs(neighbour - center)];\n                        sum += neighbour * w;\n                        norm += w;\n                    }\n                }\n                const pix = out[ij] = Math.round(sum / norm);\n                histogram[pix]++;\n            }\n        }\n        return [\n            out,\n            histogram\n        ];\n    }\n    static #getHistogram(buf) {\n        const histogram = new Uint32Array(256);\n        for (const g of buf){\n            histogram[g]++;\n        }\n        return histogram;\n    }\n    static #toUint8(buf) {\n        const N = buf.length;\n        const out = new Uint8ClampedArray(N >> 2);\n        let max = -Infinity;\n        let min = Infinity;\n        for(let i = 0, ii = out.length; i < ii; i++){\n            const A = buf[(i << 2) + 3];\n            if (A === 0) {\n                max = out[i] = 0xff;\n                continue;\n            }\n            const pix = out[i] = buf[i << 2];\n            if (pix > max) {\n                max = pix;\n            }\n            if (pix < min) {\n                min = pix;\n            }\n        }\n        const ratio = 255 / (max - min);\n        for(let i = 0; i < N; i++){\n            out[i] = (out[i] - min) * ratio;\n        }\n        return out;\n    }\n    static #guessThreshold(histogram) {\n        let i;\n        let M = -Infinity;\n        let L = -Infinity;\n        const min = histogram.findIndex((v)=>v !== 0);\n        let pos = min;\n        let spos = min;\n        for(i = min; i < 256; i++){\n            const v = histogram[i];\n            if (v > M) {\n                if (i - pos > L) {\n                    L = i - pos;\n                    spos = i - 1;\n                }\n                M = v;\n                pos = i;\n            }\n        }\n        for(i = spos - 1; i >= 0; i--){\n            if (histogram[i] > histogram[i + 1]) {\n                break;\n            }\n        }\n        return i;\n    }\n    static #getGrayPixels(bitmap) {\n        const originalBitmap = bitmap;\n        const { width, height } = bitmap;\n        const { maxDim } = this.#PARAMETERS;\n        let newWidth = width;\n        let newHeight = height;\n        if (width > maxDim || height > maxDim) {\n            let prevWidth = width;\n            let prevHeight = height;\n            let steps = Math.log2(Math.max(width, height) / maxDim);\n            const isteps = Math.floor(steps);\n            steps = steps === isteps ? isteps - 1 : isteps;\n            for(let i = 0; i < steps; i++){\n                newWidth = prevWidth;\n                newHeight = prevHeight;\n                if (newWidth > maxDim) {\n                    newWidth = Math.ceil(newWidth / 2);\n                }\n                if (newHeight > maxDim) {\n                    newHeight = Math.ceil(newHeight / 2);\n                }\n                const offscreen = new OffscreenCanvas(newWidth, newHeight);\n                const ctx = offscreen.getContext(\"2d\");\n                ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);\n                prevWidth = newWidth;\n                prevHeight = newHeight;\n                if (bitmap !== originalBitmap) {\n                    bitmap.close();\n                }\n                bitmap = offscreen.transferToImageBitmap();\n            }\n            const ratio = Math.min(maxDim / newWidth, maxDim / newHeight);\n            newWidth = Math.round(newWidth * ratio);\n            newHeight = Math.round(newHeight * ratio);\n        }\n        const offscreen = new OffscreenCanvas(newWidth, newHeight);\n        const ctx = offscreen.getContext(\"2d\", {\n            willReadFrequently: true\n        });\n        ctx.filter = \"grayscale(1)\";\n        ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, newWidth, newHeight);\n        const grayImage = ctx.getImageData(0, 0, newWidth, newHeight).data;\n        const uint8Buf = this.#toUint8(grayImage);\n        return [\n            uint8Buf,\n            newWidth,\n            newHeight\n        ];\n    }\n    static extractContoursFromText(text, { fontFamily, fontStyle, fontWeight }, pageWidth, pageHeight, rotation, innerMargin) {\n        let canvas = new OffscreenCanvas(1, 1);\n        let ctx = canvas.getContext(\"2d\", {\n            alpha: false\n        });\n        const fontSize = 200;\n        const font = ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;\n        const { actualBoundingBoxLeft, actualBoundingBoxRight, actualBoundingBoxAscent, actualBoundingBoxDescent, fontBoundingBoxAscent, fontBoundingBoxDescent, width } = ctx.measureText(text);\n        const SCALE = 1.5;\n        const canvasWidth = Math.ceil(Math.max(Math.abs(actualBoundingBoxLeft) + Math.abs(actualBoundingBoxRight) || 0, width) * SCALE);\n        const canvasHeight = Math.ceil(Math.max(Math.abs(actualBoundingBoxAscent) + Math.abs(actualBoundingBoxDescent) || fontSize, Math.abs(fontBoundingBoxAscent) + Math.abs(fontBoundingBoxDescent) || fontSize) * SCALE);\n        canvas = new OffscreenCanvas(canvasWidth, canvasHeight);\n        ctx = canvas.getContext(\"2d\", {\n            alpha: true,\n            willReadFrequently: true\n        });\n        ctx.font = font;\n        ctx.filter = \"grayscale(1)\";\n        ctx.fillStyle = \"white\";\n        ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n        ctx.fillStyle = \"black\";\n        ctx.fillText(text, canvasWidth * (SCALE - 1) / 2, canvasHeight * (3 - SCALE) / 2);\n        const uint8Buf = this.#toUint8(ctx.getImageData(0, 0, canvasWidth, canvasHeight).data);\n        const histogram = this.#getHistogram(uint8Buf);\n        const threshold = this.#guessThreshold(histogram);\n        const contourList = this.#findContours(uint8Buf, canvasWidth, canvasHeight, threshold);\n        return this.processDrawnLines({\n            lines: {\n                curves: contourList,\n                width: canvasWidth,\n                height: canvasHeight\n            },\n            pageWidth,\n            pageHeight,\n            rotation,\n            innerMargin,\n            mustSmooth: true,\n            areContours: true\n        });\n    }\n    static process(bitmap, pageWidth, pageHeight, rotation, innerMargin) {\n        const [uint8Buf, width, height] = this.#getGrayPixels(bitmap);\n        const [buffer, histogram] = this.#bilateralFilter(uint8Buf, width, height, Math.hypot(width, height) * this.#PARAMETERS.sigmaSFactor, this.#PARAMETERS.sigmaR, this.#PARAMETERS.kernelSize);\n        const threshold = this.#guessThreshold(histogram);\n        const contourList = this.#findContours(buffer, width, height, threshold);\n        return this.processDrawnLines({\n            lines: {\n                curves: contourList,\n                width,\n                height\n            },\n            pageWidth,\n            pageHeight,\n            rotation,\n            innerMargin,\n            mustSmooth: true,\n            areContours: true\n        });\n    }\n    static processDrawnLines({ lines, pageWidth, pageHeight, rotation, innerMargin, mustSmooth, areContours }) {\n        if (rotation % 180 !== 0) {\n            [pageWidth, pageHeight] = [\n                pageHeight,\n                pageWidth\n            ];\n        }\n        const { curves, width, height } = lines;\n        const thickness = lines.thickness ?? 0;\n        const linesAndPoints = [];\n        const ratio = Math.min(pageWidth / width, pageHeight / height);\n        const xScale = ratio / pageWidth;\n        const yScale = ratio / pageHeight;\n        const newCurves = [];\n        for (const { points } of curves){\n            const reducedPoints = mustSmooth ? this.#douglasPeucker(points) : points;\n            if (!reducedPoints) {\n                continue;\n            }\n            newCurves.push(reducedPoints);\n            const len = reducedPoints.length;\n            const newPoints = new Float32Array(len);\n            const line = new Float32Array(3 * (len === 2 ? 2 : len - 2));\n            linesAndPoints.push({\n                line,\n                points: newPoints\n            });\n            if (len === 2) {\n                newPoints[0] = reducedPoints[0] * xScale;\n                newPoints[1] = reducedPoints[1] * yScale;\n                line.set([\n                    NaN,\n                    NaN,\n                    NaN,\n                    NaN,\n                    newPoints[0],\n                    newPoints[1]\n                ], 0);\n                continue;\n            }\n            let [x1, y1, x2, y2] = reducedPoints;\n            x1 *= xScale;\n            y1 *= yScale;\n            x2 *= xScale;\n            y2 *= yScale;\n            newPoints.set([\n                x1,\n                y1,\n                x2,\n                y2\n            ], 0);\n            line.set([\n                NaN,\n                NaN,\n                NaN,\n                NaN,\n                x1,\n                y1\n            ], 0);\n            for(let i = 4; i < len; i += 2){\n                const x = newPoints[i] = reducedPoints[i] * xScale;\n                const y = newPoints[i + 1] = reducedPoints[i + 1] * yScale;\n                line.set(Outline.createBezierPoints(x1, y1, x2, y2, x, y), (i - 2) * 3);\n                [x1, y1, x2, y2] = [\n                    x2,\n                    y2,\n                    x,\n                    y\n                ];\n            }\n        }\n        if (linesAndPoints.length === 0) {\n            return null;\n        }\n        const outline = areContours ? new ContourDrawOutline() : new InkDrawOutline();\n        outline.build(linesAndPoints, pageWidth, pageHeight, 1, rotation, areContours ? 0 : thickness, innerMargin);\n        return {\n            outline,\n            newCurves,\n            areContours,\n            thickness,\n            width,\n            height\n        };\n    }\n    static async compressSignature({ outlines, areContours, thickness, width, height }) {\n        let minDiff = Infinity;\n        let maxDiff = -Infinity;\n        let outlinesLength = 0;\n        for (const points of outlines){\n            outlinesLength += points.length;\n            for(let i = 2, ii = points.length; i < ii; i++){\n                const dx = points[i] - points[i - 2];\n                minDiff = Math.min(minDiff, dx);\n                maxDiff = Math.max(maxDiff, dx);\n            }\n        }\n        let bufferType;\n        if (minDiff >= -128 && maxDiff <= 127) {\n            bufferType = Int8Array;\n        } else if (minDiff >= -32768 && maxDiff <= 32767) {\n            bufferType = Int16Array;\n        } else {\n            bufferType = Int32Array;\n        }\n        const len = outlines.length;\n        const headerLength = BASE_HEADER_LENGTH + POINTS_PROPERTIES_NUMBER * len;\n        const header = new Uint32Array(headerLength);\n        let offset = 0;\n        header[offset++] = headerLength * Uint32Array.BYTES_PER_ELEMENT + (outlinesLength - 2 * len) * bufferType.BYTES_PER_ELEMENT;\n        header[offset++] = 0;\n        header[offset++] = width;\n        header[offset++] = height;\n        header[offset++] = areContours ? 0 : 1;\n        header[offset++] = Math.max(0, Math.floor(thickness ?? 0));\n        header[offset++] = len;\n        header[offset++] = bufferType.BYTES_PER_ELEMENT;\n        for (const points of outlines){\n            header[offset++] = points.length - 2;\n            header[offset++] = points[0];\n            header[offset++] = points[1];\n        }\n        const cs = new CompressionStream(\"deflate-raw\");\n        const writer = cs.writable.getWriter();\n        await writer.ready;\n        writer.write(header);\n        const BufferCtor = bufferType.prototype.constructor;\n        for (const points of outlines){\n            const diffs = new BufferCtor(points.length - 2);\n            for(let i = 2, ii = points.length; i < ii; i++){\n                diffs[i - 2] = points[i] - points[i - 2];\n            }\n            writer.write(diffs);\n        }\n        writer.close();\n        const buf = await new Response(cs.readable).arrayBuffer();\n        const bytes = new Uint8Array(buf);\n        return toBase64Util(bytes);\n    }\n    static async decompressSignature(signatureData) {\n        try {\n            const bytes = fromBase64Util(signatureData);\n            const { readable, writable } = new DecompressionStream(\"deflate-raw\");\n            const writer = writable.getWriter();\n            await writer.ready;\n            writer.write(bytes).then(async ()=>{\n                await writer.ready;\n                await writer.close();\n            }).catch(()=>{});\n            let data = null;\n            let offset = 0;\n            for await (const chunk of readable){\n                data ||= new Uint8Array(new Uint32Array(chunk.buffer, 0, 4)[0]);\n                data.set(chunk, offset);\n                offset += chunk.length;\n            }\n            const header = new Uint32Array(data.buffer, 0, data.length >> 2);\n            const version = header[1];\n            if (version !== 0) {\n                throw new Error(`Invalid version: ${version}`);\n            }\n            const width = header[2];\n            const height = header[3];\n            const areContours = header[4] === 0;\n            const thickness = header[5];\n            const numberOfDrawings = header[6];\n            const bufferType = header[7];\n            const outlines = [];\n            const diffsOffset = (BASE_HEADER_LENGTH + POINTS_PROPERTIES_NUMBER * numberOfDrawings) * Uint32Array.BYTES_PER_ELEMENT;\n            let diffs;\n            switch(bufferType){\n                case Int8Array.BYTES_PER_ELEMENT:\n                    diffs = new Int8Array(data.buffer, diffsOffset);\n                    break;\n                case Int16Array.BYTES_PER_ELEMENT:\n                    diffs = new Int16Array(data.buffer, diffsOffset);\n                    break;\n                case Int32Array.BYTES_PER_ELEMENT:\n                    diffs = new Int32Array(data.buffer, diffsOffset);\n                    break;\n            }\n            offset = 0;\n            for(let i = 0; i < numberOfDrawings; i++){\n                const len = header[POINTS_PROPERTIES_NUMBER * i + BASE_HEADER_LENGTH];\n                const points = new Float32Array(len + 2);\n                outlines.push(points);\n                for(let j = 0; j < POINTS_PROPERTIES_NUMBER - 1; j++){\n                    points[j] = header[POINTS_PROPERTIES_NUMBER * i + BASE_HEADER_LENGTH + j + 1];\n                }\n                for(let j = 0; j < len; j++){\n                    points[j + 2] = points[j] + diffs[offset++];\n                }\n            }\n            return {\n                areContours,\n                thickness,\n                outlines,\n                width,\n                height\n            };\n        } catch (e) {\n            warn(`decompressSignature: ${e}`);\n            return null;\n        }\n    }\n}\n; // ./src/display/editor/signature.js\nclass SignatureOptions extends DrawingOptions {\n    constructor(){\n        super();\n        super.updateProperties({\n            fill: AnnotationEditor._defaultLineColor,\n            \"stroke-width\": 0\n        });\n    }\n    clone() {\n        const clone = new SignatureOptions();\n        clone.updateAll(this);\n        return clone;\n    }\n}\nclass DrawnSignatureOptions extends InkDrawingOptions {\n    constructor(viewerParameters){\n        super(viewerParameters);\n        super.updateProperties({\n            stroke: AnnotationEditor._defaultLineColor,\n            \"stroke-width\": 1\n        });\n    }\n    clone() {\n        const clone = new DrawnSignatureOptions(this._viewParameters);\n        clone.updateAll(this);\n        return clone;\n    }\n}\nclass SignatureEditor extends DrawingEditor {\n    #isExtracted;\n    #description;\n    #signatureData;\n    #signatureUUID;\n    static{\n        this._type = \"signature\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.SIGNATURE;\n    }\n    static{\n        this._defaultDrawingOptions = null;\n    }\n    constructor(params){\n        super({\n            ...params,\n            mustBeCommitted: true,\n            name: \"signatureEditor\"\n        });\n        this.#isExtracted = false;\n        this.#description = null;\n        this.#signatureData = null;\n        this.#signatureUUID = null;\n        this._willKeepAspectRatio = true;\n        this.#signatureData = params.signatureData || null;\n        this.#description = null;\n        this.defaultL10nId = \"pdfjs-editor-signature-editor1\";\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n        this._defaultDrawingOptions = new SignatureOptions();\n        this._defaultDrawnSignatureOptions = new DrawnSignatureOptions(uiManager.viewParameters);\n    }\n    static getDefaultDrawingOptions(options) {\n        const clone = this._defaultDrawingOptions.clone();\n        clone.updateProperties(options);\n        return clone;\n    }\n    static get supportMultipleDrawings() {\n        return false;\n    }\n    static get typesMap() {\n        return shadow(this, \"typesMap\", new Map());\n    }\n    static get isDrawer() {\n        return false;\n    }\n    get telemetryFinalData() {\n        return {\n            type: \"signature\",\n            hasDescription: !!this.#description\n        };\n    }\n    static computeTelemetryFinalData(data) {\n        const hasDescriptionStats = data.get(\"hasDescription\");\n        return {\n            hasAltText: hasDescriptionStats.get(true) ?? 0,\n            hasNoAltText: hasDescriptionStats.get(false) ?? 0\n        };\n    }\n    get isResizable() {\n        return true;\n    }\n    onScaleChanging() {\n        if (this._drawId === null) {\n            return;\n        }\n        super.onScaleChanging();\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        let baseX, baseY;\n        const { _isCopy } = this;\n        if (_isCopy) {\n            this._isCopy = false;\n            baseX = this.x;\n            baseY = this.y;\n        }\n        super.render();\n        if (this._drawId === null) {\n            if (this.#signatureData) {\n                const { lines, mustSmooth, areContours, description, uuid, heightInPage } = this.#signatureData;\n                const { rawDims: { pageWidth, pageHeight }, rotation } = this.parent.viewport;\n                const outline = SignatureExtractor.processDrawnLines({\n                    lines,\n                    pageWidth,\n                    pageHeight,\n                    rotation,\n                    innerMargin: SignatureEditor._INNER_MARGIN,\n                    mustSmooth,\n                    areContours\n                });\n                this.addSignature(outline, heightInPage, description, uuid);\n            } else {\n                this.div.setAttribute(\"data-l10n-args\", JSON.stringify({\n                    description: \"\"\n                }));\n                this.div.hidden = true;\n                this._uiManager.getSignature(this);\n            }\n        }\n        if (_isCopy) {\n            this._isCopy = true;\n            this._moveAfterPaste(baseX, baseY);\n        }\n        return this.div;\n    }\n    setUuid(uuid) {\n        this.#signatureUUID = uuid;\n        this.addEditToolbar();\n    }\n    getUuid() {\n        return this.#signatureUUID;\n    }\n    get description() {\n        return this.#description;\n    }\n    set description(description) {\n        this.#description = description;\n        super.addEditToolbar().then((toolbar)=>{\n            toolbar?.updateEditSignatureButton(description);\n        });\n    }\n    getSignaturePreview() {\n        const { newCurves, areContours, thickness, width, height } = this.#signatureData;\n        const maxDim = Math.max(width, height);\n        const outlineData = SignatureExtractor.processDrawnLines({\n            lines: {\n                curves: newCurves.map((points)=>({\n                        points\n                    })),\n                thickness,\n                width,\n                height\n            },\n            pageWidth: maxDim,\n            pageHeight: maxDim,\n            rotation: 0,\n            innerMargin: 0,\n            mustSmooth: false,\n            areContours\n        });\n        return {\n            areContours,\n            outline: outlineData.outline\n        };\n    }\n    async addEditToolbar() {\n        const toolbar = await super.addEditToolbar();\n        if (!toolbar) {\n            return null;\n        }\n        if (this._uiManager.signatureManager && this.#description !== null) {\n            await toolbar.addEditSignatureButton(this._uiManager.signatureManager, this.#signatureUUID, this.#description);\n            toolbar.show();\n        }\n        return toolbar;\n    }\n    addSignature(data, heightInPage, description, uuid) {\n        const { x: savedX, y: savedY } = this;\n        const { outline } = this.#signatureData = data;\n        this.#isExtracted = outline instanceof ContourDrawOutline;\n        this.#description = description;\n        this.div.setAttribute(\"data-l10n-args\", JSON.stringify({\n            description\n        }));\n        let drawingOptions;\n        if (this.#isExtracted) {\n            drawingOptions = SignatureEditor.getDefaultDrawingOptions();\n        } else {\n            drawingOptions = SignatureEditor._defaultDrawnSignatureOptions.clone();\n            drawingOptions.updateProperties({\n                \"stroke-width\": outline.thickness\n            });\n        }\n        this._addOutlines({\n            drawOutlines: outline,\n            drawingOptions\n        });\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const [, pageHeight] = this.pageDimensions;\n        let newHeight = heightInPage / pageHeight;\n        newHeight = newHeight >= 1 ? 0.5 : newHeight;\n        this.width *= newHeight / this.height;\n        if (this.width >= 1) {\n            newHeight *= 0.9 / this.width;\n            this.width = 0.9;\n        }\n        this.height = newHeight;\n        this.setDims(parentWidth * this.width, parentHeight * this.height);\n        this.x = savedX;\n        this.y = savedY;\n        this.center();\n        this._onResized();\n        this.onScaleChanging();\n        this.rotate();\n        this._uiManager.addToAnnotationStorage(this);\n        this.setUuid(uuid);\n        this._reportTelemetry({\n            action: \"pdfjs.signature.inserted\",\n            data: {\n                hasBeenSaved: !!uuid,\n                hasDescription: !!description\n            }\n        });\n        this.div.hidden = false;\n    }\n    getFromImage(bitmap) {\n        const { rawDims: { pageWidth, pageHeight }, rotation } = this.parent.viewport;\n        return SignatureExtractor.process(bitmap, pageWidth, pageHeight, rotation, SignatureEditor._INNER_MARGIN);\n    }\n    getFromText(text, fontInfo) {\n        const { rawDims: { pageWidth, pageHeight }, rotation } = this.parent.viewport;\n        return SignatureExtractor.extractContoursFromText(text, fontInfo, pageWidth, pageHeight, rotation, SignatureEditor._INNER_MARGIN);\n    }\n    getDrawnSignature(curves) {\n        const { rawDims: { pageWidth, pageHeight }, rotation } = this.parent.viewport;\n        return SignatureExtractor.processDrawnLines({\n            lines: curves,\n            pageWidth,\n            pageHeight,\n            rotation,\n            innerMargin: SignatureEditor._INNER_MARGIN,\n            mustSmooth: false,\n            areContours: false\n        });\n    }\n    createDrawingOptions({ areContours, thickness }) {\n        if (areContours) {\n            this._drawingOptions = SignatureEditor.getDefaultDrawingOptions();\n        } else {\n            this._drawingOptions = SignatureEditor._defaultDrawnSignatureOptions.clone();\n            this._drawingOptions.updateProperties({\n                \"stroke-width\": thickness\n            });\n        }\n    }\n    serialize(isForCopying = false) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        const { lines, points, rect } = this.serializeDraw(isForCopying);\n        const { _drawingOptions: { \"stroke-width\": thickness } } = this;\n        const serialized = {\n            annotationType: AnnotationEditorType.SIGNATURE,\n            isSignature: true,\n            areContours: this.#isExtracted,\n            color: [\n                0,\n                0,\n                0\n            ],\n            thickness: this.#isExtracted ? 0 : thickness,\n            pageIndex: this.pageIndex,\n            rect,\n            rotation: this.rotation,\n            structTreeParentId: this._structTreeParentId\n        };\n        if (isForCopying) {\n            serialized.paths = {\n                lines,\n                points\n            };\n            serialized.uuid = this.#signatureUUID;\n            serialized.isCopy = true;\n        } else {\n            serialized.lines = lines;\n        }\n        if (this.#description) {\n            serialized.accessibilityData = {\n                type: \"Figure\",\n                alt: this.#description\n            };\n        }\n        return serialized;\n    }\n    static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {\n        if (data.areContours) {\n            return ContourDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);\n        }\n        return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);\n    }\n    static async deserialize(data, parent, uiManager) {\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.#isExtracted = data.areContours;\n        editor.#description = data.accessibilityData?.alt || \"\";\n        editor.#signatureUUID = data.uuid;\n        return editor;\n    }\n}\n; // ./src/display/editor/stamp.js\nclass StampEditor extends AnnotationEditor {\n    #bitmap;\n    #bitmapId;\n    #bitmapPromise;\n    #bitmapUrl;\n    #bitmapFile;\n    #bitmapFileName;\n    #canvas;\n    #missingCanvas;\n    #resizeTimeoutId;\n    #isSvg;\n    #hasBeenAddedInUndoStack;\n    static{\n        this._type = \"stamp\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.STAMP;\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"stampEditor\"\n        });\n        this.#bitmap = null;\n        this.#bitmapId = null;\n        this.#bitmapPromise = null;\n        this.#bitmapUrl = null;\n        this.#bitmapFile = null;\n        this.#bitmapFileName = \"\";\n        this.#canvas = null;\n        this.#missingCanvas = false;\n        this.#resizeTimeoutId = null;\n        this.#isSvg = false;\n        this.#hasBeenAddedInUndoStack = false;\n        this.#bitmapUrl = params.bitmapUrl;\n        this.#bitmapFile = params.bitmapFile;\n        this.defaultL10nId = \"pdfjs-editor-stamp-editor\";\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n    }\n    static isHandlingMimeForPasting(mime) {\n        return SupportedImageMimeTypes.includes(mime);\n    }\n    static paste(item, parent) {\n        parent.pasteEditor(AnnotationEditorType.STAMP, {\n            bitmapFile: item.getAsFile()\n        });\n    }\n    altTextFinish() {\n        if (this._uiManager.useNewAltTextFlow) {\n            this.div.hidden = false;\n        }\n        super.altTextFinish();\n    }\n    get telemetryFinalData() {\n        return {\n            type: \"stamp\",\n            hasAltText: !!this.altTextData?.altText\n        };\n    }\n    static computeTelemetryFinalData(data) {\n        const hasAltTextStats = data.get(\"hasAltText\");\n        return {\n            hasAltText: hasAltTextStats.get(true) ?? 0,\n            hasNoAltText: hasAltTextStats.get(false) ?? 0\n        };\n    }\n    #getBitmapFetched(data, fromId = false) {\n        if (!data) {\n            this.remove();\n            return;\n        }\n        this.#bitmap = data.bitmap;\n        if (!fromId) {\n            this.#bitmapId = data.id;\n            this.#isSvg = data.isSvg;\n        }\n        if (data.file) {\n            this.#bitmapFileName = data.file.name;\n        }\n        this.#createCanvas();\n    }\n    #getBitmapDone() {\n        this.#bitmapPromise = null;\n        this._uiManager.enableWaiting(false);\n        if (!this.#canvas) {\n            return;\n        }\n        if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {\n            this._editToolbar.hide();\n            this._uiManager.editAltText(this, true);\n            return;\n        }\n        if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {\n            this._reportTelemetry({\n                action: \"pdfjs.image.image_added\",\n                data: {\n                    alt_text_modal: false,\n                    alt_text_type: \"empty\"\n                }\n            });\n            try {\n                this.mlGuessAltText();\n            } catch  {}\n        }\n        this.div.focus();\n    }\n    async mlGuessAltText(imageData = null, updateAltTextData = true) {\n        if (this.hasAltTextData()) {\n            return null;\n        }\n        const { mlManager } = this._uiManager;\n        if (!mlManager) {\n            throw new Error(\"No ML.\");\n        }\n        if (!await mlManager.isEnabledFor(\"altText\")) {\n            throw new Error(\"ML isn't enabled for alt text.\");\n        }\n        const { data, width, height } = imageData || this.copyCanvas(null, null, true).imageData;\n        const response = await mlManager.guess({\n            name: \"altText\",\n            request: {\n                data,\n                width,\n                height,\n                channels: data.length / (width * height)\n            }\n        });\n        if (!response) {\n            throw new Error(\"No response from the AI service.\");\n        }\n        if (response.error) {\n            throw new Error(\"Error from the AI service.\");\n        }\n        if (response.cancel) {\n            return null;\n        }\n        if (!response.output) {\n            throw new Error(\"No valid response from the AI service.\");\n        }\n        const altText = response.output;\n        await this.setGuessedAltText(altText);\n        if (updateAltTextData && !this.hasAltTextData()) {\n            this.altTextData = {\n                alt: altText,\n                decorative: false\n            };\n        }\n        return altText;\n    }\n    #getBitmap() {\n        if (this.#bitmapId) {\n            this._uiManager.enableWaiting(true);\n            this._uiManager.imageManager.getFromId(this.#bitmapId).then((data)=>this.#getBitmapFetched(data, true)).finally(()=>this.#getBitmapDone());\n            return;\n        }\n        if (this.#bitmapUrl) {\n            const url = this.#bitmapUrl;\n            this.#bitmapUrl = null;\n            this._uiManager.enableWaiting(true);\n            this.#bitmapPromise = this._uiManager.imageManager.getFromUrl(url).then((data)=>this.#getBitmapFetched(data)).finally(()=>this.#getBitmapDone());\n            return;\n        }\n        if (this.#bitmapFile) {\n            const file = this.#bitmapFile;\n            this.#bitmapFile = null;\n            this._uiManager.enableWaiting(true);\n            this.#bitmapPromise = this._uiManager.imageManager.getFromFile(file).then((data)=>this.#getBitmapFetched(data)).finally(()=>this.#getBitmapDone());\n            return;\n        }\n        const input = document.createElement(\"input\");\n        input.type = \"file\";\n        input.accept = SupportedImageMimeTypes.join(\",\");\n        const signal = this._uiManager._signal;\n        this.#bitmapPromise = new Promise((resolve)=>{\n            input.addEventListener(\"change\", async ()=>{\n                if (!input.files || input.files.length === 0) {\n                    this.remove();\n                } else {\n                    this._uiManager.enableWaiting(true);\n                    const data = await this._uiManager.imageManager.getFromFile(input.files[0]);\n                    this._reportTelemetry({\n                        action: \"pdfjs.image.image_selected\",\n                        data: {\n                            alt_text_modal: this._uiManager.useNewAltTextFlow\n                        }\n                    });\n                    this.#getBitmapFetched(data);\n                }\n                resolve();\n            }, {\n                signal\n            });\n            input.addEventListener(\"cancel\", ()=>{\n                this.remove();\n                resolve();\n            }, {\n                signal\n            });\n        }).finally(()=>this.#getBitmapDone());\n        input.click();\n    }\n    remove() {\n        if (this.#bitmapId) {\n            this.#bitmap = null;\n            this._uiManager.imageManager.deleteId(this.#bitmapId);\n            this.#canvas?.remove();\n            this.#canvas = null;\n            if (this.#resizeTimeoutId) {\n                clearTimeout(this.#resizeTimeoutId);\n                this.#resizeTimeoutId = null;\n            }\n        }\n        super.remove();\n    }\n    rebuild() {\n        if (!this.parent) {\n            if (this.#bitmapId) {\n                this.#getBitmap();\n            }\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        if (this.#bitmapId && this.#canvas === null) {\n            this.#getBitmap();\n        }\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    onceAdded(focus) {\n        this._isDraggable = true;\n        if (focus) {\n            this.div.focus();\n        }\n    }\n    isEmpty() {\n        return !(this.#bitmapPromise || this.#bitmap || this.#bitmapUrl || this.#bitmapFile || this.#bitmapId || this.#missingCanvas);\n    }\n    get isResizable() {\n        return true;\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        let baseX, baseY;\n        if (this._isCopy) {\n            baseX = this.x;\n            baseY = this.y;\n        }\n        super.render();\n        this.div.hidden = true;\n        this.addAltTextButton();\n        if (!this.#missingCanvas) {\n            if (this.#bitmap) {\n                this.#createCanvas();\n            } else {\n                this.#getBitmap();\n            }\n        }\n        if (this._isCopy) {\n            this._moveAfterPaste(baseX, baseY);\n        }\n        this._uiManager.addShouldRescale(this);\n        return this.div;\n    }\n    setCanvas(annotationElementId, canvas) {\n        const { id: bitmapId, bitmap } = this._uiManager.imageManager.getFromCanvas(annotationElementId, canvas);\n        canvas.remove();\n        if (bitmapId && this._uiManager.imageManager.isValidId(bitmapId)) {\n            this.#bitmapId = bitmapId;\n            if (bitmap) {\n                this.#bitmap = bitmap;\n            }\n            this.#missingCanvas = false;\n            this.#createCanvas();\n        }\n    }\n    _onResized() {\n        this.onScaleChanging();\n    }\n    onScaleChanging() {\n        if (!this.parent) {\n            return;\n        }\n        if (this.#resizeTimeoutId !== null) {\n            clearTimeout(this.#resizeTimeoutId);\n        }\n        const TIME_TO_WAIT = 200;\n        this.#resizeTimeoutId = setTimeout(()=>{\n            this.#resizeTimeoutId = null;\n            this.#drawBitmap();\n        }, TIME_TO_WAIT);\n    }\n    #createCanvas() {\n        const { div } = this;\n        let { width, height } = this.#bitmap;\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const MAX_RATIO = 0.75;\n        if (this.width) {\n            width = this.width * pageWidth;\n            height = this.height * pageHeight;\n        } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {\n            const factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);\n            width *= factor;\n            height *= factor;\n        }\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setDims(width * parentWidth / pageWidth, height * parentHeight / pageHeight);\n        this._uiManager.enableWaiting(false);\n        const canvas = this.#canvas = document.createElement(\"canvas\");\n        canvas.setAttribute(\"role\", \"img\");\n        this.addContainer(canvas);\n        this.width = width / pageWidth;\n        this.height = height / pageHeight;\n        if (this._initialOptions?.isCentered) {\n            this.center();\n        } else {\n            this.fixAndSetPosition();\n        }\n        this._initialOptions = null;\n        if (!this._uiManager.useNewAltTextWhenAddingImage || !this._uiManager.useNewAltTextFlow || this.annotationElementId) {\n            div.hidden = false;\n        }\n        this.#drawBitmap();\n        if (!this.#hasBeenAddedInUndoStack) {\n            this.parent.addUndoableEditor(this);\n            this.#hasBeenAddedInUndoStack = true;\n        }\n        this._reportTelemetry({\n            action: \"inserted_image\"\n        });\n        if (this.#bitmapFileName) {\n            this.div.setAttribute(\"aria-description\", this.#bitmapFileName);\n        }\n    }\n    copyCanvas(maxDataDimension, maxPreviewDimension, createImageData = false) {\n        if (!maxDataDimension) {\n            maxDataDimension = 224;\n        }\n        const { width: bitmapWidth, height: bitmapHeight } = this.#bitmap;\n        const outputScale = new OutputScale();\n        let bitmap = this.#bitmap;\n        let width = bitmapWidth, height = bitmapHeight;\n        let canvas = null;\n        if (maxPreviewDimension) {\n            if (bitmapWidth > maxPreviewDimension || bitmapHeight > maxPreviewDimension) {\n                const ratio = Math.min(maxPreviewDimension / bitmapWidth, maxPreviewDimension / bitmapHeight);\n                width = Math.floor(bitmapWidth * ratio);\n                height = Math.floor(bitmapHeight * ratio);\n            }\n            canvas = document.createElement(\"canvas\");\n            const scaledWidth = canvas.width = Math.ceil(width * outputScale.sx);\n            const scaledHeight = canvas.height = Math.ceil(height * outputScale.sy);\n            if (!this.#isSvg) {\n                bitmap = this.#scaleBitmap(scaledWidth, scaledHeight);\n            }\n            const ctx = canvas.getContext(\"2d\");\n            ctx.filter = this._uiManager.hcmFilter;\n            let white = \"white\", black = \"#cfcfd8\";\n            if (this._uiManager.hcmFilter !== \"none\") {\n                black = \"black\";\n            } else if (window.matchMedia?.(\"(prefers-color-scheme: dark)\").matches) {\n                white = \"#8f8f9d\";\n                black = \"#42414d\";\n            }\n            const boxDim = 15;\n            const boxDimWidth = boxDim * outputScale.sx;\n            const boxDimHeight = boxDim * outputScale.sy;\n            const pattern = new OffscreenCanvas(boxDimWidth * 2, boxDimHeight * 2);\n            const patternCtx = pattern.getContext(\"2d\");\n            patternCtx.fillStyle = white;\n            patternCtx.fillRect(0, 0, boxDimWidth * 2, boxDimHeight * 2);\n            patternCtx.fillStyle = black;\n            patternCtx.fillRect(0, 0, boxDimWidth, boxDimHeight);\n            patternCtx.fillRect(boxDimWidth, boxDimHeight, boxDimWidth, boxDimHeight);\n            ctx.fillStyle = ctx.createPattern(pattern, \"repeat\");\n            ctx.fillRect(0, 0, scaledWidth, scaledHeight);\n            ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);\n        }\n        let imageData = null;\n        if (createImageData) {\n            let dataWidth, dataHeight;\n            if (outputScale.symmetric && bitmap.width < maxDataDimension && bitmap.height < maxDataDimension) {\n                dataWidth = bitmap.width;\n                dataHeight = bitmap.height;\n            } else {\n                bitmap = this.#bitmap;\n                if (bitmapWidth > maxDataDimension || bitmapHeight > maxDataDimension) {\n                    const ratio = Math.min(maxDataDimension / bitmapWidth, maxDataDimension / bitmapHeight);\n                    dataWidth = Math.floor(bitmapWidth * ratio);\n                    dataHeight = Math.floor(bitmapHeight * ratio);\n                    if (!this.#isSvg) {\n                        bitmap = this.#scaleBitmap(dataWidth, dataHeight);\n                    }\n                }\n            }\n            const offscreen = new OffscreenCanvas(dataWidth, dataHeight);\n            const offscreenCtx = offscreen.getContext(\"2d\", {\n                willReadFrequently: true\n            });\n            offscreenCtx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, dataWidth, dataHeight);\n            imageData = {\n                width: dataWidth,\n                height: dataHeight,\n                data: offscreenCtx.getImageData(0, 0, dataWidth, dataHeight).data\n            };\n        }\n        return {\n            canvas,\n            width,\n            height,\n            imageData\n        };\n    }\n    #scaleBitmap(width, height) {\n        const { width: bitmapWidth, height: bitmapHeight } = this.#bitmap;\n        let newWidth = bitmapWidth;\n        let newHeight = bitmapHeight;\n        let bitmap = this.#bitmap;\n        while(newWidth > 2 * width || newHeight > 2 * height){\n            const prevWidth = newWidth;\n            const prevHeight = newHeight;\n            if (newWidth > 2 * width) {\n                newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);\n            }\n            if (newHeight > 2 * height) {\n                newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);\n            }\n            const offscreen = new OffscreenCanvas(newWidth, newHeight);\n            const ctx = offscreen.getContext(\"2d\");\n            ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);\n            bitmap = offscreen.transferToImageBitmap();\n        }\n        return bitmap;\n    }\n    #drawBitmap() {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const { width, height } = this;\n        const outputScale = new OutputScale();\n        const scaledWidth = Math.ceil(width * parentWidth * outputScale.sx);\n        const scaledHeight = Math.ceil(height * parentHeight * outputScale.sy);\n        const canvas = this.#canvas;\n        if (!canvas || canvas.width === scaledWidth && canvas.height === scaledHeight) {\n            return;\n        }\n        canvas.width = scaledWidth;\n        canvas.height = scaledHeight;\n        const bitmap = this.#isSvg ? this.#bitmap : this.#scaleBitmap(scaledWidth, scaledHeight);\n        const ctx = canvas.getContext(\"2d\");\n        ctx.filter = this._uiManager.hcmFilter;\n        ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);\n    }\n    #serializeBitmap(toUrl) {\n        if (toUrl) {\n            if (this.#isSvg) {\n                const url = this._uiManager.imageManager.getSvgUrl(this.#bitmapId);\n                if (url) {\n                    return url;\n                }\n            }\n            const canvas = document.createElement(\"canvas\");\n            ({ width: canvas.width, height: canvas.height } = this.#bitmap);\n            const ctx = canvas.getContext(\"2d\");\n            ctx.drawImage(this.#bitmap, 0, 0);\n            return canvas.toDataURL();\n        }\n        if (this.#isSvg) {\n            const [pageWidth, pageHeight] = this.pageDimensions;\n            const width = Math.round(this.width * pageWidth * PixelsPerInch.PDF_TO_CSS_UNITS);\n            const height = Math.round(this.height * pageHeight * PixelsPerInch.PDF_TO_CSS_UNITS);\n            const offscreen = new OffscreenCanvas(width, height);\n            const ctx = offscreen.getContext(\"2d\");\n            ctx.drawImage(this.#bitmap, 0, 0, this.#bitmap.width, this.#bitmap.height, 0, 0, width, height);\n            return offscreen.transferToImageBitmap();\n        }\n        return structuredClone(this.#bitmap);\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        let missingCanvas = false;\n        if (data instanceof StampAnnotationElement) {\n            const { data: { rect, rotation, id, structParent, popupRef }, container, parent: { page: { pageNumber } }, canvas } = data;\n            let bitmapId, bitmap;\n            if (canvas) {\n                delete data.canvas;\n                ({ id: bitmapId, bitmap } = uiManager.imageManager.getFromCanvas(container.id, canvas));\n                canvas.remove();\n            } else {\n                missingCanvas = true;\n                data._hasNoCanvas = true;\n            }\n            const altText = (await parent._structTree.getAriaAttributes(`${AnnotationPrefix}${id}`))?.get(\"aria-label\") || \"\";\n            initialData = data = {\n                annotationType: AnnotationEditorType.STAMP,\n                bitmapId,\n                bitmap,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                id,\n                deleted: false,\n                accessibilityData: {\n                    decorative: false,\n                    altText\n                },\n                isSvg: false,\n                structParent,\n                popupRef\n            };\n        }\n        const editor = await super.deserialize(data, parent, uiManager);\n        const { rect, bitmap, bitmapUrl, bitmapId, isSvg, accessibilityData } = data;\n        if (missingCanvas) {\n            uiManager.addMissingCanvas(data.id, editor);\n            editor.#missingCanvas = true;\n        } else if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {\n            editor.#bitmapId = bitmapId;\n            if (bitmap) {\n                editor.#bitmap = bitmap;\n            }\n        } else {\n            editor.#bitmapUrl = bitmapUrl;\n        }\n        editor.#isSvg = isSvg;\n        const [parentWidth, parentHeight] = editor.pageDimensions;\n        editor.width = (rect[2] - rect[0]) / parentWidth;\n        editor.height = (rect[3] - rect[1]) / parentHeight;\n        editor.annotationElementId = data.id || null;\n        if (accessibilityData) {\n            editor.altTextData = accessibilityData;\n        }\n        editor._initialData = initialData;\n        editor.#hasBeenAddedInUndoStack = !!initialData;\n        return editor;\n    }\n    serialize(isForCopying = false, context = null) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const serialized = {\n            annotationType: AnnotationEditorType.STAMP,\n            bitmapId: this.#bitmapId,\n            pageIndex: this.pageIndex,\n            rect: this.getRect(0, 0),\n            rotation: this.rotation,\n            isSvg: this.#isSvg,\n            structTreeParentId: this._structTreeParentId\n        };\n        if (isForCopying) {\n            serialized.bitmapUrl = this.#serializeBitmap(true);\n            serialized.accessibilityData = this.serializeAltText(true);\n            serialized.isCopy = true;\n            return serialized;\n        }\n        const { decorative, altText } = this.serializeAltText(false);\n        if (!decorative && altText) {\n            serialized.accessibilityData = {\n                type: \"Figure\",\n                alt: altText\n            };\n        }\n        if (this.annotationElementId) {\n            const changes = this.#hasElementChanged(serialized);\n            if (changes.isSame) {\n                return null;\n            }\n            if (changes.isSameAltText) {\n                delete serialized.accessibilityData;\n            } else {\n                serialized.accessibilityData.structParent = this._initialData.structParent ?? -1;\n            }\n        }\n        serialized.id = this.annotationElementId;\n        if (context === null) {\n            return serialized;\n        }\n        context.stamps ||= new Map();\n        const area = this.#isSvg ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;\n        if (!context.stamps.has(this.#bitmapId)) {\n            context.stamps.set(this.#bitmapId, {\n                area,\n                serialized\n            });\n            serialized.bitmap = this.#serializeBitmap(false);\n        } else if (this.#isSvg) {\n            const prevData = context.stamps.get(this.#bitmapId);\n            if (area > prevData.area) {\n                prevData.area = area;\n                prevData.serialized.bitmap.close();\n                prevData.serialized.bitmap = this.#serializeBitmap(false);\n            }\n        }\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { pageIndex, accessibilityData: { altText } } = this._initialData;\n        const isSamePageIndex = serialized.pageIndex === pageIndex;\n        const isSameAltText = (serialized.accessibilityData?.alt || \"\") === altText;\n        return {\n            isSame: !this._hasBeenMoved && !this._hasBeenResized && isSamePageIndex && isSameAltText,\n            isSameAltText\n        };\n    }\n    renderAnnotationElement(annotation) {\n        annotation.updateEdited({\n            rect: this.getRect(0, 0)\n        });\n        return null;\n    }\n}\n; // ./src/display/editor/annotation_editor_layer.js\nclass AnnotationEditorLayer {\n    #accessibilityManager;\n    #allowClick;\n    #annotationLayer;\n    #clickAC;\n    #editorFocusTimeoutId;\n    #editors;\n    #hadPointerDown;\n    #isDisabling;\n    #isEnabling;\n    #drawingAC;\n    #focusedElement;\n    #textLayer;\n    #textSelectionAC;\n    #uiManager;\n    static{\n        this._initialized = false;\n    }\n    static #editorTypes = new Map([\n        FreeTextEditor,\n        InkEditor,\n        StampEditor,\n        HighlightEditor,\n        SignatureEditor\n    ].map((type)=>[\n            type._editorType,\n            type\n        ]));\n    constructor({ uiManager, pageIndex, div, structTreeLayer, accessibilityManager, annotationLayer, drawLayer, textLayer, viewport, l10n }){\n        this.#allowClick = false;\n        this.#annotationLayer = null;\n        this.#clickAC = null;\n        this.#editorFocusTimeoutId = null;\n        this.#editors = new Map();\n        this.#hadPointerDown = false;\n        this.#isDisabling = false;\n        this.#isEnabling = false;\n        this.#drawingAC = null;\n        this.#focusedElement = null;\n        this.#textLayer = null;\n        this.#textSelectionAC = null;\n        const editorTypes = [\n            ...AnnotationEditorLayer.#editorTypes.values()\n        ];\n        if (!AnnotationEditorLayer._initialized) {\n            AnnotationEditorLayer._initialized = true;\n            for (const editorType of editorTypes){\n                editorType.initialize(l10n, uiManager);\n            }\n        }\n        uiManager.registerEditorTypes(editorTypes);\n        this.#uiManager = uiManager;\n        this.pageIndex = pageIndex;\n        this.div = div;\n        this.#accessibilityManager = accessibilityManager;\n        this.#annotationLayer = annotationLayer;\n        this.viewport = viewport;\n        this.#textLayer = textLayer;\n        this.drawLayer = drawLayer;\n        this._structTree = structTreeLayer;\n        this.#uiManager.addLayer(this);\n    }\n    get isEmpty() {\n        return this.#editors.size === 0;\n    }\n    get isInvisible() {\n        return this.isEmpty && this.#uiManager.getMode() === AnnotationEditorType.NONE;\n    }\n    updateToolbar(mode) {\n        this.#uiManager.updateToolbar(mode);\n    }\n    updateMode(mode = this.#uiManager.getMode()) {\n        this.#cleanup();\n        switch(mode){\n            case AnnotationEditorType.NONE:\n                this.disableTextSelection();\n                this.togglePointerEvents(false);\n                this.toggleAnnotationLayerPointerEvents(true);\n                this.disableClick();\n                return;\n            case AnnotationEditorType.INK:\n                this.disableTextSelection();\n                this.togglePointerEvents(true);\n                this.enableClick();\n                break;\n            case AnnotationEditorType.HIGHLIGHT:\n                this.enableTextSelection();\n                this.togglePointerEvents(false);\n                this.disableClick();\n                break;\n            default:\n                this.disableTextSelection();\n                this.togglePointerEvents(true);\n                this.enableClick();\n        }\n        this.toggleAnnotationLayerPointerEvents(false);\n        const { classList } = this.div;\n        for (const editorType of AnnotationEditorLayer.#editorTypes.values()){\n            classList.toggle(`${editorType._type}Editing`, mode === editorType._editorType);\n        }\n        this.div.hidden = false;\n    }\n    hasTextLayer(textLayer) {\n        return textLayer === this.#textLayer?.div;\n    }\n    setEditingState(isEditing) {\n        this.#uiManager.setEditingState(isEditing);\n    }\n    addCommands(params) {\n        this.#uiManager.addCommands(params);\n    }\n    cleanUndoStack(type) {\n        this.#uiManager.cleanUndoStack(type);\n    }\n    toggleDrawing(enabled = false) {\n        this.div.classList.toggle(\"drawing\", !enabled);\n    }\n    togglePointerEvents(enabled = false) {\n        this.div.classList.toggle(\"disabled\", !enabled);\n    }\n    toggleAnnotationLayerPointerEvents(enabled = false) {\n        this.#annotationLayer?.div.classList.toggle(\"disabled\", !enabled);\n    }\n    async enable() {\n        this.#isEnabling = true;\n        this.div.tabIndex = 0;\n        this.togglePointerEvents(true);\n        const annotationElementIds = new Set();\n        for (const editor of this.#editors.values()){\n            editor.enableEditing();\n            editor.show(true);\n            if (editor.annotationElementId) {\n                this.#uiManager.removeChangedExistingAnnotation(editor);\n                annotationElementIds.add(editor.annotationElementId);\n            }\n        }\n        if (!this.#annotationLayer) {\n            this.#isEnabling = false;\n            return;\n        }\n        const editables = this.#annotationLayer.getEditableAnnotations();\n        for (const editable of editables){\n            editable.hide();\n            if (this.#uiManager.isDeletedAnnotationElement(editable.data.id)) {\n                continue;\n            }\n            if (annotationElementIds.has(editable.data.id)) {\n                continue;\n            }\n            const editor = await this.deserialize(editable);\n            if (!editor) {\n                continue;\n            }\n            this.addOrRebuild(editor);\n            editor.enableEditing();\n        }\n        this.#isEnabling = false;\n    }\n    disable() {\n        this.#isDisabling = true;\n        this.div.tabIndex = -1;\n        this.togglePointerEvents(false);\n        const changedAnnotations = new Map();\n        const resetAnnotations = new Map();\n        for (const editor of this.#editors.values()){\n            editor.disableEditing();\n            if (!editor.annotationElementId) {\n                continue;\n            }\n            if (editor.serialize() !== null) {\n                changedAnnotations.set(editor.annotationElementId, editor);\n                continue;\n            } else {\n                resetAnnotations.set(editor.annotationElementId, editor);\n            }\n            this.getEditableAnnotation(editor.annotationElementId)?.show();\n            editor.remove();\n        }\n        if (this.#annotationLayer) {\n            const editables = this.#annotationLayer.getEditableAnnotations();\n            for (const editable of editables){\n                const { id } = editable.data;\n                if (this.#uiManager.isDeletedAnnotationElement(id)) {\n                    continue;\n                }\n                let editor = resetAnnotations.get(id);\n                if (editor) {\n                    editor.resetAnnotationElement(editable);\n                    editor.show(false);\n                    editable.show();\n                    continue;\n                }\n                editor = changedAnnotations.get(id);\n                if (editor) {\n                    this.#uiManager.addChangedExistingAnnotation(editor);\n                    if (editor.renderAnnotationElement(editable)) {\n                        editor.show(false);\n                    }\n                }\n                editable.show();\n            }\n        }\n        this.#cleanup();\n        if (this.isEmpty) {\n            this.div.hidden = true;\n        }\n        const { classList } = this.div;\n        for (const editorType of AnnotationEditorLayer.#editorTypes.values()){\n            classList.remove(`${editorType._type}Editing`);\n        }\n        this.disableTextSelection();\n        this.toggleAnnotationLayerPointerEvents(true);\n        this.#isDisabling = false;\n    }\n    getEditableAnnotation(id) {\n        return this.#annotationLayer?.getEditableAnnotation(id) || null;\n    }\n    setActiveEditor(editor) {\n        const currentActive = this.#uiManager.getActive();\n        if (currentActive === editor) {\n            return;\n        }\n        this.#uiManager.setActiveEditor(editor);\n    }\n    enableTextSelection() {\n        this.div.tabIndex = -1;\n        if (this.#textLayer?.div && !this.#textSelectionAC) {\n            this.#textSelectionAC = new AbortController();\n            const signal = this.#uiManager.combinedSignal(this.#textSelectionAC);\n            this.#textLayer.div.addEventListener(\"pointerdown\", this.#textLayerPointerDown.bind(this), {\n                signal\n            });\n            this.#textLayer.div.classList.add(\"highlighting\");\n        }\n    }\n    disableTextSelection() {\n        this.div.tabIndex = 0;\n        if (this.#textLayer?.div && this.#textSelectionAC) {\n            this.#textSelectionAC.abort();\n            this.#textSelectionAC = null;\n            this.#textLayer.div.classList.remove(\"highlighting\");\n        }\n    }\n    #textLayerPointerDown(event) {\n        this.#uiManager.unselectAll();\n        const { target } = event;\n        if (target === this.#textLayer.div || (target.getAttribute(\"role\") === \"img\" || target.classList.contains(\"endOfContent\")) && this.#textLayer.div.contains(target)) {\n            const { isMac } = util_FeatureTest.platform;\n            if (event.button !== 0 || event.ctrlKey && isMac) {\n                return;\n            }\n            this.#uiManager.showAllEditors(\"highlight\", true, true);\n            this.#textLayer.div.classList.add(\"free\");\n            this.toggleDrawing();\n            HighlightEditor.startHighlighting(this, this.#uiManager.direction === \"ltr\", {\n                target: this.#textLayer.div,\n                x: event.x,\n                y: event.y\n            });\n            this.#textLayer.div.addEventListener(\"pointerup\", ()=>{\n                this.#textLayer.div.classList.remove(\"free\");\n                this.toggleDrawing(true);\n            }, {\n                once: true,\n                signal: this.#uiManager._signal\n            });\n            event.preventDefault();\n        }\n    }\n    enableClick() {\n        if (this.#clickAC) {\n            return;\n        }\n        this.#clickAC = new AbortController();\n        const signal = this.#uiManager.combinedSignal(this.#clickAC);\n        this.div.addEventListener(\"pointerdown\", this.pointerdown.bind(this), {\n            signal\n        });\n        const pointerup = this.pointerup.bind(this);\n        this.div.addEventListener(\"pointerup\", pointerup, {\n            signal\n        });\n        this.div.addEventListener(\"pointercancel\", pointerup, {\n            signal\n        });\n    }\n    disableClick() {\n        this.#clickAC?.abort();\n        this.#clickAC = null;\n    }\n    attach(editor) {\n        this.#editors.set(editor.id, editor);\n        const { annotationElementId } = editor;\n        if (annotationElementId && this.#uiManager.isDeletedAnnotationElement(annotationElementId)) {\n            this.#uiManager.removeDeletedAnnotationElement(editor);\n        }\n    }\n    detach(editor) {\n        this.#editors.delete(editor.id);\n        this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n        if (!this.#isDisabling && editor.annotationElementId) {\n            this.#uiManager.addDeletedAnnotationElement(editor);\n        }\n    }\n    remove(editor) {\n        this.detach(editor);\n        this.#uiManager.removeEditor(editor);\n        editor.div.remove();\n        editor.isAttachedToDOM = false;\n    }\n    changeParent(editor) {\n        if (editor.parent === this) {\n            return;\n        }\n        if (editor.parent && editor.annotationElementId) {\n            this.#uiManager.addDeletedAnnotationElement(editor.annotationElementId);\n            AnnotationEditor.deleteAnnotationElement(editor);\n            editor.annotationElementId = null;\n        }\n        this.attach(editor);\n        editor.parent?.detach(editor);\n        editor.setParent(this);\n        if (editor.div && editor.isAttachedToDOM) {\n            editor.div.remove();\n            this.div.append(editor.div);\n        }\n    }\n    add(editor) {\n        if (editor.parent === this && editor.isAttachedToDOM) {\n            return;\n        }\n        this.changeParent(editor);\n        this.#uiManager.addEditor(editor);\n        this.attach(editor);\n        if (!editor.isAttachedToDOM) {\n            const div = editor.render();\n            this.div.append(div);\n            editor.isAttachedToDOM = true;\n        }\n        editor.fixAndSetPosition();\n        editor.onceAdded(!this.#isEnabling);\n        this.#uiManager.addToAnnotationStorage(editor);\n        editor._reportTelemetry(editor.telemetryInitialData);\n    }\n    moveEditorInDOM(editor) {\n        if (!editor.isAttachedToDOM) {\n            return;\n        }\n        const { activeElement } = document;\n        if (editor.div.contains(activeElement) && !this.#editorFocusTimeoutId) {\n            editor._focusEventsAllowed = false;\n            this.#editorFocusTimeoutId = setTimeout(()=>{\n                this.#editorFocusTimeoutId = null;\n                if (!editor.div.contains(document.activeElement)) {\n                    editor.div.addEventListener(\"focusin\", ()=>{\n                        editor._focusEventsAllowed = true;\n                    }, {\n                        once: true,\n                        signal: this.#uiManager._signal\n                    });\n                    activeElement.focus();\n                } else {\n                    editor._focusEventsAllowed = true;\n                }\n            }, 0);\n        }\n        editor._structTreeParentId = this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);\n    }\n    addOrRebuild(editor) {\n        if (editor.needsToBeRebuilt()) {\n            editor.parent ||= this;\n            editor.rebuild();\n            editor.show();\n        } else {\n            this.add(editor);\n        }\n    }\n    addUndoableEditor(editor) {\n        const cmd = ()=>editor._uiManager.rebuild(editor);\n        const undo = ()=>{\n            editor.remove();\n        };\n        this.addCommands({\n            cmd,\n            undo,\n            mustExec: false\n        });\n    }\n    getNextId() {\n        return this.#uiManager.getId();\n    }\n    get #currentEditorType() {\n        return AnnotationEditorLayer.#editorTypes.get(this.#uiManager.getMode());\n    }\n    combinedSignal(ac) {\n        return this.#uiManager.combinedSignal(ac);\n    }\n    #createNewEditor(params) {\n        const editorType = this.#currentEditorType;\n        return editorType ? new editorType.prototype.constructor(params) : null;\n    }\n    canCreateNewEmptyEditor() {\n        return this.#currentEditorType?.canCreateNewEmptyEditor();\n    }\n    async pasteEditor(mode, params) {\n        this.#uiManager.updateToolbar(mode);\n        await this.#uiManager.updateMode(mode);\n        const { offsetX, offsetY } = this.#getCenterPoint();\n        const id = this.getNextId();\n        const editor = this.#createNewEditor({\n            parent: this,\n            id,\n            x: offsetX,\n            y: offsetY,\n            uiManager: this.#uiManager,\n            isCentered: true,\n            ...params\n        });\n        if (editor) {\n            this.add(editor);\n        }\n    }\n    async deserialize(data) {\n        return await AnnotationEditorLayer.#editorTypes.get(data.annotationType ?? data.annotationEditorType)?.deserialize(data, this, this.#uiManager) || null;\n    }\n    createAndAddNewEditor(event, isCentered, data = {}) {\n        const id = this.getNextId();\n        const editor = this.#createNewEditor({\n            parent: this,\n            id,\n            x: event.offsetX,\n            y: event.offsetY,\n            uiManager: this.#uiManager,\n            isCentered,\n            ...data\n        });\n        if (editor) {\n            this.add(editor);\n        }\n        return editor;\n    }\n    #getCenterPoint() {\n        const { x, y, width, height } = this.div.getBoundingClientRect();\n        const tlX = Math.max(0, x);\n        const tlY = Math.max(0, y);\n        const brX = Math.min(window.innerWidth, x + width);\n        const brY = Math.min(window.innerHeight, y + height);\n        const centerX = (tlX + brX) / 2 - x;\n        const centerY = (tlY + brY) / 2 - y;\n        const [offsetX, offsetY] = this.viewport.rotation % 180 === 0 ? [\n            centerX,\n            centerY\n        ] : [\n            centerY,\n            centerX\n        ];\n        return {\n            offsetX,\n            offsetY\n        };\n    }\n    addNewEditor(data = {}) {\n        this.createAndAddNewEditor(this.#getCenterPoint(), true, data);\n    }\n    setSelected(editor) {\n        this.#uiManager.setSelected(editor);\n    }\n    toggleSelected(editor) {\n        this.#uiManager.toggleSelected(editor);\n    }\n    unselect(editor) {\n        this.#uiManager.unselect(editor);\n    }\n    pointerup(event) {\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            return;\n        }\n        if (event.target !== this.div) {\n            return;\n        }\n        if (!this.#hadPointerDown) {\n            return;\n        }\n        this.#hadPointerDown = false;\n        if (this.#currentEditorType?.isDrawer && this.#currentEditorType.supportMultipleDrawings) {\n            return;\n        }\n        if (!this.#allowClick) {\n            this.#allowClick = true;\n            return;\n        }\n        const currentMode = this.#uiManager.getMode();\n        if (currentMode === AnnotationEditorType.STAMP || currentMode === AnnotationEditorType.SIGNATURE) {\n            this.#uiManager.unselectAll();\n            return;\n        }\n        this.createAndAddNewEditor(event, false);\n    }\n    pointerdown(event) {\n        if (this.#uiManager.getMode() === AnnotationEditorType.HIGHLIGHT) {\n            this.enableTextSelection();\n        }\n        if (this.#hadPointerDown) {\n            this.#hadPointerDown = false;\n            return;\n        }\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            return;\n        }\n        if (event.target !== this.div) {\n            return;\n        }\n        this.#hadPointerDown = true;\n        if (this.#currentEditorType?.isDrawer) {\n            this.startDrawingSession(event);\n            return;\n        }\n        const editor = this.#uiManager.getActive();\n        this.#allowClick = !editor || editor.isEmpty();\n    }\n    startDrawingSession(event) {\n        this.div.focus({\n            preventScroll: true\n        });\n        if (this.#drawingAC) {\n            this.#currentEditorType.startDrawing(this, this.#uiManager, false, event);\n            return;\n        }\n        this.#uiManager.setCurrentDrawingSession(this);\n        this.#drawingAC = new AbortController();\n        const signal = this.#uiManager.combinedSignal(this.#drawingAC);\n        this.div.addEventListener(\"blur\", ({ relatedTarget })=>{\n            if (relatedTarget && !this.div.contains(relatedTarget)) {\n                this.#focusedElement = null;\n                this.commitOrRemove();\n            }\n        }, {\n            signal\n        });\n        this.#currentEditorType.startDrawing(this, this.#uiManager, false, event);\n    }\n    pause(on) {\n        if (on) {\n            const { activeElement } = document;\n            if (this.div.contains(activeElement)) {\n                this.#focusedElement = activeElement;\n            }\n            return;\n        }\n        if (this.#focusedElement) {\n            setTimeout(()=>{\n                this.#focusedElement?.focus();\n                this.#focusedElement = null;\n            }, 0);\n        }\n    }\n    endDrawingSession(isAborted = false) {\n        if (!this.#drawingAC) {\n            return null;\n        }\n        this.#uiManager.setCurrentDrawingSession(null);\n        this.#drawingAC.abort();\n        this.#drawingAC = null;\n        this.#focusedElement = null;\n        return this.#currentEditorType.endDrawing(isAborted);\n    }\n    findNewParent(editor, x, y) {\n        const layer = this.#uiManager.findParent(x, y);\n        if (layer === null || layer === this) {\n            return false;\n        }\n        layer.changeParent(editor);\n        return true;\n    }\n    commitOrRemove() {\n        if (this.#drawingAC) {\n            this.endDrawingSession();\n            return true;\n        }\n        return false;\n    }\n    onScaleChanging() {\n        if (!this.#drawingAC) {\n            return;\n        }\n        this.#currentEditorType.onScaleChangingWhenDrawing(this);\n    }\n    destroy() {\n        this.commitOrRemove();\n        if (this.#uiManager.getActive()?.parent === this) {\n            this.#uiManager.commitOrRemove();\n            this.#uiManager.setActiveEditor(null);\n        }\n        if (this.#editorFocusTimeoutId) {\n            clearTimeout(this.#editorFocusTimeoutId);\n            this.#editorFocusTimeoutId = null;\n        }\n        for (const editor of this.#editors.values()){\n            this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n            editor.setParent(null);\n            editor.isAttachedToDOM = false;\n            editor.div.remove();\n        }\n        this.div = null;\n        this.#editors.clear();\n        this.#uiManager.removeLayer(this);\n    }\n    #cleanup() {\n        for (const editor of this.#editors.values()){\n            if (editor.isEmpty()) {\n                editor.remove();\n            }\n        }\n    }\n    render({ viewport }) {\n        this.viewport = viewport;\n        setLayerDimensions(this.div, viewport);\n        for (const editor of this.#uiManager.getEditors(this.pageIndex)){\n            this.add(editor);\n            editor.rebuild();\n        }\n        this.updateMode();\n    }\n    update({ viewport }) {\n        this.#uiManager.commitOrRemove();\n        this.#cleanup();\n        const oldRotation = this.viewport.rotation;\n        const rotation = viewport.rotation;\n        this.viewport = viewport;\n        setLayerDimensions(this.div, {\n            rotation\n        });\n        if (oldRotation !== rotation) {\n            for (const editor of this.#editors.values()){\n                editor.rotate(rotation);\n            }\n        }\n    }\n    get pageDimensions() {\n        const { pageWidth, pageHeight } = this.viewport.rawDims;\n        return [\n            pageWidth,\n            pageHeight\n        ];\n    }\n    get scale() {\n        return this.#uiManager.viewParameters.realScale;\n    }\n}\n; // ./src/display/draw_layer.js\nclass DrawLayer {\n    #parent;\n    #mapping;\n    #toUpdate;\n    static #id = 0;\n    constructor({ pageIndex }){\n        this.#parent = null;\n        this.#mapping = new Map();\n        this.#toUpdate = new Map();\n        this.pageIndex = pageIndex;\n    }\n    setParent(parent) {\n        if (!this.#parent) {\n            this.#parent = parent;\n            return;\n        }\n        if (this.#parent !== parent) {\n            if (this.#mapping.size > 0) {\n                for (const root of this.#mapping.values()){\n                    root.remove();\n                    parent.append(root);\n                }\n            }\n            this.#parent = parent;\n        }\n    }\n    static get _svgFactory() {\n        return shadow(this, \"_svgFactory\", new DOMSVGFactory());\n    }\n    static #setBox(element, [x, y, width, height]) {\n        const { style } = element;\n        style.top = `${100 * y}%`;\n        style.left = `${100 * x}%`;\n        style.width = `${100 * width}%`;\n        style.height = `${100 * height}%`;\n    }\n    #createSVG() {\n        const svg = DrawLayer._svgFactory.create(1, 1, true);\n        this.#parent.append(svg);\n        svg.setAttribute(\"aria-hidden\", true);\n        return svg;\n    }\n    #createClipPath(defs, pathId) {\n        const clipPath = DrawLayer._svgFactory.createElement(\"clipPath\");\n        defs.append(clipPath);\n        const clipPathId = `clip_${pathId}`;\n        clipPath.setAttribute(\"id\", clipPathId);\n        clipPath.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n        const clipPathUse = DrawLayer._svgFactory.createElement(\"use\");\n        clipPath.append(clipPathUse);\n        clipPathUse.setAttribute(\"href\", `#${pathId}`);\n        clipPathUse.classList.add(\"clip\");\n        return clipPathId;\n    }\n    #updateProperties(element, properties) {\n        for (const [key, value] of Object.entries(properties)){\n            if (value === null) {\n                element.removeAttribute(key);\n            } else {\n                element.setAttribute(key, value);\n            }\n        }\n    }\n    draw(properties, isPathUpdatable = false, hasClip = false) {\n        const id = DrawLayer.#id++;\n        const root = this.#createSVG();\n        const defs = DrawLayer._svgFactory.createElement(\"defs\");\n        root.append(defs);\n        const path = DrawLayer._svgFactory.createElement(\"path\");\n        defs.append(path);\n        const pathId = `path_p${this.pageIndex}_${id}`;\n        path.setAttribute(\"id\", pathId);\n        path.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\n        if (isPathUpdatable) {\n            this.#toUpdate.set(id, path);\n        }\n        const clipPathId = hasClip ? this.#createClipPath(defs, pathId) : null;\n        const use = DrawLayer._svgFactory.createElement(\"use\");\n        root.append(use);\n        use.setAttribute(\"href\", `#${pathId}`);\n        this.updateProperties(root, properties);\n        this.#mapping.set(id, root);\n        return {\n            id,\n            clipPathId: `url(#${clipPathId})`\n        };\n    }\n    drawOutline(properties, mustRemoveSelfIntersections) {\n        const id = DrawLayer.#id++;\n        const root = this.#createSVG();\n        const defs = DrawLayer._svgFactory.createElement(\"defs\");\n        root.append(defs);\n        const path = DrawLayer._svgFactory.createElement(\"path\");\n        defs.append(path);\n        const pathId = `path_p${this.pageIndex}_${id}`;\n        path.setAttribute(\"id\", pathId);\n        path.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\n        let maskId;\n        if (mustRemoveSelfIntersections) {\n            const mask = DrawLayer._svgFactory.createElement(\"mask\");\n            defs.append(mask);\n            maskId = `mask_p${this.pageIndex}_${id}`;\n            mask.setAttribute(\"id\", maskId);\n            mask.setAttribute(\"maskUnits\", \"objectBoundingBox\");\n            const rect = DrawLayer._svgFactory.createElement(\"rect\");\n            mask.append(rect);\n            rect.setAttribute(\"width\", \"1\");\n            rect.setAttribute(\"height\", \"1\");\n            rect.setAttribute(\"fill\", \"white\");\n            const use = DrawLayer._svgFactory.createElement(\"use\");\n            mask.append(use);\n            use.setAttribute(\"href\", `#${pathId}`);\n            use.setAttribute(\"stroke\", \"none\");\n            use.setAttribute(\"fill\", \"black\");\n            use.setAttribute(\"fill-rule\", \"nonzero\");\n            use.classList.add(\"mask\");\n        }\n        const use1 = DrawLayer._svgFactory.createElement(\"use\");\n        root.append(use1);\n        use1.setAttribute(\"href\", `#${pathId}`);\n        if (maskId) {\n            use1.setAttribute(\"mask\", `url(#${maskId})`);\n        }\n        const use2 = use1.cloneNode();\n        root.append(use2);\n        use1.classList.add(\"mainOutline\");\n        use2.classList.add(\"secondaryOutline\");\n        this.updateProperties(root, properties);\n        this.#mapping.set(id, root);\n        return id;\n    }\n    finalizeDraw(id, properties) {\n        this.#toUpdate.delete(id);\n        this.updateProperties(id, properties);\n    }\n    updateProperties(elementOrId, properties) {\n        if (!properties) {\n            return;\n        }\n        const { root, bbox, rootClass, path } = properties;\n        const element = typeof elementOrId === \"number\" ? this.#mapping.get(elementOrId) : elementOrId;\n        if (!element) {\n            return;\n        }\n        if (root) {\n            this.#updateProperties(element, root);\n        }\n        if (bbox) {\n            DrawLayer.#setBox(element, bbox);\n        }\n        if (rootClass) {\n            const { classList } = element;\n            for (const [className, value] of Object.entries(rootClass)){\n                classList.toggle(className, value);\n            }\n        }\n        if (path) {\n            const defs = element.firstChild;\n            const pathElement = defs.firstChild;\n            this.#updateProperties(pathElement, path);\n        }\n    }\n    updateParent(id, layer) {\n        if (layer === this) {\n            return;\n        }\n        const root = this.#mapping.get(id);\n        if (!root) {\n            return;\n        }\n        layer.#parent.append(root);\n        this.#mapping.delete(id);\n        layer.#mapping.set(id, root);\n    }\n    remove(id) {\n        this.#toUpdate.delete(id);\n        if (this.#parent === null) {\n            return;\n        }\n        this.#mapping.get(id).remove();\n        this.#mapping.delete(id);\n    }\n    destroy() {\n        this.#parent = null;\n        for (const root of this.#mapping.values()){\n            root.remove();\n        }\n        this.#mapping.clear();\n        this.#toUpdate.clear();\n    }\n}\n; // ./src/pdf.js\nconst pdfjsVersion = \"5.2.133\";\nconst pdfjsBuild = \"4f7761353\";\n{\n    globalThis.pdfjsTestingUtils = {\n        HighlightOutliner: HighlightOutliner\n    };\n}globalThis.pdfjsLib = {\n    AbortException: AbortException,\n    AnnotationEditorLayer: AnnotationEditorLayer,\n    AnnotationEditorParamsType: AnnotationEditorParamsType,\n    AnnotationEditorType: AnnotationEditorType,\n    AnnotationEditorUIManager: AnnotationEditorUIManager,\n    AnnotationLayer: AnnotationLayer,\n    AnnotationMode: AnnotationMode,\n    AnnotationType: AnnotationType,\n    build: build,\n    ColorPicker: ColorPicker,\n    createValidAbsoluteUrl: createValidAbsoluteUrl,\n    DOMSVGFactory: DOMSVGFactory,\n    DrawLayer: DrawLayer,\n    FeatureTest: util_FeatureTest,\n    fetchData: fetchData,\n    getDocument: getDocument,\n    getFilenameFromUrl: getFilenameFromUrl,\n    getPdfFilenameFromUrl: getPdfFilenameFromUrl,\n    getUuid: getUuid,\n    getXfaPageViewport: getXfaPageViewport,\n    GlobalWorkerOptions: GlobalWorkerOptions,\n    ImageKind: util_ImageKind,\n    InvalidPDFException: InvalidPDFException,\n    isDataScheme: isDataScheme,\n    isPdfFile: isPdfFile,\n    isValidExplicitDest: isValidExplicitDest,\n    MathClamp: MathClamp,\n    noContextMenu: noContextMenu,\n    normalizeUnicode: normalizeUnicode,\n    OPS: OPS,\n    OutputScale: OutputScale,\n    PasswordResponses: PasswordResponses,\n    PDFDataRangeTransport: PDFDataRangeTransport,\n    PDFDateString: PDFDateString,\n    PDFWorker: PDFWorker,\n    PermissionFlag: PermissionFlag,\n    PixelsPerInch: PixelsPerInch,\n    RenderingCancelledException: RenderingCancelledException,\n    ResponseException: ResponseException,\n    setLayerDimensions: setLayerDimensions,\n    shadow: shadow,\n    SignatureExtractor: SignatureExtractor,\n    stopEvent: stopEvent,\n    SupportedImageMimeTypes: SupportedImageMimeTypes,\n    TextLayer: TextLayer,\n    TouchManager: TouchManager,\n    updateUrlHash: updateUrlHash,\n    Util: Util,\n    VerbosityLevel: VerbosityLevel,\n    version: version,\n    XfaLayer: XfaLayer\n};\n //# sourceMappingURL=pdf.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGRmanMtZGlzdC9idWlsZC9wZGYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQXVCQyx1QkFBdUI7QUFDeEIsTUFBTUEsV0FBVyxPQUFPQyxZQUFZLFlBQVlBLFVBQVUsT0FBTyxzQkFBc0IsQ0FBQ0EsUUFBUUMsUUFBUSxDQUFDQyxFQUFFLElBQUksQ0FBRUYsQ0FBQUEsUUFBUUMsUUFBUSxDQUFDRSxRQUFRLElBQUlILFFBQVFJLElBQUksSUFBSUosUUFBUUksSUFBSSxLQUFLLFNBQVE7QUFDdkwsTUFBTUMsdUJBQXVCO0lBQUM7SUFBTztJQUFHO0lBQUc7SUFBTztJQUFHO0NBQUU7QUFDdkQsTUFBTUMsY0FBYztBQUNwQixNQUFNQyxzQkFBc0I7QUFDNUIsTUFBTUMsa0JBQWtCRCxzQkFBc0JEO0FBQzlDLE1BQU1HLHNCQUFzQjtJQUMxQkMsS0FBSztJQUNMQyxTQUFTO0lBQ1RDLE9BQU87SUFDUEMsTUFBTTtJQUNOQyxtQkFBbUI7SUFDbkJDLHFCQUFxQjtJQUNyQkMscUJBQXFCO0lBQ3JCQyxZQUFZO0lBQ1pDLFFBQVE7QUFDVjtBQUNBLE1BQU1DLGlCQUFpQjtJQUNyQkMsU0FBUztJQUNUQyxRQUFRO0lBQ1JDLGNBQWM7SUFDZEMsZ0JBQWdCO0FBQ2xCO0FBQ0EsTUFBTUMseUJBQXlCO0FBQy9CLE1BQU1DLHVCQUF1QjtJQUMzQkwsU0FBUyxDQUFDO0lBQ1ZNLE1BQU07SUFDTkMsVUFBVTtJQUNWQyxXQUFXO0lBQ1hDLE9BQU87SUFDUEMsS0FBSztJQUNMQyxXQUFXO0FBQ2I7QUFDQSxNQUFNQyw2QkFBNkI7SUFDakNDLFFBQVE7SUFDUkMsUUFBUTtJQUNSQyxlQUFlO0lBQ2ZDLGdCQUFnQjtJQUNoQkMsa0JBQWtCO0lBQ2xCQyxXQUFXO0lBQ1hDLGVBQWU7SUFDZkMsYUFBYTtJQUNiQyxpQkFBaUI7SUFDakJDLHlCQUF5QjtJQUN6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QXFCQTtJQUNyQjVXLFdBQVd4MEQ7SUFDWG1QLHFCQUFxQkE7SUFDckJvUixjQUFjQTtJQUNkSSxXQUFXQTtJQUNYNGdFLHFCQUFxQkE7SUFDckI3bEUsV0FBV0E7SUFDWHlHLGVBQWVBO0lBQ2ZoSSxrQkFBa0JBO0lBQ2xCelUsS0FBS0E7SUFDTHFnQixhQUFhQTtJQUNieGEsbUJBQW1CQTtJQUNuQnl5RSx1QkFBdUJBO0lBQ3ZCdjdELGVBQWVBO0lBQ2Z5N0QsV0FBV0E7SUFDWHIvRSxnQkFBZ0JBO0lBQ2hCaWUsZUFBZUE7SUFDZnVELDZCQUE2QkE7SUFDN0JqUixtQkFBbUJBO0lBQ25CZ1csb0JBQW9CQTtJQUNwQnJYLFFBQVFBO0lBQ1JzdEcsb0JBQW9CQTtJQUNwQi80RixXQUFXQTtJQUNYd0UseUJBQXlCQTtJQUN6QnF5RCxXQUFXQTtJQUNYMXhDLGNBQWNBO0lBQ2RoNkIsZUFBZUE7SUFDZnNGLE1BQU1BO0lBQ056TixnQkFBZ0JBO0lBQ2hCa3BGLFNBQVNBO0lBQ1R5QixVQUFVQTtBQUNaO0FBRWkyQixDQUVqMkIsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHNhLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3BkZmpzLWRpc3QvYnVpbGQvcGRmLm1qcz84M2UyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY3N0YXJ0IFRoZSBmb2xsb3dpbmcgaXMgdGhlIGVudGlyZSBsaWNlbnNlIG5vdGljZSBmb3IgdGhlXG4gKiBKYXZhU2NyaXB0IGNvZGUgaW4gdGhpcyBwYWdlXG4gKlxuICogQ29weXJpZ2h0IDIwMjQgTW96aWxsYSBGb3VuZGF0aW9uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBsaWNlbmQgVGhlIGFib3ZlIGlzIHRoZSBlbnRpcmUgbGljZW5zZSBub3RpY2UgZm9yIHRoZVxuICogSmF2YVNjcmlwdCBjb2RlIGluIHRoaXMgcGFnZVxuICovXG5cblxuOy8vIC4vc3JjL3NoYXJlZC91dGlsLmpzXG5jb25zdCBpc05vZGVKUyA9IHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MgKyBcIlwiID09PSBcIltvYmplY3QgcHJvY2Vzc11cIiAmJiAhcHJvY2Vzcy52ZXJzaW9ucy5udyAmJiAhKHByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb24gJiYgcHJvY2Vzcy50eXBlICYmIHByb2Nlc3MudHlwZSAhPT0gXCJicm93c2VyXCIpO1xuY29uc3QgRk9OVF9JREVOVElUWV9NQVRSSVggPSBbMC4wMDEsIDAsIDAsIDAuMDAxLCAwLCAwXTtcbmNvbnN0IExJTkVfRkFDVE9SID0gMS4zNTtcbmNvbnN0IExJTkVfREVTQ0VOVF9GQUNUT1IgPSAwLjM1O1xuY29uc3QgQkFTRUxJTkVfRkFDVE9SID0gTElORV9ERVNDRU5UX0ZBQ1RPUiAvIExJTkVfRkFDVE9SO1xuY29uc3QgUmVuZGVyaW5nSW50ZW50RmxhZyA9IHtcbiAgQU5ZOiAweDAxLFxuICBESVNQTEFZOiAweDAyLFxuICBQUklOVDogMHgwNCxcbiAgU0FWRTogMHgwOCxcbiAgQU5OT1RBVElPTlNfRk9STVM6IDB4MTAsXG4gIEFOTk9UQVRJT05TX1NUT1JBR0U6IDB4MjAsXG4gIEFOTk9UQVRJT05TX0RJU0FCTEU6IDB4NDAsXG4gIElTX0VESVRJTkc6IDB4ODAsXG4gIE9QTElTVDogMHgxMDBcbn07XG5jb25zdCBBbm5vdGF0aW9uTW9kZSA9IHtcbiAgRElTQUJMRTogMCxcbiAgRU5BQkxFOiAxLFxuICBFTkFCTEVfRk9STVM6IDIsXG4gIEVOQUJMRV9TVE9SQUdFOiAzXG59O1xuY29uc3QgQW5ub3RhdGlvbkVkaXRvclByZWZpeCA9IFwicGRmanNfaW50ZXJuYWxfZWRpdG9yX1wiO1xuY29uc3QgQW5ub3RhdGlvbkVkaXRvclR5cGUgPSB7XG4gIERJU0FCTEU6IC0xLFxuICBOT05FOiAwLFxuICBGUkVFVEVYVDogMyxcbiAgSElHSExJR0hUOiA5LFxuICBTVEFNUDogMTMsXG4gIElOSzogMTUsXG4gIFNJR05BVFVSRTogMTAxXG59O1xuY29uc3QgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUgPSB7XG4gIFJFU0laRTogMSxcbiAgQ1JFQVRFOiAyLFxuICBGUkVFVEVYVF9TSVpFOiAxMSxcbiAgRlJFRVRFWFRfQ09MT1I6IDEyLFxuICBGUkVFVEVYVF9PUEFDSVRZOiAxMyxcbiAgSU5LX0NPTE9SOiAyMSxcbiAgSU5LX1RISUNLTkVTUzogMjIsXG4gIElOS19PUEFDSVRZOiAyMyxcbiAgSElHSExJR0hUX0NPTE9SOiAzMSxcbiAgSElHSExJR0hUX0RFRkFVTFRfQ09MT1I6IDMyLFxuICBISUdITElHSFRfVEhJQ0tORVNTOiAzMyxcbiAgSElHSExJR0hUX0ZSRUU6IDM0LFxuICBISUdITElHSFRfU0hPV19BTEw6IDM1LFxuICBEUkFXX1NURVA6IDQxXG59O1xuY29uc3QgUGVybWlzc2lvbkZsYWcgPSB7XG4gIFBSSU5UOiAweDA0LFxuICBNT0RJRllfQ09OVEVOVFM6IDB4MDgsXG4gIENPUFk6IDB4MTAsXG4gIE1PRElGWV9BTk5PVEFUSU9OUzogMHgyMCxcbiAgRklMTF9JTlRFUkFDVElWRV9GT1JNUzogMHgxMDAsXG4gIENPUFlfRk9SX0FDQ0VTU0lCSUxJVFk6IDB4MjAwLFxuICBBU1NFTUJMRTogMHg0MDAsXG4gIFBSSU5UX0hJR0hfUVVBTElUWTogMHg4MDBcbn07XG5jb25zdCBUZXh0UmVuZGVyaW5nTW9kZSA9IHtcbiAgRklMTDogMCxcbiAgU1RST0tFOiAxLFxuICBGSUxMX1NUUk9LRTogMixcbiAgSU5WSVNJQkxFOiAzLFxuICBGSUxMX0FERF9UT19QQVRIOiA0LFxuICBTVFJPS0VfQUREX1RPX1BBVEg6IDUsXG4gIEZJTExfU1RST0tFX0FERF9UT19QQVRIOiA2LFxuICBBRERfVE9fUEFUSDogNyxcbiAgRklMTF9TVFJPS0VfTUFTSzogMyxcbiAgQUREX1RPX1BBVEhfRkxBRzogNFxufTtcbmNvbnN0IHV0aWxfSW1hZ2VLaW5kID0ge1xuICBHUkFZU0NBTEVfMUJQUDogMSxcbiAgUkdCXzI0QlBQOiAyLFxuICBSR0JBXzMyQlBQOiAzXG59O1xuY29uc3QgQW5ub3RhdGlvblR5cGUgPSB7XG4gIFRFWFQ6IDEsXG4gIExJTks6IDIsXG4gIEZSRUVURVhUOiAzLFxuICBMSU5FOiA0LFxuICBTUVVBUkU6IDUsXG4gIENJUkNMRTogNixcbiAgUE9MWUdPTjogNyxcbiAgUE9MWUxJTkU6IDgsXG4gIEhJR0hMSUdIVDogOSxcbiAgVU5ERVJMSU5FOiAxMCxcbiAgU1FVSUdHTFk6IDExLFxuICBTVFJJS0VPVVQ6IDEyLFxuICBTVEFNUDogMTMsXG4gIENBUkVUOiAxNCxcbiAgSU5LOiAxNSxcbiAgUE9QVVA6IDE2LFxuICBGSUxFQVRUQUNITUVOVDogMTcsXG4gIFNPVU5EOiAxOCxcbiAgTU9WSUU6IDE5LFxuICBXSURHRVQ6IDIwLFxuICBTQ1JFRU46IDIxLFxuICBQUklOVEVSTUFSSzogMjIsXG4gIFRSQVBORVQ6IDIzLFxuICBXQVRFUk1BUks6IDI0LFxuICBUSFJFRUQ6IDI1LFxuICBSRURBQ1Q6IDI2XG59O1xuY29uc3QgQW5ub3RhdGlvblJlcGx5VHlwZSA9IHtcbiAgR1JPVVA6IFwiR3JvdXBcIixcbiAgUkVQTFk6IFwiUlwiXG59O1xuY29uc3QgQW5ub3RhdGlvbkZsYWcgPSB7XG4gIElOVklTSUJMRTogMHgwMSxcbiAgSElEREVOOiAweDAyLFxuICBQUklOVDogMHgwNCxcbiAgTk9aT09NOiAweDA4LFxuICBOT1JPVEFURTogMHgxMCxcbiAgTk9WSUVXOiAweDIwLFxuICBSRUFET05MWTogMHg0MCxcbiAgTE9DS0VEOiAweDgwLFxuICBUT0dHTEVOT1ZJRVc6IDB4MTAwLFxuICBMT0NLRURDT05URU5UUzogMHgyMDBcbn07XG5jb25zdCBBbm5vdGF0aW9uRmllbGRGbGFnID0ge1xuICBSRUFET05MWTogMHgwMDAwMDAxLFxuICBSRVFVSVJFRDogMHgwMDAwMDAyLFxuICBOT0VYUE9SVDogMHgwMDAwMDA0LFxuICBNVUxUSUxJTkU6IDB4MDAwMTAwMCxcbiAgUEFTU1dPUkQ6IDB4MDAwMjAwMCxcbiAgTk9UT0dHTEVUT09GRjogMHgwMDA0MDAwLFxuICBSQURJTzogMHgwMDA4MDAwLFxuICBQVVNIQlVUVE9OOiAweDAwMTAwMDAsXG4gIENPTUJPOiAweDAwMjAwMDAsXG4gIEVESVQ6IDB4MDA0MDAwMCxcbiAgU09SVDogMHgwMDgwMDAwLFxuICBGSUxFU0VMRUNUOiAweDAxMDAwMDAsXG4gIE1VTFRJU0VMRUNUOiAweDAyMDAwMDAsXG4gIERPTk9UU1BFTExDSEVDSzogMHgwNDAwMDAwLFxuICBET05PVFNDUk9MTDogMHgwODAwMDAwLFxuICBDT01COiAweDEwMDAwMDAsXG4gIFJJQ0hURVhUOiAweDIwMDAwMDAsXG4gIFJBRElPU0lOVU5JU09OOiAweDIwMDAwMDAsXG4gIENPTU1JVE9OU0VMQ0hBTkdFOiAweDQwMDAwMDBcbn07XG5jb25zdCBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlID0ge1xuICBTT0xJRDogMSxcbiAgREFTSEVEOiAyLFxuICBCRVZFTEVEOiAzLFxuICBJTlNFVDogNCxcbiAgVU5ERVJMSU5FOiA1XG59O1xuY29uc3QgQW5ub3RhdGlvbkFjdGlvbkV2ZW50VHlwZSA9IHtcbiAgRTogXCJNb3VzZSBFbnRlclwiLFxuICBYOiBcIk1vdXNlIEV4aXRcIixcbiAgRDogXCJNb3VzZSBEb3duXCIsXG4gIFU6IFwiTW91c2UgVXBcIixcbiAgRm86IFwiRm9jdXNcIixcbiAgQmw6IFwiQmx1clwiLFxuICBQTzogXCJQYWdlT3BlblwiLFxuICBQQzogXCJQYWdlQ2xvc2VcIixcbiAgUFY6IFwiUGFnZVZpc2libGVcIixcbiAgUEk6IFwiUGFnZUludmlzaWJsZVwiLFxuICBLOiBcIktleXN0cm9rZVwiLFxuICBGOiBcIkZvcm1hdFwiLFxuICBWOiBcIlZhbGlkYXRlXCIsXG4gIEM6IFwiQ2FsY3VsYXRlXCJcbn07XG5jb25zdCBEb2N1bWVudEFjdGlvbkV2ZW50VHlwZSA9IHtcbiAgV0M6IFwiV2lsbENsb3NlXCIsXG4gIFdTOiBcIldpbGxTYXZlXCIsXG4gIERTOiBcIkRpZFNhdmVcIixcbiAgV1A6IFwiV2lsbFByaW50XCIsXG4gIERQOiBcIkRpZFByaW50XCJcbn07XG5jb25zdCBQYWdlQWN0aW9uRXZlbnRUeXBlID0ge1xuICBPOiBcIlBhZ2VPcGVuXCIsXG4gIEM6IFwiUGFnZUNsb3NlXCJcbn07XG5jb25zdCBWZXJib3NpdHlMZXZlbCA9IHtcbiAgRVJST1JTOiAwLFxuICBXQVJOSU5HUzogMSxcbiAgSU5GT1M6IDVcbn07XG5jb25zdCBPUFMgPSB7XG4gIGRlcGVuZGVuY3k6IDEsXG4gIHNldExpbmVXaWR0aDogMixcbiAgc2V0TGluZUNhcDogMyxcbiAgc2V0TGluZUpvaW46IDQsXG4gIHNldE1pdGVyTGltaXQ6IDUsXG4gIHNldERhc2g6IDYsXG4gIHNldFJlbmRlcmluZ0ludGVudDogNyxcbiAgc2V0RmxhdG5lc3M6IDgsXG4gIHNldEdTdGF0ZTogOSxcbiAgc2F2ZTogMTAsXG4gIHJlc3RvcmU6IDExLFxuICB0cmFuc2Zvcm06IDEyLFxuICBtb3ZlVG86IDEzLFxuICBsaW5lVG86IDE0LFxuICBjdXJ2ZVRvOiAxNSxcbiAgY3VydmVUbzI6IDE2LFxuICBjdXJ2ZVRvMzogMTcsXG4gIGNsb3NlUGF0aDogMTgsXG4gIHJlY3RhbmdsZTogMTksXG4gIHN0cm9rZTogMjAsXG4gIGNsb3NlU3Ryb2tlOiAyMSxcbiAgZmlsbDogMjIsXG4gIGVvRmlsbDogMjMsXG4gIGZpbGxTdHJva2U6IDI0LFxuICBlb0ZpbGxTdHJva2U6IDI1LFxuICBjbG9zZUZpbGxTdHJva2U6IDI2LFxuICBjbG9zZUVPRmlsbFN0cm9rZTogMjcsXG4gIGVuZFBhdGg6IDI4LFxuICBjbGlwOiAyOSxcbiAgZW9DbGlwOiAzMCxcbiAgYmVnaW5UZXh0OiAzMSxcbiAgZW5kVGV4dDogMzIsXG4gIHNldENoYXJTcGFjaW5nOiAzMyxcbiAgc2V0V29yZFNwYWNpbmc6IDM0LFxuICBzZXRIU2NhbGU6IDM1LFxuICBzZXRMZWFkaW5nOiAzNixcbiAgc2V0Rm9udDogMzcsXG4gIHNldFRleHRSZW5kZXJpbmdNb2RlOiAzOCxcbiAgc2V0VGV4dFJpc2U6IDM5LFxuICBtb3ZlVGV4dDogNDAsXG4gIHNldExlYWRpbmdNb3ZlVGV4dDogNDEsXG4gIHNldFRleHRNYXRyaXg6IDQyLFxuICBuZXh0TGluZTogNDMsXG4gIHNob3dUZXh0OiA0NCxcbiAgc2hvd1NwYWNlZFRleHQ6IDQ1LFxuICBuZXh0TGluZVNob3dUZXh0OiA0NixcbiAgbmV4dExpbmVTZXRTcGFjaW5nU2hvd1RleHQ6IDQ3LFxuICBzZXRDaGFyV2lkdGg6IDQ4LFxuICBzZXRDaGFyV2lkdGhBbmRCb3VuZHM6IDQ5LFxuICBzZXRTdHJva2VDb2xvclNwYWNlOiA1MCxcbiAgc2V0RmlsbENvbG9yU3BhY2U6IDUxLFxuICBzZXRTdHJva2VDb2xvcjogNTIsXG4gIHNldFN0cm9rZUNvbG9yTjogNTMsXG4gIHNldEZpbGxDb2xvcjogNTQsXG4gIHNldEZpbGxDb2xvck46IDU1LFxuICBzZXRTdHJva2VHcmF5OiA1NixcbiAgc2V0RmlsbEdyYXk6IDU3LFxuICBzZXRTdHJva2VSR0JDb2xvcjogNTgsXG4gIHNldEZpbGxSR0JDb2xvcjogNTksXG4gIHNldFN0cm9rZUNNWUtDb2xvcjogNjAsXG4gIHNldEZpbGxDTVlLQ29sb3I6IDYxLFxuICBzaGFkaW5nRmlsbDogNjIsXG4gIGJlZ2luSW5saW5lSW1hZ2U6IDYzLFxuICBiZWdpbkltYWdlRGF0YTogNjQsXG4gIGVuZElubGluZUltYWdlOiA2NSxcbiAgcGFpbnRYT2JqZWN0OiA2NixcbiAgbWFya1BvaW50OiA2NyxcbiAgbWFya1BvaW50UHJvcHM6IDY4LFxuICBiZWdpbk1hcmtlZENvbnRlbnQ6IDY5LFxuICBiZWdpbk1hcmtlZENvbnRlbnRQcm9wczogNzAsXG4gIGVuZE1hcmtlZENvbnRlbnQ6IDcxLFxuICBiZWdpbkNvbXBhdDogNzIsXG4gIGVuZENvbXBhdDogNzMsXG4gIHBhaW50Rm9ybVhPYmplY3RCZWdpbjogNzQsXG4gIHBhaW50Rm9ybVhPYmplY3RFbmQ6IDc1LFxuICBiZWdpbkdyb3VwOiA3NixcbiAgZW5kR3JvdXA6IDc3LFxuICBiZWdpbkFubm90YXRpb246IDgwLFxuICBlbmRBbm5vdGF0aW9uOiA4MSxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0OiA4MyxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0R3JvdXA6IDg0LFxuICBwYWludEltYWdlWE9iamVjdDogODUsXG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0OiA4NixcbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cDogODcsXG4gIHBhaW50SW1hZ2VYT2JqZWN0UmVwZWF0OiA4OCxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0UmVwZWF0OiA4OSxcbiAgcGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrOiA5MCxcbiAgY29uc3RydWN0UGF0aDogOTEsXG4gIHNldFN0cm9rZVRyYW5zcGFyZW50OiA5MixcbiAgc2V0RmlsbFRyYW5zcGFyZW50OiA5MyxcbiAgcmF3RmlsbFBhdGg6IDk0XG59O1xuY29uc3QgRHJhd09QUyA9IHtcbiAgbW92ZVRvOiAwLFxuICBsaW5lVG86IDEsXG4gIGN1cnZlVG86IDIsXG4gIGNsb3NlUGF0aDogM1xufTtcbmNvbnN0IFBhc3N3b3JkUmVzcG9uc2VzID0ge1xuICBORUVEX1BBU1NXT1JEOiAxLFxuICBJTkNPUlJFQ1RfUEFTU1dPUkQ6IDJcbn07XG5sZXQgdmVyYm9zaXR5ID0gVmVyYm9zaXR5TGV2ZWwuV0FSTklOR1M7XG5mdW5jdGlvbiBzZXRWZXJib3NpdHlMZXZlbChsZXZlbCkge1xuICBpZiAoTnVtYmVyLmlzSW50ZWdlcihsZXZlbCkpIHtcbiAgICB2ZXJib3NpdHkgPSBsZXZlbDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VmVyYm9zaXR5TGV2ZWwoKSB7XG4gIHJldHVybiB2ZXJib3NpdHk7XG59XG5mdW5jdGlvbiBpbmZvKG1zZykge1xuICBpZiAodmVyYm9zaXR5ID49IFZlcmJvc2l0eUxldmVsLklORk9TKSB7XG4gICAgY29uc29sZS5sb2coYEluZm86ICR7bXNnfWApO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuKG1zZykge1xuICBpZiAodmVyYm9zaXR5ID49IFZlcmJvc2l0eUxldmVsLldBUk5JTkdTKSB7XG4gICAgY29uc29sZS5sb2coYFdhcm5pbmc6ICR7bXNnfWApO1xuICB9XG59XG5mdW5jdGlvbiB1bnJlYWNoYWJsZShtc2cpIHtcbiAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG59XG5mdW5jdGlvbiBhc3NlcnQoY29uZCwgbXNnKSB7XG4gIGlmICghY29uZCkge1xuICAgIHVucmVhY2hhYmxlKG1zZyk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9pc1ZhbGlkUHJvdG9jb2wodXJsKSB7XG4gIHN3aXRjaCAodXJsPy5wcm90b2NvbCkge1xuICAgIGNhc2UgXCJodHRwOlwiOlxuICAgIGNhc2UgXCJodHRwczpcIjpcbiAgICBjYXNlIFwiZnRwOlwiOlxuICAgIGNhc2UgXCJtYWlsdG86XCI6XG4gICAgY2FzZSBcInRlbDpcIjpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwodXJsLCBiYXNlVXJsID0gbnVsbCwgb3B0aW9ucyA9IG51bGwpIHtcbiAgaWYgKCF1cmwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAob3B0aW9ucyAmJiB0eXBlb2YgdXJsID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKG9wdGlvbnMuYWRkRGVmYXVsdFByb3RvY29sICYmIHVybC5zdGFydHNXaXRoKFwid3d3LlwiKSkge1xuICAgICAgY29uc3QgZG90cyA9IHVybC5tYXRjaCgvXFwuL2cpO1xuICAgICAgaWYgKGRvdHM/Lmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIHVybCA9IGBodHRwOi8vJHt1cmx9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudHJ5Q29udmVydEVuY29kaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICB1cmwgPSBzdHJpbmdUb1VURjhTdHJpbmcodXJsKTtcbiAgICAgIH0gY2F0Y2gge31cbiAgICB9XG4gIH1cbiAgY29uc3QgYWJzb2x1dGVVcmwgPSBiYXNlVXJsID8gVVJMLnBhcnNlKHVybCwgYmFzZVVybCkgOiBVUkwucGFyc2UodXJsKTtcbiAgcmV0dXJuIF9pc1ZhbGlkUHJvdG9jb2woYWJzb2x1dGVVcmwpID8gYWJzb2x1dGVVcmwgOiBudWxsO1xufVxuZnVuY3Rpb24gdXBkYXRlVXJsSGFzaCh1cmwsIGhhc2gsIGFsbG93UmVsID0gZmFsc2UpIHtcbiAgY29uc3QgcmVzID0gVVJMLnBhcnNlKHVybCk7XG4gIGlmIChyZXMpIHtcbiAgICByZXMuaGFzaCA9IGhhc2g7XG4gICAgcmV0dXJuIHJlcy5ocmVmO1xuICB9XG4gIGlmIChhbGxvd1JlbCAmJiBjcmVhdGVWYWxpZEFic29sdXRlVXJsKHVybCwgXCJodHRwOi8vZXhhbXBsZS5jb21cIikpIHtcbiAgICByZXR1cm4gdXJsLnNwbGl0KFwiI1wiLCAxKVswXSArIGAke2hhc2ggPyBgIyR7aGFzaH1gIDogXCJcIn1gO1xuICB9XG4gIHJldHVybiBcIlwiO1xufVxuZnVuY3Rpb24gc2hhZG93KG9iaiwgcHJvcCwgdmFsdWUsIG5vblNlcmlhbGl6YWJsZSA9IGZhbHNlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHtcbiAgICB2YWx1ZSxcbiAgICBlbnVtZXJhYmxlOiAhbm9uU2VyaWFsaXphYmxlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IEJhc2VFeGNlcHRpb24gPSBmdW5jdGlvbiBCYXNlRXhjZXB0aW9uQ2xvc3VyZSgpIHtcbiAgZnVuY3Rpb24gQmFzZUV4Y2VwdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICB9XG4gIEJhc2VFeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gIEJhc2VFeGNlcHRpb24uY29uc3RydWN0b3IgPSBCYXNlRXhjZXB0aW9uO1xuICByZXR1cm4gQmFzZUV4Y2VwdGlvbjtcbn0oKTtcbmNsYXNzIFBhc3N3b3JkRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZywgY29kZSkge1xuICAgIHN1cGVyKG1zZywgXCJQYXNzd29yZEV4Y2VwdGlvblwiKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICB9XG59XG5jbGFzcyBVbmtub3duRXJyb3JFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnLCBkZXRhaWxzKSB7XG4gICAgc3VwZXIobXNnLCBcIlVua25vd25FcnJvckV4Y2VwdGlvblwiKTtcbiAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICB9XG59XG5jbGFzcyBJbnZhbGlkUERGRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZykge1xuICAgIHN1cGVyKG1zZywgXCJJbnZhbGlkUERGRXhjZXB0aW9uXCIpO1xuICB9XG59XG5jbGFzcyBSZXNwb25zZUV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIHN0YXR1cywgbWlzc2luZykge1xuICAgIHN1cGVyKG1zZywgXCJSZXNwb25zZUV4Y2VwdGlvblwiKTtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLm1pc3NpbmcgPSBtaXNzaW5nO1xuICB9XG59XG5jbGFzcyBGb3JtYXRFcnJvciBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICBzdXBlcihtc2csIFwiRm9ybWF0RXJyb3JcIik7XG4gIH1cbn1cbmNsYXNzIEFib3J0RXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZykge1xuICAgIHN1cGVyKG1zZywgXCJBYm9ydEV4Y2VwdGlvblwiKTtcbiAgfVxufVxuZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyhieXRlcykge1xuICBpZiAodHlwZW9mIGJ5dGVzICE9PSBcIm9iamVjdFwiIHx8IGJ5dGVzPy5sZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIHVucmVhY2hhYmxlKFwiSW52YWxpZCBhcmd1bWVudCBmb3IgYnl0ZXNUb1N0cmluZ1wiKTtcbiAgfVxuICBjb25zdCBsZW5ndGggPSBieXRlcy5sZW5ndGg7XG4gIGNvbnN0IE1BWF9BUkdVTUVOVF9DT1VOVCA9IDgxOTI7XG4gIGlmIChsZW5ndGggPCBNQVhfQVJHVU1FTlRfQ09VTlQpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBieXRlcyk7XG4gIH1cbiAgY29uc3Qgc3RyQnVmID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IE1BWF9BUkdVTUVOVF9DT1VOVCkge1xuICAgIGNvbnN0IGNodW5rRW5kID0gTWF0aC5taW4oaSArIE1BWF9BUkdVTUVOVF9DT1VOVCwgbGVuZ3RoKTtcbiAgICBjb25zdCBjaHVuayA9IGJ5dGVzLnN1YmFycmF5KGksIGNodW5rRW5kKTtcbiAgICBzdHJCdWYucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNodW5rKSk7XG4gIH1cbiAgcmV0dXJuIHN0ckJ1Zi5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyhzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09IFwic3RyaW5nXCIpIHtcbiAgICB1bnJlYWNoYWJsZShcIkludmFsaWQgYXJndW1lbnQgZm9yIHN0cmluZ1RvQnl0ZXNcIik7XG4gIH1cbiAgY29uc3QgbGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgYnl0ZXNbaV0gPSBzdHIuY2hhckNvZGVBdChpKSAmIDB4ZmY7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufVxuZnVuY3Rpb24gc3RyaW5nMzIodmFsdWUpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodmFsdWUgPj4gMjQgJiAweGZmLCB2YWx1ZSA+PiAxNiAmIDB4ZmYsIHZhbHVlID4+IDggJiAweGZmLCB2YWx1ZSAmIDB4ZmYpO1xufVxuZnVuY3Rpb24gb2JqZWN0U2l6ZShvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoO1xufVxuZnVuY3Rpb24gaXNMaXR0bGVFbmRpYW4oKSB7XG4gIGNvbnN0IGJ1ZmZlcjggPSBuZXcgVWludDhBcnJheSg0KTtcbiAgYnVmZmVyOFswXSA9IDE7XG4gIGNvbnN0IHZpZXczMiA9IG5ldyBVaW50MzJBcnJheShidWZmZXI4LmJ1ZmZlciwgMCwgMSk7XG4gIHJldHVybiB2aWV3MzJbMF0gPT09IDE7XG59XG5mdW5jdGlvbiBpc0V2YWxTdXBwb3J0ZWQoKSB7XG4gIHRyeSB7XG4gICAgbmV3IEZ1bmN0aW9uKFwiXCIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmNsYXNzIHV0aWxfRmVhdHVyZVRlc3Qge1xuICBzdGF0aWMgZ2V0IGlzTGl0dGxlRW5kaWFuKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0xpdHRsZUVuZGlhblwiLCBpc0xpdHRsZUVuZGlhbigpKTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzRXZhbFN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNFdmFsU3VwcG9ydGVkXCIsIGlzRXZhbFN1cHBvcnRlZCgpKTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZFwiLCB0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzSW1hZ2VEZWNvZGVyU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0ltYWdlRGVjb2RlclN1cHBvcnRlZFwiLCB0eXBlb2YgSW1hZ2VEZWNvZGVyICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHBsYXRmb3JtKCkge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBuYXZpZ2F0b3I/LnBsYXRmb3JtID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBuYXZpZ2F0b3I/LnVzZXJBZ2VudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgdXNlckFnZW50XG4gICAgICB9ID0gbmF2aWdhdG9yO1xuICAgICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcInBsYXRmb3JtXCIsIHtcbiAgICAgICAgaXNBbmRyb2lkOiB1c2VyQWdlbnQuaW5jbHVkZXMoXCJBbmRyb2lkXCIpLFxuICAgICAgICBpc0xpbnV4OiBwbGF0Zm9ybS5pbmNsdWRlcyhcIkxpbnV4XCIpLFxuICAgICAgICBpc01hYzogcGxhdGZvcm0uaW5jbHVkZXMoXCJNYWNcIiksXG4gICAgICAgIGlzV2luZG93czogcGxhdGZvcm0uaW5jbHVkZXMoXCJXaW5cIiksXG4gICAgICAgIGlzRmlyZWZveDogdXNlckFnZW50LmluY2x1ZGVzKFwiRmlyZWZveFwiKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJwbGF0Zm9ybVwiLCB7XG4gICAgICBpc0FuZHJvaWQ6IGZhbHNlLFxuICAgICAgaXNMaW51eDogZmFsc2UsXG4gICAgICBpc01hYzogZmFsc2UsXG4gICAgICBpc1dpbmRvd3M6IGZhbHNlLFxuICAgICAgaXNGaXJlZm94OiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNDU1NSb3VuZFN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNDU1NSb3VuZFN1cHBvcnRlZFwiLCBnbG9iYWxUaGlzLkNTUz8uc3VwcG9ydHM/LihcIndpZHRoOiByb3VuZCgxLjVweCwgMXB4KVwiKSk7XG4gIH1cbn1cbmNvbnN0IGhleE51bWJlcnMgPSBBcnJheS5mcm9tKEFycmF5KDI1Nikua2V5cygpLCBuID0+IG4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSk7XG5jbGFzcyBVdGlsIHtcbiAgc3RhdGljIG1ha2VIZXhDb2xvcihyLCBnLCBiKSB7XG4gICAgcmV0dXJuIGAjJHtoZXhOdW1iZXJzW3JdfSR7aGV4TnVtYmVyc1tnXX0ke2hleE51bWJlcnNbYl19YDtcbiAgfVxuICBzdGF0aWMgc2NhbGVNaW5NYXgodHJhbnNmb3JtLCBtaW5NYXgpIHtcbiAgICBsZXQgdGVtcDtcbiAgICBpZiAodHJhbnNmb3JtWzBdKSB7XG4gICAgICBpZiAodHJhbnNmb3JtWzBdIDwgMCkge1xuICAgICAgICB0ZW1wID0gbWluTWF4WzBdO1xuICAgICAgICBtaW5NYXhbMF0gPSBtaW5NYXhbMl07XG4gICAgICAgIG1pbk1heFsyXSA9IHRlbXA7XG4gICAgICB9XG4gICAgICBtaW5NYXhbMF0gKj0gdHJhbnNmb3JtWzBdO1xuICAgICAgbWluTWF4WzJdICo9IHRyYW5zZm9ybVswXTtcbiAgICAgIGlmICh0cmFuc2Zvcm1bM10gPCAwKSB7XG4gICAgICAgIHRlbXAgPSBtaW5NYXhbMV07XG4gICAgICAgIG1pbk1heFsxXSA9IG1pbk1heFszXTtcbiAgICAgICAgbWluTWF4WzNdID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIG1pbk1heFsxXSAqPSB0cmFuc2Zvcm1bM107XG4gICAgICBtaW5NYXhbM10gKj0gdHJhbnNmb3JtWzNdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZW1wID0gbWluTWF4WzBdO1xuICAgICAgbWluTWF4WzBdID0gbWluTWF4WzFdO1xuICAgICAgbWluTWF4WzFdID0gdGVtcDtcbiAgICAgIHRlbXAgPSBtaW5NYXhbMl07XG4gICAgICBtaW5NYXhbMl0gPSBtaW5NYXhbM107XG4gICAgICBtaW5NYXhbM10gPSB0ZW1wO1xuICAgICAgaWYgKHRyYW5zZm9ybVsxXSA8IDApIHtcbiAgICAgICAgdGVtcCA9IG1pbk1heFsxXTtcbiAgICAgICAgbWluTWF4WzFdID0gbWluTWF4WzNdO1xuICAgICAgICBtaW5NYXhbM10gPSB0ZW1wO1xuICAgICAgfVxuICAgICAgbWluTWF4WzFdICo9IHRyYW5zZm9ybVsxXTtcbiAgICAgIG1pbk1heFszXSAqPSB0cmFuc2Zvcm1bMV07XG4gICAgICBpZiAodHJhbnNmb3JtWzJdIDwgMCkge1xuICAgICAgICB0ZW1wID0gbWluTWF4WzBdO1xuICAgICAgICBtaW5NYXhbMF0gPSBtaW5NYXhbMl07XG4gICAgICAgIG1pbk1heFsyXSA9IHRlbXA7XG4gICAgICB9XG4gICAgICBtaW5NYXhbMF0gKj0gdHJhbnNmb3JtWzJdO1xuICAgICAgbWluTWF4WzJdICo9IHRyYW5zZm9ybVsyXTtcbiAgICB9XG4gICAgbWluTWF4WzBdICs9IHRyYW5zZm9ybVs0XTtcbiAgICBtaW5NYXhbMV0gKz0gdHJhbnNmb3JtWzVdO1xuICAgIG1pbk1heFsyXSArPSB0cmFuc2Zvcm1bNF07XG4gICAgbWluTWF4WzNdICs9IHRyYW5zZm9ybVs1XTtcbiAgfVxuICBzdGF0aWMgdHJhbnNmb3JtKG0xLCBtMikge1xuICAgIHJldHVybiBbbTFbMF0gKiBtMlswXSArIG0xWzJdICogbTJbMV0sIG0xWzFdICogbTJbMF0gKyBtMVszXSAqIG0yWzFdLCBtMVswXSAqIG0yWzJdICsgbTFbMl0gKiBtMlszXSwgbTFbMV0gKiBtMlsyXSArIG0xWzNdICogbTJbM10sIG0xWzBdICogbTJbNF0gKyBtMVsyXSAqIG0yWzVdICsgbTFbNF0sIG0xWzFdICogbTJbNF0gKyBtMVszXSAqIG0yWzVdICsgbTFbNV1dO1xuICB9XG4gIHN0YXRpYyBhcHBseVRyYW5zZm9ybShwLCBtLCBwb3MgPSAwKSB7XG4gICAgY29uc3QgcDAgPSBwW3Bvc107XG4gICAgY29uc3QgcDEgPSBwW3BvcyArIDFdO1xuICAgIHBbcG9zXSA9IHAwICogbVswXSArIHAxICogbVsyXSArIG1bNF07XG4gICAgcFtwb3MgKyAxXSA9IHAwICogbVsxXSArIHAxICogbVszXSArIG1bNV07XG4gIH1cbiAgc3RhdGljIGFwcGx5VHJhbnNmb3JtVG9CZXppZXIocCwgdHJhbnNmb3JtLCBwb3MgPSAwKSB7XG4gICAgY29uc3QgbTAgPSB0cmFuc2Zvcm1bMF07XG4gICAgY29uc3QgbTEgPSB0cmFuc2Zvcm1bMV07XG4gICAgY29uc3QgbTIgPSB0cmFuc2Zvcm1bMl07XG4gICAgY29uc3QgbTMgPSB0cmFuc2Zvcm1bM107XG4gICAgY29uc3QgbTQgPSB0cmFuc2Zvcm1bNF07XG4gICAgY29uc3QgbTUgPSB0cmFuc2Zvcm1bNV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHBJID0gcFtwb3MgKyBpXTtcbiAgICAgIGNvbnN0IHBJMSA9IHBbcG9zICsgaSArIDFdO1xuICAgICAgcFtwb3MgKyBpXSA9IHBJICogbTAgKyBwSTEgKiBtMiArIG00O1xuICAgICAgcFtwb3MgKyBpICsgMV0gPSBwSSAqIG0xICsgcEkxICogbTMgKyBtNTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGFwcGx5SW52ZXJzZVRyYW5zZm9ybShwLCBtKSB7XG4gICAgY29uc3QgcDAgPSBwWzBdO1xuICAgIGNvbnN0IHAxID0gcFsxXTtcbiAgICBjb25zdCBkID0gbVswXSAqIG1bM10gLSBtWzFdICogbVsyXTtcbiAgICBwWzBdID0gKHAwICogbVszXSAtIHAxICogbVsyXSArIG1bMl0gKiBtWzVdIC0gbVs0XSAqIG1bM10pIC8gZDtcbiAgICBwWzFdID0gKC1wMCAqIG1bMV0gKyBwMSAqIG1bMF0gKyBtWzRdICogbVsxXSAtIG1bNV0gKiBtWzBdKSAvIGQ7XG4gIH1cbiAgc3RhdGljIGF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KHJlY3QsIHRyYW5zZm9ybSwgb3V0cHV0KSB7XG4gICAgY29uc3QgbTAgPSB0cmFuc2Zvcm1bMF07XG4gICAgY29uc3QgbTEgPSB0cmFuc2Zvcm1bMV07XG4gICAgY29uc3QgbTIgPSB0cmFuc2Zvcm1bMl07XG4gICAgY29uc3QgbTMgPSB0cmFuc2Zvcm1bM107XG4gICAgY29uc3QgbTQgPSB0cmFuc2Zvcm1bNF07XG4gICAgY29uc3QgbTUgPSB0cmFuc2Zvcm1bNV07XG4gICAgY29uc3QgcjAgPSByZWN0WzBdO1xuICAgIGNvbnN0IHIxID0gcmVjdFsxXTtcbiAgICBjb25zdCByMiA9IHJlY3RbMl07XG4gICAgY29uc3QgcjMgPSByZWN0WzNdO1xuICAgIGxldCBhMCA9IG0wICogcjAgKyBtNDtcbiAgICBsZXQgYTIgPSBhMDtcbiAgICBsZXQgYTEgPSBtMCAqIHIyICsgbTQ7XG4gICAgbGV0IGEzID0gYTE7XG4gICAgbGV0IGIwID0gbTMgKiByMSArIG01O1xuICAgIGxldCBiMiA9IGIwO1xuICAgIGxldCBiMSA9IG0zICogcjMgKyBtNTtcbiAgICBsZXQgYjMgPSBiMTtcbiAgICBpZiAobTEgIT09IDAgfHwgbTIgIT09IDApIHtcbiAgICAgIGNvbnN0IG0xcjAgPSBtMSAqIHIwO1xuICAgICAgY29uc3QgbTFyMiA9IG0xICogcjI7XG4gICAgICBjb25zdCBtMnIxID0gbTIgKiByMTtcbiAgICAgIGNvbnN0IG0ycjMgPSBtMiAqIHIzO1xuICAgICAgYTAgKz0gbTJyMTtcbiAgICAgIGEzICs9IG0ycjE7XG4gICAgICBhMSArPSBtMnIzO1xuICAgICAgYTIgKz0gbTJyMztcbiAgICAgIGIwICs9IG0xcjA7XG4gICAgICBiMyArPSBtMXIwO1xuICAgICAgYjEgKz0gbTFyMjtcbiAgICAgIGIyICs9IG0xcjI7XG4gICAgfVxuICAgIG91dHB1dFswXSA9IE1hdGgubWluKG91dHB1dFswXSwgYTAsIGExLCBhMiwgYTMpO1xuICAgIG91dHB1dFsxXSA9IE1hdGgubWluKG91dHB1dFsxXSwgYjAsIGIxLCBiMiwgYjMpO1xuICAgIG91dHB1dFsyXSA9IE1hdGgubWF4KG91dHB1dFsyXSwgYTAsIGExLCBhMiwgYTMpO1xuICAgIG91dHB1dFszXSA9IE1hdGgubWF4KG91dHB1dFszXSwgYjAsIGIxLCBiMiwgYjMpO1xuICB9XG4gIHN0YXRpYyBpbnZlcnNlVHJhbnNmb3JtKG0pIHtcbiAgICBjb25zdCBkID0gbVswXSAqIG1bM10gLSBtWzFdICogbVsyXTtcbiAgICByZXR1cm4gW21bM10gLyBkLCAtbVsxXSAvIGQsIC1tWzJdIC8gZCwgbVswXSAvIGQsIChtWzJdICogbVs1XSAtIG1bNF0gKiBtWzNdKSAvIGQsIChtWzRdICogbVsxXSAtIG1bNV0gKiBtWzBdKSAvIGRdO1xuICB9XG4gIHN0YXRpYyBzaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShtYXRyaXgsIG91dHB1dCkge1xuICAgIGNvbnN0IG0wID0gbWF0cml4WzBdO1xuICAgIGNvbnN0IG0xID0gbWF0cml4WzFdO1xuICAgIGNvbnN0IG0yID0gbWF0cml4WzJdO1xuICAgIGNvbnN0IG0zID0gbWF0cml4WzNdO1xuICAgIGNvbnN0IGEgPSBtMCAqKiAyICsgbTEgKiogMjtcbiAgICBjb25zdCBiID0gbTAgKiBtMiArIG0xICogbTM7XG4gICAgY29uc3QgYyA9IG0yICoqIDIgKyBtMyAqKiAyO1xuICAgIGNvbnN0IGZpcnN0ID0gKGEgKyBjKSAvIDI7XG4gICAgY29uc3Qgc2Vjb25kID0gTWF0aC5zcXJ0KGZpcnN0ICoqIDIgLSAoYSAqIGMgLSBiICoqIDIpKTtcbiAgICBvdXRwdXRbMF0gPSBNYXRoLnNxcnQoZmlyc3QgKyBzZWNvbmQgfHwgMSk7XG4gICAgb3V0cHV0WzFdID0gTWF0aC5zcXJ0KGZpcnN0IC0gc2Vjb25kIHx8IDEpO1xuICB9XG4gIHN0YXRpYyBub3JtYWxpemVSZWN0KHJlY3QpIHtcbiAgICBjb25zdCByID0gcmVjdC5zbGljZSgwKTtcbiAgICBpZiAocmVjdFswXSA+IHJlY3RbMl0pIHtcbiAgICAgIHJbMF0gPSByZWN0WzJdO1xuICAgICAgclsyXSA9IHJlY3RbMF07XG4gICAgfVxuICAgIGlmIChyZWN0WzFdID4gcmVjdFszXSkge1xuICAgICAgclsxXSA9IHJlY3RbM107XG4gICAgICByWzNdID0gcmVjdFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgc3RhdGljIGludGVyc2VjdChyZWN0MSwgcmVjdDIpIHtcbiAgICBjb25zdCB4TG93ID0gTWF0aC5tYXgoTWF0aC5taW4ocmVjdDFbMF0sIHJlY3QxWzJdKSwgTWF0aC5taW4ocmVjdDJbMF0sIHJlY3QyWzJdKSk7XG4gICAgY29uc3QgeEhpZ2ggPSBNYXRoLm1pbihNYXRoLm1heChyZWN0MVswXSwgcmVjdDFbMl0pLCBNYXRoLm1heChyZWN0MlswXSwgcmVjdDJbMl0pKTtcbiAgICBpZiAoeExvdyA+IHhIaWdoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeUxvdyA9IE1hdGgubWF4KE1hdGgubWluKHJlY3QxWzFdLCByZWN0MVszXSksIE1hdGgubWluKHJlY3QyWzFdLCByZWN0MlszXSkpO1xuICAgIGNvbnN0IHlIaWdoID0gTWF0aC5taW4oTWF0aC5tYXgocmVjdDFbMV0sIHJlY3QxWzNdKSwgTWF0aC5tYXgocmVjdDJbMV0sIHJlY3QyWzNdKSk7XG4gICAgaWYgKHlMb3cgPiB5SGlnaCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBbeExvdywgeUxvdywgeEhpZ2gsIHlIaWdoXTtcbiAgfVxuICBzdGF0aWMgcG9pbnRCb3VuZGluZ0JveCh4LCB5LCBtaW5NYXgpIHtcbiAgICBtaW5NYXhbMF0gPSBNYXRoLm1pbihtaW5NYXhbMF0sIHgpO1xuICAgIG1pbk1heFsxXSA9IE1hdGgubWluKG1pbk1heFsxXSwgeSk7XG4gICAgbWluTWF4WzJdID0gTWF0aC5tYXgobWluTWF4WzJdLCB4KTtcbiAgICBtaW5NYXhbM10gPSBNYXRoLm1heChtaW5NYXhbM10sIHkpO1xuICB9XG4gIHN0YXRpYyByZWN0Qm91bmRpbmdCb3goeDAsIHkwLCB4MSwgeTEsIG1pbk1heCkge1xuICAgIG1pbk1heFswXSA9IE1hdGgubWluKG1pbk1heFswXSwgeDAsIHgxKTtcbiAgICBtaW5NYXhbMV0gPSBNYXRoLm1pbihtaW5NYXhbMV0sIHkwLCB5MSk7XG4gICAgbWluTWF4WzJdID0gTWF0aC5tYXgobWluTWF4WzJdLCB4MCwgeDEpO1xuICAgIG1pbk1heFszXSA9IE1hdGgubWF4KG1pbk1heFszXSwgeTAsIHkxKTtcbiAgfVxuICBzdGF0aWMgI2dldEV4dHJlbXVtT25DdXJ2ZSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsIHQsIG1pbk1heCkge1xuICAgIGlmICh0IDw9IDAgfHwgdCA+PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG10ID0gMSAtIHQ7XG4gICAgY29uc3QgdHQgPSB0ICogdDtcbiAgICBjb25zdCB0dHQgPSB0dCAqIHQ7XG4gICAgY29uc3QgeCA9IG10ICogKG10ICogKG10ICogeDAgKyAzICogdCAqIHgxKSArIDMgKiB0dCAqIHgyKSArIHR0dCAqIHgzO1xuICAgIGNvbnN0IHkgPSBtdCAqIChtdCAqIChtdCAqIHkwICsgMyAqIHQgKiB5MSkgKyAzICogdHQgKiB5MikgKyB0dHQgKiB5MztcbiAgICBtaW5NYXhbMF0gPSBNYXRoLm1pbihtaW5NYXhbMF0sIHgpO1xuICAgIG1pbk1heFsxXSA9IE1hdGgubWluKG1pbk1heFsxXSwgeSk7XG4gICAgbWluTWF4WzJdID0gTWF0aC5tYXgobWluTWF4WzJdLCB4KTtcbiAgICBtaW5NYXhbM10gPSBNYXRoLm1heChtaW5NYXhbM10sIHkpO1xuICB9XG4gIHN0YXRpYyAjZ2V0RXh0cmVtdW0oeDAsIHgxLCB4MiwgeDMsIHkwLCB5MSwgeTIsIHkzLCBhLCBiLCBjLCBtaW5NYXgpIHtcbiAgICBpZiAoTWF0aC5hYnMoYSkgPCAxZS0xMikge1xuICAgICAgaWYgKE1hdGguYWJzKGIpID49IDFlLTEyKSB7XG4gICAgICAgIHRoaXMuI2dldEV4dHJlbXVtT25DdXJ2ZSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsIC1jIC8gYiwgbWluTWF4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGVsdGEgPSBiICoqIDIgLSA0ICogYyAqIGE7XG4gICAgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzcXJ0RGVsdGEgPSBNYXRoLnNxcnQoZGVsdGEpO1xuICAgIGNvbnN0IGEyID0gMiAqIGE7XG4gICAgdGhpcy4jZ2V0RXh0cmVtdW1PbkN1cnZlKHgwLCB4MSwgeDIsIHgzLCB5MCwgeTEsIHkyLCB5MywgKC1iICsgc3FydERlbHRhKSAvIGEyLCBtaW5NYXgpO1xuICAgIHRoaXMuI2dldEV4dHJlbXVtT25DdXJ2ZSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsICgtYiAtIHNxcnREZWx0YSkgLyBhMiwgbWluTWF4KTtcbiAgfVxuICBzdGF0aWMgYmV6aWVyQm91bmRpbmdCb3goeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBtaW5NYXgpIHtcbiAgICBtaW5NYXhbMF0gPSBNYXRoLm1pbihtaW5NYXhbMF0sIHgwLCB4Myk7XG4gICAgbWluTWF4WzFdID0gTWF0aC5taW4obWluTWF4WzFdLCB5MCwgeTMpO1xuICAgIG1pbk1heFsyXSA9IE1hdGgubWF4KG1pbk1heFsyXSwgeDAsIHgzKTtcbiAgICBtaW5NYXhbM10gPSBNYXRoLm1heChtaW5NYXhbM10sIHkwLCB5Myk7XG4gICAgdGhpcy4jZ2V0RXh0cmVtdW0oeDAsIHgxLCB4MiwgeDMsIHkwLCB5MSwgeTIsIHkzLCAzICogKC14MCArIDMgKiAoeDEgLSB4MikgKyB4MyksIDYgKiAoeDAgLSAyICogeDEgKyB4MiksIDMgKiAoeDEgLSB4MCksIG1pbk1heCk7XG4gICAgdGhpcy4jZ2V0RXh0cmVtdW0oeDAsIHgxLCB4MiwgeDMsIHkwLCB5MSwgeTIsIHkzLCAzICogKC15MCArIDMgKiAoeTEgLSB5MikgKyB5MyksIDYgKiAoeTAgLSAyICogeTEgKyB5MiksIDMgKiAoeTEgLSB5MCksIG1pbk1heCk7XG4gIH1cbn1cbmNvbnN0IFBERlN0cmluZ1RyYW5zbGF0ZVRhYmxlID0gKC8qIHVudXNlZCBwdXJlIGV4cHJlc3Npb24gb3Igc3VwZXIgKi8gbnVsbCAmJiAoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDB4MmQ4LCAweDJjNywgMHgyYzYsIDB4MmQ5LCAweDJkZCwgMHgyZGIsIDB4MmRhLCAweDJkYywgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMHgyMDIyLCAweDIwMjAsIDB4MjAyMSwgMHgyMDI2LCAweDIwMTQsIDB4MjAxMywgMHgxOTIsIDB4MjA0NCwgMHgyMDM5LCAweDIwM2EsIDB4MjIxMiwgMHgyMDMwLCAweDIwMWUsIDB4MjAxYywgMHgyMDFkLCAweDIwMTgsIDB4MjAxOSwgMHgyMDFhLCAweDIxMjIsIDB4ZmIwMSwgMHhmYjAyLCAweDE0MSwgMHgxNTIsIDB4MTYwLCAweDE3OCwgMHgxN2QsIDB4MTMxLCAweDE0MiwgMHgxNTMsIDB4MTYxLCAweDE3ZSwgMCwgMHgyMGFjXSkpO1xuZnVuY3Rpb24gc3RyaW5nVG9QREZTdHJpbmcoc3RyKSB7XG4gIGlmIChzdHJbMF0gPj0gXCJcXHhFRlwiKSB7XG4gICAgbGV0IGVuY29kaW5nO1xuICAgIGlmIChzdHJbMF0gPT09IFwiXFx4RkVcIiAmJiBzdHJbMV0gPT09IFwiXFx4RkZcIikge1xuICAgICAgZW5jb2RpbmcgPSBcInV0Zi0xNmJlXCI7XG4gICAgICBpZiAoc3RyLmxlbmd0aCAlIDIgPT09IDEpIHtcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN0clswXSA9PT0gXCJcXHhGRlwiICYmIHN0clsxXSA9PT0gXCJcXHhGRVwiKSB7XG4gICAgICBlbmNvZGluZyA9IFwidXRmLTE2bGVcIjtcbiAgICAgIGlmIChzdHIubGVuZ3RoICUgMiA9PT0gMSkge1xuICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RyWzBdID09PSBcIlxceEVGXCIgJiYgc3RyWzFdID09PSBcIlxceEJCXCIgJiYgc3RyWzJdID09PSBcIlxceEJGXCIpIHtcbiAgICAgIGVuY29kaW5nID0gXCJ1dGYtOFwiO1xuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoZW5jb2RpbmcsIHtcbiAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gc3RyaW5nVG9CeXRlcyhzdHIpO1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyKTtcbiAgICAgICAgaWYgKCFkZWNvZGVkLmluY2x1ZGVzKFwiXFx4MWJcIikpIHtcbiAgICAgICAgICByZXR1cm4gZGVjb2RlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjb2RlZC5yZXBsYWNlQWxsKC9cXHgxYlteXFx4MWJdKig/OlxceDFifCQpL2csIFwiXCIpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgd2Fybihgc3RyaW5nVG9QREZTdHJpbmc6IFwiJHtleH1cIi5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3Qgc3RyQnVmID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IHN0ci5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgY29uc3QgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY2hhckNvZGUgPT09IDB4MWIpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBpaSAmJiBzdHIuY2hhckNvZGVBdChpKSAhPT0gMHgxYikge31cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBjb2RlID0gUERGU3RyaW5nVHJhbnNsYXRlVGFibGVbY2hhckNvZGVdO1xuICAgIHN0ckJ1Zi5wdXNoKGNvZGUgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpIDogc3RyLmNoYXJBdChpKSk7XG4gIH1cbiAgcmV0dXJuIHN0ckJ1Zi5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gc3RyaW5nVG9VVEY4U3RyaW5nKHN0cikge1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzdHIpKTtcbn1cbmZ1bmN0aW9uIHV0ZjhTdHJpbmdUb1N0cmluZyhzdHIpIHtcbiAgcmV0dXJuIHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTtcbn1cbmZ1bmN0aW9uIGlzQXJyYXlFcXVhbChhcnIxLCBhcnIyKSB7XG4gIGlmIChhcnIxLmxlbmd0aCAhPT0gYXJyMi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gYXJyMS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgaWYgKGFycjFbaV0gIT09IGFycjJbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZXRNb2RpZmljYXRpb25EYXRlKGRhdGUgPSBuZXcgRGF0ZSgpKSB7XG4gIGNvbnN0IGJ1ZmZlciA9IFtkYXRlLmdldFVUQ0Z1bGxZZWFyKCkudG9TdHJpbmcoKSwgKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpLCBkYXRlLmdldFVUQ0RhdGUoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgZGF0ZS5nZXRVVENIb3VycygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpLCBkYXRlLmdldFVUQ01pbnV0ZXMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgZGF0ZS5nZXRVVENTZWNvbmRzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIildO1xuICByZXR1cm4gYnVmZmVyLmpvaW4oXCJcIik7XG59XG5sZXQgTm9ybWFsaXplUmVnZXggPSBudWxsO1xubGV0IE5vcm1hbGl6YXRpb25NYXAgPSBudWxsO1xuZnVuY3Rpb24gbm9ybWFsaXplVW5pY29kZShzdHIpIHtcbiAgaWYgKCFOb3JtYWxpemVSZWdleCkge1xuICAgIE5vcm1hbGl6ZVJlZ2V4ID0gLyhbXFx1MDBhMFxcdTAwYjVcXHUwMzdlXFx1MGViM1xcdTIwMDAtXFx1MjAwYVxcdTIwMmZcXHUyMTI2XFx1ZmIwMC1cXHVmYjA0XFx1ZmIwNlxcdWZiMjAtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwLVxcdWZiNDFcXHVmYjQzLVxcdWZiNDRcXHVmYjQ2LVxcdWZiYTFcXHVmYmE0LVxcdWZiYTlcXHVmYmFlLVxcdWZiYjFcXHVmYmQzLVxcdWZiZGNcXHVmYmRlLVxcdWZiZTdcXHVmYmVhLVxcdWZiZjhcXHVmYmZjLVxcdWZiZmRcXHVmYzAwLVxcdWZjNWRcXHVmYzY0LVxcdWZjZjFcXHVmY2Y1LVxcdWZkM2RcXHVmZDg4XFx1ZmRmNFxcdWZkZmEtXFx1ZmRmYlxcdWZlNzFcXHVmZTc3XFx1ZmU3OVxcdWZlN2JcXHVmZTdkXSspfChcXHVmYjA1KykvZ3U7XG4gICAgTm9ybWFsaXphdGlvbk1hcCA9IG5ldyBNYXAoW1tcIu+shVwiLCBcIsW/dFwiXV0pO1xuICB9XG4gIHJldHVybiBzdHIucmVwbGFjZUFsbChOb3JtYWxpemVSZWdleCwgKF8sIHAxLCBwMikgPT4gcDEgPyBwMS5ub3JtYWxpemUoXCJORktDXCIpIDogTm9ybWFsaXphdGlvbk1hcC5nZXQocDIpKTtcbn1cbmZ1bmN0aW9uIGdldFV1aWQoKSB7XG4gIGlmICh0eXBlb2YgY3J5cHRvLnJhbmRvbVVVSUQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuICB9XG4gIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhidWYpO1xuICByZXR1cm4gYnl0ZXNUb1N0cmluZyhidWYpO1xufVxuY29uc3QgQW5ub3RhdGlvblByZWZpeCA9IFwicGRmanNfaW50ZXJuYWxfaWRfXCI7XG5mdW5jdGlvbiBfaXNWYWxpZEV4cGxpY2l0RGVzdCh2YWxpZFJlZiwgdmFsaWROYW1lLCBkZXN0KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShkZXN0KSB8fCBkZXN0Lmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgW3BhZ2UsIHpvb20sIC4uLmFyZ3NdID0gZGVzdDtcbiAgaWYgKCF2YWxpZFJlZihwYWdlKSAmJiAhTnVtYmVyLmlzSW50ZWdlcihwYWdlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIXZhbGlkTmFtZSh6b29tKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBhcmdzTGVuID0gYXJncy5sZW5ndGg7XG4gIGxldCBhbGxvd051bGwgPSB0cnVlO1xuICBzd2l0Y2ggKHpvb20ubmFtZSkge1xuICAgIGNhc2UgXCJYWVpcIjpcbiAgICAgIGlmIChhcmdzTGVuIDwgMiB8fCBhcmdzTGVuID4gMykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiRml0XCI6XG4gICAgY2FzZSBcIkZpdEJcIjpcbiAgICAgIHJldHVybiBhcmdzTGVuID09PSAwO1xuICAgIGNhc2UgXCJGaXRIXCI6XG4gICAgY2FzZSBcIkZpdEJIXCI6XG4gICAgY2FzZSBcIkZpdFZcIjpcbiAgICBjYXNlIFwiRml0QlZcIjpcbiAgICAgIGlmIChhcmdzTGVuID4gMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiRml0UlwiOlxuICAgICAgaWYgKGFyZ3NMZW4gIT09IDQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYWxsb3dOdWxsID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gXCJudW1iZXJcIiB8fCBhbGxvd051bGwgJiYgYXJnID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gTWF0aENsYW1wKHYsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2LCBtaW4pLCBtYXgpO1xufVxuZnVuY3Rpb24gdG9IZXhVdGlsKGFycikge1xuICBpZiAoVWludDhBcnJheS5wcm90b3R5cGUudG9IZXgpIHtcbiAgICByZXR1cm4gYXJyLnRvSGV4KCk7XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oYXJyLCBudW0gPT4gaGV4TnVtYmVyc1tudW1dKS5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gdG9CYXNlNjRVdGlsKGFycikge1xuICBpZiAoVWludDhBcnJheS5wcm90b3R5cGUudG9CYXNlNjQpIHtcbiAgICByZXR1cm4gYXJyLnRvQmFzZTY0KCk7XG4gIH1cbiAgcmV0dXJuIGJ0b2EoYnl0ZXNUb1N0cmluZyhhcnIpKTtcbn1cbmZ1bmN0aW9uIGZyb21CYXNlNjRVdGlsKHN0cikge1xuICBpZiAoVWludDhBcnJheS5mcm9tQmFzZTY0KSB7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbUJhc2U2NChzdHIpO1xuICB9XG4gIHJldHVybiBzdHJpbmdUb0J5dGVzKGF0b2Ioc3RyKSk7XG59XG5pZiAodHlwZW9mIFByb21pc2UudHJ5ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgUHJvbWlzZS50cnkgPSBmdW5jdGlvbiAoZm4sIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICB9KTtcbiAgfTtcbn1cbmlmICh0eXBlb2YgTWF0aC5zdW1QcmVjaXNlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgTWF0aC5zdW1QcmVjaXNlID0gZnVuY3Rpb24gKG51bWJlcnMpIHtcbiAgICByZXR1cm4gbnVtYmVycy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcbiAgfTtcbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZGlzcGxheV91dGlscy5qc1xuXG5jb25zdCBTVkdfTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG5jbGFzcyBQaXhlbHNQZXJJbmNoIHtcbiAgc3RhdGljIENTUyA9IDk2LjA7XG4gIHN0YXRpYyBQREYgPSA3Mi4wO1xuICBzdGF0aWMgUERGX1RPX0NTU19VTklUUyA9IHRoaXMuQ1NTIC8gdGhpcy5QREY7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaERhdGEodXJsLCB0eXBlID0gXCJ0ZXh0XCIpIHtcbiAgaWYgKGlzVmFsaWRGZXRjaFVybCh1cmwsIGRvY3VtZW50LmJhc2VVUkkpKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0KTtcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiYXJyYXlidWZmZXJcIjpcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICBjYXNlIFwiYmxvYlwiOlxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuYmxvYigpO1xuICAgICAgY2FzZSBcImpzb25cIjpcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICByZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgdXJsLCB0cnVlKTtcbiAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IHR5cGU7XG4gICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBpZiAocmVxdWVzdC5yZWFkeVN0YXRlICE9PSBYTUxIdHRwUmVxdWVzdC5ET05FKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMjAwIHx8IHJlcXVlc3Quc3RhdHVzID09PSAwKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJhcnJheWJ1ZmZlclwiOlxuICAgICAgICAgIGNhc2UgXCJibG9iXCI6XG4gICAgICAgICAgY2FzZSBcImpzb25cIjpcbiAgICAgICAgICAgIHJlc29sdmUocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlamVjdChuZXcgRXJyb3IocmVxdWVzdC5zdGF0dXNUZXh0KSk7XG4gICAgfTtcbiAgICByZXF1ZXN0LnNlbmQobnVsbCk7XG4gIH0pO1xufVxuY2xhc3MgUGFnZVZpZXdwb3J0IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHZpZXdCb3gsXG4gICAgdXNlclVuaXQsXG4gICAgc2NhbGUsXG4gICAgcm90YXRpb24sXG4gICAgb2Zmc2V0WCA9IDAsXG4gICAgb2Zmc2V0WSA9IDAsXG4gICAgZG9udEZsaXAgPSBmYWxzZVxuICB9KSB7XG4gICAgdGhpcy52aWV3Qm94ID0gdmlld0JveDtcbiAgICB0aGlzLnVzZXJVbml0ID0gdXNlclVuaXQ7XG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgIHRoaXMucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICB0aGlzLm9mZnNldFggPSBvZmZzZXRYO1xuICAgIHRoaXMub2Zmc2V0WSA9IG9mZnNldFk7XG4gICAgc2NhbGUgKj0gdXNlclVuaXQ7XG4gICAgY29uc3QgY2VudGVyWCA9ICh2aWV3Qm94WzJdICsgdmlld0JveFswXSkgLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSAodmlld0JveFszXSArIHZpZXdCb3hbMV0pIC8gMjtcbiAgICBsZXQgcm90YXRlQSwgcm90YXRlQiwgcm90YXRlQywgcm90YXRlRDtcbiAgICByb3RhdGlvbiAlPSAzNjA7XG4gICAgaWYgKHJvdGF0aW9uIDwgMCkge1xuICAgICAgcm90YXRpb24gKz0gMzYwO1xuICAgIH1cbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcm90YXRlQSA9IC0xO1xuICAgICAgICByb3RhdGVCID0gMDtcbiAgICAgICAgcm90YXRlQyA9IDA7XG4gICAgICAgIHJvdGF0ZUQgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJvdGF0ZUEgPSAwO1xuICAgICAgICByb3RhdGVCID0gMTtcbiAgICAgICAgcm90YXRlQyA9IDE7XG4gICAgICAgIHJvdGF0ZUQgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByb3RhdGVBID0gMDtcbiAgICAgICAgcm90YXRlQiA9IC0xO1xuICAgICAgICByb3RhdGVDID0gLTE7XG4gICAgICAgIHJvdGF0ZUQgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcm90YXRlQSA9IDE7XG4gICAgICAgIHJvdGF0ZUIgPSAwO1xuICAgICAgICByb3RhdGVDID0gMDtcbiAgICAgICAgcm90YXRlRCA9IC0xO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhZ2VWaWV3cG9ydDogSW52YWxpZCByb3RhdGlvbiwgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDkwIGRlZ3JlZXMuXCIpO1xuICAgIH1cbiAgICBpZiAoZG9udEZsaXApIHtcbiAgICAgIHJvdGF0ZUMgPSAtcm90YXRlQztcbiAgICAgIHJvdGF0ZUQgPSAtcm90YXRlRDtcbiAgICB9XG4gICAgbGV0IG9mZnNldENhbnZhc1gsIG9mZnNldENhbnZhc1k7XG4gICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG4gICAgaWYgKHJvdGF0ZUEgPT09IDApIHtcbiAgICAgIG9mZnNldENhbnZhc1ggPSBNYXRoLmFicyhjZW50ZXJZIC0gdmlld0JveFsxXSkgKiBzY2FsZSArIG9mZnNldFg7XG4gICAgICBvZmZzZXRDYW52YXNZID0gTWF0aC5hYnMoY2VudGVyWCAtIHZpZXdCb3hbMF0pICogc2NhbGUgKyBvZmZzZXRZO1xuICAgICAgd2lkdGggPSAodmlld0JveFszXSAtIHZpZXdCb3hbMV0pICogc2NhbGU7XG4gICAgICBoZWlnaHQgPSAodmlld0JveFsyXSAtIHZpZXdCb3hbMF0pICogc2NhbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldENhbnZhc1ggPSBNYXRoLmFicyhjZW50ZXJYIC0gdmlld0JveFswXSkgKiBzY2FsZSArIG9mZnNldFg7XG4gICAgICBvZmZzZXRDYW52YXNZID0gTWF0aC5hYnMoY2VudGVyWSAtIHZpZXdCb3hbMV0pICogc2NhbGUgKyBvZmZzZXRZO1xuICAgICAgd2lkdGggPSAodmlld0JveFsyXSAtIHZpZXdCb3hbMF0pICogc2NhbGU7XG4gICAgICBoZWlnaHQgPSAodmlld0JveFszXSAtIHZpZXdCb3hbMV0pICogc2NhbGU7XG4gICAgfVxuICAgIHRoaXMudHJhbnNmb3JtID0gW3JvdGF0ZUEgKiBzY2FsZSwgcm90YXRlQiAqIHNjYWxlLCByb3RhdGVDICogc2NhbGUsIHJvdGF0ZUQgKiBzY2FsZSwgb2Zmc2V0Q2FudmFzWCAtIHJvdGF0ZUEgKiBzY2FsZSAqIGNlbnRlclggLSByb3RhdGVDICogc2NhbGUgKiBjZW50ZXJZLCBvZmZzZXRDYW52YXNZIC0gcm90YXRlQiAqIHNjYWxlICogY2VudGVyWCAtIHJvdGF0ZUQgKiBzY2FsZSAqIGNlbnRlclldO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxuICBnZXQgcmF3RGltcygpIHtcbiAgICBjb25zdCBkaW1zID0gdGhpcy52aWV3Qm94O1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJyYXdEaW1zXCIsIHtcbiAgICAgIHBhZ2VXaWR0aDogZGltc1syXSAtIGRpbXNbMF0sXG4gICAgICBwYWdlSGVpZ2h0OiBkaW1zWzNdIC0gZGltc1sxXSxcbiAgICAgIHBhZ2VYOiBkaW1zWzBdLFxuICAgICAgcGFnZVk6IGRpbXNbMV1cbiAgICB9KTtcbiAgfVxuICBjbG9uZSh7XG4gICAgc2NhbGUgPSB0aGlzLnNjYWxlLFxuICAgIHJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbixcbiAgICBvZmZzZXRYID0gdGhpcy5vZmZzZXRYLFxuICAgIG9mZnNldFkgPSB0aGlzLm9mZnNldFksXG4gICAgZG9udEZsaXAgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFBhZ2VWaWV3cG9ydCh7XG4gICAgICB2aWV3Qm94OiB0aGlzLnZpZXdCb3guc2xpY2UoKSxcbiAgICAgIHVzZXJVbml0OiB0aGlzLnVzZXJVbml0LFxuICAgICAgc2NhbGUsXG4gICAgICByb3RhdGlvbixcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZLFxuICAgICAgZG9udEZsaXBcbiAgICB9KTtcbiAgfVxuICBjb252ZXJ0VG9WaWV3cG9ydFBvaW50KHgsIHkpIHtcbiAgICBjb25zdCBwID0gW3gsIHldO1xuICAgIFV0aWwuYXBwbHlUcmFuc2Zvcm0ocCwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIHJldHVybiBwO1xuICB9XG4gIGNvbnZlcnRUb1ZpZXdwb3J0UmVjdGFuZ2xlKHJlY3QpIHtcbiAgICBjb25zdCB0b3BMZWZ0ID0gW3JlY3RbMF0sIHJlY3RbMV1dO1xuICAgIFV0aWwuYXBwbHlUcmFuc2Zvcm0odG9wTGVmdCwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIGNvbnN0IGJvdHRvbVJpZ2h0ID0gW3JlY3RbMl0sIHJlY3RbM11dO1xuICAgIFV0aWwuYXBwbHlUcmFuc2Zvcm0oYm90dG9tUmlnaHQsIHRoaXMudHJhbnNmb3JtKTtcbiAgICByZXR1cm4gW3RvcExlZnRbMF0sIHRvcExlZnRbMV0sIGJvdHRvbVJpZ2h0WzBdLCBib3R0b21SaWdodFsxXV07XG4gIH1cbiAgY29udmVydFRvUGRmUG9pbnQoeCwgeSkge1xuICAgIGNvbnN0IHAgPSBbeCwgeV07XG4gICAgVXRpbC5hcHBseUludmVyc2VUcmFuc2Zvcm0ocCwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIHJldHVybiBwO1xuICB9XG59XG5jbGFzcyBSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnLCBleHRyYURlbGF5ID0gMCkge1xuICAgIHN1cGVyKG1zZywgXCJSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb25cIik7XG4gICAgdGhpcy5leHRyYURlbGF5ID0gZXh0cmFEZWxheTtcbiAgfVxufVxuZnVuY3Rpb24gaXNEYXRhU2NoZW1lKHVybCkge1xuICBjb25zdCBpaSA9IHVybC5sZW5ndGg7XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKGkgPCBpaSAmJiB1cmxbaV0udHJpbSgpID09PSBcIlwiKSB7XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiB1cmwuc3Vic3RyaW5nKGksIGkgKyA1KS50b0xvd2VyQ2FzZSgpID09PSBcImRhdGE6XCI7XG59XG5mdW5jdGlvbiBpc1BkZkZpbGUoZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHR5cGVvZiBmaWxlbmFtZSA9PT0gXCJzdHJpbmdcIiAmJiAvXFwucGRmJC9pLnRlc3QoZmlsZW5hbWUpO1xufVxuZnVuY3Rpb24gZ2V0RmlsZW5hbWVGcm9tVXJsKHVybCkge1xuICBbdXJsXSA9IHVybC5zcGxpdCgvWyM/XS8sIDEpO1xuICByZXR1cm4gdXJsLnN1YnN0cmluZyh1cmwubGFzdEluZGV4T2YoXCIvXCIpICsgMSk7XG59XG5mdW5jdGlvbiBnZXRQZGZGaWxlbmFtZUZyb21VcmwodXJsLCBkZWZhdWx0RmlsZW5hbWUgPSBcImRvY3VtZW50LnBkZlwiKSB7XG4gIGlmICh0eXBlb2YgdXJsICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRGaWxlbmFtZTtcbiAgfVxuICBpZiAoaXNEYXRhU2NoZW1lKHVybCkpIHtcbiAgICB3YXJuKCdnZXRQZGZGaWxlbmFtZUZyb21Vcmw6IGlnbm9yZSBcImRhdGE6XCItVVJMIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLicpO1xuICAgIHJldHVybiBkZWZhdWx0RmlsZW5hbWU7XG4gIH1cbiAgY29uc3QgcmVVUkkgPSAvXig/Oig/OlteOl0rOik/XFwvXFwvW14vXSspPyhbXj8jXSopKFxcP1teI10qKT8oIy4qKT8kLztcbiAgY29uc3QgcmVGaWxlbmFtZSA9IC9bXi8/Iz1dK1xcLnBkZlxcYig/IS4qXFwucGRmXFxiKS9pO1xuICBjb25zdCBzcGxpdFVSSSA9IHJlVVJJLmV4ZWModXJsKTtcbiAgbGV0IHN1Z2dlc3RlZEZpbGVuYW1lID0gcmVGaWxlbmFtZS5leGVjKHNwbGl0VVJJWzFdKSB8fCByZUZpbGVuYW1lLmV4ZWMoc3BsaXRVUklbMl0pIHx8IHJlRmlsZW5hbWUuZXhlYyhzcGxpdFVSSVszXSk7XG4gIGlmIChzdWdnZXN0ZWRGaWxlbmFtZSkge1xuICAgIHN1Z2dlc3RlZEZpbGVuYW1lID0gc3VnZ2VzdGVkRmlsZW5hbWVbMF07XG4gICAgaWYgKHN1Z2dlc3RlZEZpbGVuYW1lLmluY2x1ZGVzKFwiJVwiKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3VnZ2VzdGVkRmlsZW5hbWUgPSByZUZpbGVuYW1lLmV4ZWMoZGVjb2RlVVJJQ29tcG9uZW50KHN1Z2dlc3RlZEZpbGVuYW1lKSlbMF07XG4gICAgICB9IGNhdGNoIHt9XG4gICAgfVxuICB9XG4gIHJldHVybiBzdWdnZXN0ZWRGaWxlbmFtZSB8fCBkZWZhdWx0RmlsZW5hbWU7XG59XG5jbGFzcyBTdGF0VGltZXIge1xuICBzdGFydGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGltZXMgPSBbXTtcbiAgdGltZShuYW1lKSB7XG4gICAgaWYgKG5hbWUgaW4gdGhpcy5zdGFydGVkKSB7XG4gICAgICB3YXJuKGBUaW1lciBpcyBhbHJlYWR5IHJ1bm5pbmcgZm9yICR7bmFtZX1gKTtcbiAgICB9XG4gICAgdGhpcy5zdGFydGVkW25hbWVdID0gRGF0ZS5ub3coKTtcbiAgfVxuICB0aW1lRW5kKG5hbWUpIHtcbiAgICBpZiAoIShuYW1lIGluIHRoaXMuc3RhcnRlZCkpIHtcbiAgICAgIHdhcm4oYFRpbWVyIGhhcyBub3QgYmVlbiBzdGFydGVkIGZvciAke25hbWV9YCk7XG4gICAgfVxuICAgIHRoaXMudGltZXMucHVzaCh7XG4gICAgICBuYW1lLFxuICAgICAgc3RhcnQ6IHRoaXMuc3RhcnRlZFtuYW1lXSxcbiAgICAgIGVuZDogRGF0ZS5ub3coKVxuICAgIH0pO1xuICAgIGRlbGV0ZSB0aGlzLnN0YXJ0ZWRbbmFtZV07XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3Qgb3V0QnVmID0gW107XG4gICAgbGV0IGxvbmdlc3QgPSAwO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgbmFtZVxuICAgIH0gb2YgdGhpcy50aW1lcykge1xuICAgICAgbG9uZ2VzdCA9IE1hdGgubWF4KG5hbWUubGVuZ3RoLCBsb25nZXN0KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgc3RhcnQsXG4gICAgICBlbmRcbiAgICB9IG9mIHRoaXMudGltZXMpIHtcbiAgICAgIG91dEJ1Zi5wdXNoKGAke25hbWUucGFkRW5kKGxvbmdlc3QpfSAke2VuZCAtIHN0YXJ0fW1zXFxuYCk7XG4gICAgfVxuICAgIHJldHVybiBvdXRCdWYuam9pbihcIlwiKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNWYWxpZEZldGNoVXJsKHVybCwgYmFzZVVybCkge1xuICBjb25zdCByZXMgPSBiYXNlVXJsID8gVVJMLnBhcnNlKHVybCwgYmFzZVVybCkgOiBVUkwucGFyc2UodXJsKTtcbiAgcmV0dXJuIHJlcz8ucHJvdG9jb2wgPT09IFwiaHR0cDpcIiB8fCByZXM/LnByb3RvY29sID09PSBcImh0dHBzOlwiO1xufVxuZnVuY3Rpb24gbm9Db250ZXh0TWVudShlKSB7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbn1cbmZ1bmN0aW9uIHN0b3BFdmVudChlKSB7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbiAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbn1cbmZ1bmN0aW9uIGRlcHJlY2F0ZWQoZGV0YWlscykge1xuICBjb25zb2xlLmxvZyhcIkRlcHJlY2F0ZWQgQVBJIHVzYWdlOiBcIiArIGRldGFpbHMpO1xufVxuY2xhc3MgUERGRGF0ZVN0cmluZyB7XG4gIHN0YXRpYyAjcmVnZXg7XG4gIHN0YXRpYyB0b0RhdGVPYmplY3QoaW5wdXQpIHtcbiAgICBpZiAoIWlucHV0IHx8IHR5cGVvZiBpbnB1dCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRoaXMuI3JlZ2V4IHx8PSBuZXcgUmVnRXhwKFwiXkQ6XCIgKyBcIihcXFxcZHs0fSlcIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFtafCt8LV0pP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCInP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCInP1wiKTtcbiAgICBjb25zdCBtYXRjaGVzID0gdGhpcy4jcmVnZXguZXhlYyhpbnB1dCk7XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeWVhciA9IHBhcnNlSW50KG1hdGNoZXNbMV0sIDEwKTtcbiAgICBsZXQgbW9udGggPSBwYXJzZUludChtYXRjaGVzWzJdLCAxMCk7XG4gICAgbW9udGggPSBtb250aCA+PSAxICYmIG1vbnRoIDw9IDEyID8gbW9udGggLSAxIDogMDtcbiAgICBsZXQgZGF5ID0gcGFyc2VJbnQobWF0Y2hlc1szXSwgMTApO1xuICAgIGRheSA9IGRheSA+PSAxICYmIGRheSA8PSAzMSA/IGRheSA6IDE7XG4gICAgbGV0IGhvdXIgPSBwYXJzZUludChtYXRjaGVzWzRdLCAxMCk7XG4gICAgaG91ciA9IGhvdXIgPj0gMCAmJiBob3VyIDw9IDIzID8gaG91ciA6IDA7XG4gICAgbGV0IG1pbnV0ZSA9IHBhcnNlSW50KG1hdGNoZXNbNV0sIDEwKTtcbiAgICBtaW51dGUgPSBtaW51dGUgPj0gMCAmJiBtaW51dGUgPD0gNTkgPyBtaW51dGUgOiAwO1xuICAgIGxldCBzZWNvbmQgPSBwYXJzZUludChtYXRjaGVzWzZdLCAxMCk7XG4gICAgc2Vjb25kID0gc2Vjb25kID49IDAgJiYgc2Vjb25kIDw9IDU5ID8gc2Vjb25kIDogMDtcbiAgICBjb25zdCB1bml2ZXJzYWxUaW1lUmVsYXRpb24gPSBtYXRjaGVzWzddIHx8IFwiWlwiO1xuICAgIGxldCBvZmZzZXRIb3VyID0gcGFyc2VJbnQobWF0Y2hlc1s4XSwgMTApO1xuICAgIG9mZnNldEhvdXIgPSBvZmZzZXRIb3VyID49IDAgJiYgb2Zmc2V0SG91ciA8PSAyMyA/IG9mZnNldEhvdXIgOiAwO1xuICAgIGxldCBvZmZzZXRNaW51dGUgPSBwYXJzZUludChtYXRjaGVzWzldLCAxMCkgfHwgMDtcbiAgICBvZmZzZXRNaW51dGUgPSBvZmZzZXRNaW51dGUgPj0gMCAmJiBvZmZzZXRNaW51dGUgPD0gNTkgPyBvZmZzZXRNaW51dGUgOiAwO1xuICAgIGlmICh1bml2ZXJzYWxUaW1lUmVsYXRpb24gPT09IFwiLVwiKSB7XG4gICAgICBob3VyICs9IG9mZnNldEhvdXI7XG4gICAgICBtaW51dGUgKz0gb2Zmc2V0TWludXRlO1xuICAgIH0gZWxzZSBpZiAodW5pdmVyc2FsVGltZVJlbGF0aW9uID09PSBcIitcIikge1xuICAgICAgaG91ciAtPSBvZmZzZXRIb3VyO1xuICAgICAgbWludXRlIC09IG9mZnNldE1pbnV0ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFhmYVBhZ2VWaWV3cG9ydCh4ZmFQYWdlLCB7XG4gIHNjYWxlID0gMSxcbiAgcm90YXRpb24gPSAwXG59KSB7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IHhmYVBhZ2UuYXR0cmlidXRlcy5zdHlsZTtcbiAgY29uc3Qgdmlld0JveCA9IFswLCAwLCBwYXJzZUludCh3aWR0aCksIHBhcnNlSW50KGhlaWdodCldO1xuICByZXR1cm4gbmV3IFBhZ2VWaWV3cG9ydCh7XG4gICAgdmlld0JveCxcbiAgICB1c2VyVW5pdDogMSxcbiAgICBzY2FsZSxcbiAgICByb3RhdGlvblxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFJHQihjb2xvcikge1xuICBpZiAoY29sb3Iuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICBjb25zdCBjb2xvclJHQiA9IHBhcnNlSW50KGNvbG9yLnNsaWNlKDEpLCAxNik7XG4gICAgcmV0dXJuIFsoY29sb3JSR0IgJiAweGZmMDAwMCkgPj4gMTYsIChjb2xvclJHQiAmIDB4MDBmZjAwKSA+PiA4LCBjb2xvclJHQiAmIDB4MDAwMGZmXTtcbiAgfVxuICBpZiAoY29sb3Iuc3RhcnRzV2l0aChcInJnYihcIikpIHtcbiAgICByZXR1cm4gY29sb3Iuc2xpY2UoNCwgLTEpLnNwbGl0KFwiLFwiKS5tYXAoeCA9PiBwYXJzZUludCh4KSk7XG4gIH1cbiAgaWYgKGNvbG9yLnN0YXJ0c1dpdGgoXCJyZ2JhKFwiKSkge1xuICAgIHJldHVybiBjb2xvci5zbGljZSg1LCAtMSkuc3BsaXQoXCIsXCIpLm1hcCh4ID0+IHBhcnNlSW50KHgpKS5zbGljZSgwLCAzKTtcbiAgfVxuICB3YXJuKGBOb3QgYSB2YWxpZCBjb2xvciBmb3JtYXQ6IFwiJHtjb2xvcn1cImApO1xuICByZXR1cm4gWzAsIDAsIDBdO1xufVxuZnVuY3Rpb24gZ2V0Q29sb3JWYWx1ZXMoY29sb3JzKSB7XG4gIGNvbnN0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgc3Bhbi5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgc3Bhbi5zdHlsZS5jb2xvclNjaGVtZSA9IFwib25seSBsaWdodFwiO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZChzcGFuKTtcbiAgZm9yIChjb25zdCBuYW1lIG9mIGNvbG9ycy5rZXlzKCkpIHtcbiAgICBzcGFuLnN0eWxlLmNvbG9yID0gbmFtZTtcbiAgICBjb25zdCBjb21wdXRlZENvbG9yID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoc3BhbikuY29sb3I7XG4gICAgY29sb3JzLnNldChuYW1lLCBnZXRSR0IoY29tcHV0ZWRDb2xvcikpO1xuICB9XG4gIHNwYW4ucmVtb3ZlKCk7XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCkge1xuICBjb25zdCB7XG4gICAgYSxcbiAgICBiLFxuICAgIGMsXG4gICAgZCxcbiAgICBlLFxuICAgIGZcbiAgfSA9IGN0eC5nZXRUcmFuc2Zvcm0oKTtcbiAgcmV0dXJuIFthLCBiLCBjLCBkLCBlLCBmXTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCkge1xuICBjb25zdCB7XG4gICAgYSxcbiAgICBiLFxuICAgIGMsXG4gICAgZCxcbiAgICBlLFxuICAgIGZcbiAgfSA9IGN0eC5nZXRUcmFuc2Zvcm0oKS5pbnZlcnRTZWxmKCk7XG4gIHJldHVybiBbYSwgYiwgYywgZCwgZSwgZl07XG59XG5mdW5jdGlvbiBzZXRMYXllckRpbWVuc2lvbnMoZGl2LCB2aWV3cG9ydCwgbXVzdEZsaXAgPSBmYWxzZSwgbXVzdFJvdGF0ZSA9IHRydWUpIHtcbiAgaWYgKHZpZXdwb3J0IGluc3RhbmNlb2YgUGFnZVZpZXdwb3J0KSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodFxuICAgIH0gPSB2aWV3cG9ydC5yYXdEaW1zO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IGRpdjtcbiAgICBjb25zdCB1c2VSb3VuZCA9IHV0aWxfRmVhdHVyZVRlc3QuaXNDU1NSb3VuZFN1cHBvcnRlZDtcbiAgICBjb25zdCB3ID0gYHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikgKiAke3BhZ2VXaWR0aH1weGAsXG4gICAgICBoID0gYHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikgKiAke3BhZ2VIZWlnaHR9cHhgO1xuICAgIGNvbnN0IHdpZHRoU3RyID0gdXNlUm91bmQgPyBgcm91bmQoZG93biwgJHt3fSwgdmFyKC0tc2NhbGUtcm91bmQteCkpYCA6IGBjYWxjKCR7d30pYCxcbiAgICAgIGhlaWdodFN0ciA9IHVzZVJvdW5kID8gYHJvdW5kKGRvd24sICR7aH0sIHZhcigtLXNjYWxlLXJvdW5kLXkpKWAgOiBgY2FsYygke2h9KWA7XG4gICAgaWYgKCFtdXN0RmxpcCB8fCB2aWV3cG9ydC5yb3RhdGlvbiAlIDE4MCA9PT0gMCkge1xuICAgICAgc3R5bGUud2lkdGggPSB3aWR0aFN0cjtcbiAgICAgIHN0eWxlLmhlaWdodCA9IGhlaWdodFN0cjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUud2lkdGggPSBoZWlnaHRTdHI7XG4gICAgICBzdHlsZS5oZWlnaHQgPSB3aWR0aFN0cjtcbiAgICB9XG4gIH1cbiAgaWYgKG11c3RSb3RhdGUpIHtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1tYWluLXJvdGF0aW9uXCIsIHZpZXdwb3J0LnJvdGF0aW9uKTtcbiAgfVxufVxuY2xhc3MgT3V0cHV0U2NhbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBwaXhlbFJhdGlvXG4gICAgfSA9IE91dHB1dFNjYWxlO1xuICAgIHRoaXMuc3ggPSBwaXhlbFJhdGlvO1xuICAgIHRoaXMuc3kgPSBwaXhlbFJhdGlvO1xuICB9XG4gIGdldCBzY2FsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3ggIT09IDEgfHwgdGhpcy5zeSAhPT0gMTtcbiAgfVxuICBnZXQgc3ltbWV0cmljKCkge1xuICAgIHJldHVybiB0aGlzLnN4ID09PSB0aGlzLnN5O1xuICB9XG4gIGxpbWl0Q2FudmFzKHdpZHRoLCBoZWlnaHQsIG1heFBpeGVscywgbWF4RGltKSB7XG4gICAgbGV0IG1heEFyZWFTY2FsZSA9IEluZmluaXR5LFxuICAgICAgbWF4V2lkdGhTY2FsZSA9IEluZmluaXR5LFxuICAgICAgbWF4SGVpZ2h0U2NhbGUgPSBJbmZpbml0eTtcbiAgICBpZiAobWF4UGl4ZWxzID4gMCkge1xuICAgICAgbWF4QXJlYVNjYWxlID0gTWF0aC5zcXJ0KG1heFBpeGVscyAvICh3aWR0aCAqIGhlaWdodCkpO1xuICAgIH1cbiAgICBpZiAobWF4RGltICE9PSAtMSkge1xuICAgICAgbWF4V2lkdGhTY2FsZSA9IG1heERpbSAvIHdpZHRoO1xuICAgICAgbWF4SGVpZ2h0U2NhbGUgPSBtYXhEaW0gLyBoZWlnaHQ7XG4gICAgfVxuICAgIGNvbnN0IG1heFNjYWxlID0gTWF0aC5taW4obWF4QXJlYVNjYWxlLCBtYXhXaWR0aFNjYWxlLCBtYXhIZWlnaHRTY2FsZSk7XG4gICAgaWYgKHRoaXMuc3ggPiBtYXhTY2FsZSB8fCB0aGlzLnN5ID4gbWF4U2NhbGUpIHtcbiAgICAgIHRoaXMuc3ggPSBtYXhTY2FsZTtcbiAgICAgIHRoaXMuc3kgPSBtYXhTY2FsZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIGdldCBwaXhlbFJhdGlvKCkge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgfVxufVxuY29uc3QgU3VwcG9ydGVkSW1hZ2VNaW1lVHlwZXMgPSBbXCJpbWFnZS9hcG5nXCIsIFwiaW1hZ2UvYXZpZlwiLCBcImltYWdlL2JtcFwiLCBcImltYWdlL2dpZlwiLCBcImltYWdlL2pwZWdcIiwgXCJpbWFnZS9wbmdcIiwgXCJpbWFnZS9zdmcreG1sXCIsIFwiaW1hZ2Uvd2VicFwiLCBcImltYWdlL3gtaWNvblwiXTtcblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL3Rvb2xiYXIuanNcblxuY2xhc3MgRWRpdG9yVG9vbGJhciB7XG4gICN0b29sYmFyID0gbnVsbDtcbiAgI2NvbG9yUGlja2VyID0gbnVsbDtcbiAgI2VkaXRvcjtcbiAgI2J1dHRvbnMgPSBudWxsO1xuICAjYWx0VGV4dCA9IG51bGw7XG4gICNzaWduYXR1cmVEZXNjcmlwdGlvbkJ1dHRvbiA9IG51bGw7XG4gIHN0YXRpYyAjbDEwblJlbW92ZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvciA9IGVkaXRvcjtcbiAgICBFZGl0b3JUb29sYmFyLiNsMTBuUmVtb3ZlIHx8PSBPYmplY3QuZnJlZXplKHtcbiAgICAgIGZyZWV0ZXh0OiBcInBkZmpzLWVkaXRvci1yZW1vdmUtZnJlZXRleHQtYnV0dG9uXCIsXG4gICAgICBoaWdobGlnaHQ6IFwicGRmanMtZWRpdG9yLXJlbW92ZS1oaWdobGlnaHQtYnV0dG9uXCIsXG4gICAgICBpbms6IFwicGRmanMtZWRpdG9yLXJlbW92ZS1pbmstYnV0dG9uXCIsXG4gICAgICBzdGFtcDogXCJwZGZqcy1lZGl0b3ItcmVtb3ZlLXN0YW1wLWJ1dHRvblwiLFxuICAgICAgc2lnbmF0dXJlOiBcInBkZmpzLWVkaXRvci1yZW1vdmUtc2lnbmF0dXJlLWJ1dHRvblwiXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IGVkaXRUb29sYmFyID0gdGhpcy4jdG9vbGJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZWRpdFRvb2xiYXIuY2xhc3NMaXN0LmFkZChcImVkaXRUb29sYmFyXCIsIFwiaGlkZGVuXCIpO1xuICAgIGVkaXRUb29sYmFyLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJ0b29sYmFyXCIpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgZWRpdFRvb2xiYXIuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGVkaXRUb29sYmFyLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBFZGl0b3JUb29sYmFyLiNwb2ludGVyRG93biwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3QgYnV0dG9ucyA9IHRoaXMuI2J1dHRvbnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGJ1dHRvbnMuY2xhc3NOYW1lID0gXCJidXR0b25zXCI7XG4gICAgZWRpdFRvb2xiYXIuYXBwZW5kKGJ1dHRvbnMpO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy4jZWRpdG9yLnRvb2xiYXJQb3NpdGlvbjtcbiAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3R5bGVcbiAgICAgIH0gPSBlZGl0VG9vbGJhcjtcbiAgICAgIGNvbnN0IHggPSB0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5kaXJlY3Rpb24gPT09IFwibHRyXCIgPyAxIC0gcG9zaXRpb25bMF0gOiBwb3NpdGlvblswXTtcbiAgICAgIHN0eWxlLmluc2V0SW5saW5lRW5kID0gYCR7MTAwICogeH0lYDtcbiAgICAgIHN0eWxlLnRvcCA9IGBjYWxjKCR7MTAwICogcG9zaXRpb25bMV19JSArIHZhcigtLWVkaXRvci10b29sYmFyLXZlcnQtb2Zmc2V0KSlgO1xuICAgIH1cbiAgICB0aGlzLiNhZGREZWxldGVCdXR0b24oKTtcbiAgICByZXR1cm4gZWRpdFRvb2xiYXI7XG4gIH1cbiAgZ2V0IGRpdigpIHtcbiAgICByZXR1cm4gdGhpcy4jdG9vbGJhcjtcbiAgfVxuICBzdGF0aWMgI3BvaW50ZXJEb3duKGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG4gICNmb2N1c0luKGUpIHtcbiAgICB0aGlzLiNlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IGZhbHNlO1xuICAgIHN0b3BFdmVudChlKTtcbiAgfVxuICAjZm9jdXNPdXQoZSkge1xuICAgIHRoaXMuI2VkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgICBzdG9wRXZlbnQoZSk7XG4gIH1cbiAgI2FkZExpc3RlbmVyc1RvRWxlbWVudChlbGVtZW50KSB7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuI2ZvY3VzSW4uYmluZCh0aGlzKSwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHRoaXMuI2ZvY3VzT3V0LmJpbmQodGhpcyksIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICBoaWRlKCkge1xuICAgIHRoaXMuI3Rvb2xiYXIuY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKTtcbiAgICB0aGlzLiNjb2xvclBpY2tlcj8uaGlkZURyb3Bkb3duKCk7XG4gIH1cbiAgc2hvdygpIHtcbiAgICB0aGlzLiN0b29sYmFyLmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIik7XG4gICAgdGhpcy4jYWx0VGV4dD8uc2hvd24oKTtcbiAgfVxuICAjYWRkRGVsZXRlQnV0dG9uKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVkaXRvclR5cGUsXG4gICAgICBfdWlNYW5hZ2VyXG4gICAgfSA9IHRoaXMuI2VkaXRvcjtcbiAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGJ1dHRvbi5jbGFzc05hbWUgPSBcImRlbGV0ZVwiO1xuICAgIGJ1dHRvbi50YWJJbmRleCA9IDA7XG4gICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBFZGl0b3JUb29sYmFyLiNsMTBuUmVtb3ZlW2VkaXRvclR5cGVdKTtcbiAgICB0aGlzLiNhZGRMaXN0ZW5lcnNUb0VsZW1lbnQoYnV0dG9uKTtcbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGUgPT4ge1xuICAgICAgX3VpTWFuYWdlci5kZWxldGUoKTtcbiAgICB9LCB7XG4gICAgICBzaWduYWw6IF91aU1hbmFnZXIuX3NpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuI2J1dHRvbnMuYXBwZW5kKGJ1dHRvbik7XG4gIH1cbiAgZ2V0ICNkaXZpZGVyKCkge1xuICAgIGNvbnN0IGRpdmlkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdmlkZXIuY2xhc3NOYW1lID0gXCJkaXZpZGVyXCI7XG4gICAgcmV0dXJuIGRpdmlkZXI7XG4gIH1cbiAgYXN5bmMgYWRkQWx0VGV4dChhbHRUZXh0KSB7XG4gICAgY29uc3QgYnV0dG9uID0gYXdhaXQgYWx0VGV4dC5yZW5kZXIoKTtcbiAgICB0aGlzLiNhZGRMaXN0ZW5lcnNUb0VsZW1lbnQoYnV0dG9uKTtcbiAgICB0aGlzLiNidXR0b25zLnByZXBlbmQoYnV0dG9uLCB0aGlzLiNkaXZpZGVyKTtcbiAgICB0aGlzLiNhbHRUZXh0ID0gYWx0VGV4dDtcbiAgfVxuICBhZGRDb2xvclBpY2tlcihjb2xvclBpY2tlcikge1xuICAgIHRoaXMuI2NvbG9yUGlja2VyID0gY29sb3JQaWNrZXI7XG4gICAgY29uc3QgYnV0dG9uID0gY29sb3JQaWNrZXIucmVuZGVyQnV0dG9uKCk7XG4gICAgdGhpcy4jYWRkTGlzdGVuZXJzVG9FbGVtZW50KGJ1dHRvbik7XG4gICAgdGhpcy4jYnV0dG9ucy5wcmVwZW5kKGJ1dHRvbiwgdGhpcy4jZGl2aWRlcik7XG4gIH1cbiAgYXN5bmMgYWRkRWRpdFNpZ25hdHVyZUJ1dHRvbihzaWduYXR1cmVNYW5hZ2VyKSB7XG4gICAgY29uc3QgYnV0dG9uID0gdGhpcy4jc2lnbmF0dXJlRGVzY3JpcHRpb25CdXR0b24gPSBhd2FpdCBzaWduYXR1cmVNYW5hZ2VyLnJlbmRlckVkaXRCdXR0b24odGhpcy4jZWRpdG9yKTtcbiAgICB0aGlzLiNhZGRMaXN0ZW5lcnNUb0VsZW1lbnQoYnV0dG9uKTtcbiAgICB0aGlzLiNidXR0b25zLnByZXBlbmQoYnV0dG9uLCB0aGlzLiNkaXZpZGVyKTtcbiAgfVxuICB1cGRhdGVFZGl0U2lnbmF0dXJlQnV0dG9uKGRlc2NyaXB0aW9uKSB7XG4gICAgaWYgKHRoaXMuI3NpZ25hdHVyZURlc2NyaXB0aW9uQnV0dG9uKSB7XG4gICAgICB0aGlzLiNzaWduYXR1cmVEZXNjcmlwdGlvbkJ1dHRvbi50aXRsZSA9IGRlc2NyaXB0aW9uO1xuICAgIH1cbiAgfVxuICByZW1vdmUoKSB7XG4gICAgdGhpcy4jdG9vbGJhci5yZW1vdmUoKTtcbiAgICB0aGlzLiNjb2xvclBpY2tlcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuI2NvbG9yUGlja2VyID0gbnVsbDtcbiAgfVxufVxuY2xhc3MgSGlnaGxpZ2h0VG9vbGJhciB7XG4gICNidXR0b25zID0gbnVsbDtcbiAgI3Rvb2xiYXIgPSBudWxsO1xuICAjdWlNYW5hZ2VyO1xuICBjb25zdHJ1Y3Rvcih1aU1hbmFnZXIpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIgPSB1aU1hbmFnZXI7XG4gIH1cbiAgI3JlbmRlcigpIHtcbiAgICBjb25zdCBlZGl0VG9vbGJhciA9IHRoaXMuI3Rvb2xiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGVkaXRUb29sYmFyLmNsYXNzTmFtZSA9IFwiZWRpdFRvb2xiYXJcIjtcbiAgICBlZGl0VG9vbGJhci5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwidG9vbGJhclwiKTtcbiAgICBlZGl0VG9vbGJhci5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsOiB0aGlzLiN1aU1hbmFnZXIuX3NpZ25hbFxuICAgIH0pO1xuICAgIGNvbnN0IGJ1dHRvbnMgPSB0aGlzLiNidXR0b25zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBidXR0b25zLmNsYXNzTmFtZSA9IFwiYnV0dG9uc1wiO1xuICAgIGVkaXRUb29sYmFyLmFwcGVuZChidXR0b25zKTtcbiAgICB0aGlzLiNhZGRIaWdobGlnaHRCdXR0b24oKTtcbiAgICByZXR1cm4gZWRpdFRvb2xiYXI7XG4gIH1cbiAgI2dldExhc3RQb2ludChib3hlcywgaXNMVFIpIHtcbiAgICBsZXQgbGFzdFkgPSAwO1xuICAgIGxldCBsYXN0WCA9IDA7XG4gICAgZm9yIChjb25zdCBib3ggb2YgYm94ZXMpIHtcbiAgICAgIGNvbnN0IHkgPSBib3gueSArIGJveC5oZWlnaHQ7XG4gICAgICBpZiAoeSA8IGxhc3RZKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgeCA9IGJveC54ICsgKGlzTFRSID8gYm94LndpZHRoIDogMCk7XG4gICAgICBpZiAoeSA+IGxhc3RZKSB7XG4gICAgICAgIGxhc3RYID0geDtcbiAgICAgICAgbGFzdFkgPSB5O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xUUikge1xuICAgICAgICBpZiAoeCA+IGxhc3RYKSB7XG4gICAgICAgICAgbGFzdFggPSB4O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHggPCBsYXN0WCkge1xuICAgICAgICBsYXN0WCA9IHg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbaXNMVFIgPyAxIC0gbGFzdFggOiBsYXN0WCwgbGFzdFldO1xuICB9XG4gIHNob3cocGFyZW50LCBib3hlcywgaXNMVFIpIHtcbiAgICBjb25zdCBbeCwgeV0gPSB0aGlzLiNnZXRMYXN0UG9pbnQoYm94ZXMsIGlzTFRSKTtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLiN0b29sYmFyIHx8PSB0aGlzLiNyZW5kZXIoKTtcbiAgICBwYXJlbnQuYXBwZW5kKHRoaXMuI3Rvb2xiYXIpO1xuICAgIHN0eWxlLmluc2V0SW5saW5lRW5kID0gYCR7MTAwICogeH0lYDtcbiAgICBzdHlsZS50b3AgPSBgY2FsYygkezEwMCAqIHl9JSArIHZhcigtLWVkaXRvci10b29sYmFyLXZlcnQtb2Zmc2V0KSlgO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgdGhpcy4jdG9vbGJhci5yZW1vdmUoKTtcbiAgfVxuICAjYWRkSGlnaGxpZ2h0QnV0dG9uKCkge1xuICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgYnV0dG9uLmNsYXNzTmFtZSA9IFwiaGlnaGxpZ2h0QnV0dG9uXCI7XG4gICAgYnV0dG9uLnRhYkluZGV4ID0gMDtcbiAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIGBwZGZqcy1oaWdobGlnaHQtZmxvYXRpbmctYnV0dG9uMWApO1xuICAgIGNvbnN0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBidXR0b24uYXBwZW5kKHNwYW4pO1xuICAgIHNwYW4uY2xhc3NOYW1lID0gXCJ2aXN1YWxseUhpZGRlblwiO1xuICAgIHNwYW4uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtaGlnaGxpZ2h0LWZsb2F0aW5nLWJ1dHRvbi1sYWJlbFwiKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiN1aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLmhpZ2hsaWdodFNlbGVjdGlvbihcImZsb2F0aW5nX2J1dHRvblwiKTtcbiAgICB9LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLiNidXR0b25zLmFwcGVuZChidXR0b24pO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci90b29scy5qc1xuXG5cblxuZnVuY3Rpb24gYmluZEV2ZW50cyhvYmosIGVsZW1lbnQsIG5hbWVzKSB7XG4gIGZvciAoY29uc3QgbmFtZSBvZiBuYW1lcykge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBvYmpbbmFtZV0uYmluZChvYmopKTtcbiAgfVxufVxuY2xhc3MgSWRNYW5hZ2VyIHtcbiAgI2lkID0gMDtcbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiBgJHtBbm5vdGF0aW9uRWRpdG9yUHJlZml4fSR7dGhpcy4jaWQrK31gO1xuICB9XG59XG5jbGFzcyBJbWFnZU1hbmFnZXIge1xuICAjYmFzZUlkID0gZ2V0VXVpZCgpO1xuICAjaWQgPSAwO1xuICAjY2FjaGUgPSBudWxsO1xuICBzdGF0aWMgZ2V0IF9pc1NWR0ZpdHRpbmdDYW52YXMoKSB7XG4gICAgY29uc3Qgc3ZnID0gYGRhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PVVURi04LDxzdmcgdmlld0JveD1cIjAgMCAxIDFcIiB3aWR0aD1cIjFcIiBoZWlnaHQ9XCIxXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxyZWN0IHdpZHRoPVwiMVwiIGhlaWdodD1cIjFcIiBzdHlsZT1cImZpbGw6cmVkO1wiLz48L3N2Zz5gO1xuICAgIGNvbnN0IGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMyk7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIGltYWdlLnNyYyA9IHN2ZztcbiAgICBjb25zdCBwcm9taXNlID0gaW1hZ2UuZGVjb2RlKCkudGhlbigoKSA9PiB7XG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCAxLCAxLCAwLCAwLCAxLCAzKTtcbiAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhLmJ1ZmZlcilbMF0gPT09IDA7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9pc1NWR0ZpdHRpbmdDYW52YXNcIiwgcHJvbWlzZSk7XG4gIH1cbiAgYXN5bmMgI2dldChrZXksIHJhd0RhdGEpIHtcbiAgICB0aGlzLiNjYWNoZSB8fD0gbmV3IE1hcCgpO1xuICAgIGxldCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZGF0YT8uYml0bWFwKSB7XG4gICAgICBkYXRhLnJlZkNvdW50ZXIgKz0gMTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgZGF0YSB8fD0ge1xuICAgICAgICBiaXRtYXA6IG51bGwsXG4gICAgICAgIGlkOiBgaW1hZ2VfJHt0aGlzLiNiYXNlSWR9XyR7dGhpcy4jaWQrK31gLFxuICAgICAgICByZWZDb3VudGVyOiAwLFxuICAgICAgICBpc1N2ZzogZmFsc2VcbiAgICAgIH07XG4gICAgICBsZXQgaW1hZ2U7XG4gICAgICBpZiAodHlwZW9mIHJhd0RhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZGF0YS51cmwgPSByYXdEYXRhO1xuICAgICAgICBpbWFnZSA9IGF3YWl0IGZldGNoRGF0YShyYXdEYXRhLCBcImJsb2JcIik7XG4gICAgICB9IGVsc2UgaWYgKHJhd0RhdGEgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgIGltYWdlID0gZGF0YS5maWxlID0gcmF3RGF0YTtcbiAgICAgIH0gZWxzZSBpZiAocmF3RGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgaW1hZ2UgPSByYXdEYXRhO1xuICAgICAgfVxuICAgICAgaWYgKGltYWdlLnR5cGUgPT09IFwiaW1hZ2Uvc3ZnK3htbFwiKSB7XG4gICAgICAgIGNvbnN0IG11c3RSZW1vdmVBc3BlY3RSYXRpb1Byb21pc2UgPSBJbWFnZU1hbmFnZXIuX2lzU1ZHRml0dGluZ0NhbnZhcztcbiAgICAgICAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIGNvbnN0IGltYWdlRWxlbWVudCA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBjb25zdCBpbWFnZVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgaW1hZ2VFbGVtZW50Lm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGRhdGEuYml0bWFwID0gaW1hZ2VFbGVtZW50O1xuICAgICAgICAgICAgZGF0YS5pc1N2ZyA9IHRydWU7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGRhdGEuc3ZnVXJsID0gZmlsZVJlYWRlci5yZXN1bHQ7XG4gICAgICAgICAgICBpbWFnZUVsZW1lbnQuc3JjID0gKGF3YWl0IG11c3RSZW1vdmVBc3BlY3RSYXRpb1Byb21pc2UpID8gYCR7dXJsfSNzdmdWaWV3KHByZXNlcnZlQXNwZWN0UmF0aW8obm9uZSkpYCA6IHVybDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGltYWdlRWxlbWVudC5vbmVycm9yID0gZmlsZVJlYWRlci5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKGltYWdlKTtcbiAgICAgICAgYXdhaXQgaW1hZ2VQcm9taXNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS5iaXRtYXAgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChpbWFnZSk7XG4gICAgICB9XG4gICAgICBkYXRhLnJlZkNvdW50ZXIgPSAxO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHdhcm4oZSk7XG4gICAgICBkYXRhID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jY2FjaGUuc2V0KGtleSwgZGF0YSk7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMuI2NhY2hlLnNldChkYXRhLmlkLCBkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgYXN5bmMgZ2V0RnJvbUZpbGUoZmlsZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxhc3RNb2RpZmllZCxcbiAgICAgIG5hbWUsXG4gICAgICBzaXplLFxuICAgICAgdHlwZVxuICAgIH0gPSBmaWxlO1xuICAgIHJldHVybiB0aGlzLiNnZXQoYCR7bGFzdE1vZGlmaWVkfV8ke25hbWV9XyR7c2l6ZX1fJHt0eXBlfWAsIGZpbGUpO1xuICB9XG4gIGFzeW5jIGdldEZyb21VcmwodXJsKSB7XG4gICAgcmV0dXJuIHRoaXMuI2dldCh1cmwsIHVybCk7XG4gIH1cbiAgYXN5bmMgZ2V0RnJvbUJsb2IoaWQsIGJsb2JQcm9taXNlKSB7XG4gICAgY29uc3QgYmxvYiA9IGF3YWl0IGJsb2JQcm9taXNlO1xuICAgIHJldHVybiB0aGlzLiNnZXQoaWQsIGJsb2IpO1xuICB9XG4gIGFzeW5jIGdldEZyb21JZChpZCkge1xuICAgIHRoaXMuI2NhY2hlIHx8PSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuI2NhY2hlLmdldChpZCk7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGRhdGEuYml0bWFwKSB7XG4gICAgICBkYXRhLnJlZkNvdW50ZXIgKz0gMTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAoZGF0YS5maWxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRGcm9tRmlsZShkYXRhLmZpbGUpO1xuICAgIH1cbiAgICBpZiAoZGF0YS5ibG9iUHJvbWlzZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBibG9iUHJvbWlzZVxuICAgICAgfSA9IGRhdGE7XG4gICAgICBkZWxldGUgZGF0YS5ibG9iUHJvbWlzZTtcbiAgICAgIHJldHVybiB0aGlzLmdldEZyb21CbG9iKGRhdGEuaWQsIGJsb2JQcm9taXNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0RnJvbVVybChkYXRhLnVybCk7XG4gIH1cbiAgZ2V0RnJvbUNhbnZhcyhpZCwgY2FudmFzKSB7XG4gICAgdGhpcy4jY2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgICBsZXQgZGF0YSA9IHRoaXMuI2NhY2hlLmdldChpZCk7XG4gICAgaWYgKGRhdGE/LmJpdG1hcCkge1xuICAgICAgZGF0YS5yZWZDb3VudGVyICs9IDE7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGNvbnN0IGN0eCA9IG9mZnNjcmVlbi5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgY3R4LmRyYXdJbWFnZShjYW52YXMsIDAsIDApO1xuICAgIGRhdGEgPSB7XG4gICAgICBiaXRtYXA6IG9mZnNjcmVlbi50cmFuc2ZlclRvSW1hZ2VCaXRtYXAoKSxcbiAgICAgIGlkOiBgaW1hZ2VfJHt0aGlzLiNiYXNlSWR9XyR7dGhpcy4jaWQrK31gLFxuICAgICAgcmVmQ291bnRlcjogMSxcbiAgICAgIGlzU3ZnOiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy4jY2FjaGUuc2V0KGlkLCBkYXRhKTtcbiAgICB0aGlzLiNjYWNoZS5zZXQoZGF0YS5pZCwgZGF0YSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgZ2V0U3ZnVXJsKGlkKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuI2NhY2hlLmdldChpZCk7XG4gICAgaWYgKCFkYXRhPy5pc1N2Zykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBkYXRhLnN2Z1VybDtcbiAgfVxuICBkZWxldGVJZChpZCkge1xuICAgIHRoaXMuI2NhY2hlIHx8PSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuI2NhY2hlLmdldChpZCk7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRhdGEucmVmQ291bnRlciAtPSAxO1xuICAgIGlmIChkYXRhLnJlZkNvdW50ZXIgIT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYml0bWFwXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKCFkYXRhLnVybCAmJiAhZGF0YS5maWxlKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKGJpdG1hcC53aWR0aCwgYml0bWFwLmhlaWdodCk7XG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcImJpdG1hcHJlbmRlcmVyXCIpO1xuICAgICAgY3R4LnRyYW5zZmVyRnJvbUltYWdlQml0bWFwKGJpdG1hcCk7XG4gICAgICBkYXRhLmJsb2JQcm9taXNlID0gY2FudmFzLmNvbnZlcnRUb0Jsb2IoKTtcbiAgICB9XG4gICAgYml0bWFwLmNsb3NlPy4oKTtcbiAgICBkYXRhLmJpdG1hcCA9IG51bGw7XG4gIH1cbiAgaXNWYWxpZElkKGlkKSB7XG4gICAgcmV0dXJuIGlkLnN0YXJ0c1dpdGgoYGltYWdlXyR7dGhpcy4jYmFzZUlkfV9gKTtcbiAgfVxufVxuY2xhc3MgQ29tbWFuZE1hbmFnZXIge1xuICAjY29tbWFuZHMgPSBbXTtcbiAgI2xvY2tlZCA9IGZhbHNlO1xuICAjbWF4U2l6ZTtcbiAgI3Bvc2l0aW9uID0gLTE7XG4gIGNvbnN0cnVjdG9yKG1heFNpemUgPSAxMjgpIHtcbiAgICB0aGlzLiNtYXhTaXplID0gbWF4U2l6ZTtcbiAgfVxuICBhZGQoe1xuICAgIGNtZCxcbiAgICB1bmRvLFxuICAgIHBvc3QsXG4gICAgbXVzdEV4ZWMsXG4gICAgdHlwZSA9IE5hTixcbiAgICBvdmVyd3JpdGVJZlNhbWVUeXBlID0gZmFsc2UsXG4gICAga2VlcFVuZG8gPSBmYWxzZVxuICB9KSB7XG4gICAgaWYgKG11c3RFeGVjKSB7XG4gICAgICBjbWQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2xvY2tlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzYXZlID0ge1xuICAgICAgY21kLFxuICAgICAgdW5kbyxcbiAgICAgIHBvc3QsXG4gICAgICB0eXBlXG4gICAgfTtcbiAgICBpZiAodGhpcy4jcG9zaXRpb24gPT09IC0xKSB7XG4gICAgICBpZiAodGhpcy4jY29tbWFuZHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLiNjb21tYW5kcy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy4jcG9zaXRpb24gPSAwO1xuICAgICAgdGhpcy4jY29tbWFuZHMucHVzaChzYXZlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG92ZXJ3cml0ZUlmU2FtZVR5cGUgJiYgdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgIGlmIChrZWVwVW5kbykge1xuICAgICAgICBzYXZlLnVuZG8gPSB0aGlzLiNjb21tYW5kc1t0aGlzLiNwb3NpdGlvbl0udW5kbztcbiAgICAgIH1cbiAgICAgIHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXSA9IHNhdmU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5leHQgPSB0aGlzLiNwb3NpdGlvbiArIDE7XG4gICAgaWYgKG5leHQgPT09IHRoaXMuI21heFNpemUpIHtcbiAgICAgIHRoaXMuI2NvbW1hbmRzLnNwbGljZSgwLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jcG9zaXRpb24gPSBuZXh0O1xuICAgICAgaWYgKG5leHQgPCB0aGlzLiNjb21tYW5kcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy4jY29tbWFuZHMuc3BsaWNlKG5leHQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNjb21tYW5kcy5wdXNoKHNhdmUpO1xuICB9XG4gIHVuZG8oKSB7XG4gICAgaWYgKHRoaXMuI3Bvc2l0aW9uID09PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNsb2NrZWQgPSB0cnVlO1xuICAgIGNvbnN0IHtcbiAgICAgIHVuZG8sXG4gICAgICBwb3N0XG4gICAgfSA9IHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXTtcbiAgICB1bmRvKCk7XG4gICAgcG9zdD8uKCk7XG4gICAgdGhpcy4jbG9ja2VkID0gZmFsc2U7XG4gICAgdGhpcy4jcG9zaXRpb24gLT0gMTtcbiAgfVxuICByZWRvKCkge1xuICAgIGlmICh0aGlzLiNwb3NpdGlvbiA8IHRoaXMuI2NvbW1hbmRzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMuI3Bvc2l0aW9uICs9IDE7XG4gICAgICB0aGlzLiNsb2NrZWQgPSB0cnVlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbWQsXG4gICAgICAgIHBvc3RcbiAgICAgIH0gPSB0aGlzLiNjb21tYW5kc1t0aGlzLiNwb3NpdGlvbl07XG4gICAgICBjbWQoKTtcbiAgICAgIHBvc3Q/LigpO1xuICAgICAgdGhpcy4jbG9ja2VkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGhhc1NvbWV0aGluZ1RvVW5kbygpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9zaXRpb24gIT09IC0xO1xuICB9XG4gIGhhc1NvbWV0aGluZ1RvUmVkbygpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9zaXRpb24gPCB0aGlzLiNjb21tYW5kcy5sZW5ndGggLSAxO1xuICB9XG4gIGNsZWFuVHlwZSh0eXBlKSB7XG4gICAgaWYgKHRoaXMuI3Bvc2l0aW9uID09PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gdGhpcy4jcG9zaXRpb247IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAodGhpcy4jY29tbWFuZHNbaV0udHlwZSAhPT0gdHlwZSkge1xuICAgICAgICB0aGlzLiNjb21tYW5kcy5zcGxpY2UoaSArIDEsIHRoaXMuI3Bvc2l0aW9uIC0gaSk7XG4gICAgICAgIHRoaXMuI3Bvc2l0aW9uID0gaTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNjb21tYW5kcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuI3Bvc2l0aW9uID0gLTE7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNjb21tYW5kcyA9IG51bGw7XG4gIH1cbn1cbmNsYXNzIEtleWJvYXJkTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrcykge1xuICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgdGhpcy5jYWxsYmFja3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5hbGxLZXlzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgZm9yIChjb25zdCBba2V5cywgY2FsbGJhY2ssIG9wdGlvbnMgPSB7fV0gb2YgY2FsbGJhY2tzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGNvbnN0IGlzTWFjS2V5ID0ga2V5LnN0YXJ0c1dpdGgoXCJtYWMrXCIpO1xuICAgICAgICBpZiAoaXNNYWMgJiYgaXNNYWNLZXkpIHtcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5zZXQoa2V5LnNsaWNlKDQpLCB7XG4gICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmFsbEtleXMuYWRkKGtleS5zcGxpdChcIitcIikuYXQoLTEpKTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNNYWMgJiYgIWlzTWFjS2V5KSB7XG4gICAgICAgICAgdGhpcy5jYWxsYmFja3Muc2V0KGtleSwge1xuICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5hbGxLZXlzLmFkZChrZXkuc3BsaXQoXCIrXCIpLmF0KC0xKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI3NlcmlhbGl6ZShldmVudCkge1xuICAgIGlmIChldmVudC5hbHRLZXkpIHtcbiAgICAgIHRoaXMuYnVmZmVyLnB1c2goXCJhbHRcIik7XG4gICAgfVxuICAgIGlmIChldmVudC5jdHJsS2V5KSB7XG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwiY3RybFwiKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50Lm1ldGFLZXkpIHtcbiAgICAgIHRoaXMuYnVmZmVyLnB1c2goXCJtZXRhXCIpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgIHRoaXMuYnVmZmVyLnB1c2goXCJzaGlmdFwiKTtcbiAgICB9XG4gICAgdGhpcy5idWZmZXIucHVzaChldmVudC5rZXkpO1xuICAgIGNvbnN0IHN0ciA9IHRoaXMuYnVmZmVyLmpvaW4oXCIrXCIpO1xuICAgIHRoaXMuYnVmZmVyLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBleGVjKHNlbGYsIGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmFsbEtleXMuaGFzKGV2ZW50LmtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5mbyA9IHRoaXMuY2FsbGJhY2tzLmdldCh0aGlzLiNzZXJpYWxpemUoZXZlbnQpKTtcbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGJ1YmJsZXMgPSBmYWxzZSxcbiAgICAgICAgYXJncyA9IFtdLFxuICAgICAgICBjaGVja2VyID0gbnVsbFxuICAgICAgfVxuICAgIH0gPSBpbmZvO1xuICAgIGlmIChjaGVja2VyICYmICFjaGVja2VyKHNlbGYsIGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjay5iaW5kKHNlbGYsIC4uLmFyZ3MsIGV2ZW50KSgpO1xuICAgIGlmICghYnViYmxlcykge1xuICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIENvbG9yTWFuYWdlciB7XG4gIHN0YXRpYyBfY29sb3JzTWFwcGluZyA9IG5ldyBNYXAoW1tcIkNhbnZhc1RleHRcIiwgWzAsIDAsIDBdXSwgW1wiQ2FudmFzXCIsIFsyNTUsIDI1NSwgMjU1XV1dKTtcbiAgZ2V0IF9jb2xvcnMoKSB7XG4gICAgY29uc3QgY29sb3JzID0gbmV3IE1hcChbW1wiQ2FudmFzVGV4dFwiLCBudWxsXSwgW1wiQ2FudmFzXCIsIG51bGxdXSk7XG4gICAgZ2V0Q29sb3JWYWx1ZXMoY29sb3JzKTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2NvbG9yc1wiLCBjb2xvcnMpO1xuICB9XG4gIGNvbnZlcnQoY29sb3IpIHtcbiAgICBjb25zdCByZ2IgPSBnZXRSR0IoY29sb3IpO1xuICAgIGlmICghd2luZG93Lm1hdGNoTWVkaWEoXCIoZm9yY2VkLWNvbG9yczogYWN0aXZlKVwiKS5tYXRjaGVzKSB7XG4gICAgICByZXR1cm4gcmdiO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBSR0JdIG9mIHRoaXMuX2NvbG9ycykge1xuICAgICAgaWYgKFJHQi5ldmVyeSgoeCwgaSkgPT4geCA9PT0gcmdiW2ldKSkge1xuICAgICAgICByZXR1cm4gQ29sb3JNYW5hZ2VyLl9jb2xvcnNNYXBwaW5nLmdldChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJnYjtcbiAgfVxuICBnZXRIZXhDb2RlKG5hbWUpIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9jb2xvcnMuZ2V0KG5hbWUpO1xuICAgIGlmICghcmdiKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIFV0aWwubWFrZUhleENvbG9yKC4uLnJnYik7XG4gIH1cbn1cbmNsYXNzIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIge1xuICAjYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAjYWN0aXZlRWRpdG9yID0gbnVsbDtcbiAgI2FsbEVkaXRvcnMgPSBuZXcgTWFwKCk7XG4gICNhbGxMYXllcnMgPSBuZXcgTWFwKCk7XG4gICNhbHRUZXh0TWFuYWdlciA9IG51bGw7XG4gICNhbm5vdGF0aW9uU3RvcmFnZSA9IG51bGw7XG4gICNjaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9ucyA9IG51bGw7XG4gICNjb21tYW5kTWFuYWdlciA9IG5ldyBDb21tYW5kTWFuYWdlcigpO1xuICAjY29weVBhc3RlQUMgPSBudWxsO1xuICAjY3VycmVudERyYXdpbmdTZXNzaW9uID0gbnVsbDtcbiAgI2N1cnJlbnRQYWdlSW5kZXggPSAwO1xuICAjZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcyA9IG5ldyBTZXQoKTtcbiAgI2RyYWdnaW5nRWRpdG9ycyA9IG51bGw7XG4gICNlZGl0b3JUeXBlcyA9IG51bGw7XG4gICNlZGl0b3JzVG9SZXNjYWxlID0gbmV3IFNldCgpO1xuICBfZWRpdG9yVW5kb0JhciA9IG51bGw7XG4gICNlbmFibGVIaWdobGlnaHRGbG9hdGluZ0J1dHRvbiA9IGZhbHNlO1xuICAjZW5hYmxlVXBkYXRlZEFkZEltYWdlID0gZmFsc2U7XG4gICNlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlID0gZmFsc2U7XG4gICNmaWx0ZXJGYWN0b3J5ID0gbnVsbDtcbiAgI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCA9IG51bGw7XG4gICNmb2N1c01hbmFnZXJBQyA9IG51bGw7XG4gICNoaWdobGlnaHRDb2xvcnMgPSBudWxsO1xuICAjaGlnaGxpZ2h0V2hlblNoaWZ0VXAgPSBmYWxzZTtcbiAgI2hpZ2hsaWdodFRvb2xiYXIgPSBudWxsO1xuICAjaWRNYW5hZ2VyID0gbmV3IElkTWFuYWdlcigpO1xuICAjaXNFbmFibGVkID0gZmFsc2U7XG4gICNpc1dhaXRpbmcgPSBmYWxzZTtcbiAgI2tleWJvYXJkTWFuYWdlckFDID0gbnVsbDtcbiAgI2xhc3RBY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgI21haW5IaWdobGlnaHRDb2xvclBpY2tlciA9IG51bGw7XG4gICNtaXNzaW5nQ2FudmFzZXMgPSBudWxsO1xuICAjbWxNYW5hZ2VyID0gbnVsbDtcbiAgI21vZGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FO1xuICAjc2VsZWN0ZWRFZGl0b3JzID0gbmV3IFNldCgpO1xuICAjc2VsZWN0ZWRUZXh0Tm9kZSA9IG51bGw7XG4gICNzaWduYXR1cmVNYW5hZ2VyID0gbnVsbDtcbiAgI3BhZ2VDb2xvcnMgPSBudWxsO1xuICAjc2hvd0FsbFN0YXRlcyA9IG51bGw7XG4gICNwcmV2aW91c1N0YXRlcyA9IHtcbiAgICBpc0VkaXRpbmc6IGZhbHNlLFxuICAgIGlzRW1wdHk6IHRydWUsXG4gICAgaGFzU29tZXRoaW5nVG9VbmRvOiBmYWxzZSxcbiAgICBoYXNTb21ldGhpbmdUb1JlZG86IGZhbHNlLFxuICAgIGhhc1NlbGVjdGVkRWRpdG9yOiBmYWxzZSxcbiAgICBoYXNTZWxlY3RlZFRleHQ6IGZhbHNlXG4gIH07XG4gICN0cmFuc2xhdGlvbiA9IFswLCAwXTtcbiAgI3RyYW5zbGF0aW9uVGltZW91dElkID0gbnVsbDtcbiAgI2NvbnRhaW5lciA9IG51bGw7XG4gICN2aWV3ZXIgPSBudWxsO1xuICAjdXBkYXRlTW9kZUNhcGFiaWxpdHkgPSBudWxsO1xuICBzdGF0aWMgVFJBTlNMQVRFX1NNQUxMID0gMTtcbiAgc3RhdGljIFRSQU5TTEFURV9CSUcgPSAxMDtcbiAgc3RhdGljIGdldCBfa2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGNvbnN0IHByb3RvID0gQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5wcm90b3R5cGU7XG4gICAgY29uc3QgYXJyb3dDaGVja2VyID0gc2VsZiA9PiBzZWxmLiNjb250YWluZXIuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC50YWdOYW1lICE9PSBcIkJVVFRPTlwiICYmIHNlbGYuaGFzU29tZXRoaW5nVG9Db250cm9sKCk7XG4gICAgY29uc3QgdGV4dElucHV0Q2hlY2tlciA9IChfc2VsZiwge1xuICAgICAgdGFyZ2V0OiBlbFxuICAgIH0pID0+IHtcbiAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHR5cGVcbiAgICAgICAgfSA9IGVsO1xuICAgICAgICByZXR1cm4gdHlwZSAhPT0gXCJ0ZXh0XCIgJiYgdHlwZSAhPT0gXCJudW1iZXJcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgY29uc3Qgc21hbGwgPSB0aGlzLlRSQU5TTEFURV9TTUFMTDtcbiAgICBjb25zdCBiaWcgPSB0aGlzLlRSQU5TTEFURV9CSUc7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9rZXlib2FyZE1hbmFnZXJcIiwgbmV3IEtleWJvYXJkTWFuYWdlcihbW1tcImN0cmwrYVwiLCBcIm1hYyttZXRhK2FcIl0sIHByb3RvLnNlbGVjdEFsbCwge1xuICAgICAgY2hlY2tlcjogdGV4dElucHV0Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCt6XCIsIFwibWFjK21ldGErelwiXSwgcHJvdG8udW5kbywge1xuICAgICAgY2hlY2tlcjogdGV4dElucHV0Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCt5XCIsIFwiY3RybCtzaGlmdCt6XCIsIFwibWFjK21ldGErc2hpZnQrelwiLCBcImN0cmwrc2hpZnQrWlwiLCBcIm1hYyttZXRhK3NoaWZ0K1pcIl0sIHByb3RvLnJlZG8sIHtcbiAgICAgIGNoZWNrZXI6IHRleHRJbnB1dENoZWNrZXJcbiAgICB9XSwgW1tcIkJhY2tzcGFjZVwiLCBcImFsdCtCYWNrc3BhY2VcIiwgXCJjdHJsK0JhY2tzcGFjZVwiLCBcInNoaWZ0K0JhY2tzcGFjZVwiLCBcIm1hYytCYWNrc3BhY2VcIiwgXCJtYWMrYWx0K0JhY2tzcGFjZVwiLCBcIm1hYytjdHJsK0JhY2tzcGFjZVwiLCBcIkRlbGV0ZVwiLCBcImN0cmwrRGVsZXRlXCIsIFwic2hpZnQrRGVsZXRlXCIsIFwibWFjK0RlbGV0ZVwiXSwgcHJvdG8uZGVsZXRlLCB7XG4gICAgICBjaGVja2VyOiB0ZXh0SW5wdXRDaGVja2VyXG4gICAgfV0sIFtbXCJFbnRlclwiLCBcIm1hYytFbnRlclwiXSwgcHJvdG8uYWRkTmV3RWRpdG9yRnJvbUtleWJvYXJkLCB7XG4gICAgICBjaGVja2VyOiAoc2VsZiwge1xuICAgICAgICB0YXJnZXQ6IGVsXG4gICAgICB9KSA9PiAhKGVsIGluc3RhbmNlb2YgSFRNTEJ1dHRvbkVsZW1lbnQpICYmIHNlbGYuI2NvbnRhaW5lci5jb250YWlucyhlbCkgJiYgIXNlbGYuaXNFbnRlckhhbmRsZWRcbiAgICB9XSwgW1tcIiBcIiwgXCJtYWMrIFwiXSwgcHJvdG8uYWRkTmV3RWRpdG9yRnJvbUtleWJvYXJkLCB7XG4gICAgICBjaGVja2VyOiAoc2VsZiwge1xuICAgICAgICB0YXJnZXQ6IGVsXG4gICAgICB9KSA9PiAhKGVsIGluc3RhbmNlb2YgSFRNTEJ1dHRvbkVsZW1lbnQpICYmIHNlbGYuI2NvbnRhaW5lci5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KVxuICAgIH1dLCBbW1wiRXNjYXBlXCIsIFwibWFjK0VzY2FwZVwiXSwgcHJvdG8udW5zZWxlY3RBbGxdLCBbW1wiQXJyb3dMZWZ0XCIsIFwibWFjK0Fycm93TGVmdFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbLXNtYWxsLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0xlZnRcIiwgXCJtYWMrc2hpZnQrQXJyb3dMZWZ0XCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFstYmlnLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dSaWdodFwiLCBcIm1hYytBcnJvd1JpZ2h0XCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFtzbWFsbCwgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dSaWdodFwiLCBcIm1hYytzaGlmdCtBcnJvd1JpZ2h0XCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFtiaWcsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd1VwXCIsIFwibWFjK0Fycm93VXBcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWzAsIC1zbWFsbF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dVcFwiLCBcIm1hYytzaGlmdCtBcnJvd1VwXCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFswLCAtYmlnXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dEb3duXCIsIFwibWFjK0Fycm93RG93blwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbMCwgc21hbGxdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93RG93blwiLCBcIm1hYytzaGlmdCtBcnJvd0Rvd25cIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWzAsIGJpZ10sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XV0pKTtcbiAgfVxuICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIHZpZXdlciwgYWx0VGV4dE1hbmFnZXIsIHNpZ25hdHVyZU1hbmFnZXIsIGV2ZW50QnVzLCBwZGZEb2N1bWVudCwgcGFnZUNvbG9ycywgaGlnaGxpZ2h0Q29sb3JzLCBlbmFibGVIaWdobGlnaHRGbG9hdGluZ0J1dHRvbiwgZW5hYmxlVXBkYXRlZEFkZEltYWdlLCBlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlLCBtbE1hbmFnZXIsIGVkaXRvclVuZG9CYXIsIHN1cHBvcnRzUGluY2hUb1pvb20pIHtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl9zaWduYWwgPSB0aGlzLiNhYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuICAgIHRoaXMuI2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLiN2aWV3ZXIgPSB2aWV3ZXI7XG4gICAgdGhpcy4jYWx0VGV4dE1hbmFnZXIgPSBhbHRUZXh0TWFuYWdlcjtcbiAgICB0aGlzLiNzaWduYXR1cmVNYW5hZ2VyID0gc2lnbmF0dXJlTWFuYWdlcjtcbiAgICB0aGlzLl9ldmVudEJ1cyA9IGV2ZW50QnVzO1xuICAgIGV2ZW50QnVzLl9vbihcImVkaXRpbmdhY3Rpb25cIiwgdGhpcy5vbkVkaXRpbmdBY3Rpb24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZXZlbnRCdXMuX29uKFwicGFnZWNoYW5naW5nXCIsIHRoaXMub25QYWdlQ2hhbmdpbmcuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZXZlbnRCdXMuX29uKFwic2NhbGVjaGFuZ2luZ1wiLCB0aGlzLm9uU2NhbGVDaGFuZ2luZy5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBldmVudEJ1cy5fb24oXCJyb3RhdGlvbmNoYW5naW5nXCIsIHRoaXMub25Sb3RhdGlvbkNoYW5naW5nLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGV2ZW50QnVzLl9vbihcInNldHByZWZlcmVuY2VcIiwgdGhpcy5vblNldFByZWZlcmVuY2UuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZXZlbnRCdXMuX29uKFwic3dpdGNoYW5ub3RhdGlvbmVkaXRvcnBhcmFtc1wiLCBldnQgPT4gdGhpcy51cGRhdGVQYXJhbXMoZXZ0LnR5cGUsIGV2dC52YWx1ZSksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuI2FkZFNlbGVjdGlvbkxpc3RlbmVyKCk7XG4gICAgdGhpcy4jYWRkRHJhZ0FuZERyb3BMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLiNhZGRLZXlib2FyZE1hbmFnZXIoKTtcbiAgICB0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZSA9IHBkZkRvY3VtZW50LmFubm90YXRpb25TdG9yYWdlO1xuICAgIHRoaXMuI2ZpbHRlckZhY3RvcnkgPSBwZGZEb2N1bWVudC5maWx0ZXJGYWN0b3J5O1xuICAgIHRoaXMuI3BhZ2VDb2xvcnMgPSBwYWdlQ29sb3JzO1xuICAgIHRoaXMuI2hpZ2hsaWdodENvbG9ycyA9IGhpZ2hsaWdodENvbG9ycyB8fCBudWxsO1xuICAgIHRoaXMuI2VuYWJsZUhpZ2hsaWdodEZsb2F0aW5nQnV0dG9uID0gZW5hYmxlSGlnaGxpZ2h0RmxvYXRpbmdCdXR0b247XG4gICAgdGhpcy4jZW5hYmxlVXBkYXRlZEFkZEltYWdlID0gZW5hYmxlVXBkYXRlZEFkZEltYWdlO1xuICAgIHRoaXMuI2VuYWJsZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UgPSBlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlO1xuICAgIHRoaXMuI21sTWFuYWdlciA9IG1sTWFuYWdlciB8fCBudWxsO1xuICAgIHRoaXMudmlld1BhcmFtZXRlcnMgPSB7XG4gICAgICByZWFsU2NhbGU6IFBpeGVsc1BlckluY2guUERGX1RPX0NTU19VTklUUyxcbiAgICAgIHJvdGF0aW9uOiAwXG4gICAgfTtcbiAgICB0aGlzLmlzU2hpZnRLZXlEb3duID0gZmFsc2U7XG4gICAgdGhpcy5fZWRpdG9yVW5kb0JhciA9IGVkaXRvclVuZG9CYXIgfHwgbnVsbDtcbiAgICB0aGlzLl9zdXBwb3J0c1BpbmNoVG9ab29tID0gc3VwcG9ydHNQaW5jaFRvWm9vbSAhPT0gZmFsc2U7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eT8ucmVzb2x2ZSgpO1xuICAgIHRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5ID0gbnVsbDtcbiAgICB0aGlzLiNhYm9ydENvbnRyb2xsZXI/LmFib3J0KCk7XG4gICAgdGhpcy4jYWJvcnRDb250cm9sbGVyID0gbnVsbDtcbiAgICB0aGlzLl9zaWduYWwgPSBudWxsO1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICBsYXllci5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuI2FsbExheWVycy5jbGVhcigpO1xuICAgIHRoaXMuI2FsbEVkaXRvcnMuY2xlYXIoKTtcbiAgICB0aGlzLiNlZGl0b3JzVG9SZXNjYWxlLmNsZWFyKCk7XG4gICAgdGhpcy4jbWlzc2luZ0NhbnZhc2VzPy5jbGVhcigpO1xuICAgIHRoaXMuI2FjdGl2ZUVkaXRvciA9IG51bGw7XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jY29tbWFuZE1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuI2FsdFRleHRNYW5hZ2VyPy5kZXN0cm95KCk7XG4gICAgdGhpcy4jc2lnbmF0dXJlTWFuYWdlcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuI2hpZ2hsaWdodFRvb2xiYXI/LmhpZGUoKTtcbiAgICB0aGlzLiNoaWdobGlnaHRUb29sYmFyID0gbnVsbDtcbiAgICB0aGlzLiNtYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXI/LmRlc3Ryb3koKTtcbiAgICB0aGlzLiNtYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXIgPSBudWxsO1xuICAgIGlmICh0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQpO1xuICAgICAgdGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQpO1xuICAgICAgdGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9lZGl0b3JVbmRvQmFyPy5kZXN0cm95KCk7XG4gIH1cbiAgY29tYmluZWRTaWduYWwoYWMpIHtcbiAgICByZXR1cm4gQWJvcnRTaWduYWwuYW55KFt0aGlzLl9zaWduYWwsIGFjLnNpZ25hbF0pO1xuICB9XG4gIGdldCBtbE1hbmFnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuI21sTWFuYWdlcjtcbiAgfVxuICBnZXQgdXNlTmV3QWx0VGV4dEZsb3coKSB7XG4gICAgcmV0dXJuIHRoaXMuI2VuYWJsZVVwZGF0ZWRBZGRJbWFnZTtcbiAgfVxuICBnZXQgdXNlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZTtcbiAgfVxuICBnZXQgaGNtRmlsdGVyKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJoY21GaWx0ZXJcIiwgdGhpcy4jcGFnZUNvbG9ycyA/IHRoaXMuI2ZpbHRlckZhY3RvcnkuYWRkSENNRmlsdGVyKHRoaXMuI3BhZ2VDb2xvcnMuZm9yZWdyb3VuZCwgdGhpcy4jcGFnZUNvbG9ycy5iYWNrZ3JvdW5kKSA6IFwibm9uZVwiKTtcbiAgfVxuICBnZXQgZGlyZWN0aW9uKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJkaXJlY3Rpb25cIiwgZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiNjb250YWluZXIpLmRpcmVjdGlvbik7XG4gIH1cbiAgZ2V0IGhpZ2hsaWdodENvbG9ycygpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaGlnaGxpZ2h0Q29sb3JzXCIsIHRoaXMuI2hpZ2hsaWdodENvbG9ycyA/IG5ldyBNYXAodGhpcy4jaGlnaGxpZ2h0Q29sb3JzLnNwbGl0KFwiLFwiKS5tYXAocGFpciA9PiBwYWlyLnNwbGl0KFwiPVwiKS5tYXAoeCA9PiB4LnRyaW0oKSkpKSA6IG51bGwpO1xuICB9XG4gIGdldCBoaWdobGlnaHRDb2xvck5hbWVzKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJoaWdobGlnaHRDb2xvck5hbWVzXCIsIHRoaXMuaGlnaGxpZ2h0Q29sb3JzID8gbmV3IE1hcChBcnJheS5mcm9tKHRoaXMuaGlnaGxpZ2h0Q29sb3JzLCBlID0+IGUucmV2ZXJzZSgpKSkgOiBudWxsKTtcbiAgfVxuICBzZXRDdXJyZW50RHJhd2luZ1Nlc3Npb24obGF5ZXIpIHtcbiAgICBpZiAobGF5ZXIpIHtcbiAgICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcbiAgICAgIHRoaXMuZGlzYWJsZVVzZXJTZWxlY3QodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlzYWJsZVVzZXJTZWxlY3QoZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLiNjdXJyZW50RHJhd2luZ1Nlc3Npb24gPSBsYXllcjtcbiAgfVxuICBzZXRNYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXIoY29sb3JQaWNrZXIpIHtcbiAgICB0aGlzLiNtYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXIgPSBjb2xvclBpY2tlcjtcbiAgfVxuICBlZGl0QWx0VGV4dChlZGl0b3IsIGZpcnN0VGltZSA9IGZhbHNlKSB7XG4gICAgdGhpcy4jYWx0VGV4dE1hbmFnZXI/LmVkaXRBbHRUZXh0KHRoaXMsIGVkaXRvciwgZmlyc3RUaW1lKTtcbiAgfVxuICBnZXRTaWduYXR1cmUoZWRpdG9yKSB7XG4gICAgdGhpcy4jc2lnbmF0dXJlTWFuYWdlcj8uZ2V0U2lnbmF0dXJlKHtcbiAgICAgIHVpTWFuYWdlcjogdGhpcyxcbiAgICAgIGVkaXRvclxuICAgIH0pO1xuICB9XG4gIGdldCBzaWduYXR1cmVNYW5hZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLiNzaWduYXR1cmVNYW5hZ2VyO1xuICB9XG4gIHN3aXRjaFRvTW9kZShtb2RlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2V2ZW50QnVzLm9uKFwiYW5ub3RhdGlvbmVkaXRvcm1vZGVjaGFuZ2VkXCIsIGNhbGxiYWNrLCB7XG4gICAgICBvbmNlOiB0cnVlLFxuICAgICAgc2lnbmFsOiB0aGlzLl9zaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLl9ldmVudEJ1cy5kaXNwYXRjaChcInNob3dhbm5vdGF0aW9uZWRpdG9ydWlcIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgbW9kZVxuICAgIH0pO1xuICB9XG4gIHNldFByZWZlcmVuY2UobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLl9ldmVudEJ1cy5kaXNwYXRjaChcInNldHByZWZlcmVuY2VcIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgbmFtZSxcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gIH1cbiAgb25TZXRQcmVmZXJlbmNlKHtcbiAgICBuYW1lLFxuICAgIHZhbHVlXG4gIH0pIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgXCJlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlXCI6XG4gICAgICAgIHRoaXMuI2VuYWJsZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIG9uUGFnZUNoYW5naW5nKHtcbiAgICBwYWdlTnVtYmVyXG4gIH0pIHtcbiAgICB0aGlzLiNjdXJyZW50UGFnZUluZGV4ID0gcGFnZU51bWJlciAtIDE7XG4gIH1cbiAgZm9jdXNNYWluQ29udGFpbmVyKCkge1xuICAgIHRoaXMuI2NvbnRhaW5lci5mb2N1cygpO1xuICB9XG4gIGZpbmRQYXJlbnQoeCwgeSkge1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHg6IGxheWVyWCxcbiAgICAgICAgeTogbGF5ZXJZLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9ID0gbGF5ZXIuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKHggPj0gbGF5ZXJYICYmIHggPD0gbGF5ZXJYICsgd2lkdGggJiYgeSA+PSBsYXllclkgJiYgeSA8PSBsYXllclkgKyBoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBkaXNhYmxlVXNlclNlbGVjdCh2YWx1ZSA9IGZhbHNlKSB7XG4gICAgdGhpcy4jdmlld2VyLmNsYXNzTGlzdC50b2dnbGUoXCJub1VzZXJTZWxlY3RcIiwgdmFsdWUpO1xuICB9XG4gIGFkZFNob3VsZFJlc2NhbGUoZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9yc1RvUmVzY2FsZS5hZGQoZWRpdG9yKTtcbiAgfVxuICByZW1vdmVTaG91bGRSZXNjYWxlKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvcnNUb1Jlc2NhbGUuZGVsZXRlKGVkaXRvcik7XG4gIH1cbiAgb25TY2FsZUNoYW5naW5nKHtcbiAgICBzY2FsZVxuICB9KSB7XG4gICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIHRoaXMudmlld1BhcmFtZXRlcnMucmVhbFNjYWxlID0gc2NhbGUgKiBQaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFM7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9yc1RvUmVzY2FsZSkge1xuICAgICAgZWRpdG9yLm9uU2NhbGVDaGFuZ2luZygpO1xuICAgIH1cbiAgICB0aGlzLiNjdXJyZW50RHJhd2luZ1Nlc3Npb24/Lm9uU2NhbGVDaGFuZ2luZygpO1xuICB9XG4gIG9uUm90YXRpb25DaGFuZ2luZyh7XG4gICAgcGFnZXNSb3RhdGlvblxuICB9KSB7XG4gICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIHRoaXMudmlld1BhcmFtZXRlcnMucm90YXRpb24gPSBwYWdlc1JvdGF0aW9uO1xuICB9XG4gICNnZXRBbmNob3JFbGVtZW50Rm9yU2VsZWN0aW9uKHtcbiAgICBhbmNob3JOb2RlXG4gIH0pIHtcbiAgICByZXR1cm4gYW5jaG9yTm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgPyBhbmNob3JOb2RlLnBhcmVudEVsZW1lbnQgOiBhbmNob3JOb2RlO1xuICB9XG4gICNnZXRMYXllckZvclRleHRMYXllcih0ZXh0TGF5ZXIpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50TGF5ZXJcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoY3VycmVudExheWVyLmhhc1RleHRMYXllcih0ZXh0TGF5ZXIpKSB7XG4gICAgICByZXR1cm4gY3VycmVudExheWVyO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGxheWVyLmhhc1RleHRMYXllcih0ZXh0TGF5ZXIpKSB7XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaGlnaGxpZ2h0U2VsZWN0aW9uKG1ldGhvZE9mQ3JlYXRpb24gPSBcIlwiKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQsXG4gICAgICBmb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldFxuICAgIH0gPSBzZWxlY3Rpb247XG4gICAgY29uc3QgdGV4dCA9IHNlbGVjdGlvbi50b1N0cmluZygpO1xuICAgIGNvbnN0IGFuY2hvckVsZW1lbnQgPSB0aGlzLiNnZXRBbmNob3JFbGVtZW50Rm9yU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgY29uc3QgdGV4dExheWVyID0gYW5jaG9yRWxlbWVudC5jbG9zZXN0KFwiLnRleHRMYXllclwiKTtcbiAgICBjb25zdCBib3hlcyA9IHRoaXMuZ2V0U2VsZWN0aW9uQm94ZXModGV4dExheWVyKTtcbiAgICBpZiAoIWJveGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGVjdGlvbi5lbXB0eSgpO1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy4jZ2V0TGF5ZXJGb3JUZXh0TGF5ZXIodGV4dExheWVyKTtcbiAgICBjb25zdCBpc05vbmVNb2RlID0gdGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORTtcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIGxheWVyPy5jcmVhdGVBbmRBZGROZXdFZGl0b3Ioe1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9LCBmYWxzZSwge1xuICAgICAgICBtZXRob2RPZkNyZWF0aW9uLFxuICAgICAgICBib3hlcyxcbiAgICAgICAgYW5jaG9yTm9kZSxcbiAgICAgICAgYW5jaG9yT2Zmc2V0LFxuICAgICAgICBmb2N1c05vZGUsXG4gICAgICAgIGZvY3VzT2Zmc2V0LFxuICAgICAgICB0ZXh0XG4gICAgICB9KTtcbiAgICAgIGlmIChpc05vbmVNb2RlKSB7XG4gICAgICAgIHRoaXMuc2hvd0FsbEVkaXRvcnMoXCJoaWdobGlnaHRcIiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNOb25lTW9kZSkge1xuICAgICAgdGhpcy5zd2l0Y2hUb01vZGUoQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hULCBjYWxsYmFjayk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrKCk7XG4gIH1cbiAgI2Rpc3BsYXlIaWdobGlnaHRUb29sYmFyKCkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhbmNob3JFbGVtZW50ID0gdGhpcy4jZ2V0QW5jaG9yRWxlbWVudEZvclNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIGNvbnN0IHRleHRMYXllciA9IGFuY2hvckVsZW1lbnQuY2xvc2VzdChcIi50ZXh0TGF5ZXJcIik7XG4gICAgY29uc3QgYm94ZXMgPSB0aGlzLmdldFNlbGVjdGlvbkJveGVzKHRleHRMYXllcik7XG4gICAgaWYgKCFib3hlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNoaWdobGlnaHRUb29sYmFyIHx8PSBuZXcgSGlnaGxpZ2h0VG9vbGJhcih0aGlzKTtcbiAgICB0aGlzLiNoaWdobGlnaHRUb29sYmFyLnNob3codGV4dExheWVyLCBib3hlcywgdGhpcy5kaXJlY3Rpb24gPT09IFwibHRyXCIpO1xuICB9XG4gIGFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoZWRpdG9yKSB7XG4gICAgaWYgKCFlZGl0b3IuaXNFbXB0eSgpICYmIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlICYmICF0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZS5oYXMoZWRpdG9yLmlkKSkge1xuICAgICAgdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUoZWRpdG9yLmlkLCBlZGl0b3IpO1xuICAgIH1cbiAgfVxuICAjc2VsZWN0aW9uQ2hhbmdlKCkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xuICAgICAgaWYgKHRoaXMuI3NlbGVjdGVkVGV4dE5vZGUpIHtcbiAgICAgICAgdGhpcy4jaGlnaGxpZ2h0VG9vbGJhcj8uaGlkZSgpO1xuICAgICAgICB0aGlzLiNzZWxlY3RlZFRleHROb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICAgIGhhc1NlbGVjdGVkVGV4dDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFuY2hvck5vZGVcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIGlmIChhbmNob3JOb2RlID09PSB0aGlzLiNzZWxlY3RlZFRleHROb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFuY2hvckVsZW1lbnQgPSB0aGlzLiNnZXRBbmNob3JFbGVtZW50Rm9yU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgY29uc3QgdGV4dExheWVyID0gYW5jaG9yRWxlbWVudC5jbG9zZXN0KFwiLnRleHRMYXllclwiKTtcbiAgICBpZiAoIXRleHRMYXllcikge1xuICAgICAgaWYgKHRoaXMuI3NlbGVjdGVkVGV4dE5vZGUpIHtcbiAgICAgICAgdGhpcy4jaGlnaGxpZ2h0VG9vbGJhcj8uaGlkZSgpO1xuICAgICAgICB0aGlzLiNzZWxlY3RlZFRleHROb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICAgIGhhc1NlbGVjdGVkVGV4dDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2hpZ2hsaWdodFRvb2xiYXI/LmhpZGUoKTtcbiAgICB0aGlzLiNzZWxlY3RlZFRleHROb2RlID0gYW5jaG9yTm9kZTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTZWxlY3RlZFRleHQ6IHRydWVcbiAgICB9KTtcbiAgICBpZiAodGhpcy4jbW9kZSAhPT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUICYmIHRoaXMuI21vZGUgIT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI21vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCkge1xuICAgICAgdGhpcy5zaG93QWxsRWRpdG9ycyhcImhpZ2hsaWdodFwiLCB0cnVlLCB0cnVlKTtcbiAgICB9XG4gICAgdGhpcy4jaGlnaGxpZ2h0V2hlblNoaWZ0VXAgPSB0aGlzLmlzU2hpZnRLZXlEb3duO1xuICAgIGlmICghdGhpcy5pc1NoaWZ0S2V5RG93bikge1xuICAgICAgY29uc3QgYWN0aXZlTGF5ZXIgPSB0aGlzLiNtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQgPyB0aGlzLiNnZXRMYXllckZvclRleHRMYXllcih0ZXh0TGF5ZXIpIDogbnVsbDtcbiAgICAgIGFjdGl2ZUxheWVyPy50b2dnbGVEcmF3aW5nKCk7XG4gICAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuY29tYmluZWRTaWduYWwoYWMpO1xuICAgICAgY29uc3QgcG9pbnRlcnVwID0gZSA9PiB7XG4gICAgICAgIGlmIChlLnR5cGUgPT09IFwicG9pbnRlcnVwXCIgJiYgZS5idXR0b24gIT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYWMuYWJvcnQoKTtcbiAgICAgICAgYWN0aXZlTGF5ZXI/LnRvZ2dsZURyYXdpbmcodHJ1ZSk7XG4gICAgICAgIGlmIChlLnR5cGUgPT09IFwicG9pbnRlcnVwXCIpIHtcbiAgICAgICAgICB0aGlzLiNvblNlbGVjdEVuZChcIm1haW5fdG9vbGJhclwiKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHBvaW50ZXJ1cCwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHBvaW50ZXJ1cCwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAjb25TZWxlY3RFbmQobWV0aG9kT2ZDcmVhdGlvbiA9IFwiXCIpIHtcbiAgICBpZiAodGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUKSB7XG4gICAgICB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbihtZXRob2RPZkNyZWF0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuI2VuYWJsZUhpZ2hsaWdodEZsb2F0aW5nQnV0dG9uKSB7XG4gICAgICB0aGlzLiNkaXNwbGF5SGlnaGxpZ2h0VG9vbGJhcigpO1xuICAgIH1cbiAgfVxuICAjYWRkU2VsZWN0aW9uTGlzdGVuZXIoKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB0aGlzLiNzZWxlY3Rpb25DaGFuZ2UuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsOiB0aGlzLl9zaWduYWxcbiAgICB9KTtcbiAgfVxuICAjYWRkRm9jdXNNYW5hZ2VyKCkge1xuICAgIGlmICh0aGlzLiNmb2N1c01hbmFnZXJBQykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNmb2N1c01hbmFnZXJBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLmNvbWJpbmVkU2lnbmFsKHRoaXMuI2ZvY3VzTWFuYWdlckFDKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuZm9jdXMuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuYmx1ci5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICAjcmVtb3ZlRm9jdXNNYW5hZ2VyKCkge1xuICAgIHRoaXMuI2ZvY3VzTWFuYWdlckFDPy5hYm9ydCgpO1xuICAgIHRoaXMuI2ZvY3VzTWFuYWdlckFDID0gbnVsbDtcbiAgfVxuICBibHVyKCkge1xuICAgIHRoaXMuaXNTaGlmdEtleURvd24gPSBmYWxzZTtcbiAgICBpZiAodGhpcy4jaGlnaGxpZ2h0V2hlblNoaWZ0VXApIHtcbiAgICAgIHRoaXMuI2hpZ2hsaWdodFdoZW5TaGlmdFVwID0gZmFsc2U7XG4gICAgICB0aGlzLiNvblNlbGVjdEVuZChcIm1haW5fdG9vbGJhclwiKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhY3RpdmVFbGVtZW50XG4gICAgfSA9IGRvY3VtZW50O1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgaWYgKGVkaXRvci5kaXYuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgdGhpcy4jbGFzdEFjdGl2ZUVsZW1lbnQgPSBbZWRpdG9yLCBhY3RpdmVFbGVtZW50XTtcbiAgICAgICAgZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvY3VzKCkge1xuICAgIGlmICghdGhpcy4jbGFzdEFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgW2xhc3RFZGl0b3IsIGxhc3RBY3RpdmVFbGVtZW50XSA9IHRoaXMuI2xhc3RBY3RpdmVFbGVtZW50O1xuICAgIHRoaXMuI2xhc3RBY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICBsYXN0QWN0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCAoKSA9PiB7XG4gICAgICBsYXN0RWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSB0cnVlO1xuICAgIH0sIHtcbiAgICAgIG9uY2U6IHRydWUsXG4gICAgICBzaWduYWw6IHRoaXMuX3NpZ25hbFxuICAgIH0pO1xuICAgIGxhc3RBY3RpdmVFbGVtZW50LmZvY3VzKCk7XG4gIH1cbiAgI2FkZEtleWJvYXJkTWFuYWdlcigpIHtcbiAgICBpZiAodGhpcy4ja2V5Ym9hcmRNYW5hZ2VyQUMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4ja2V5Ym9hcmRNYW5hZ2VyQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5jb21iaW5lZFNpZ25hbCh0aGlzLiNrZXlib2FyZE1hbmFnZXJBQyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMua2V5ZG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIHRoaXMua2V5dXAuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgI3JlbW92ZUtleWJvYXJkTWFuYWdlcigpIHtcbiAgICB0aGlzLiNrZXlib2FyZE1hbmFnZXJBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNrZXlib2FyZE1hbmFnZXJBQyA9IG51bGw7XG4gIH1cbiAgI2FkZENvcHlQYXN0ZUxpc3RlbmVycygpIHtcbiAgICBpZiAodGhpcy4jY29weVBhc3RlQUMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY29weVBhc3RlQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5jb21iaW5lZFNpZ25hbCh0aGlzLiNjb3B5UGFzdGVBQyk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNvcHlcIiwgdGhpcy5jb3B5LmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjdXRcIiwgdGhpcy5jdXQuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBhc3RlXCIsIHRoaXMucGFzdGUuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgI3JlbW92ZUNvcHlQYXN0ZUxpc3RlbmVycygpIHtcbiAgICB0aGlzLiNjb3B5UGFzdGVBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNjb3B5UGFzdGVBQyA9IG51bGw7XG4gIH1cbiAgI2FkZERyYWdBbmREcm9wTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3NpZ25hbDtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ292ZXJcIiwgdGhpcy5kcmFnT3Zlci5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLCB0aGlzLmRyb3AuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgYWRkRWRpdExpc3RlbmVycygpIHtcbiAgICB0aGlzLiNhZGRLZXlib2FyZE1hbmFnZXIoKTtcbiAgICB0aGlzLiNhZGRDb3B5UGFzdGVMaXN0ZW5lcnMoKTtcbiAgfVxuICByZW1vdmVFZGl0TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuI3JlbW92ZUtleWJvYXJkTWFuYWdlcigpO1xuICAgIHRoaXMuI3JlbW92ZUNvcHlQYXN0ZUxpc3RlbmVycygpO1xuICB9XG4gIGRyYWdPdmVyKGV2ZW50KSB7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSBvZiBldmVudC5kYXRhVHJhbnNmZXIuaXRlbXMpIHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiB0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgICBpZiAoZWRpdG9yVHlwZS5pc0hhbmRsaW5nTWltZUZvclBhc3RpbmcodHlwZSkpIHtcbiAgICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IFwiY29weVwiO1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRyb3AoZXZlbnQpIHtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZXZlbnQuZGF0YVRyYW5zZmVyLml0ZW1zKSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgICAgaWYgKGVkaXRvclR5cGUuaXNIYW5kbGluZ01pbWVGb3JQYXN0aW5nKGl0ZW0udHlwZSkpIHtcbiAgICAgICAgICBlZGl0b3JUeXBlLnBhc3RlKGl0ZW0sIHRoaXMuY3VycmVudExheWVyKTtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb3B5KGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLiNhY3RpdmVFZGl0b3I/LmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3JzID0gW107XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBjb25zdCBzZXJpYWxpemVkID0gZWRpdG9yLnNlcmlhbGl6ZSh0cnVlKTtcbiAgICAgIGlmIChzZXJpYWxpemVkKSB7XG4gICAgICAgIGVkaXRvcnMucHVzaChzZXJpYWxpemVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVkaXRvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LmNsaXBib2FyZERhdGEuc2V0RGF0YShcImFwcGxpY2F0aW9uL3BkZmpzXCIsIEpTT04uc3RyaW5naWZ5KGVkaXRvcnMpKTtcbiAgfVxuICBjdXQoZXZlbnQpIHtcbiAgICB0aGlzLmNvcHkoZXZlbnQpO1xuICAgIHRoaXMuZGVsZXRlKCk7XG4gIH1cbiAgYXN5bmMgcGFzdGUoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGNsaXBib2FyZERhdGFcbiAgICB9ID0gZXZlbnQ7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGNsaXBib2FyZERhdGEuaXRlbXMpIHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiB0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgICBpZiAoZWRpdG9yVHlwZS5pc0hhbmRsaW5nTWltZUZvclBhc3RpbmcoaXRlbS50eXBlKSkge1xuICAgICAgICAgIGVkaXRvclR5cGUucGFzdGUoaXRlbSwgdGhpcy5jdXJyZW50TGF5ZXIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgZGF0YSA9IGNsaXBib2FyZERhdGEuZ2V0RGF0YShcImFwcGxpY2F0aW9uL3BkZmpzXCIpO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHdhcm4oYHBhc3RlOiBcIiR7ZXgubWVzc2FnZX1cIi5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuY3VycmVudExheWVyO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBuZXdFZGl0b3JzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGRlc2VyaWFsaXplZEVkaXRvciA9IGF3YWl0IGxheWVyLmRlc2VyaWFsaXplKGVkaXRvcik7XG4gICAgICAgIGlmICghZGVzZXJpYWxpemVkRWRpdG9yKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5ld0VkaXRvcnMucHVzaChkZXNlcmlhbGl6ZWRFZGl0b3IpO1xuICAgICAgfVxuICAgICAgY29uc3QgY21kID0gKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBuZXdFZGl0b3JzKSB7XG4gICAgICAgICAgdGhpcy4jYWRkRWRpdG9yVG9MYXllcihlZGl0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3NlbGVjdEVkaXRvcnMobmV3RWRpdG9ycyk7XG4gICAgICB9O1xuICAgICAgY29uc3QgdW5kbyA9ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgbmV3RWRpdG9ycykge1xuICAgICAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgICBjbWQsXG4gICAgICAgIHVuZG8sXG4gICAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgd2FybihgcGFzdGU6IFwiJHtleC5tZXNzYWdlfVwiLmApO1xuICAgIH1cbiAgfVxuICBrZXlkb3duKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmlzU2hpZnRLZXlEb3duICYmIGV2ZW50LmtleSA9PT0gXCJTaGlmdFwiKSB7XG4gICAgICB0aGlzLmlzU2hpZnRLZXlEb3duID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI21vZGUgIT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUgJiYgIXRoaXMuaXNFZGl0b3JIYW5kbGluZ0tleWJvYXJkKSB7XG4gICAgICBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLl9rZXlib2FyZE1hbmFnZXIuZXhlYyh0aGlzLCBldmVudCk7XG4gICAgfVxuICB9XG4gIGtleXVwKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuaXNTaGlmdEtleURvd24gJiYgZXZlbnQua2V5ID09PSBcIlNoaWZ0XCIpIHtcbiAgICAgIHRoaXMuaXNTaGlmdEtleURvd24gPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLiNoaWdobGlnaHRXaGVuU2hpZnRVcCkge1xuICAgICAgICB0aGlzLiNoaWdobGlnaHRXaGVuU2hpZnRVcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNvblNlbGVjdEVuZChcIm1haW5fdG9vbGJhclwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25FZGl0aW5nQWN0aW9uKHtcbiAgICBuYW1lXG4gIH0pIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgXCJ1bmRvXCI6XG4gICAgICBjYXNlIFwicmVkb1wiOlxuICAgICAgY2FzZSBcImRlbGV0ZVwiOlxuICAgICAgY2FzZSBcInNlbGVjdEFsbFwiOlxuICAgICAgICB0aGlzW25hbWVdKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImhpZ2hsaWdodFNlbGVjdGlvblwiOlxuICAgICAgICB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbihcImNvbnRleHRfbWVudVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gICNkaXNwYXRjaFVwZGF0ZVN0YXRlcyhkZXRhaWxzKSB7XG4gICAgY29uc3QgaGFzQ2hhbmdlZCA9IE9iamVjdC5lbnRyaWVzKGRldGFpbHMpLnNvbWUoKFtrZXksIHZhbHVlXSkgPT4gdGhpcy4jcHJldmlvdXNTdGF0ZXNba2V5XSAhPT0gdmFsdWUpO1xuICAgIGlmIChoYXNDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9ldmVudEJ1cy5kaXNwYXRjaChcImFubm90YXRpb25lZGl0b3JzdGF0ZXNjaGFuZ2VkXCIsIHtcbiAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICBkZXRhaWxzOiBPYmplY3QuYXNzaWduKHRoaXMuI3ByZXZpb3VzU3RhdGVzLCBkZXRhaWxzKVxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUICYmIGRldGFpbHMuaGFzU2VsZWN0ZWRFZGl0b3IgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoW1tBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfRlJFRSwgdHJ1ZV1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI2Rpc3BhdGNoVXBkYXRlVUkoZGV0YWlscykge1xuICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwiYW5ub3RhdGlvbmVkaXRvcnBhcmFtc2NoYW5nZWRcIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgZGV0YWlsc1xuICAgIH0pO1xuICB9XG4gIHNldEVkaXRpbmdTdGF0ZShpc0VkaXRpbmcpIHtcbiAgICBpZiAoaXNFZGl0aW5nKSB7XG4gICAgICB0aGlzLiNhZGRGb2N1c01hbmFnZXIoKTtcbiAgICAgIHRoaXMuI2FkZENvcHlQYXN0ZUxpc3RlbmVycygpO1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICBpc0VkaXRpbmc6IHRoaXMuI21vZGUgIT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUsXG4gICAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKSxcbiAgICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1VuZG8oKSxcbiAgICAgICAgaGFzU29tZXRoaW5nVG9SZWRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1JlZG8oKSxcbiAgICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jcmVtb3ZlRm9jdXNNYW5hZ2VyKCk7XG4gICAgICB0aGlzLiNyZW1vdmVDb3B5UGFzdGVMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgICAgaXNFZGl0aW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICB0aGlzLmRpc2FibGVVc2VyU2VsZWN0KGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJFZGl0b3JUeXBlcyh0eXBlcykge1xuICAgIGlmICh0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNlZGl0b3JUeXBlcyA9IHR5cGVzO1xuICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiB0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3JUeXBlLmRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICAgIH1cbiAgfVxuICBnZXRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jaWRNYW5hZ2VyLmlkO1xuICB9XG4gIGdldCBjdXJyZW50TGF5ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsbExheWVycy5nZXQodGhpcy4jY3VycmVudFBhZ2VJbmRleCk7XG4gIH1cbiAgZ2V0TGF5ZXIocGFnZUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsbExheWVycy5nZXQocGFnZUluZGV4KTtcbiAgfVxuICBnZXQgY3VycmVudFBhZ2VJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY3VycmVudFBhZ2VJbmRleDtcbiAgfVxuICBhZGRMYXllcihsYXllcikge1xuICAgIHRoaXMuI2FsbExheWVycy5zZXQobGF5ZXIucGFnZUluZGV4LCBsYXllcik7XG4gICAgaWYgKHRoaXMuI2lzRW5hYmxlZCkge1xuICAgICAgbGF5ZXIuZW5hYmxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxheWVyLmRpc2FibGUoKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlTGF5ZXIobGF5ZXIpIHtcbiAgICB0aGlzLiNhbGxMYXllcnMuZGVsZXRlKGxheWVyLnBhZ2VJbmRleCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTW9kZShtb2RlLCBlZGl0SWQgPSBudWxsLCBpc0Zyb21LZXlib2FyZCA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuI21vZGUgPT09IG1vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5KSB7XG4gICAgICBhd2FpdCB0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgaWYgKCF0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy4jY3VycmVudERyYXdpbmdTZXNzaW9uPy5jb21taXRPclJlbW92ZSgpO1xuICAgIHRoaXMuI21vZGUgPSBtb2RlO1xuICAgIGlmIChtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FKSB7XG4gICAgICB0aGlzLnNldEVkaXRpbmdTdGF0ZShmYWxzZSk7XG4gICAgICB0aGlzLiNkaXNhYmxlQWxsKCk7XG4gICAgICB0aGlzLl9lZGl0b3JVbmRvQmFyPy5oaWRlKCk7XG4gICAgICB0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TSUdOQVRVUkUpIHtcbiAgICAgIGF3YWl0IHRoaXMuI3NpZ25hdHVyZU1hbmFnZXI/LmxvYWRTaWduYXR1cmVzKCk7XG4gICAgfVxuICAgIHRoaXMuc2V0RWRpdGluZ1N0YXRlKHRydWUpO1xuICAgIGF3YWl0IHRoaXMuI2VuYWJsZUFsbCgpO1xuICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgbGF5ZXIudXBkYXRlTW9kZShtb2RlKTtcbiAgICB9XG4gICAgaWYgKCFlZGl0SWQpIHtcbiAgICAgIGlmIChpc0Zyb21LZXlib2FyZCkge1xuICAgICAgICB0aGlzLmFkZE5ld0VkaXRvckZyb21LZXlib2FyZCgpO1xuICAgICAgfVxuICAgICAgdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgPT09IGVkaXRJZCkge1xuICAgICAgICB0aGlzLnNldFNlbGVjdGVkKGVkaXRvcik7XG4gICAgICAgIGVkaXRvci5lbnRlckluRWRpdE1vZGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRvci51bnNlbGVjdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgYWRkTmV3RWRpdG9yRnJvbUtleWJvYXJkKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRMYXllci5jYW5DcmVhdGVOZXdFbXB0eUVkaXRvcigpKSB7XG4gICAgICB0aGlzLmN1cnJlbnRMYXllci5hZGROZXdFZGl0b3IoKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlVG9vbGJhcihtb2RlKSB7XG4gICAgaWYgKG1vZGUgPT09IHRoaXMuI21vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJzd2l0Y2hhbm5vdGF0aW9uZWRpdG9ybW9kZVwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBtb2RlXG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuQ1JFQVRFOlxuICAgICAgICB0aGlzLmN1cnJlbnRMYXllci5hZGROZXdFZGl0b3IodmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9ERUZBVUxUX0NPTE9SOlxuICAgICAgICB0aGlzLiNtYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXI/LnVwZGF0ZUNvbG9yKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9TSE9XX0FMTDpcbiAgICAgICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJyZXBvcnR0ZWxlbWV0cnlcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICB0eXBlOiBcImVkaXRpbmdcIixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJoaWdobGlnaHRcIixcbiAgICAgICAgICAgICAgYWN0aW9uOiBcInRvZ2dsZV92aXNpYmlsaXR5XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAodGhpcy4jc2hvd0FsbFN0YXRlcyB8fD0gbmV3IE1hcCgpKS5zZXQodHlwZSwgdmFsdWUpO1xuICAgICAgICB0aGlzLnNob3dBbGxFZGl0b3JzKFwiaGlnaGxpZ2h0XCIsIHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgZWRpdG9yLnVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiB0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgZWRpdG9yVHlwZS51cGRhdGVEZWZhdWx0UGFyYW1zKHR5cGUsIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgc2hvd0FsbEVkaXRvcnModHlwZSwgdmlzaWJsZSwgdXBkYXRlQnV0dG9uID0gZmFsc2UpIHtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZWRpdG9yLmVkaXRvclR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgZWRpdG9yLnNob3codmlzaWJsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy4jc2hvd0FsbFN0YXRlcz8uZ2V0KEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9TSE9XX0FMTCkgPz8gdHJ1ZTtcbiAgICBpZiAoc3RhdGUgIT09IHZpc2libGUpIHtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoW1tBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfU0hPV19BTEwsIHZpc2libGVdXSk7XG4gICAgfVxuICB9XG4gIGVuYWJsZVdhaXRpbmcobXVzdFdhaXQgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLiNpc1dhaXRpbmcgPT09IG11c3RXYWl0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2lzV2FpdGluZyA9IG11c3RXYWl0O1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICBpZiAobXVzdFdhaXQpIHtcbiAgICAgICAgbGF5ZXIuZGlzYWJsZUNsaWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXllci5lbmFibGVDbGljaygpO1xuICAgICAgfVxuICAgICAgbGF5ZXIuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJ3YWl0aW5nXCIsIG11c3RXYWl0KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgI2VuYWJsZUFsbCgpIHtcbiAgICBpZiAoIXRoaXMuI2lzRW5hYmxlZCkge1xuICAgICAgdGhpcy4jaXNFbmFibGVkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgICBwcm9taXNlcy5wdXNoKGxheWVyLmVuYWJsZSgpKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgICAgZWRpdG9yLmVuYWJsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAjZGlzYWJsZUFsbCgpIHtcbiAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG4gICAgaWYgKHRoaXMuI2lzRW5hYmxlZCkge1xuICAgICAgdGhpcy4jaXNFbmFibGVkID0gZmFsc2U7XG4gICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgICBsYXllci5kaXNhYmxlKCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICAgIGVkaXRvci5kaXNhYmxlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldEVkaXRvcnMocGFnZUluZGV4KSB7XG4gICAgY29uc3QgZWRpdG9ycyA9IFtdO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlZGl0b3IucGFnZUluZGV4ID09PSBwYWdlSW5kZXgpIHtcbiAgICAgICAgZWRpdG9ycy5wdXNoKGVkaXRvcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlZGl0b3JzO1xuICB9XG4gIGdldEVkaXRvcihpZCkge1xuICAgIHJldHVybiB0aGlzLiNhbGxFZGl0b3JzLmdldChpZCk7XG4gIH1cbiAgYWRkRWRpdG9yKGVkaXRvcikge1xuICAgIHRoaXMuI2FsbEVkaXRvcnMuc2V0KGVkaXRvci5pZCwgZWRpdG9yKTtcbiAgfVxuICByZW1vdmVFZGl0b3IoZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvci5kaXYuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIGlmICh0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCk7XG4gICAgICB9XG4gICAgICB0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5mb2N1c01haW5Db250YWluZXIoKTtcbiAgICAgICAgdGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkID0gbnVsbDtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgICB0aGlzLiNhbGxFZGl0b3JzLmRlbGV0ZShlZGl0b3IuaWQpO1xuICAgIGlmIChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgdGhpcy4jbWlzc2luZ0NhbnZhc2VzPy5kZWxldGUoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgIH1cbiAgICB0aGlzLnVuc2VsZWN0KGVkaXRvcik7XG4gICAgaWYgKCFlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCB8fCAhdGhpcy4jZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcy5oYXMoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpKSB7XG4gICAgICB0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZT8ucmVtb3ZlKGVkaXRvci5pZCk7XG4gICAgfVxuICB9XG4gIGFkZERlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpIHtcbiAgICB0aGlzLiNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzLmFkZChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgdGhpcy5hZGRDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uKGVkaXRvcik7XG4gICAgZWRpdG9yLmRlbGV0ZWQgPSB0cnVlO1xuICB9XG4gIGlzRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICByZXR1cm4gdGhpcy4jZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcy5oYXMoYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gIH1cbiAgcmVtb3ZlRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRvcikge1xuICAgIHRoaXMuI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMuZGVsZXRlKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICB0aGlzLnJlbW92ZUNoYW5nZWRFeGlzdGluZ0Fubm90YXRpb24oZWRpdG9yKTtcbiAgICBlZGl0b3IuZGVsZXRlZCA9IGZhbHNlO1xuICB9XG4gICNhZGRFZGl0b3JUb0xheWVyKGVkaXRvcikge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy4jYWxsTGF5ZXJzLmdldChlZGl0b3IucGFnZUluZGV4KTtcbiAgICBpZiAobGF5ZXIpIHtcbiAgICAgIGxheWVyLmFkZE9yUmVidWlsZChlZGl0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZEVkaXRvcihlZGl0b3IpO1xuICAgICAgdGhpcy5hZGRUb0Fubm90YXRpb25TdG9yYWdlKGVkaXRvcik7XG4gICAgfVxuICB9XG4gIHNldEFjdGl2ZUVkaXRvcihlZGl0b3IpIHtcbiAgICBpZiAodGhpcy4jYWN0aXZlRWRpdG9yID09PSBlZGl0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWN0aXZlRWRpdG9yID0gZWRpdG9yO1xuICAgIGlmIChlZGl0b3IpIHtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yLnByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgfVxuICB9XG4gIGdldCAjbGFzdFNlbGVjdGVkRWRpdG9yKCkge1xuICAgIGxldCBlZCA9IG51bGw7XG4gICAgZm9yIChlZCBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHt9XG4gICAgcmV0dXJuIGVkO1xuICB9XG4gIHVwZGF0ZVVJKGVkaXRvcikge1xuICAgIGlmICh0aGlzLiNsYXN0U2VsZWN0ZWRFZGl0b3IgPT09IGVkaXRvcikge1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3IucHJvcGVydGllc1RvVXBkYXRlKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlVUlGb3JEZWZhdWx0UHJvcGVydGllcyhlZGl0b3JUeXBlKSB7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3JUeXBlLmRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICB9XG4gIHRvZ2dsZVNlbGVjdGVkKGVkaXRvcikge1xuICAgIGlmICh0aGlzLiNzZWxlY3RlZEVkaXRvcnMuaGFzKGVkaXRvcikpIHtcbiAgICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5kZWxldGUoZWRpdG9yKTtcbiAgICAgIGVkaXRvci51bnNlbGVjdCgpO1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICBoYXNTZWxlY3RlZEVkaXRvcjogdGhpcy5oYXNTZWxlY3Rpb25cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuYWRkKGVkaXRvcik7XG4gICAgZWRpdG9yLnNlbGVjdCgpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yLnByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRydWVcbiAgICB9KTtcbiAgfVxuICBzZXRTZWxlY3RlZChlZGl0b3IpIHtcbiAgICB0aGlzLiNjdXJyZW50RHJhd2luZ1Nlc3Npb24/LmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgZm9yIChjb25zdCBlZCBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGlmIChlZCAhPT0gZWRpdG9yKSB7XG4gICAgICAgIGVkLnVuc2VsZWN0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5hZGQoZWRpdG9yKTtcbiAgICBlZGl0b3Iuc2VsZWN0KCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3IucHJvcGVydGllc1RvVXBkYXRlKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTZWxlY3RlZEVkaXRvcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGlzU2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5oYXMoZWRpdG9yKTtcbiAgfVxuICBnZXQgZmlyc3RTZWxlY3RlZEVkaXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcbiAgfVxuICB1bnNlbGVjdChlZGl0b3IpIHtcbiAgICBlZGl0b3IudW5zZWxlY3QoKTtcbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuZGVsZXRlKGVkaXRvcik7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRoaXMuaGFzU2VsZWN0aW9uXG4gICAgfSk7XG4gIH1cbiAgZ2V0IGhhc1NlbGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLnNpemUgIT09IDA7XG4gIH1cbiAgZ2V0IGlzRW50ZXJIYW5kbGVkKCkge1xuICAgIHJldHVybiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuc2l6ZSA9PT0gMSAmJiB0aGlzLmZpcnN0U2VsZWN0ZWRFZGl0b3IuaXNFbnRlckhhbmRsZWQ7XG4gIH1cbiAgdW5kbygpIHtcbiAgICB0aGlzLiNjb21tYW5kTWFuYWdlci51bmRvKCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1VuZG8oKSxcbiAgICAgIGhhc1NvbWV0aGluZ1RvUmVkbzogdHJ1ZSxcbiAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKVxuICAgIH0pO1xuICAgIHRoaXMuX2VkaXRvclVuZG9CYXI/LmhpZGUoKTtcbiAgfVxuICByZWRvKCkge1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLnJlZG8oKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTb21ldGhpbmdUb1VuZG86IHRydWUsXG4gICAgICBoYXNTb21ldGhpbmdUb1JlZG86IHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmhhc1NvbWV0aGluZ1RvUmVkbygpLFxuICAgICAgaXNFbXB0eTogdGhpcy4jaXNFbXB0eSgpXG4gICAgfSk7XG4gIH1cbiAgYWRkQ29tbWFuZHMocGFyYW1zKSB7XG4gICAgdGhpcy4jY29tbWFuZE1hbmFnZXIuYWRkKHBhcmFtcyk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0cnVlLFxuICAgICAgaGFzU29tZXRoaW5nVG9SZWRvOiBmYWxzZSxcbiAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKVxuICAgIH0pO1xuICB9XG4gIGNsZWFuVW5kb1N0YWNrKHR5cGUpIHtcbiAgICB0aGlzLiNjb21tYW5kTWFuYWdlci5jbGVhblR5cGUodHlwZSk7XG4gIH1cbiAgI2lzRW1wdHkoKSB7XG4gICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLiNhbGxFZGl0b3JzLnNpemUgPT09IDEpIHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgICAgcmV0dXJuIGVkaXRvci5pc0VtcHR5KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBkZWxldGUoKSB7XG4gICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIGNvbnN0IGRyYXdpbmdFZGl0b3IgPSB0aGlzLmN1cnJlbnRMYXllcj8uZW5kRHJhd2luZ1Nlc3Npb24odHJ1ZSk7XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbiAmJiAhZHJhd2luZ0VkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3JzID0gZHJhd2luZ0VkaXRvciA/IFtkcmF3aW5nRWRpdG9yXSA6IFsuLi50aGlzLiNzZWxlY3RlZEVkaXRvcnNdO1xuICAgIGNvbnN0IGNtZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2VkaXRvclVuZG9CYXI/LnNob3codW5kbywgZWRpdG9ycy5sZW5ndGggPT09IDEgPyBlZGl0b3JzWzBdLmVkaXRvclR5cGUgOiBlZGl0b3JzLmxlbmd0aCk7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHVuZG8gPSAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICAgIHRoaXMuI2FkZEVkaXRvclRvTGF5ZXIoZWRpdG9yKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kLFxuICAgICAgdW5kbyxcbiAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgY29tbWl0T3JSZW1vdmUoKSB7XG4gICAgdGhpcy4jYWN0aXZlRWRpdG9yPy5jb21taXRPclJlbW92ZSgpO1xuICB9XG4gIGhhc1NvbWV0aGluZ1RvQ29udHJvbCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWN0aXZlRWRpdG9yIHx8IHRoaXMuaGFzU2VsZWN0aW9uO1xuICB9XG4gICNzZWxlY3RFZGl0b3JzKGVkaXRvcnMpIHtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGVkaXRvci51bnNlbGVjdCgpO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICBpZiAoZWRpdG9yLmlzRW1wdHkoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5hZGQoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5zZWxlY3QoKTtcbiAgICB9XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRoaXMuaGFzU2VsZWN0aW9uXG4gICAgfSk7XG4gIH1cbiAgc2VsZWN0QWxsKCkge1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgZWRpdG9yLmNvbW1pdCgpO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RFZGl0b3JzKHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpO1xuICB9XG4gIHVuc2VsZWN0QWxsKCkge1xuICAgIGlmICh0aGlzLiNhY3RpdmVFZGl0b3IpIHtcbiAgICAgIHRoaXMuI2FjdGl2ZUVkaXRvci5jb21taXRPclJlbW92ZSgpO1xuICAgICAgaWYgKHRoaXMuI21vZGUgIT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy4jY3VycmVudERyYXdpbmdTZXNzaW9uPy5jb21taXRPclJlbW92ZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBlZGl0b3IudW5zZWxlY3QoKTtcbiAgICB9XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgdHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzKHgsIHksIG5vQ29tbWl0ID0gZmFsc2UpIHtcbiAgICBpZiAoIW5vQ29tbWl0KSB7XG4gICAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jdHJhbnNsYXRpb25bMF0gKz0geDtcbiAgICB0aGlzLiN0cmFuc2xhdGlvblsxXSArPSB5O1xuICAgIGNvbnN0IFt0b3RhbFgsIHRvdGFsWV0gPSB0aGlzLiN0cmFuc2xhdGlvbjtcbiAgICBjb25zdCBlZGl0b3JzID0gWy4uLnRoaXMuI3NlbGVjdGVkRWRpdG9yc107XG4gICAgY29uc3QgVElNRV9UT19XQUlUID0gMTAwMDtcbiAgICBpZiAodGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCk7XG4gICAgfVxuICAgIHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB0aGlzLiN0cmFuc2xhdGlvblswXSA9IHRoaXMuI3RyYW5zbGF0aW9uWzFdID0gMDtcbiAgICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jYWxsRWRpdG9ycy5oYXMoZWRpdG9yLmlkKSkge1xuICAgICAgICAgICAgICBlZGl0b3IudHJhbnNsYXRlSW5QYWdlKHRvdGFsWCwgdG90YWxZKTtcbiAgICAgICAgICAgICAgZWRpdG9yLnRyYW5zbGF0aW9uRG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNhbGxFZGl0b3JzLmhhcyhlZGl0b3IuaWQpKSB7XG4gICAgICAgICAgICAgIGVkaXRvci50cmFuc2xhdGVJblBhZ2UoLXRvdGFsWCwgLXRvdGFsWSk7XG4gICAgICAgICAgICAgIGVkaXRvci50cmFuc2xhdGlvbkRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG11c3RFeGVjOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSwgVElNRV9UT19XQUlUKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICBlZGl0b3IudHJhbnNsYXRlSW5QYWdlKHgsIHkpO1xuICAgICAgZWRpdG9yLnRyYW5zbGF0aW9uRG9uZSgpO1xuICAgIH1cbiAgfVxuICBzZXRVcERyYWdTZXNzaW9uKCkge1xuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kaXNhYmxlVXNlclNlbGVjdCh0cnVlKTtcbiAgICB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMuc2V0KGVkaXRvciwge1xuICAgICAgICBzYXZlZFg6IGVkaXRvci54LFxuICAgICAgICBzYXZlZFk6IGVkaXRvci55LFxuICAgICAgICBzYXZlZFBhZ2VJbmRleDogZWRpdG9yLnBhZ2VJbmRleCxcbiAgICAgICAgbmV3WDogMCxcbiAgICAgICAgbmV3WTogMCxcbiAgICAgICAgbmV3UGFnZUluZGV4OiAtMVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGVuZERyYWdTZXNzaW9uKCkge1xuICAgIGlmICghdGhpcy4jZHJhZ2dpbmdFZGl0b3JzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuZGlzYWJsZVVzZXJTZWxlY3QoZmFsc2UpO1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuI2RyYWdnaW5nRWRpdG9ycztcbiAgICB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMgPSBudWxsO1xuICAgIGxldCBtdXN0QmVBZGRlZEluVW5kb1N0YWNrID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBbe1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBwYWdlSW5kZXhcbiAgICB9LCB2YWx1ZV0gb2YgbWFwKSB7XG4gICAgICB2YWx1ZS5uZXdYID0geDtcbiAgICAgIHZhbHVlLm5ld1kgPSB5O1xuICAgICAgdmFsdWUubmV3UGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgICAgbXVzdEJlQWRkZWRJblVuZG9TdGFjayB8fD0geCAhPT0gdmFsdWUuc2F2ZWRYIHx8IHkgIT09IHZhbHVlLnNhdmVkWSB8fCBwYWdlSW5kZXggIT09IHZhbHVlLnNhdmVkUGFnZUluZGV4O1xuICAgIH1cbiAgICBpZiAoIW11c3RCZUFkZGVkSW5VbmRvU3RhY2spIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbW92ZSA9IChlZGl0b3IsIHgsIHksIHBhZ2VJbmRleCkgPT4ge1xuICAgICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy4jYWxsTGF5ZXJzLmdldChwYWdlSW5kZXgpO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgZWRpdG9yLl9zZXRQYXJlbnRBbmRQb3NpdGlvbihwYXJlbnQsIHgsIHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVkaXRvci5wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgICAgICAgZWRpdG9yLnggPSB4O1xuICAgICAgICAgIGVkaXRvci55ID0geTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBbZWRpdG9yLCB7XG4gICAgICAgICAgbmV3WCxcbiAgICAgICAgICBuZXdZLFxuICAgICAgICAgIG5ld1BhZ2VJbmRleFxuICAgICAgICB9XSBvZiBtYXApIHtcbiAgICAgICAgICBtb3ZlKGVkaXRvciwgbmV3WCwgbmV3WSwgbmV3UGFnZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBbZWRpdG9yLCB7XG4gICAgICAgICAgc2F2ZWRYLFxuICAgICAgICAgIHNhdmVkWSxcbiAgICAgICAgICBzYXZlZFBhZ2VJbmRleFxuICAgICAgICB9XSBvZiBtYXApIHtcbiAgICAgICAgICBtb3ZlKGVkaXRvciwgc2F2ZWRYLCBzYXZlZFksIHNhdmVkUGFnZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZHJhZ1NlbGVjdGVkRWRpdG9ycyh0eCwgdHkpIHtcbiAgICBpZiAoIXRoaXMuI2RyYWdnaW5nRWRpdG9ycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMua2V5cygpKSB7XG4gICAgICBlZGl0b3IuZHJhZyh0eCwgdHkpO1xuICAgIH1cbiAgfVxuICByZWJ1aWxkKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IucGFyZW50ID09PSBudWxsKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldExheWVyKGVkaXRvci5wYWdlSW5kZXgpO1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuY2hhbmdlUGFyZW50KGVkaXRvcik7XG4gICAgICAgIHBhcmVudC5hZGRPclJlYnVpbGQoZWRpdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkRWRpdG9yKGVkaXRvcik7XG4gICAgICAgIHRoaXMuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZShlZGl0b3IpO1xuICAgICAgICBlZGl0b3IucmVidWlsZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlZGl0b3IucGFyZW50LmFkZE9yUmVidWlsZChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBnZXQgaXNFZGl0b3JIYW5kbGluZ0tleWJvYXJkKCkge1xuICAgIHJldHVybiB0aGlzLmdldEFjdGl2ZSgpPy5zaG91bGRHZXRLZXlib2FyZEV2ZW50cygpIHx8IHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5zaXplID09PSAxICYmIHRoaXMuZmlyc3RTZWxlY3RlZEVkaXRvci5zaG91bGRHZXRLZXlib2FyZEV2ZW50cygpO1xuICB9XG4gIGlzQWN0aXZlKGVkaXRvcikge1xuICAgIHJldHVybiB0aGlzLiNhY3RpdmVFZGl0b3IgPT09IGVkaXRvcjtcbiAgfVxuICBnZXRBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FjdGl2ZUVkaXRvcjtcbiAgfVxuICBnZXRNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLiNtb2RlO1xuICB9XG4gIGdldCBpbWFnZU1hbmFnZXIoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImltYWdlTWFuYWdlclwiLCBuZXcgSW1hZ2VNYW5hZ2VyKCkpO1xuICB9XG4gIGdldFNlbGVjdGlvbkJveGVzKHRleHRMYXllcikge1xuICAgIGlmICghdGV4dExheWVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc2VsZWN0aW9uLnJhbmdlQ291bnQ7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBpZiAoIXRleHRMYXllci5jb250YWlucyhzZWxlY3Rpb24uZ2V0UmFuZ2VBdChpKS5jb21tb25BbmNlc3RvckNvbnRhaW5lcikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHg6IGxheWVyWCxcbiAgICAgIHk6IGxheWVyWSxcbiAgICAgIHdpZHRoOiBwYXJlbnRXaWR0aCxcbiAgICAgIGhlaWdodDogcGFyZW50SGVpZ2h0XG4gICAgfSA9IHRleHRMYXllci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgcm90YXRvcjtcbiAgICBzd2l0Y2ggKHRleHRMYXllci5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1haW4tcm90YXRpb25cIikpIHtcbiAgICAgIGNhc2UgXCI5MFwiOlxuICAgICAgICByb3RhdG9yID0gKHgsIHksIHcsIGgpID0+ICh7XG4gICAgICAgICAgeDogKHkgLSBsYXllclkpIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIHk6IDEgLSAoeCArIHcgLSBsYXllclgpIC8gcGFyZW50V2lkdGgsXG4gICAgICAgICAgd2lkdGg6IGggLyBwYXJlbnRIZWlnaHQsXG4gICAgICAgICAgaGVpZ2h0OiB3IC8gcGFyZW50V2lkdGhcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIjE4MFwiOlxuICAgICAgICByb3RhdG9yID0gKHgsIHksIHcsIGgpID0+ICh7XG4gICAgICAgICAgeDogMSAtICh4ICsgdyAtIGxheWVyWCkgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICB5OiAxIC0gKHkgKyBoIC0gbGF5ZXJZKSAvIHBhcmVudEhlaWdodCxcbiAgICAgICAgICB3aWR0aDogdyAvIHBhcmVudFdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaCAvIHBhcmVudEhlaWdodFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiMjcwXCI6XG4gICAgICAgIHJvdGF0b3IgPSAoeCwgeSwgdywgaCkgPT4gKHtcbiAgICAgICAgICB4OiAxIC0gKHkgKyBoIC0gbGF5ZXJZKSAvIHBhcmVudEhlaWdodCxcbiAgICAgICAgICB5OiAoeCAtIGxheWVyWCkgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICB3aWR0aDogaCAvIHBhcmVudEhlaWdodCxcbiAgICAgICAgICBoZWlnaHQ6IHcgLyBwYXJlbnRXaWR0aFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByb3RhdG9yID0gKHgsIHksIHcsIGgpID0+ICh7XG4gICAgICAgICAgeDogKHggLSBsYXllclgpIC8gcGFyZW50V2lkdGgsXG4gICAgICAgICAgeTogKHkgLSBsYXllclkpIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiB3IC8gcGFyZW50V2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoIC8gcGFyZW50SGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgYm94ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzZWxlY3Rpb24ucmFuZ2VDb3VudDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoaSk7XG4gICAgICBpZiAocmFuZ2UuY29sbGFwc2VkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gb2YgcmFuZ2UuZ2V0Q2xpZW50UmVjdHMoKSkge1xuICAgICAgICBpZiAod2lkdGggPT09IDAgfHwgaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYm94ZXMucHVzaChyb3RhdG9yKHgsIHksIHdpZHRoLCBoZWlnaHQpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJveGVzLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBib3hlcztcbiAgfVxuICBhZGRDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uKHtcbiAgICBhbm5vdGF0aW9uRWxlbWVudElkLFxuICAgIGlkXG4gIH0pIHtcbiAgICAodGhpcy4jY2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbnMgfHw9IG5ldyBNYXAoKSkuc2V0KGFubm90YXRpb25FbGVtZW50SWQsIGlkKTtcbiAgfVxuICByZW1vdmVDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uKHtcbiAgICBhbm5vdGF0aW9uRWxlbWVudElkXG4gIH0pIHtcbiAgICB0aGlzLiNjaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9ucz8uZGVsZXRlKGFubm90YXRpb25FbGVtZW50SWQpO1xuICB9XG4gIHJlbmRlckFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pIHtcbiAgICBjb25zdCBlZGl0b3JJZCA9IHRoaXMuI2NoYW5nZWRFeGlzdGluZ0Fubm90YXRpb25zPy5nZXQoYW5ub3RhdGlvbi5kYXRhLmlkKTtcbiAgICBpZiAoIWVkaXRvcklkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI2Fubm90YXRpb25TdG9yYWdlLmdldFJhd1ZhbHVlKGVkaXRvcklkKTtcbiAgICBpZiAoIWVkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSAmJiAhZWRpdG9yLmhhc0JlZW5Nb2RpZmllZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZGl0b3IucmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbik7XG4gIH1cbiAgc2V0TWlzc2luZ0NhbnZhcyhhbm5vdGF0aW9uSWQsIGFubm90YXRpb25FbGVtZW50SWQsIGNhbnZhcykge1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI21pc3NpbmdDYW52YXNlcz8uZ2V0KGFubm90YXRpb25JZCk7XG4gICAgaWYgKCFlZGl0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWRpdG9yLnNldENhbnZhcyhhbm5vdGF0aW9uRWxlbWVudElkLCBjYW52YXMpO1xuICAgIHRoaXMuI21pc3NpbmdDYW52YXNlcy5kZWxldGUoYW5ub3RhdGlvbklkKTtcbiAgfVxuICBhZGRNaXNzaW5nQ2FudmFzKGFubm90YXRpb25JZCwgZWRpdG9yKSB7XG4gICAgKHRoaXMuI21pc3NpbmdDYW52YXNlcyB8fD0gbmV3IE1hcCgpKS5zZXQoYW5ub3RhdGlvbklkLCBlZGl0b3IpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9hbHRfdGV4dC5qc1xuXG5jbGFzcyBBbHRUZXh0IHtcbiAgI2FsdFRleHQgPSBudWxsO1xuICAjYWx0VGV4dERlY29yYXRpdmUgPSBmYWxzZTtcbiAgI2FsdFRleHRCdXR0b24gPSBudWxsO1xuICAjYWx0VGV4dEJ1dHRvbkxhYmVsID0gbnVsbDtcbiAgI2FsdFRleHRUb29sdGlwID0gbnVsbDtcbiAgI2FsdFRleHRUb29sdGlwVGltZW91dCA9IG51bGw7XG4gICNhbHRUZXh0V2FzRnJvbUtleUJvYXJkID0gZmFsc2U7XG4gICNiYWRnZSA9IG51bGw7XG4gICNlZGl0b3IgPSBudWxsO1xuICAjZ3Vlc3NlZFRleHQgPSBudWxsO1xuICAjdGV4dFdpdGhEaXNjbGFpbWVyID0gbnVsbDtcbiAgI3VzZU5ld0FsdFRleHRGbG93ID0gZmFsc2U7XG4gIHN0YXRpYyAjbDEwbk5ld0J1dHRvbiA9IG51bGw7XG4gIHN0YXRpYyBfbDEwbiA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvciA9IGVkaXRvcjtcbiAgICB0aGlzLiN1c2VOZXdBbHRUZXh0RmxvdyA9IGVkaXRvci5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRGbG93O1xuICAgIEFsdFRleHQuI2wxMG5OZXdCdXR0b24gfHw9IE9iamVjdC5mcmVlemUoe1xuICAgICAgYWRkZWQ6IFwicGRmanMtZWRpdG9yLW5ldy1hbHQtdGV4dC1hZGRlZC1idXR0b25cIixcbiAgICAgIFwiYWRkZWQtbGFiZWxcIjogXCJwZGZqcy1lZGl0b3ItbmV3LWFsdC10ZXh0LWFkZGVkLWJ1dHRvbi1sYWJlbFwiLFxuICAgICAgbWlzc2luZzogXCJwZGZqcy1lZGl0b3ItbmV3LWFsdC10ZXh0LW1pc3NpbmctYnV0dG9uXCIsXG4gICAgICBcIm1pc3NpbmctbGFiZWxcIjogXCJwZGZqcy1lZGl0b3ItbmV3LWFsdC10ZXh0LW1pc3NpbmctYnV0dG9uLWxhYmVsXCIsXG4gICAgICByZXZpZXc6IFwicGRmanMtZWRpdG9yLW5ldy1hbHQtdGV4dC10by1yZXZpZXctYnV0dG9uXCIsXG4gICAgICBcInJldmlldy1sYWJlbFwiOiBcInBkZmpzLWVkaXRvci1uZXctYWx0LXRleHQtdG8tcmV2aWV3LWJ1dHRvbi1sYWJlbFwiXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbikge1xuICAgIEFsdFRleHQuX2wxMG4gPz89IGwxMG47XG4gIH1cbiAgYXN5bmMgcmVuZGVyKCkge1xuICAgIGNvbnN0IGFsdFRleHQgPSB0aGlzLiNhbHRUZXh0QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBhbHRUZXh0LmNsYXNzTmFtZSA9IFwiYWx0VGV4dFwiO1xuICAgIGFsdFRleHQudGFiSW5kZXggPSBcIjBcIjtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuI2FsdFRleHRCdXR0b25MYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGFsdFRleHQuYXBwZW5kKGxhYmVsKTtcbiAgICBpZiAodGhpcy4jdXNlTmV3QWx0VGV4dEZsb3cpIHtcbiAgICAgIGFsdFRleHQuY2xhc3NMaXN0LmFkZChcIm5ld1wiKTtcbiAgICAgIGFsdFRleHQuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIEFsdFRleHQuI2wxMG5OZXdCdXR0b24ubWlzc2luZyk7XG4gICAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQWx0VGV4dC4jbDEwbk5ld0J1dHRvbltcIm1pc3NpbmctbGFiZWxcIl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbHRUZXh0LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWVkaXRvci1hbHQtdGV4dC1idXR0b25cIik7XG4gICAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItYWx0LXRleHQtYnV0dG9uLWxhYmVsXCIpO1xuICAgIH1cbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5fc2lnbmFsO1xuICAgIGFsdFRleHQuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGFsdFRleHQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGV2ZW50ID0+IGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBjb25zdCBvbkNsaWNrID0gZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLmVkaXRBbHRUZXh0KHRoaXMuI2VkaXRvcik7XG4gICAgICBpZiAodGhpcy4jdXNlTmV3QWx0VGV4dEZsb3cpIHtcbiAgICAgICAgdGhpcy4jZWRpdG9yLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgICAgIGFjdGlvbjogXCJwZGZqcy5pbWFnZS5hbHRfdGV4dC5pbWFnZV9zdGF0dXNfbGFiZWxfY2xpY2tlZFwiLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGxhYmVsOiB0aGlzLiNsYWJlbFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBhbHRUZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBvbkNsaWNrLCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgYWx0VGV4dC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBhbHRUZXh0ICYmIGV2ZW50LmtleSA9PT0gXCJFbnRlclwiKSB7XG4gICAgICAgIHRoaXMuI2FsdFRleHRXYXNGcm9tS2V5Qm9hcmQgPSB0cnVlO1xuICAgICAgICBvbkNsaWNrKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBhd2FpdCB0aGlzLiNzZXRTdGF0ZSgpO1xuICAgIHJldHVybiBhbHRUZXh0O1xuICB9XG4gIGdldCAjbGFiZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsdFRleHQgJiYgXCJhZGRlZFwiIHx8IHRoaXMuI2FsdFRleHQgPT09IG51bGwgJiYgdGhpcy5ndWVzc2VkVGV4dCAmJiBcInJldmlld1wiIHx8IFwibWlzc2luZ1wiO1xuICB9XG4gIGZpbmlzaCgpIHtcbiAgICBpZiAoIXRoaXMuI2FsdFRleHRCdXR0b24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWx0VGV4dEJ1dHRvbi5mb2N1cyh7XG4gICAgICBmb2N1c1Zpc2libGU6IHRoaXMuI2FsdFRleHRXYXNGcm9tS2V5Qm9hcmRcbiAgICB9KTtcbiAgICB0aGlzLiNhbHRUZXh0V2FzRnJvbUtleUJvYXJkID0gZmFsc2U7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICBpZiAodGhpcy4jdXNlTmV3QWx0VGV4dEZsb3cpIHtcbiAgICAgIHJldHVybiB0aGlzLiNhbHRUZXh0ID09PSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gIXRoaXMuI2FsdFRleHQgJiYgIXRoaXMuI2FsdFRleHREZWNvcmF0aXZlO1xuICB9XG4gIGhhc0RhdGEoKSB7XG4gICAgaWYgKHRoaXMuI3VzZU5ld0FsdFRleHRGbG93KSB7XG4gICAgICByZXR1cm4gdGhpcy4jYWx0VGV4dCAhPT0gbnVsbCB8fCAhIXRoaXMuI2d1ZXNzZWRUZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pc0VtcHR5KCk7XG4gIH1cbiAgZ2V0IGd1ZXNzZWRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiNndWVzc2VkVGV4dDtcbiAgfVxuICBhc3luYyBzZXRHdWVzc2VkVGV4dChndWVzc2VkVGV4dCkge1xuICAgIGlmICh0aGlzLiNhbHRUZXh0ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2d1ZXNzZWRUZXh0ID0gZ3Vlc3NlZFRleHQ7XG4gICAgdGhpcy4jdGV4dFdpdGhEaXNjbGFpbWVyID0gYXdhaXQgQWx0VGV4dC5fbDEwbi5nZXQoXCJwZGZqcy1lZGl0b3ItbmV3LWFsdC10ZXh0LWdlbmVyYXRlZC1hbHQtdGV4dC13aXRoLWRpc2NsYWltZXJcIiwge1xuICAgICAgZ2VuZXJhdGVkQWx0VGV4dDogZ3Vlc3NlZFRleHRcbiAgICB9KTtcbiAgICB0aGlzLiNzZXRTdGF0ZSgpO1xuICB9XG4gIHRvZ2dsZUFsdFRleHRCYWRnZSh2aXNpYmlsaXR5ID0gZmFsc2UpIHtcbiAgICBpZiAoIXRoaXMuI3VzZU5ld0FsdFRleHRGbG93IHx8IHRoaXMuI2FsdFRleHQpIHtcbiAgICAgIHRoaXMuI2JhZGdlPy5yZW1vdmUoKTtcbiAgICAgIHRoaXMuI2JhZGdlID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNiYWRnZSkge1xuICAgICAgY29uc3QgYmFkZ2UgPSB0aGlzLiNiYWRnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBiYWRnZS5jbGFzc05hbWUgPSBcIm5vQWx0VGV4dEJhZGdlXCI7XG4gICAgICB0aGlzLiNlZGl0b3IuZGl2LmFwcGVuZChiYWRnZSk7XG4gICAgfVxuICAgIHRoaXMuI2JhZGdlLmNsYXNzTGlzdC50b2dnbGUoXCJoaWRkZW5cIiwgIXZpc2liaWxpdHkpO1xuICB9XG4gIHNlcmlhbGl6ZShpc0ZvckNvcHlpbmcpIHtcbiAgICBsZXQgYWx0VGV4dCA9IHRoaXMuI2FsdFRleHQ7XG4gICAgaWYgKCFpc0ZvckNvcHlpbmcgJiYgdGhpcy4jZ3Vlc3NlZFRleHQgPT09IGFsdFRleHQpIHtcbiAgICAgIGFsdFRleHQgPSB0aGlzLiN0ZXh0V2l0aERpc2NsYWltZXI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBhbHRUZXh0LFxuICAgICAgZGVjb3JhdGl2ZTogdGhpcy4jYWx0VGV4dERlY29yYXRpdmUsXG4gICAgICBndWVzc2VkVGV4dDogdGhpcy4jZ3Vlc3NlZFRleHQsXG4gICAgICB0ZXh0V2l0aERpc2NsYWltZXI6IHRoaXMuI3RleHRXaXRoRGlzY2xhaW1lclxuICAgIH07XG4gIH1cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFsdFRleHQ6IHRoaXMuI2FsdFRleHQsXG4gICAgICBkZWNvcmF0aXZlOiB0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZVxuICAgIH07XG4gIH1cbiAgc2V0IGRhdGEoe1xuICAgIGFsdFRleHQsXG4gICAgZGVjb3JhdGl2ZSxcbiAgICBndWVzc2VkVGV4dCxcbiAgICB0ZXh0V2l0aERpc2NsYWltZXIsXG4gICAgY2FuY2VsID0gZmFsc2VcbiAgfSkge1xuICAgIGlmIChndWVzc2VkVGV4dCkge1xuICAgICAgdGhpcy4jZ3Vlc3NlZFRleHQgPSBndWVzc2VkVGV4dDtcbiAgICAgIHRoaXMuI3RleHRXaXRoRGlzY2xhaW1lciA9IHRleHRXaXRoRGlzY2xhaW1lcjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2FsdFRleHQgPT09IGFsdFRleHQgJiYgdGhpcy4jYWx0VGV4dERlY29yYXRpdmUgPT09IGRlY29yYXRpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjYW5jZWwpIHtcbiAgICAgIHRoaXMuI2FsdFRleHQgPSBhbHRUZXh0O1xuICAgICAgdGhpcy4jYWx0VGV4dERlY29yYXRpdmUgPSBkZWNvcmF0aXZlO1xuICAgIH1cbiAgICB0aGlzLiNzZXRTdGF0ZSgpO1xuICB9XG4gIHRvZ2dsZShlbmFibGVkID0gZmFsc2UpIHtcbiAgICBpZiAoIXRoaXMuI2FsdFRleHRCdXR0b24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFlbmFibGVkICYmIHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCk7XG4gICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLiNhbHRUZXh0QnV0dG9uLmRpc2FibGVkID0gIWVuYWJsZWQ7XG4gIH1cbiAgc2hvd24oKSB7XG4gICAgdGhpcy4jZWRpdG9yLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgYWN0aW9uOiBcInBkZmpzLmltYWdlLmFsdF90ZXh0LmltYWdlX3N0YXR1c19sYWJlbF9kaXNwbGF5ZWRcIixcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbGFiZWw6IHRoaXMuI2xhYmVsXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNhbHRUZXh0QnV0dG9uPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNhbHRUZXh0QnV0dG9uID0gbnVsbDtcbiAgICB0aGlzLiNhbHRUZXh0QnV0dG9uTGFiZWwgPSBudWxsO1xuICAgIHRoaXMuI2FsdFRleHRUb29sdGlwID0gbnVsbDtcbiAgICB0aGlzLiNiYWRnZT8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jYmFkZ2UgPSBudWxsO1xuICB9XG4gIGFzeW5jICNzZXRTdGF0ZSgpIHtcbiAgICBjb25zdCBidXR0b24gPSB0aGlzLiNhbHRUZXh0QnV0dG9uO1xuICAgIGlmICghYnV0dG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiN1c2VOZXdBbHRUZXh0Rmxvdykge1xuICAgICAgYnV0dG9uLmNsYXNzTGlzdC50b2dnbGUoXCJkb25lXCIsICEhdGhpcy4jYWx0VGV4dCk7XG4gICAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIEFsdFRleHQuI2wxMG5OZXdCdXR0b25bdGhpcy4jbGFiZWxdKTtcbiAgICAgIHRoaXMuI2FsdFRleHRCdXR0b25MYWJlbD8uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIEFsdFRleHQuI2wxMG5OZXdCdXR0b25bYCR7dGhpcy4jbGFiZWx9LWxhYmVsYF0pO1xuICAgICAgaWYgKCF0aGlzLiNhbHRUZXh0KSB7XG4gICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwPy5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuI2FsdFRleHQgJiYgIXRoaXMuI2FsdFRleHREZWNvcmF0aXZlKSB7XG4gICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwiZG9uZVwiKTtcbiAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXA/LnJlbW92ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBidXR0b24uY2xhc3NMaXN0LmFkZChcImRvbmVcIik7XG4gICAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtZWRpdG9yLWFsdC10ZXh0LWVkaXQtYnV0dG9uXCIpO1xuICAgIH1cbiAgICBsZXQgdG9vbHRpcCA9IHRoaXMuI2FsdFRleHRUb29sdGlwO1xuICAgIGlmICghdG9vbHRpcCkge1xuICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXAgPSB0b29sdGlwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICB0b29sdGlwLmNsYXNzTmFtZSA9IFwidG9vbHRpcFwiO1xuICAgICAgdG9vbHRpcC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwidG9vbHRpcFwiKTtcbiAgICAgIHRvb2x0aXAuaWQgPSBgYWx0LXRleHQtdG9vbHRpcC0ke3RoaXMuI2VkaXRvci5pZH1gO1xuICAgICAgY29uc3QgREVMQVlfVE9fU0hPV19UT09MVElQID0gMTAwO1xuICAgICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuX3NpZ25hbDtcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0KTtcbiAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgIH0sIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwLmNsYXNzTGlzdC5hZGQoXCJzaG93XCIpO1xuICAgICAgICAgIHRoaXMuI2VkaXRvci5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgICAgICAgIGFjdGlvbjogXCJhbHRfdGV4dF90b29sdGlwXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgREVMQVlfVE9fU0hPV19UT09MVElQKTtcbiAgICAgIH0sIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0KTtcbiAgICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwPy5jbGFzc0xpc3QucmVtb3ZlKFwic2hvd1wiKTtcbiAgICAgIH0sIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2FsdFRleHREZWNvcmF0aXZlKSB7XG4gICAgICB0b29sdGlwLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWVkaXRvci1hbHQtdGV4dC1kZWNvcmF0aXZlLXRvb2x0aXBcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvb2x0aXAucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIpO1xuICAgICAgdG9vbHRpcC50ZXh0Q29udGVudCA9IHRoaXMuI2FsdFRleHQ7XG4gICAgfVxuICAgIGlmICghdG9vbHRpcC5wYXJlbnROb2RlKSB7XG4gICAgICBidXR0b24uYXBwZW5kKHRvb2x0aXApO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy4jZWRpdG9yLmdldEVsZW1lbnRGb3JBbHRUZXh0KCk7XG4gICAgZWxlbWVudD8uc2V0QXR0cmlidXRlKFwiYXJpYS1kZXNjcmliZWRieVwiLCB0b29sdGlwLmlkKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS90b3VjaF9tYW5hZ2VyLmpzXG5cbmNsYXNzIFRvdWNoTWFuYWdlciB7XG4gICNjb250YWluZXI7XG4gICNpc1BpbmNoaW5nID0gZmFsc2U7XG4gICNpc1BpbmNoaW5nU3RvcHBlZCA9IG51bGw7XG4gICNpc1BpbmNoaW5nRGlzYWJsZWQ7XG4gICNvblBpbmNoU3RhcnQ7XG4gICNvblBpbmNoaW5nO1xuICAjb25QaW5jaEVuZDtcbiAgI3BvaW50ZXJEb3duQUMgPSBudWxsO1xuICAjc2lnbmFsO1xuICAjdG91Y2hJbmZvID0gbnVsbDtcbiAgI3RvdWNoTWFuYWdlckFDO1xuICAjdG91Y2hNb3ZlQUMgPSBudWxsO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY29udGFpbmVyLFxuICAgIGlzUGluY2hpbmdEaXNhYmxlZCA9IG51bGwsXG4gICAgaXNQaW5jaGluZ1N0b3BwZWQgPSBudWxsLFxuICAgIG9uUGluY2hTdGFydCA9IG51bGwsXG4gICAgb25QaW5jaGluZyA9IG51bGwsXG4gICAgb25QaW5jaEVuZCA9IG51bGwsXG4gICAgc2lnbmFsXG4gIH0pIHtcbiAgICB0aGlzLiNjb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy4jaXNQaW5jaGluZ1N0b3BwZWQgPSBpc1BpbmNoaW5nU3RvcHBlZDtcbiAgICB0aGlzLiNpc1BpbmNoaW5nRGlzYWJsZWQgPSBpc1BpbmNoaW5nRGlzYWJsZWQ7XG4gICAgdGhpcy4jb25QaW5jaFN0YXJ0ID0gb25QaW5jaFN0YXJ0O1xuICAgIHRoaXMuI29uUGluY2hpbmcgPSBvblBpbmNoaW5nO1xuICAgIHRoaXMuI29uUGluY2hFbmQgPSBvblBpbmNoRW5kO1xuICAgIHRoaXMuI3RvdWNoTWFuYWdlckFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHRoaXMuI3NpZ25hbCA9IEFib3J0U2lnbmFsLmFueShbc2lnbmFsLCB0aGlzLiN0b3VjaE1hbmFnZXJBQy5zaWduYWxdKTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy4jb25Ub3VjaFN0YXJ0LmJpbmQodGhpcyksIHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgc2lnbmFsOiB0aGlzLiNzaWduYWxcbiAgICB9KTtcbiAgfVxuICBnZXQgTUlOX1RPVUNIX0RJU1RBTkNFX1RPX1BJTkNIKCkge1xuICAgIHJldHVybiAzNSAvIE91dHB1dFNjYWxlLnBpeGVsUmF0aW87XG4gIH1cbiAgI29uVG91Y2hTdGFydChldnQpIHtcbiAgICBpZiAodGhpcy4jaXNQaW5jaGluZ0Rpc2FibGVkPy4oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZ0LnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAodGhpcy4jcG9pbnRlckRvd25BQykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwb2ludGVyRG93bkFDID0gdGhpcy4jcG9pbnRlckRvd25BQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IEFib3J0U2lnbmFsLmFueShbdGhpcy4jc2lnbmFsLCBwb2ludGVyRG93bkFDLnNpZ25hbF0pO1xuICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy4jY29udGFpbmVyO1xuICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgICAgc2lnbmFsLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNhbmNlbFBvaW50ZXJEb3duID0gZSA9PiB7XG4gICAgICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICAgICAgICB0aGlzLiNwb2ludGVyRG93bkFDPy5hYm9ydCgpO1xuICAgICAgICAgIHRoaXMuI3BvaW50ZXJEb3duQUMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBlID0+IHtcbiAgICAgICAgaWYgKGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikge1xuICAgICAgICAgIHN0b3BFdmVudChlKTtcbiAgICAgICAgICBjYW5jZWxQb2ludGVyRG93bihlKTtcbiAgICAgICAgfVxuICAgICAgfSwgb3B0cyk7XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBjYW5jZWxQb2ludGVyRG93biwgb3B0cyk7XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJjYW5jZWxcIiwgY2FuY2VsUG9pbnRlckRvd24sIG9wdHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI3RvdWNoTW92ZUFDKSB7XG4gICAgICB0aGlzLiN0b3VjaE1vdmVBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IEFib3J0U2lnbmFsLmFueShbdGhpcy4jc2lnbmFsLCB0aGlzLiN0b3VjaE1vdmVBQy5zaWduYWxdKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuI2NvbnRhaW5lcjtcbiAgICAgIGNvbnN0IG9wdCA9IHtcbiAgICAgICAgc2lnbmFsLFxuICAgICAgICBjYXB0dXJlOiBmYWxzZSxcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH07XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLiNvblRvdWNoTW92ZS5iaW5kKHRoaXMpLCBvcHQpO1xuICAgICAgY29uc3Qgb25Ub3VjaEVuZCA9IHRoaXMuI29uVG91Y2hFbmQuYmluZCh0aGlzKTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgb25Ub3VjaEVuZCwgb3B0KTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgb25Ub3VjaEVuZCwgb3B0KTtcbiAgICAgIG9wdC5jYXB0dXJlID0gdHJ1ZTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgc3RvcEV2ZW50LCBvcHQpO1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBzdG9wRXZlbnQsIG9wdCk7XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJjYW5jZWxcIiwgc3RvcEV2ZW50LCBvcHQpO1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgc3RvcEV2ZW50LCBvcHQpO1xuICAgICAgdGhpcy4jb25QaW5jaFN0YXJ0Py4oKTtcbiAgICB9XG4gICAgc3RvcEV2ZW50KGV2dCk7XG4gICAgaWYgKGV2dC50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCB0aGlzLiNpc1BpbmNoaW5nU3RvcHBlZD8uKCkpIHtcbiAgICAgIHRoaXMuI3RvdWNoSW5mbyA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBbdG91Y2gwLCB0b3VjaDFdID0gZXZ0LnRvdWNoZXM7XG4gICAgaWYgKHRvdWNoMC5pZGVudGlmaWVyID4gdG91Y2gxLmlkZW50aWZpZXIpIHtcbiAgICAgIFt0b3VjaDAsIHRvdWNoMV0gPSBbdG91Y2gxLCB0b3VjaDBdO1xuICAgIH1cbiAgICB0aGlzLiN0b3VjaEluZm8gPSB7XG4gICAgICB0b3VjaDBYOiB0b3VjaDAuc2NyZWVuWCxcbiAgICAgIHRvdWNoMFk6IHRvdWNoMC5zY3JlZW5ZLFxuICAgICAgdG91Y2gxWDogdG91Y2gxLnNjcmVlblgsXG4gICAgICB0b3VjaDFZOiB0b3VjaDEuc2NyZWVuWVxuICAgIH07XG4gIH1cbiAgI29uVG91Y2hNb3ZlKGV2dCkge1xuICAgIGlmICghdGhpcy4jdG91Y2hJbmZvIHx8IGV2dC50b3VjaGVzLmxlbmd0aCAhPT0gMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdG9wRXZlbnQoZXZ0KTtcbiAgICBsZXQgW3RvdWNoMCwgdG91Y2gxXSA9IGV2dC50b3VjaGVzO1xuICAgIGlmICh0b3VjaDAuaWRlbnRpZmllciA+IHRvdWNoMS5pZGVudGlmaWVyKSB7XG4gICAgICBbdG91Y2gwLCB0b3VjaDFdID0gW3RvdWNoMSwgdG91Y2gwXTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc2NyZWVuWDogc2NyZWVuMFgsXG4gICAgICBzY3JlZW5ZOiBzY3JlZW4wWVxuICAgIH0gPSB0b3VjaDA7XG4gICAgY29uc3Qge1xuICAgICAgc2NyZWVuWDogc2NyZWVuMVgsXG4gICAgICBzY3JlZW5ZOiBzY3JlZW4xWVxuICAgIH0gPSB0b3VjaDE7XG4gICAgY29uc3QgdG91Y2hJbmZvID0gdGhpcy4jdG91Y2hJbmZvO1xuICAgIGNvbnN0IHtcbiAgICAgIHRvdWNoMFg6IHBUb3VjaDBYLFxuICAgICAgdG91Y2gwWTogcFRvdWNoMFksXG4gICAgICB0b3VjaDFYOiBwVG91Y2gxWCxcbiAgICAgIHRvdWNoMVk6IHBUb3VjaDFZXG4gICAgfSA9IHRvdWNoSW5mbztcbiAgICBjb25zdCBwcmV2R2FwWCA9IHBUb3VjaDFYIC0gcFRvdWNoMFg7XG4gICAgY29uc3QgcHJldkdhcFkgPSBwVG91Y2gxWSAtIHBUb3VjaDBZO1xuICAgIGNvbnN0IGN1cnJHYXBYID0gc2NyZWVuMVggLSBzY3JlZW4wWDtcbiAgICBjb25zdCBjdXJyR2FwWSA9IHNjcmVlbjFZIC0gc2NyZWVuMFk7XG4gICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLmh5cG90KGN1cnJHYXBYLCBjdXJyR2FwWSkgfHwgMTtcbiAgICBjb25zdCBwRGlzdGFuY2UgPSBNYXRoLmh5cG90KHByZXZHYXBYLCBwcmV2R2FwWSkgfHwgMTtcbiAgICBpZiAoIXRoaXMuI2lzUGluY2hpbmcgJiYgTWF0aC5hYnMocERpc3RhbmNlIC0gZGlzdGFuY2UpIDw9IFRvdWNoTWFuYWdlci5NSU5fVE9VQ0hfRElTVEFOQ0VfVE9fUElOQ0gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdG91Y2hJbmZvLnRvdWNoMFggPSBzY3JlZW4wWDtcbiAgICB0b3VjaEluZm8udG91Y2gwWSA9IHNjcmVlbjBZO1xuICAgIHRvdWNoSW5mby50b3VjaDFYID0gc2NyZWVuMVg7XG4gICAgdG91Y2hJbmZvLnRvdWNoMVkgPSBzY3JlZW4xWTtcbiAgICBpZiAoIXRoaXMuI2lzUGluY2hpbmcpIHtcbiAgICAgIHRoaXMuI2lzUGluY2hpbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvcmlnaW4gPSBbKHNjcmVlbjBYICsgc2NyZWVuMVgpIC8gMiwgKHNjcmVlbjBZICsgc2NyZWVuMVkpIC8gMl07XG4gICAgdGhpcy4jb25QaW5jaGluZz8uKG9yaWdpbiwgcERpc3RhbmNlLCBkaXN0YW5jZSk7XG4gIH1cbiAgI29uVG91Y2hFbmQoZXZ0KSB7XG4gICAgaWYgKGV2dC50b3VjaGVzLmxlbmd0aCA+PSAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiN0b3VjaE1vdmVBQykge1xuICAgICAgdGhpcy4jdG91Y2hNb3ZlQUMuYWJvcnQoKTtcbiAgICAgIHRoaXMuI3RvdWNoTW92ZUFDID0gbnVsbDtcbiAgICAgIHRoaXMuI29uUGluY2hFbmQ/LigpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI3RvdWNoSW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdG9wRXZlbnQoZXZ0KTtcbiAgICB0aGlzLiN0b3VjaEluZm8gPSBudWxsO1xuICAgIHRoaXMuI2lzUGluY2hpbmcgPSBmYWxzZTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI3RvdWNoTWFuYWdlckFDPy5hYm9ydCgpO1xuICAgIHRoaXMuI3RvdWNoTWFuYWdlckFDID0gbnVsbDtcbiAgICB0aGlzLiNwb2ludGVyRG93bkFDPy5hYm9ydCgpO1xuICAgIHRoaXMuI3BvaW50ZXJEb3duQUMgPSBudWxsO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9lZGl0b3IuanNcblxuXG5cblxuXG5cbmNsYXNzIEFubm90YXRpb25FZGl0b3Ige1xuICAjYWNjZXNzaWJpbGl0eURhdGEgPSBudWxsO1xuICAjYWxsUmVzaXplckRpdnMgPSBudWxsO1xuICAjYWx0VGV4dCA9IG51bGw7XG4gICNkaXNhYmxlZCA9IGZhbHNlO1xuICAjZHJhZ1BvaW50ZXJJZCA9IG51bGw7XG4gICNkcmFnUG9pbnRlclR5cGUgPSBcIlwiO1xuICAja2VlcEFzcGVjdFJhdGlvID0gZmFsc2U7XG4gICNyZXNpemVyc0RpdiA9IG51bGw7XG4gICNsYXN0UG9pbnRlckNvb3JkcyA9IG51bGw7XG4gICNzYXZlZERpbWVuc2lvbnMgPSBudWxsO1xuICAjZm9jdXNBQyA9IG51bGw7XG4gICNmb2N1c2VkUmVzaXplck5hbWUgPSBcIlwiO1xuICAjaGFzQmVlbkNsaWNrZWQgPSBmYWxzZTtcbiAgI2luaXRpYWxSZWN0ID0gbnVsbDtcbiAgI2lzRWRpdGluZyA9IGZhbHNlO1xuICAjaXNJbkVkaXRNb2RlID0gZmFsc2U7XG4gICNpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQgPSBmYWxzZTtcbiAgI21vdmVJbkRPTVRpbWVvdXQgPSBudWxsO1xuICAjcHJldkRyYWdYID0gMDtcbiAgI3ByZXZEcmFnWSA9IDA7XG4gICN0ZWxlbWV0cnlUaW1lb3V0cyA9IG51bGw7XG4gICN0b3VjaE1hbmFnZXIgPSBudWxsO1xuICBfaXNDb3B5ID0gZmFsc2U7XG4gIF9lZGl0VG9vbGJhciA9IG51bGw7XG4gIF9pbml0aWFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIF9pbml0aWFsRGF0YSA9IG51bGw7XG4gIF9pc1Zpc2libGUgPSB0cnVlO1xuICBfdWlNYW5hZ2VyID0gbnVsbDtcbiAgX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IHRydWU7XG4gIHN0YXRpYyBfbDEwbiA9IG51bGw7XG4gIHN0YXRpYyBfbDEwblJlc2l6ZXIgPSBudWxsO1xuICAjaXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgI3pJbmRleCA9IEFubm90YXRpb25FZGl0b3IuX3pJbmRleCsrO1xuICBzdGF0aWMgX2JvcmRlckxpbmVXaWR0aCA9IC0xO1xuICBzdGF0aWMgX2NvbG9yTWFuYWdlciA9IG5ldyBDb2xvck1hbmFnZXIoKTtcbiAgc3RhdGljIF96SW5kZXggPSAxO1xuICBzdGF0aWMgX3RlbGVtZXRyeVRpbWVvdXQgPSAxMDAwO1xuICBzdGF0aWMgZ2V0IF9yZXNpemVyS2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGNvbnN0IHJlc2l6ZSA9IEFubm90YXRpb25FZGl0b3IucHJvdG90eXBlLl9yZXNpemVXaXRoS2V5Ym9hcmQ7XG4gICAgY29uc3Qgc21hbGwgPSBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLlRSQU5TTEFURV9TTUFMTDtcbiAgICBjb25zdCBiaWcgPSBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLlRSQU5TTEFURV9CSUc7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9yZXNpemVyS2V5Ym9hcmRNYW5hZ2VyXCIsIG5ldyBLZXlib2FyZE1hbmFnZXIoW1tbXCJBcnJvd0xlZnRcIiwgXCJtYWMrQXJyb3dMZWZ0XCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFstc21hbGwsIDBdXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93TGVmdFwiLCBcIm1hYytzaGlmdCtBcnJvd0xlZnRcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogWy1iaWcsIDBdXG4gICAgfV0sIFtbXCJBcnJvd1JpZ2h0XCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogW3NtYWxsLCAwXVxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1JpZ2h0XCIsIFwibWFjK3NoaWZ0K0Fycm93UmlnaHRcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogW2JpZywgMF1cbiAgICB9XSwgW1tcIkFycm93VXBcIiwgXCJtYWMrQXJyb3dVcFwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbMCwgLXNtYWxsXVxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1VwXCIsIFwibWFjK3NoaWZ0K0Fycm93VXBcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogWzAsIC1iaWddXG4gICAgfV0sIFtbXCJBcnJvd0Rvd25cIiwgXCJtYWMrQXJyb3dEb3duXCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFswLCBzbWFsbF1cbiAgICB9XSwgW1tcImN0cmwrQXJyb3dEb3duXCIsIFwibWFjK3NoaWZ0K0Fycm93RG93blwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbMCwgYmlnXVxuICAgIH1dLCBbW1wiRXNjYXBlXCIsIFwibWFjK0VzY2FwZVwiXSwgQW5ub3RhdGlvbkVkaXRvci5wcm90b3R5cGUuX3N0b3BSZXNpemluZ1dpdGhLZXlib2FyZF1dKSk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHRoaXMucGFyZW50ID0gcGFyYW1ldGVycy5wYXJlbnQ7XG4gICAgdGhpcy5pZCA9IHBhcmFtZXRlcnMuaWQ7XG4gICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gbnVsbDtcbiAgICB0aGlzLnBhZ2VJbmRleCA9IHBhcmFtZXRlcnMucGFyZW50LnBhZ2VJbmRleDtcbiAgICB0aGlzLm5hbWUgPSBwYXJhbWV0ZXJzLm5hbWU7XG4gICAgdGhpcy5kaXYgPSBudWxsO1xuICAgIHRoaXMuX3VpTWFuYWdlciA9IHBhcmFtZXRlcnMudWlNYW5hZ2VyO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IG51bGw7XG4gICAgdGhpcy5fd2lsbEtlZXBBc3BlY3RSYXRpbyA9IGZhbHNlO1xuICAgIHRoaXMuX2luaXRpYWxPcHRpb25zLmlzQ2VudGVyZWQgPSBwYXJhbWV0ZXJzLmlzQ2VudGVyZWQ7XG4gICAgdGhpcy5fc3RydWN0VHJlZVBhcmVudElkID0gbnVsbDtcbiAgICBjb25zdCB7XG4gICAgICByb3RhdGlvbixcbiAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICBwYWdlSGVpZ2h0LFxuICAgICAgICBwYWdlWCxcbiAgICAgICAgcGFnZVlcbiAgICAgIH1cbiAgICB9ID0gdGhpcy5wYXJlbnQudmlld3BvcnQ7XG4gICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMucGFnZVJvdGF0aW9uID0gKDM2MCArIHJvdGF0aW9uIC0gdGhpcy5fdWlNYW5hZ2VyLnZpZXdQYXJhbWV0ZXJzLnJvdGF0aW9uKSAlIDM2MDtcbiAgICB0aGlzLnBhZ2VEaW1lbnNpb25zID0gW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF07XG4gICAgdGhpcy5wYWdlVHJhbnNsYXRpb24gPSBbcGFnZVgsIHBhZ2VZXTtcbiAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy54ID0gcGFyYW1ldGVycy54IC8gd2lkdGg7XG4gICAgdGhpcy55ID0gcGFyYW1ldGVycy55IC8gaGVpZ2h0O1xuICAgIHRoaXMuaXNBdHRhY2hlZFRvRE9NID0gZmFsc2U7XG4gICAgdGhpcy5kZWxldGVkID0gZmFsc2U7XG4gIH1cbiAgZ2V0IGVkaXRvclR5cGUoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvci5fdHlwZTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzRHJhd2VyKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgZ2V0IF9kZWZhdWx0TGluZUNvbG9yKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfZGVmYXVsdExpbmVDb2xvclwiLCB0aGlzLl9jb2xvck1hbmFnZXIuZ2V0SGV4Q29kZShcIkNhbnZhc1RleHRcIikpO1xuICB9XG4gIHN0YXRpYyBkZWxldGVBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpIHtcbiAgICBjb25zdCBmYWtlRWRpdG9yID0gbmV3IEZha2VFZGl0b3Ioe1xuICAgICAgaWQ6IGVkaXRvci5wYXJlbnQuZ2V0TmV4dElkKCksXG4gICAgICBwYXJlbnQ6IGVkaXRvci5wYXJlbnQsXG4gICAgICB1aU1hbmFnZXI6IGVkaXRvci5fdWlNYW5hZ2VyXG4gICAgfSk7XG4gICAgZmFrZUVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkID0gZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQ7XG4gICAgZmFrZUVkaXRvci5kZWxldGVkID0gdHJ1ZTtcbiAgICBmYWtlRWRpdG9yLl91aU1hbmFnZXIuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZShmYWtlRWRpdG9yKTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuLCBfdWlNYW5hZ2VyKSB7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5fbDEwbiA/Pz0gbDEwbjtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLl9sMTBuUmVzaXplciB8fD0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICB0b3BMZWZ0OiBcInBkZmpzLWVkaXRvci1yZXNpemVyLXRvcC1sZWZ0XCIsXG4gICAgICB0b3BNaWRkbGU6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItdG9wLW1pZGRsZVwiLFxuICAgICAgdG9wUmlnaHQ6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItdG9wLXJpZ2h0XCIsXG4gICAgICBtaWRkbGVSaWdodDogXCJwZGZqcy1lZGl0b3ItcmVzaXplci1taWRkbGUtcmlnaHRcIixcbiAgICAgIGJvdHRvbVJpZ2h0OiBcInBkZmpzLWVkaXRvci1yZXNpemVyLWJvdHRvbS1yaWdodFwiLFxuICAgICAgYm90dG9tTWlkZGxlOiBcInBkZmpzLWVkaXRvci1yZXNpemVyLWJvdHRvbS1taWRkbGVcIixcbiAgICAgIGJvdHRvbUxlZnQ6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItYm90dG9tLWxlZnRcIixcbiAgICAgIG1pZGRsZUxlZnQ6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItbWlkZGxlLWxlZnRcIlxuICAgIH0pO1xuICAgIGlmIChBbm5vdGF0aW9uRWRpdG9yLl9ib3JkZXJMaW5lV2lkdGggIT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuICAgIEFubm90YXRpb25FZGl0b3IuX2JvcmRlckxpbmVXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIi0tb3V0bGluZS13aWR0aFwiKSkgfHwgMDtcbiAgfVxuICBzdGF0aWMgdXBkYXRlRGVmYXVsdFBhcmFtcyhfdHlwZSwgX3ZhbHVlKSB7fVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHN0YXRpYyBpc0hhbmRsaW5nTWltZUZvclBhc3RpbmcobWltZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgcGFzdGUoaXRlbSwgcGFyZW50KSB7XG4gICAgdW5yZWFjaGFibGUoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgZ2V0IHByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgZ2V0IF9pc0RyYWdnYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNEcmFnZ2FibGU7XG4gIH1cbiAgc2V0IF9pc0RyYWdnYWJsZSh2YWx1ZSkge1xuICAgIHRoaXMuI2lzRHJhZ2dhYmxlID0gdmFsdWU7XG4gICAgdGhpcy5kaXY/LmNsYXNzTGlzdC50b2dnbGUoXCJkcmFnZ2FibGVcIiwgdmFsdWUpO1xuICB9XG4gIGdldCBpc0VudGVySGFuZGxlZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjZW50ZXIoKSB7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnRSb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgdGhpcy54IC09IHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodCAvIChwYWdlV2lkdGggKiAyKTtcbiAgICAgICAgdGhpcy55ICs9IHRoaXMud2lkdGggKiBwYWdlV2lkdGggLyAocGFnZUhlaWdodCAqIDIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICB0aGlzLnggKz0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMueSArPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHRoaXMueCArPSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQgLyAocGFnZVdpZHRoICogMik7XG4gICAgICAgIHRoaXMueSAtPSB0aGlzLndpZHRoICogcGFnZVdpZHRoIC8gKHBhZ2VIZWlnaHQgKiAyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnggLT0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMueSAtPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gIH1cbiAgYWRkQ29tbWFuZHMocGFyYW1zKSB7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmFkZENvbW1hbmRzKHBhcmFtcyk7XG4gIH1cbiAgZ2V0IGN1cnJlbnRMYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy5fdWlNYW5hZ2VyLmN1cnJlbnRMYXllcjtcbiAgfVxuICBzZXRJbkJhY2tncm91bmQoKSB7XG4gICAgdGhpcy5kaXYuc3R5bGUuekluZGV4ID0gMDtcbiAgfVxuICBzZXRJbkZvcmVncm91bmQoKSB7XG4gICAgdGhpcy5kaXYuc3R5bGUuekluZGV4ID0gdGhpcy4jekluZGV4O1xuICB9XG4gIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnBhZ2VJbmRleCA9IHBhcmVudC5wYWdlSW5kZXg7XG4gICAgICB0aGlzLnBhZ2VEaW1lbnNpb25zID0gcGFyZW50LnBhZ2VEaW1lbnNpb25zO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNzdG9wUmVzaXppbmcoKTtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIH1cbiAgZm9jdXNpbihldmVudCkge1xuICAgIGlmICghdGhpcy5fZm9jdXNFdmVudHNBbGxvd2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jaGFzQmVlbkNsaWNrZWQpIHtcbiAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNoYXNCZWVuQ2xpY2tlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb2N1c291dChldmVudCkge1xuICAgIGlmICghdGhpcy5fZm9jdXNFdmVudHNBbGxvd2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICBpZiAodGFyZ2V0Py5jbG9zZXN0KGAjJHt0aGlzLmlkfWApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKCF0aGlzLnBhcmVudD8uaXNNdWx0aXBsZVNlbGVjdGlvbikge1xuICAgICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIH1cbiAgfVxuICBjb21taXRPclJlbW92ZSgpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29tbWl0KCk7XG4gICAgfVxuICB9XG4gIGNvbW1pdCgpIHtcbiAgICB0aGlzLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoKTtcbiAgfVxuICBhZGRUb0Fubm90YXRpb25TdG9yYWdlKCkge1xuICAgIHRoaXMuX3VpTWFuYWdlci5hZGRUb0Fubm90YXRpb25TdG9yYWdlKHRoaXMpO1xuICB9XG4gIHNldEF0KHgsIHksIHR4LCB0eSkge1xuICAgIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBbdHgsIHR5XSA9IHRoaXMuc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24odHgsIHR5KTtcbiAgICB0aGlzLnggPSAoeCArIHR4KSAvIHdpZHRoO1xuICAgIHRoaXMueSA9ICh5ICsgdHkpIC8gaGVpZ2h0O1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICBfbW92ZUFmdGVyUGFzdGUoYmFzZVgsIGJhc2VZKSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMuc2V0QXQoYmFzZVggKiBwYXJlbnRXaWR0aCwgYmFzZVkgKiBwYXJlbnRIZWlnaHQsIHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgIHRoaXMuX29uVHJhbnNsYXRlZCgpO1xuICB9XG4gICN0cmFuc2xhdGUoW3dpZHRoLCBoZWlnaHRdLCB4LCB5KSB7XG4gICAgW3gsIHldID0gdGhpcy5zY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbih4LCB5KTtcbiAgICB0aGlzLnggKz0geCAvIHdpZHRoO1xuICAgIHRoaXMueSArPSB5IC8gaGVpZ2h0O1xuICAgIHRoaXMuX29uVHJhbnNsYXRpbmcodGhpcy54LCB0aGlzLnkpO1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICB0cmFuc2xhdGUoeCwgeSkge1xuICAgIHRoaXMuI3RyYW5zbGF0ZSh0aGlzLnBhcmVudERpbWVuc2lvbnMsIHgsIHkpO1xuICB9XG4gIHRyYW5zbGF0ZUluUGFnZSh4LCB5KSB7XG4gICAgdGhpcy4jaW5pdGlhbFJlY3QgfHw9IFt0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdO1xuICAgIHRoaXMuI3RyYW5zbGF0ZSh0aGlzLnBhZ2VEaW1lbnNpb25zLCB4LCB5KTtcbiAgICB0aGlzLmRpdi5zY3JvbGxJbnRvVmlldyh7XG4gICAgICBibG9jazogXCJuZWFyZXN0XCJcbiAgICB9KTtcbiAgfVxuICB0cmFuc2xhdGlvbkRvbmUoKSB7XG4gICAgdGhpcy5fb25UcmFuc2xhdGVkKHRoaXMueCwgdGhpcy55KTtcbiAgfVxuICBkcmFnKHR4LCB0eSkge1xuICAgIHRoaXMuI2luaXRpYWxSZWN0IHx8PSBbdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XTtcbiAgICBjb25zdCB7XG4gICAgICBkaXYsXG4gICAgICBwYXJlbnREaW1lbnNpb25zOiBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF1cbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLnggKz0gdHggLyBwYXJlbnRXaWR0aDtcbiAgICB0aGlzLnkgKz0gdHkgLyBwYXJlbnRIZWlnaHQ7XG4gICAgaWYgKHRoaXMucGFyZW50ICYmICh0aGlzLnggPCAwIHx8IHRoaXMueCA+IDEgfHwgdGhpcy55IDwgMCB8fCB0aGlzLnkgPiAxKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gdGhpcy5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAodGhpcy5wYXJlbnQuZmluZE5ld1BhcmVudCh0aGlzLCB4LCB5KSkge1xuICAgICAgICB0aGlzLnggLT0gTWF0aC5mbG9vcih0aGlzLngpO1xuICAgICAgICB0aGlzLnkgLT0gTWF0aC5mbG9vcih0aGlzLnkpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBbYngsIGJ5XSA9IHRoaXMuZ2V0QmFzZVRyYW5zbGF0aW9uKCk7XG4gICAgeCArPSBieDtcbiAgICB5ICs9IGJ5O1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IGRpdjtcbiAgICBzdHlsZS5sZWZ0ID0gYCR7KDEwMCAqIHgpLnRvRml4ZWQoMil9JWA7XG4gICAgc3R5bGUudG9wID0gYCR7KDEwMCAqIHkpLnRvRml4ZWQoMil9JWA7XG4gICAgdGhpcy5fb25UcmFuc2xhdGluZyh4LCB5KTtcbiAgICBkaXYuc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgYmxvY2s6IFwibmVhcmVzdFwiXG4gICAgfSk7XG4gIH1cbiAgX29uVHJhbnNsYXRpbmcoeCwgeSkge31cbiAgX29uVHJhbnNsYXRlZCh4LCB5KSB7fVxuICBnZXQgX2hhc0JlZW5Nb3ZlZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLiNpbml0aWFsUmVjdCAmJiAodGhpcy4jaW5pdGlhbFJlY3RbMF0gIT09IHRoaXMueCB8fCB0aGlzLiNpbml0aWFsUmVjdFsxXSAhPT0gdGhpcy55KTtcbiAgfVxuICBnZXQgX2hhc0JlZW5SZXNpemVkKCkge1xuICAgIHJldHVybiAhIXRoaXMuI2luaXRpYWxSZWN0ICYmICh0aGlzLiNpbml0aWFsUmVjdFsyXSAhPT0gdGhpcy53aWR0aCB8fCB0aGlzLiNpbml0aWFsUmVjdFszXSAhPT0gdGhpcy5oZWlnaHQpO1xuICB9XG4gIGdldEJhc2VUcmFuc2xhdGlvbigpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgY29uc3Qge1xuICAgICAgX2JvcmRlckxpbmVXaWR0aFxuICAgIH0gPSBBbm5vdGF0aW9uRWRpdG9yO1xuICAgIGNvbnN0IHggPSBfYm9yZGVyTGluZVdpZHRoIC8gcGFyZW50V2lkdGg7XG4gICAgY29uc3QgeSA9IF9ib3JkZXJMaW5lV2lkdGggLyBwYXJlbnRIZWlnaHQ7XG4gICAgc3dpdGNoICh0aGlzLnJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gWy14LCB5XTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeCwgLXldO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFsteCwgLXldO1xuICAgIH1cbiAgfVxuICBnZXQgX211c3RGaXhQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmaXhBbmRTZXRQb3NpdGlvbihyb3RhdGlvbiA9IHRoaXMucm90YXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICBkaXY6IHtcbiAgICAgICAgc3R5bGVcbiAgICAgIH0sXG4gICAgICBwYWdlRGltZW5zaW9uczogW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF1cbiAgICB9ID0gdGhpcztcbiAgICBsZXQge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzO1xuICAgIHdpZHRoICo9IHBhZ2VXaWR0aDtcbiAgICBoZWlnaHQgKj0gcGFnZUhlaWdodDtcbiAgICB4ICo9IHBhZ2VXaWR0aDtcbiAgICB5ICo9IHBhZ2VIZWlnaHQ7XG4gICAgaWYgKHRoaXMuX211c3RGaXhQb3NpdGlvbikge1xuICAgICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgeCA9IE1hdGhDbGFtcCh4LCAwLCBwYWdlV2lkdGggLSB3aWR0aCk7XG4gICAgICAgICAgeSA9IE1hdGhDbGFtcCh5LCAwLCBwYWdlSGVpZ2h0IC0gaGVpZ2h0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA5MDpcbiAgICAgICAgICB4ID0gTWF0aENsYW1wKHgsIDAsIHBhZ2VXaWR0aCAtIGhlaWdodCk7XG4gICAgICAgICAgeSA9IE1hdGhDbGFtcCh5LCB3aWR0aCwgcGFnZUhlaWdodCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTgwOlxuICAgICAgICAgIHggPSBNYXRoQ2xhbXAoeCwgd2lkdGgsIHBhZ2VXaWR0aCk7XG4gICAgICAgICAgeSA9IE1hdGhDbGFtcCh5LCBoZWlnaHQsIHBhZ2VIZWlnaHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI3MDpcbiAgICAgICAgICB4ID0gTWF0aENsYW1wKHgsIGhlaWdodCwgcGFnZVdpZHRoKTtcbiAgICAgICAgICB5ID0gTWF0aENsYW1wKHksIDAsIHBhZ2VIZWlnaHQgLSB3aWR0aCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMueCA9IHggLz0gcGFnZVdpZHRoO1xuICAgIHRoaXMueSA9IHkgLz0gcGFnZUhlaWdodDtcbiAgICBjb25zdCBbYngsIGJ5XSA9IHRoaXMuZ2V0QmFzZVRyYW5zbGF0aW9uKCk7XG4gICAgeCArPSBieDtcbiAgICB5ICs9IGJ5O1xuICAgIHN0eWxlLmxlZnQgPSBgJHsoMTAwICogeCkudG9GaXhlZCgyKX0lYDtcbiAgICBzdHlsZS50b3AgPSBgJHsoMTAwICogeSkudG9GaXhlZCgyKX0lYDtcbiAgICB0aGlzLm1vdmVJbkRPTSgpO1xuICB9XG4gIHN0YXRpYyAjcm90YXRlUG9pbnQoeCwgeSwgYW5nbGUpIHtcbiAgICBzd2l0Y2ggKGFuZ2xlKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gW3ksIC14XTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gWy14LCAteV07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFsteSwgeF07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cbiAgfVxuICBzY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIEFubm90YXRpb25FZGl0b3IuI3JvdGF0ZVBvaW50KHgsIHksIHRoaXMucGFyZW50Um90YXRpb24pO1xuICB9XG4gIHBhZ2VUcmFuc2xhdGlvblRvU2NyZWVuKHgsIHkpIHtcbiAgICByZXR1cm4gQW5ub3RhdGlvbkVkaXRvci4jcm90YXRlUG9pbnQoeCwgeSwgMzYwIC0gdGhpcy5wYXJlbnRSb3RhdGlvbik7XG4gIH1cbiAgI2dldFJvdGF0aW9uTWF0cml4KHJvdGF0aW9uKSB7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICAgICAgICByZXR1cm4gWzAsIC1wYWdlV2lkdGggLyBwYWdlSGVpZ2h0LCBwYWdlSGVpZ2h0IC8gcGFnZVdpZHRoLCAwXTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbLTEsIDAsIDAsIC0xXTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgICAgICAgIHJldHVybiBbMCwgcGFnZVdpZHRoIC8gcGFnZUhlaWdodCwgLXBhZ2VIZWlnaHQgLyBwYWdlV2lkdGgsIDBdO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWzEsIDAsIDAsIDFdO1xuICAgIH1cbiAgfVxuICBnZXQgcGFyZW50U2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VpTWFuYWdlci52aWV3UGFyYW1ldGVycy5yZWFsU2NhbGU7XG4gIH1cbiAgZ2V0IHBhcmVudFJvdGF0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5fdWlNYW5hZ2VyLnZpZXdQYXJhbWV0ZXJzLnJvdGF0aW9uICsgdGhpcy5wYWdlUm90YXRpb24pICUgMzYwO1xuICB9XG4gIGdldCBwYXJlbnREaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhcmVudFNjYWxlLFxuICAgICAgcGFnZURpbWVuc2lvbnM6IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdXG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuIFtwYWdlV2lkdGggKiBwYXJlbnRTY2FsZSwgcGFnZUhlaWdodCAqIHBhcmVudFNjYWxlXTtcbiAgfVxuICBzZXREaW1zKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy5kaXY7XG4gICAgc3R5bGUud2lkdGggPSBgJHsoMTAwICogd2lkdGggLyBwYXJlbnRXaWR0aCkudG9GaXhlZCgyKX0lYDtcbiAgICBpZiAoIXRoaXMuI2tlZXBBc3BlY3RSYXRpbykge1xuICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7KDEwMCAqIGhlaWdodCAvIHBhcmVudEhlaWdodCkudG9GaXhlZCgyKX0lYDtcbiAgICB9XG4gIH1cbiAgZml4RGltcygpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLmRpdjtcbiAgICBjb25zdCB7XG4gICAgICBoZWlnaHQsXG4gICAgICB3aWR0aFxuICAgIH0gPSBzdHlsZTtcbiAgICBjb25zdCB3aWR0aFBlcmNlbnQgPSB3aWR0aC5lbmRzV2l0aChcIiVcIik7XG4gICAgY29uc3QgaGVpZ2h0UGVyY2VudCA9ICF0aGlzLiNrZWVwQXNwZWN0UmF0aW8gJiYgaGVpZ2h0LmVuZHNXaXRoKFwiJVwiKTtcbiAgICBpZiAod2lkdGhQZXJjZW50ICYmIGhlaWdodFBlcmNlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGlmICghd2lkdGhQZXJjZW50KSB7XG4gICAgICBzdHlsZS53aWR0aCA9IGAkeygxMDAgKiBwYXJzZUZsb2F0KHdpZHRoKSAvIHBhcmVudFdpZHRoKS50b0ZpeGVkKDIpfSVgO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2tlZXBBc3BlY3RSYXRpbyAmJiAhaGVpZ2h0UGVyY2VudCkge1xuICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7KDEwMCAqIHBhcnNlRmxvYXQoaGVpZ2h0KSAvIHBhcmVudEhlaWdodCkudG9GaXhlZCgyKX0lYDtcbiAgICB9XG4gIH1cbiAgZ2V0SW5pdGlhbFRyYW5zbGF0aW9uKCkge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cbiAgI2NyZWF0ZVJlc2l6ZXJzKCkge1xuICAgIGlmICh0aGlzLiNyZXNpemVyc0Rpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNyZXNpemVyc0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy4jcmVzaXplcnNEaXYuY2xhc3NMaXN0LmFkZChcInJlc2l6ZXJzXCIpO1xuICAgIGNvbnN0IGNsYXNzZXMgPSB0aGlzLl93aWxsS2VlcEFzcGVjdFJhdGlvID8gW1widG9wTGVmdFwiLCBcInRvcFJpZ2h0XCIsIFwiYm90dG9tUmlnaHRcIiwgXCJib3R0b21MZWZ0XCJdIDogW1widG9wTGVmdFwiLCBcInRvcE1pZGRsZVwiLCBcInRvcFJpZ2h0XCIsIFwibWlkZGxlUmlnaHRcIiwgXCJib3R0b21SaWdodFwiLCBcImJvdHRvbU1pZGRsZVwiLCBcImJvdHRvbUxlZnRcIiwgXCJtaWRkbGVMZWZ0XCJdO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5fc2lnbmFsO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBjbGFzc2VzKSB7XG4gICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy4jcmVzaXplcnNEaXYuYXBwZW5kKGRpdik7XG4gICAgICBkaXYuY2xhc3NMaXN0LmFkZChcInJlc2l6ZXJcIiwgbmFtZSk7XG4gICAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1yZXNpemVyLW5hbWVcIiwgbmFtZSk7XG4gICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMuI3Jlc2l6ZXJQb2ludGVyZG93bi5iaW5kKHRoaXMsIG5hbWUpLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGRpdi50YWJJbmRleCA9IC0xO1xuICAgIH1cbiAgICB0aGlzLmRpdi5wcmVwZW5kKHRoaXMuI3Jlc2l6ZXJzRGl2KTtcbiAgfVxuICAjcmVzaXplclBvaW50ZXJkb3duKG5hbWUsIGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhbHRUZXh0Py50b2dnbGUoZmFsc2UpO1xuICAgIGNvbnN0IHNhdmVkRHJhZ2dhYmxlID0gdGhpcy5faXNEcmFnZ2FibGU7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICB0aGlzLiNsYXN0UG9pbnRlckNvb3JkcyA9IFtldmVudC5zY3JlZW5YLCBldmVudC5zY3JlZW5ZXTtcbiAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl91aU1hbmFnZXIuY29tYmluZWRTaWduYWwoYWMpO1xuICAgIHRoaXMucGFyZW50LnRvZ2dsZVBvaW50ZXJFdmVudHMoZmFsc2UpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgdGhpcy4jcmVzaXplclBvaW50ZXJtb3ZlLmJpbmQodGhpcywgbmFtZSksIHtcbiAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgc3RvcEV2ZW50LCB7XG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy4jc2F2ZWREaW1lbnNpb25zID0ge1xuICAgICAgc2F2ZWRYOiB0aGlzLngsXG4gICAgICBzYXZlZFk6IHRoaXMueSxcbiAgICAgIHNhdmVkV2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBzYXZlZEhlaWdodDogdGhpcy5oZWlnaHRcbiAgICB9O1xuICAgIGNvbnN0IHNhdmVkUGFyZW50Q3Vyc29yID0gdGhpcy5wYXJlbnQuZGl2LnN0eWxlLmN1cnNvcjtcbiAgICBjb25zdCBzYXZlZEN1cnNvciA9IHRoaXMuZGl2LnN0eWxlLmN1cnNvcjtcbiAgICB0aGlzLmRpdi5zdHlsZS5jdXJzb3IgPSB0aGlzLnBhcmVudC5kaXYuc3R5bGUuY3Vyc29yID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZXZlbnQudGFyZ2V0KS5jdXJzb3I7XG4gICAgY29uc3QgcG9pbnRlclVwQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICBhYy5hYm9ydCgpO1xuICAgICAgdGhpcy5wYXJlbnQudG9nZ2xlUG9pbnRlckV2ZW50cyh0cnVlKTtcbiAgICAgIHRoaXMuI2FsdFRleHQ/LnRvZ2dsZSh0cnVlKTtcbiAgICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gc2F2ZWREcmFnZ2FibGU7XG4gICAgICB0aGlzLnBhcmVudC5kaXYuc3R5bGUuY3Vyc29yID0gc2F2ZWRQYXJlbnRDdXJzb3I7XG4gICAgICB0aGlzLmRpdi5zdHlsZS5jdXJzb3IgPSBzYXZlZEN1cnNvcjtcbiAgICAgIHRoaXMuI2FkZFJlc2l6ZVRvVW5kb1N0YWNrKCk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBwb2ludGVyVXBDYWxsYmFjaywge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHBvaW50ZXJVcENhbGxiYWNrLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICAjcmVzaXplKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLnNldERpbXMocGFyZW50V2lkdGggKiB3aWR0aCwgcGFyZW50SGVpZ2h0ICogaGVpZ2h0KTtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgdGhpcy5fb25SZXNpemVkKCk7XG4gIH1cbiAgX29uUmVzaXplZCgpIHt9XG4gICNhZGRSZXNpemVUb1VuZG9TdGFjaygpIHtcbiAgICBpZiAoIXRoaXMuI3NhdmVkRGltZW5zaW9ucykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzYXZlZFgsXG4gICAgICBzYXZlZFksXG4gICAgICBzYXZlZFdpZHRoLFxuICAgICAgc2F2ZWRIZWlnaHRcbiAgICB9ID0gdGhpcy4jc2F2ZWREaW1lbnNpb25zO1xuICAgIHRoaXMuI3NhdmVkRGltZW5zaW9ucyA9IG51bGw7XG4gICAgY29uc3QgbmV3WCA9IHRoaXMueDtcbiAgICBjb25zdCBuZXdZID0gdGhpcy55O1xuICAgIGNvbnN0IG5ld1dpZHRoID0gdGhpcy53aWR0aDtcbiAgICBjb25zdCBuZXdIZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICBpZiAobmV3WCA9PT0gc2F2ZWRYICYmIG5ld1kgPT09IHNhdmVkWSAmJiBuZXdXaWR0aCA9PT0gc2F2ZWRXaWR0aCAmJiBuZXdIZWlnaHQgPT09IHNhdmVkSGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiB0aGlzLiNyZXNpemUuYmluZCh0aGlzLCBuZXdYLCBuZXdZLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KSxcbiAgICAgIHVuZG86IHRoaXMuI3Jlc2l6ZS5iaW5kKHRoaXMsIHNhdmVkWCwgc2F2ZWRZLCBzYXZlZFdpZHRoLCBzYXZlZEhlaWdodCksXG4gICAgICBtdXN0RXhlYzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBfcm91bmQoeCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHggKiAxMDAwMCkgLyAxMDAwMDtcbiAgfVxuICAjcmVzaXplclBvaW50ZXJtb3ZlKG5hbWUsIGV2ZW50KSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGNvbnN0IHNhdmVkWCA9IHRoaXMueDtcbiAgICBjb25zdCBzYXZlZFkgPSB0aGlzLnk7XG4gICAgY29uc3Qgc2F2ZWRXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgY29uc3Qgc2F2ZWRIZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICBjb25zdCBtaW5XaWR0aCA9IEFubm90YXRpb25FZGl0b3IuTUlOX1NJWkUgLyBwYXJlbnRXaWR0aDtcbiAgICBjb25zdCBtaW5IZWlnaHQgPSBBbm5vdGF0aW9uRWRpdG9yLk1JTl9TSVpFIC8gcGFyZW50SGVpZ2h0O1xuICAgIGNvbnN0IHJvdGF0aW9uTWF0cml4ID0gdGhpcy4jZ2V0Um90YXRpb25NYXRyaXgodGhpcy5yb3RhdGlvbik7XG4gICAgY29uc3QgdHJhbnNmID0gKHgsIHkpID0+IFtyb3RhdGlvbk1hdHJpeFswXSAqIHggKyByb3RhdGlvbk1hdHJpeFsyXSAqIHksIHJvdGF0aW9uTWF0cml4WzFdICogeCArIHJvdGF0aW9uTWF0cml4WzNdICogeV07XG4gICAgY29uc3QgaW52Um90YXRpb25NYXRyaXggPSB0aGlzLiNnZXRSb3RhdGlvbk1hdHJpeCgzNjAgLSB0aGlzLnJvdGF0aW9uKTtcbiAgICBjb25zdCBpbnZUcmFuc2YgPSAoeCwgeSkgPT4gW2ludlJvdGF0aW9uTWF0cml4WzBdICogeCArIGludlJvdGF0aW9uTWF0cml4WzJdICogeSwgaW52Um90YXRpb25NYXRyaXhbMV0gKiB4ICsgaW52Um90YXRpb25NYXRyaXhbM10gKiB5XTtcbiAgICBsZXQgZ2V0UG9pbnQ7XG4gICAgbGV0IGdldE9wcG9zaXRlO1xuICAgIGxldCBpc0RpYWdvbmFsID0gZmFsc2U7XG4gICAgbGV0IGlzSG9yaXpvbnRhbCA9IGZhbHNlO1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSBcInRvcExlZnRcIjpcbiAgICAgICAgaXNEaWFnb25hbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFswLCAwXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gW3csIGhdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0b3BNaWRkbGVcIjpcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gW3cgLyAyLCAwXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gW3cgLyAyLCBoXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidG9wUmlnaHRcIjpcbiAgICAgICAgaXNEaWFnb25hbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3LCAwXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gWzAsIGhdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtaWRkbGVSaWdodFwiOlxuICAgICAgICBpc0hvcml6b250YWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbdywgaCAvIDJdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbMCwgaCAvIDJdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJib3R0b21SaWdodFwiOlxuICAgICAgICBpc0RpYWdvbmFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gW3csIGhdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbMCwgMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJvdHRvbU1pZGRsZVwiOlxuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbdyAvIDIsIGhdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbdyAvIDIsIDBdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJib3R0b21MZWZ0XCI6XG4gICAgICAgIGlzRGlhZ29uYWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbMCwgaF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3LCAwXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibWlkZGxlTGVmdFwiOlxuICAgICAgICBpc0hvcml6b250YWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbMCwgaCAvIDJdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbdywgaCAvIDJdO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgcG9pbnQgPSBnZXRQb2ludChzYXZlZFdpZHRoLCBzYXZlZEhlaWdodCk7XG4gICAgY29uc3Qgb3Bwb3NpdGVQb2ludCA9IGdldE9wcG9zaXRlKHNhdmVkV2lkdGgsIHNhdmVkSGVpZ2h0KTtcbiAgICBsZXQgdHJhbnNmT3Bwb3NpdGVQb2ludCA9IHRyYW5zZiguLi5vcHBvc2l0ZVBvaW50KTtcbiAgICBjb25zdCBvcHBvc2l0ZVggPSBBbm5vdGF0aW9uRWRpdG9yLl9yb3VuZChzYXZlZFggKyB0cmFuc2ZPcHBvc2l0ZVBvaW50WzBdKTtcbiAgICBjb25zdCBvcHBvc2l0ZVkgPSBBbm5vdGF0aW9uRWRpdG9yLl9yb3VuZChzYXZlZFkgKyB0cmFuc2ZPcHBvc2l0ZVBvaW50WzFdKTtcbiAgICBsZXQgcmF0aW9YID0gMTtcbiAgICBsZXQgcmF0aW9ZID0gMTtcbiAgICBsZXQgZGVsdGFYLCBkZWx0YVk7XG4gICAgaWYgKCFldmVudC5mcm9tS2V5Ym9hcmQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2NyZWVuWCxcbiAgICAgICAgc2NyZWVuWVxuICAgICAgfSA9IGV2ZW50O1xuICAgICAgY29uc3QgW2xhc3RTY3JlZW5YLCBsYXN0U2NyZWVuWV0gPSB0aGlzLiNsYXN0UG9pbnRlckNvb3JkcztcbiAgICAgIFtkZWx0YVgsIGRlbHRhWV0gPSB0aGlzLnNjcmVlblRvUGFnZVRyYW5zbGF0aW9uKHNjcmVlblggLSBsYXN0U2NyZWVuWCwgc2NyZWVuWSAtIGxhc3RTY3JlZW5ZKTtcbiAgICAgIHRoaXMuI2xhc3RQb2ludGVyQ29vcmRzWzBdID0gc2NyZWVuWDtcbiAgICAgIHRoaXMuI2xhc3RQb2ludGVyQ29vcmRzWzFdID0gc2NyZWVuWTtcbiAgICB9IGVsc2Uge1xuICAgICAgKHtcbiAgICAgICAgZGVsdGFYLFxuICAgICAgICBkZWx0YVlcbiAgICAgIH0gPSBldmVudCk7XG4gICAgfVxuICAgIFtkZWx0YVgsIGRlbHRhWV0gPSBpbnZUcmFuc2YoZGVsdGFYIC8gcGFyZW50V2lkdGgsIGRlbHRhWSAvIHBhcmVudEhlaWdodCk7XG4gICAgaWYgKGlzRGlhZ29uYWwpIHtcbiAgICAgIGNvbnN0IG9sZERpYWcgPSBNYXRoLmh5cG90KHNhdmVkV2lkdGgsIHNhdmVkSGVpZ2h0KTtcbiAgICAgIHJhdGlvWCA9IHJhdGlvWSA9IE1hdGgubWF4KE1hdGgubWluKE1hdGguaHlwb3Qob3Bwb3NpdGVQb2ludFswXSAtIHBvaW50WzBdIC0gZGVsdGFYLCBvcHBvc2l0ZVBvaW50WzFdIC0gcG9pbnRbMV0gLSBkZWx0YVkpIC8gb2xkRGlhZywgMSAvIHNhdmVkV2lkdGgsIDEgLyBzYXZlZEhlaWdodCksIG1pbldpZHRoIC8gc2F2ZWRXaWR0aCwgbWluSGVpZ2h0IC8gc2F2ZWRIZWlnaHQpO1xuICAgIH0gZWxzZSBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICByYXRpb1ggPSBNYXRoQ2xhbXAoTWF0aC5hYnMob3Bwb3NpdGVQb2ludFswXSAtIHBvaW50WzBdIC0gZGVsdGFYKSwgbWluV2lkdGgsIDEpIC8gc2F2ZWRXaWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmF0aW9ZID0gTWF0aENsYW1wKE1hdGguYWJzKG9wcG9zaXRlUG9pbnRbMV0gLSBwb2ludFsxXSAtIGRlbHRhWSksIG1pbkhlaWdodCwgMSkgLyBzYXZlZEhlaWdodDtcbiAgICB9XG4gICAgY29uc3QgbmV3V2lkdGggPSBBbm5vdGF0aW9uRWRpdG9yLl9yb3VuZChzYXZlZFdpZHRoICogcmF0aW9YKTtcbiAgICBjb25zdCBuZXdIZWlnaHQgPSBBbm5vdGF0aW9uRWRpdG9yLl9yb3VuZChzYXZlZEhlaWdodCAqIHJhdGlvWSk7XG4gICAgdHJhbnNmT3Bwb3NpdGVQb2ludCA9IHRyYW5zZiguLi5nZXRPcHBvc2l0ZShuZXdXaWR0aCwgbmV3SGVpZ2h0KSk7XG4gICAgY29uc3QgbmV3WCA9IG9wcG9zaXRlWCAtIHRyYW5zZk9wcG9zaXRlUG9pbnRbMF07XG4gICAgY29uc3QgbmV3WSA9IG9wcG9zaXRlWSAtIHRyYW5zZk9wcG9zaXRlUG9pbnRbMV07XG4gICAgdGhpcy4jaW5pdGlhbFJlY3QgfHw9IFt0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdO1xuICAgIHRoaXMud2lkdGggPSBuZXdXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICB0aGlzLnggPSBuZXdYO1xuICAgIHRoaXMueSA9IG5ld1k7XG4gICAgdGhpcy5zZXREaW1zKHBhcmVudFdpZHRoICogbmV3V2lkdGgsIHBhcmVudEhlaWdodCAqIG5ld0hlaWdodCk7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgIHRoaXMuX29uUmVzaXppbmcoKTtcbiAgfVxuICBfb25SZXNpemluZygpIHt9XG4gIGFsdFRleHRGaW5pc2goKSB7XG4gICAgdGhpcy4jYWx0VGV4dD8uZmluaXNoKCk7XG4gIH1cbiAgYXN5bmMgYWRkRWRpdFRvb2xiYXIoKSB7XG4gICAgaWYgKHRoaXMuX2VkaXRUb29sYmFyIHx8IHRoaXMuI2lzSW5FZGl0TW9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VkaXRUb29sYmFyO1xuICAgIH1cbiAgICB0aGlzLl9lZGl0VG9vbGJhciA9IG5ldyBFZGl0b3JUb29sYmFyKHRoaXMpO1xuICAgIHRoaXMuZGl2LmFwcGVuZCh0aGlzLl9lZGl0VG9vbGJhci5yZW5kZXIoKSk7XG4gICAgaWYgKHRoaXMuI2FsdFRleHQpIHtcbiAgICAgIGF3YWl0IHRoaXMuX2VkaXRUb29sYmFyLmFkZEFsdFRleHQodGhpcy4jYWx0VGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9lZGl0VG9vbGJhcjtcbiAgfVxuICByZW1vdmVFZGl0VG9vbGJhcigpIHtcbiAgICBpZiAoIXRoaXMuX2VkaXRUb29sYmFyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2VkaXRUb29sYmFyLnJlbW92ZSgpO1xuICAgIHRoaXMuX2VkaXRUb29sYmFyID0gbnVsbDtcbiAgICB0aGlzLiNhbHRUZXh0Py5kZXN0cm95KCk7XG4gIH1cbiAgYWRkQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICAgIGNvbnN0IGVkaXRUb29sYmFyRGl2ID0gdGhpcy5fZWRpdFRvb2xiYXI/LmRpdjtcbiAgICBpZiAoZWRpdFRvb2xiYXJEaXYpIHtcbiAgICAgIGVkaXRUb29sYmFyRGl2LmJlZm9yZShjb250YWluZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpdi5hcHBlbmQoY29udGFpbmVyKTtcbiAgICB9XG4gIH1cbiAgZ2V0Q2xpZW50RGltZW5zaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cbiAgYXN5bmMgYWRkQWx0VGV4dEJ1dHRvbigpIHtcbiAgICBpZiAodGhpcy4jYWx0VGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBBbHRUZXh0LmluaXRpYWxpemUoQW5ub3RhdGlvbkVkaXRvci5fbDEwbik7XG4gICAgdGhpcy4jYWx0VGV4dCA9IG5ldyBBbHRUZXh0KHRoaXMpO1xuICAgIGlmICh0aGlzLiNhY2Nlc3NpYmlsaXR5RGF0YSkge1xuICAgICAgdGhpcy4jYWx0VGV4dC5kYXRhID0gdGhpcy4jYWNjZXNzaWJpbGl0eURhdGE7XG4gICAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5RGF0YSA9IG51bGw7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuYWRkRWRpdFRvb2xiYXIoKTtcbiAgfVxuICBnZXQgYWx0VGV4dERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsdFRleHQ/LmRhdGE7XG4gIH1cbiAgc2V0IGFsdFRleHREYXRhKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuI2FsdFRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWx0VGV4dC5kYXRhID0gZGF0YTtcbiAgfVxuICBnZXQgZ3Vlc3NlZEFsdFRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsdFRleHQ/Lmd1ZXNzZWRUZXh0O1xuICB9XG4gIGFzeW5jIHNldEd1ZXNzZWRBbHRUZXh0KHRleHQpIHtcbiAgICBhd2FpdCB0aGlzLiNhbHRUZXh0Py5zZXRHdWVzc2VkVGV4dCh0ZXh0KTtcbiAgfVxuICBzZXJpYWxpemVBbHRUZXh0KGlzRm9yQ29weWluZykge1xuICAgIHJldHVybiB0aGlzLiNhbHRUZXh0Py5zZXJpYWxpemUoaXNGb3JDb3B5aW5nKTtcbiAgfVxuICBoYXNBbHRUZXh0KCkge1xuICAgIHJldHVybiAhIXRoaXMuI2FsdFRleHQgJiYgIXRoaXMuI2FsdFRleHQuaXNFbXB0eSgpO1xuICB9XG4gIGhhc0FsdFRleHREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLiNhbHRUZXh0Py5oYXNEYXRhKCkgPz8gZmFsc2U7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IGRpdiA9IHRoaXMuZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1lZGl0b3Itcm90YXRpb25cIiwgKDM2MCAtIHRoaXMucm90YXRpb24pICUgMzYwKTtcbiAgICBkaXYuY2xhc3NOYW1lID0gdGhpcy5uYW1lO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJpZFwiLCB0aGlzLmlkKTtcbiAgICBkaXYudGFiSW5kZXggPSB0aGlzLiNkaXNhYmxlZCA/IC0xIDogMDtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImFwcGxpY2F0aW9uXCIpO1xuICAgIGlmICh0aGlzLmRlZmF1bHRMMTBuSWQpIHtcbiAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgdGhpcy5kZWZhdWx0TDEwbklkKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUpIHtcbiAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpO1xuICAgIH1cbiAgICB0aGlzLnNldEluRm9yZWdyb3VuZCgpO1xuICAgIHRoaXMuI2FkZEZvY3VzTGlzdGVuZXJzKCk7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGlmICh0aGlzLnBhcmVudFJvdGF0aW9uICUgMTgwICE9PSAwKSB7XG4gICAgICBkaXYuc3R5bGUubWF4V2lkdGggPSBgJHsoMTAwICogcGFyZW50SGVpZ2h0IC8gcGFyZW50V2lkdGgpLnRvRml4ZWQoMil9JWA7XG4gICAgICBkaXYuc3R5bGUubWF4SGVpZ2h0ID0gYCR7KDEwMCAqIHBhcmVudFdpZHRoIC8gcGFyZW50SGVpZ2h0KS50b0ZpeGVkKDIpfSVgO1xuICAgIH1cbiAgICBjb25zdCBbdHgsIHR5XSA9IHRoaXMuZ2V0SW5pdGlhbFRyYW5zbGF0aW9uKCk7XG4gICAgdGhpcy50cmFuc2xhdGUodHgsIHR5KTtcbiAgICBiaW5kRXZlbnRzKHRoaXMsIGRpdiwgW1wia2V5ZG93blwiLCBcInBvaW50ZXJkb3duXCJdKTtcbiAgICBpZiAodGhpcy5pc1Jlc2l6YWJsZSAmJiB0aGlzLl91aU1hbmFnZXIuX3N1cHBvcnRzUGluY2hUb1pvb20pIHtcbiAgICAgIHRoaXMuI3RvdWNoTWFuYWdlciB8fD0gbmV3IFRvdWNoTWFuYWdlcih7XG4gICAgICAgIGNvbnRhaW5lcjogZGl2LFxuICAgICAgICBpc1BpbmNoaW5nRGlzYWJsZWQ6ICgpID0+ICF0aGlzLmlzU2VsZWN0ZWQsXG4gICAgICAgIG9uUGluY2hTdGFydDogdGhpcy4jdG91Y2hQaW5jaFN0YXJ0Q2FsbGJhY2suYmluZCh0aGlzKSxcbiAgICAgICAgb25QaW5jaGluZzogdGhpcy4jdG91Y2hQaW5jaENhbGxiYWNrLmJpbmQodGhpcyksXG4gICAgICAgIG9uUGluY2hFbmQ6IHRoaXMuI3RvdWNoUGluY2hFbmRDYWxsYmFjay5iaW5kKHRoaXMpLFxuICAgICAgICBzaWduYWw6IHRoaXMuX3VpTWFuYWdlci5fc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fdWlNYW5hZ2VyLl9lZGl0b3JVbmRvQmFyPy5oaWRlKCk7XG4gICAgcmV0dXJuIGRpdjtcbiAgfVxuICAjdG91Y2hQaW5jaFN0YXJ0Q2FsbGJhY2soKSB7XG4gICAgdGhpcy4jc2F2ZWREaW1lbnNpb25zID0ge1xuICAgICAgc2F2ZWRYOiB0aGlzLngsXG4gICAgICBzYXZlZFk6IHRoaXMueSxcbiAgICAgIHNhdmVkV2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBzYXZlZEhlaWdodDogdGhpcy5oZWlnaHRcbiAgICB9O1xuICAgIHRoaXMuI2FsdFRleHQ/LnRvZ2dsZShmYWxzZSk7XG4gICAgdGhpcy5wYXJlbnQudG9nZ2xlUG9pbnRlckV2ZW50cyhmYWxzZSk7XG4gIH1cbiAgI3RvdWNoUGluY2hDYWxsYmFjayhfb3JpZ2luLCBwcmV2RGlzdGFuY2UsIGRpc3RhbmNlKSB7XG4gICAgY29uc3Qgc2xvd0Rvd25GYWN0b3IgPSAwLjc7XG4gICAgbGV0IGZhY3RvciA9IHNsb3dEb3duRmFjdG9yICogKGRpc3RhbmNlIC8gcHJldkRpc3RhbmNlKSArIDEgLSBzbG93RG93bkZhY3RvcjtcbiAgICBpZiAoZmFjdG9yID09PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJvdGF0aW9uTWF0cml4ID0gdGhpcy4jZ2V0Um90YXRpb25NYXRyaXgodGhpcy5yb3RhdGlvbik7XG4gICAgY29uc3QgdHJhbnNmID0gKHgsIHkpID0+IFtyb3RhdGlvbk1hdHJpeFswXSAqIHggKyByb3RhdGlvbk1hdHJpeFsyXSAqIHksIHJvdGF0aW9uTWF0cml4WzFdICogeCArIHJvdGF0aW9uTWF0cml4WzNdICogeV07XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGNvbnN0IHNhdmVkWCA9IHRoaXMueDtcbiAgICBjb25zdCBzYXZlZFkgPSB0aGlzLnk7XG4gICAgY29uc3Qgc2F2ZWRXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgY29uc3Qgc2F2ZWRIZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICBjb25zdCBtaW5XaWR0aCA9IEFubm90YXRpb25FZGl0b3IuTUlOX1NJWkUgLyBwYXJlbnRXaWR0aDtcbiAgICBjb25zdCBtaW5IZWlnaHQgPSBBbm5vdGF0aW9uRWRpdG9yLk1JTl9TSVpFIC8gcGFyZW50SGVpZ2h0O1xuICAgIGZhY3RvciA9IE1hdGgubWF4KE1hdGgubWluKGZhY3RvciwgMSAvIHNhdmVkV2lkdGgsIDEgLyBzYXZlZEhlaWdodCksIG1pbldpZHRoIC8gc2F2ZWRXaWR0aCwgbWluSGVpZ2h0IC8gc2F2ZWRIZWlnaHQpO1xuICAgIGNvbnN0IG5ld1dpZHRoID0gQW5ub3RhdGlvbkVkaXRvci5fcm91bmQoc2F2ZWRXaWR0aCAqIGZhY3Rvcik7XG4gICAgY29uc3QgbmV3SGVpZ2h0ID0gQW5ub3RhdGlvbkVkaXRvci5fcm91bmQoc2F2ZWRIZWlnaHQgKiBmYWN0b3IpO1xuICAgIGlmIChuZXdXaWR0aCA9PT0gc2F2ZWRXaWR0aCAmJiBuZXdIZWlnaHQgPT09IHNhdmVkSGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2luaXRpYWxSZWN0IHx8PSBbc2F2ZWRYLCBzYXZlZFksIHNhdmVkV2lkdGgsIHNhdmVkSGVpZ2h0XTtcbiAgICBjb25zdCB0cmFuc2ZDZW50ZXJQb2ludCA9IHRyYW5zZihzYXZlZFdpZHRoIC8gMiwgc2F2ZWRIZWlnaHQgLyAyKTtcbiAgICBjb25zdCBjZW50ZXJYID0gQW5ub3RhdGlvbkVkaXRvci5fcm91bmQoc2F2ZWRYICsgdHJhbnNmQ2VudGVyUG9pbnRbMF0pO1xuICAgIGNvbnN0IGNlbnRlclkgPSBBbm5vdGF0aW9uRWRpdG9yLl9yb3VuZChzYXZlZFkgKyB0cmFuc2ZDZW50ZXJQb2ludFsxXSk7XG4gICAgY29uc3QgbmV3VHJhbnNmQ2VudGVyUG9pbnQgPSB0cmFuc2YobmV3V2lkdGggLyAyLCBuZXdIZWlnaHQgLyAyKTtcbiAgICB0aGlzLnggPSBjZW50ZXJYIC0gbmV3VHJhbnNmQ2VudGVyUG9pbnRbMF07XG4gICAgdGhpcy55ID0gY2VudGVyWSAtIG5ld1RyYW5zZkNlbnRlclBvaW50WzFdO1xuICAgIHRoaXMud2lkdGggPSBuZXdXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICB0aGlzLnNldERpbXMocGFyZW50V2lkdGggKiBuZXdXaWR0aCwgcGFyZW50SGVpZ2h0ICogbmV3SGVpZ2h0KTtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgdGhpcy5fb25SZXNpemluZygpO1xuICB9XG4gICN0b3VjaFBpbmNoRW5kQ2FsbGJhY2soKSB7XG4gICAgdGhpcy4jYWx0VGV4dD8udG9nZ2xlKHRydWUpO1xuICAgIHRoaXMucGFyZW50LnRvZ2dsZVBvaW50ZXJFdmVudHModHJ1ZSk7XG4gICAgdGhpcy4jYWRkUmVzaXplVG9VbmRvU3RhY2soKTtcbiAgfVxuICBwb2ludGVyZG93bihldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5jdHJsS2V5ICYmIGlzTWFjKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNoYXNCZWVuQ2xpY2tlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuX2lzRHJhZ2dhYmxlKSB7XG4gICAgICB0aGlzLiNzZXRVcERyYWdTZXNzaW9uKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jc2VsZWN0T25Qb2ludGVyRXZlbnQoZXZlbnQpO1xuICB9XG4gIGdldCBpc1NlbGVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLl91aU1hbmFnZXIuaXNTZWxlY3RlZCh0aGlzKTtcbiAgfVxuICAjc2VsZWN0T25Qb2ludGVyRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5jdHJsS2V5ICYmICFpc01hYyB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5tZXRhS2V5ICYmIGlzTWFjKSB7XG4gICAgICB0aGlzLnBhcmVudC50b2dnbGVTZWxlY3RlZCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJlbnQuc2V0U2VsZWN0ZWQodGhpcyk7XG4gICAgfVxuICB9XG4gICNzZXRVcERyYWdTZXNzaW9uKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNTZWxlY3RlZFxuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMuX3VpTWFuYWdlci5zZXRVcERyYWdTZXNzaW9uKCk7XG4gICAgbGV0IGhhc0RyYWdnaW5nU3RhcnRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbChhYyk7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIHNpZ25hbFxuICAgIH07XG4gICAgY29uc3QgY2FuY2VsRHJhZyA9IGUgPT4ge1xuICAgICAgYWMuYWJvcnQoKTtcbiAgICAgIHRoaXMuI2RyYWdQb2ludGVySWQgPSBudWxsO1xuICAgICAgdGhpcy4jaGFzQmVlbkNsaWNrZWQgPSBmYWxzZTtcbiAgICAgIGlmICghdGhpcy5fdWlNYW5hZ2VyLmVuZERyYWdTZXNzaW9uKCkpIHtcbiAgICAgICAgdGhpcy4jc2VsZWN0T25Qb2ludGVyRXZlbnQoZSk7XG4gICAgICB9XG4gICAgICBpZiAoaGFzRHJhZ2dpbmdTdGFydGVkKSB7XG4gICAgICAgIHRoaXMuX29uU3RvcERyYWdnaW5nKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgdGhpcy4jcHJldkRyYWdYID0gZXZlbnQuY2xpZW50WDtcbiAgICAgIHRoaXMuI3ByZXZEcmFnWSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICB0aGlzLiNkcmFnUG9pbnRlcklkID0gZXZlbnQucG9pbnRlcklkO1xuICAgICAgdGhpcy4jZHJhZ1BvaW50ZXJUeXBlID0gZXZlbnQucG9pbnRlclR5cGU7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIGUgPT4ge1xuICAgICAgICBpZiAoIWhhc0RyYWdnaW5nU3RhcnRlZCkge1xuICAgICAgICAgIGhhc0RyYWdnaW5nU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fb25TdGFydERyYWdnaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNsaWVudFg6IHgsXG4gICAgICAgICAgY2xpZW50WTogeSxcbiAgICAgICAgICBwb2ludGVySWRcbiAgICAgICAgfSA9IGU7XG4gICAgICAgIGlmIChwb2ludGVySWQgIT09IHRoaXMuI2RyYWdQb2ludGVySWQpIHtcbiAgICAgICAgICBzdG9wRXZlbnQoZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFt0eCwgdHldID0gdGhpcy5zY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbih4IC0gdGhpcy4jcHJldkRyYWdYLCB5IC0gdGhpcy4jcHJldkRyYWdZKTtcbiAgICAgICAgdGhpcy4jcHJldkRyYWdYID0geDtcbiAgICAgICAgdGhpcy4jcHJldkRyYWdZID0geTtcbiAgICAgICAgdGhpcy5fdWlNYW5hZ2VyLmRyYWdTZWxlY3RlZEVkaXRvcnModHgsIHR5KTtcbiAgICAgIH0sIG9wdHMpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgc3RvcEV2ZW50LCBvcHRzKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgZSA9PiB7XG4gICAgICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSB0aGlzLiNkcmFnUG9pbnRlclR5cGUpIHtcbiAgICAgICAgICBpZiAodGhpcy4jdG91Y2hNYW5hZ2VyIHx8IGUuaXNQcmltYXJ5KSB7XG4gICAgICAgICAgICBjYW5jZWxEcmFnKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdG9wRXZlbnQoZSk7XG4gICAgICB9LCBvcHRzKTtcbiAgICB9XG4gICAgY29uc3QgcG9pbnRlclVwQ2FsbGJhY2sgPSBlID0+IHtcbiAgICAgIGlmICghdGhpcy4jZHJhZ1BvaW50ZXJJZCB8fCB0aGlzLiNkcmFnUG9pbnRlcklkID09PSBlLnBvaW50ZXJJZCkge1xuICAgICAgICBjYW5jZWxEcmFnKGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzdG9wRXZlbnQoZSk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBwb2ludGVyVXBDYWxsYmFjaywge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHBvaW50ZXJVcENhbGxiYWNrLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICBfb25TdGFydERyYWdnaW5nKCkge31cbiAgX29uU3RvcERyYWdnaW5nKCkge31cbiAgbW92ZUluRE9NKCkge1xuICAgIGlmICh0aGlzLiNtb3ZlSW5ET01UaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jbW92ZUluRE9NVGltZW91dCk7XG4gICAgfVxuICAgIHRoaXMuI21vdmVJbkRPTVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuI21vdmVJbkRPTVRpbWVvdXQgPSBudWxsO1xuICAgICAgdGhpcy5wYXJlbnQ/Lm1vdmVFZGl0b3JJbkRPTSh0aGlzKTtcbiAgICB9LCAwKTtcbiAgfVxuICBfc2V0UGFyZW50QW5kUG9zaXRpb24ocGFyZW50LCB4LCB5KSB7XG4gICAgcGFyZW50LmNoYW5nZVBhcmVudCh0aGlzKTtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgIHRoaXMuX29uVHJhbnNsYXRlZCgpO1xuICB9XG4gIGdldFJlY3QodHgsIHR5LCByb3RhdGlvbiA9IHRoaXMucm90YXRpb24pIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMucGFyZW50U2NhbGU7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgIGNvbnN0IFtwYWdlWCwgcGFnZVldID0gdGhpcy5wYWdlVHJhbnNsYXRpb247XG4gICAgY29uc3Qgc2hpZnRYID0gdHggLyBzY2FsZTtcbiAgICBjb25zdCBzaGlmdFkgPSB0eSAvIHNjYWxlO1xuICAgIGNvbnN0IHggPSB0aGlzLnggKiBwYWdlV2lkdGg7XG4gICAgY29uc3QgeSA9IHRoaXMueSAqIHBhZ2VIZWlnaHQ7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLndpZHRoICogcGFnZVdpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodDtcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBbeCArIHNoaWZ0WCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSAtIHNoaWZ0WSAtIGhlaWdodCArIHBhZ2VZLCB4ICsgc2hpZnRYICsgd2lkdGggKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgLSBzaGlmdFkgKyBwYWdlWV07XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gW3ggKyBzaGlmdFkgKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgKyBzaGlmdFggKyBwYWdlWSwgeCArIHNoaWZ0WSArIGhlaWdodCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSArIHNoaWZ0WCArIHdpZHRoICsgcGFnZVldO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbeCAtIHNoaWZ0WCAtIHdpZHRoICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5ICsgc2hpZnRZICsgcGFnZVksIHggLSBzaGlmdFggKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgKyBzaGlmdFkgKyBoZWlnaHQgKyBwYWdlWV07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFt4IC0gc2hpZnRZIC0gaGVpZ2h0ICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5IC0gc2hpZnRYIC0gd2lkdGggKyBwYWdlWSwgeCAtIHNoaWZ0WSArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSAtIHNoaWZ0WCArIHBhZ2VZXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcm90YXRpb25cIik7XG4gICAgfVxuICB9XG4gIGdldFJlY3RJbkN1cnJlbnRDb29yZHMocmVjdCwgcGFnZUhlaWdodCkge1xuICAgIGNvbnN0IFt4MSwgeTEsIHgyLCB5Ml0gPSByZWN0O1xuICAgIGNvbnN0IHdpZHRoID0geDIgLSB4MTtcbiAgICBjb25zdCBoZWlnaHQgPSB5MiAtIHkxO1xuICAgIHN3aXRjaCAodGhpcy5yb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gW3gxLCBwYWdlSGVpZ2h0IC0geTIsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFt4MSwgcGFnZUhlaWdodCAtIHkxLCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gW3gyLCBwYWdlSGVpZ2h0IC0geTEsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeDIsIHBhZ2VIZWlnaHQgLSB5MiwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJvdGF0aW9uXCIpO1xuICAgIH1cbiAgfVxuICBvbmNlQWRkZWQoZm9jdXMpIHt9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGVuYWJsZUVkaXRNb2RlKCkge1xuICAgIHRoaXMuI2lzSW5FZGl0TW9kZSA9IHRydWU7XG4gIH1cbiAgZGlzYWJsZUVkaXRNb2RlKCkge1xuICAgIHRoaXMuI2lzSW5FZGl0TW9kZSA9IGZhbHNlO1xuICB9XG4gIGlzSW5FZGl0TW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNJbkVkaXRNb2RlO1xuICB9XG4gIHNob3VsZEdldEtleWJvYXJkRXZlbnRzKCkge1xuICAgIHJldHVybiB0aGlzLiNpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQ7XG4gIH1cbiAgbmVlZHNUb0JlUmVidWlsdCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXYgJiYgIXRoaXMuaXNBdHRhY2hlZFRvRE9NO1xuICB9XG4gIGdldCBpc09uU2NyZWVuKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRvcCxcbiAgICAgIGxlZnQsXG4gICAgICBib3R0b20sXG4gICAgICByaWdodFxuICAgIH0gPSB0aGlzLmdldENsaWVudERpbWVuc2lvbnMoKTtcbiAgICBjb25zdCB7XG4gICAgICBpbm5lckhlaWdodCxcbiAgICAgIGlubmVyV2lkdGhcbiAgICB9ID0gd2luZG93O1xuICAgIHJldHVybiBsZWZ0IDwgaW5uZXJXaWR0aCAmJiByaWdodCA+IDAgJiYgdG9wIDwgaW5uZXJIZWlnaHQgJiYgYm90dG9tID4gMDtcbiAgfVxuICAjYWRkRm9jdXNMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMuI2ZvY3VzQUMgfHwgIXRoaXMuZGl2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2ZvY3VzQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI2ZvY3VzQUMpO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuZm9jdXNpbi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgdGhpcy5mb2N1c291dC5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIHRoaXMuI2FkZEZvY3VzTGlzdGVuZXJzKCk7XG4gIH1cbiAgcm90YXRlKF9hbmdsZSkge31cbiAgcmVzaXplKCkge31cbiAgc2VyaWFsaXplRGVsZXRlZCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCxcbiAgICAgIGRlbGV0ZWQ6IHRydWUsXG4gICAgICBwYWdlSW5kZXg6IHRoaXMucGFnZUluZGV4LFxuICAgICAgcG9wdXBSZWY6IHRoaXMuX2luaXRpYWxEYXRhPy5wb3B1cFJlZiB8fCBcIlwiXG4gICAgfTtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nID0gZmFsc2UsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBbiBlZGl0b3IgbXVzdCBiZSBzZXJpYWxpemFibGVcIik7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgY29uc3QgZWRpdG9yID0gbmV3IHRoaXMucHJvdG90eXBlLmNvbnN0cnVjdG9yKHtcbiAgICAgIHBhcmVudCxcbiAgICAgIGlkOiBwYXJlbnQuZ2V0TmV4dElkKCksXG4gICAgICB1aU1hbmFnZXJcbiAgICB9KTtcbiAgICBlZGl0b3Iucm90YXRpb24gPSBkYXRhLnJvdGF0aW9uO1xuICAgIGVkaXRvci4jYWNjZXNzaWJpbGl0eURhdGEgPSBkYXRhLmFjY2Vzc2liaWxpdHlEYXRhO1xuICAgIGVkaXRvci5faXNDb3B5ID0gZGF0YS5pc0NvcHkgfHwgZmFsc2U7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSBlZGl0b3IucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gZWRpdG9yLmdldFJlY3RJbkN1cnJlbnRDb29yZHMoZGF0YS5yZWN0LCBwYWdlSGVpZ2h0KTtcbiAgICBlZGl0b3IueCA9IHggLyBwYWdlV2lkdGg7XG4gICAgZWRpdG9yLnkgPSB5IC8gcGFnZUhlaWdodDtcbiAgICBlZGl0b3Iud2lkdGggPSB3aWR0aCAvIHBhZ2VXaWR0aDtcbiAgICBlZGl0b3IuaGVpZ2h0ID0gaGVpZ2h0IC8gcGFnZUhlaWdodDtcbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gIGdldCBoYXNCZWVuTW9kaWZpZWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkICYmICh0aGlzLmRlbGV0ZWQgfHwgdGhpcy5zZXJpYWxpemUoKSAhPT0gbnVsbCk7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMuI2ZvY3VzQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jZm9jdXNBQyA9IG51bGw7XG4gICAgaWYgKCF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgdGhpcy5jb21taXQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5yZW1vdmUodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5yZW1vdmVFZGl0b3IodGhpcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNtb3ZlSW5ET01UaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jbW92ZUluRE9NVGltZW91dCk7XG4gICAgICB0aGlzLiNtb3ZlSW5ET01UaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jc3RvcFJlc2l6aW5nKCk7XG4gICAgdGhpcy5yZW1vdmVFZGl0VG9vbGJhcigpO1xuICAgIGlmICh0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cykge1xuICAgICAgZm9yIChjb25zdCB0aW1lb3V0IG9mIHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzLnZhbHVlcygpKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMuI3RvdWNoTWFuYWdlcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuI3RvdWNoTWFuYWdlciA9IG51bGw7XG4gIH1cbiAgZ2V0IGlzUmVzaXphYmxlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBtYWtlUmVzaXphYmxlKCkge1xuICAgIGlmICh0aGlzLmlzUmVzaXphYmxlKSB7XG4gICAgICB0aGlzLiNjcmVhdGVSZXNpemVycygpO1xuICAgICAgdGhpcy4jcmVzaXplcnNEaXYuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHRvb2xiYXJQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBrZXlkb3duKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmlzUmVzaXphYmxlIHx8IGV2ZW50LnRhcmdldCAhPT0gdGhpcy5kaXYgfHwgZXZlbnQua2V5ICE9PSBcIkVudGVyXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdWlNYW5hZ2VyLnNldFNlbGVjdGVkKHRoaXMpO1xuICAgIHRoaXMuI3NhdmVkRGltZW5zaW9ucyA9IHtcbiAgICAgIHNhdmVkWDogdGhpcy54LFxuICAgICAgc2F2ZWRZOiB0aGlzLnksXG4gICAgICBzYXZlZFdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgc2F2ZWRIZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgfTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuI3Jlc2l6ZXJzRGl2LmNoaWxkcmVuO1xuICAgIGlmICghdGhpcy4jYWxsUmVzaXplckRpdnMpIHtcbiAgICAgIHRoaXMuI2FsbFJlc2l6ZXJEaXZzID0gQXJyYXkuZnJvbShjaGlsZHJlbik7XG4gICAgICBjb25zdCBib3VuZFJlc2l6ZXJLZXlkb3duID0gdGhpcy4jcmVzaXplcktleWRvd24uYmluZCh0aGlzKTtcbiAgICAgIGNvbnN0IGJvdW5kUmVzaXplckJsdXIgPSB0aGlzLiNyZXNpemVyQmx1ci5iaW5kKHRoaXMpO1xuICAgICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgICBmb3IgKGNvbnN0IGRpdiBvZiB0aGlzLiNhbGxSZXNpemVyRGl2cykge1xuICAgICAgICBjb25zdCBuYW1lID0gZGl2LmdldEF0dHJpYnV0ZShcImRhdGEtcmVzaXplci1uYW1lXCIpO1xuICAgICAgICBkaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInNwaW5idXR0b25cIik7XG4gICAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBib3VuZFJlc2l6ZXJLZXlkb3duLCB7XG4gICAgICAgICAgc2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgYm91bmRSZXNpemVyQmx1ciwge1xuICAgICAgICAgIHNpZ25hbFxuICAgICAgICB9KTtcbiAgICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLiNyZXNpemVyRm9jdXMuYmluZCh0aGlzLCBuYW1lKSwge1xuICAgICAgICAgIHNpZ25hbFxuICAgICAgICB9KTtcbiAgICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBBbm5vdGF0aW9uRWRpdG9yLl9sMTBuUmVzaXplcltuYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0ID0gdGhpcy4jYWxsUmVzaXplckRpdnNbMF07XG4gICAgbGV0IGZpcnN0UG9zaXRpb24gPSAwO1xuICAgIGZvciAoY29uc3QgZGl2IG9mIGNoaWxkcmVuKSB7XG4gICAgICBpZiAoZGl2ID09PSBmaXJzdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGZpcnN0UG9zaXRpb24rKztcbiAgICB9XG4gICAgY29uc3QgbmV4dEZpcnN0UG9zaXRpb24gPSAoMzYwIC0gdGhpcy5yb3RhdGlvbiArIHRoaXMucGFyZW50Um90YXRpb24pICUgMzYwIC8gOTAgKiAodGhpcy4jYWxsUmVzaXplckRpdnMubGVuZ3RoIC8gNCk7XG4gICAgaWYgKG5leHRGaXJzdFBvc2l0aW9uICE9PSBmaXJzdFBvc2l0aW9uKSB7XG4gICAgICBpZiAobmV4dEZpcnN0UG9zaXRpb24gPCBmaXJzdFBvc2l0aW9uKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlyc3RQb3NpdGlvbiAtIG5leHRGaXJzdFBvc2l0aW9uOyBpKyspIHtcbiAgICAgICAgICB0aGlzLiNyZXNpemVyc0Rpdi5hcHBlbmQodGhpcy4jcmVzaXplcnNEaXYuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobmV4dEZpcnN0UG9zaXRpb24gPiBmaXJzdFBvc2l0aW9uKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dEZpcnN0UG9zaXRpb24gLSBmaXJzdFBvc2l0aW9uOyBpKyspIHtcbiAgICAgICAgICB0aGlzLiNyZXNpemVyc0Rpdi5maXJzdENoaWxkLmJlZm9yZSh0aGlzLiNyZXNpemVyc0Rpdi5sYXN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgIGNvbnN0IGRpdiA9IHRoaXMuI2FsbFJlc2l6ZXJEaXZzW2krK107XG4gICAgICAgIGNvbnN0IG5hbWUgPSBkaXYuZ2V0QXR0cmlidXRlKFwiZGF0YS1yZXNpemVyLW5hbWVcIik7XG4gICAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBBbm5vdGF0aW9uRWRpdG9yLl9sMTBuUmVzaXplcltuYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI3NldFJlc2l6ZXJUYWJJbmRleCgwKTtcbiAgICB0aGlzLiNpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQgPSB0cnVlO1xuICAgIHRoaXMuI3Jlc2l6ZXJzRGl2LmZpcnN0Q2hpbGQuZm9jdXMoe1xuICAgICAgZm9jdXNWaXNpYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgfVxuICAjcmVzaXplcktleWRvd24oZXZlbnQpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLl9yZXNpemVyS2V5Ym9hcmRNYW5hZ2VyLmV4ZWModGhpcywgZXZlbnQpO1xuICB9XG4gICNyZXNpemVyQmx1cihldmVudCkge1xuICAgIGlmICh0aGlzLiNpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQgJiYgZXZlbnQucmVsYXRlZFRhcmdldD8ucGFyZW50Tm9kZSAhPT0gdGhpcy4jcmVzaXplcnNEaXYpIHtcbiAgICAgIHRoaXMuI3N0b3BSZXNpemluZygpO1xuICAgIH1cbiAgfVxuICAjcmVzaXplckZvY3VzKG5hbWUpIHtcbiAgICB0aGlzLiNmb2N1c2VkUmVzaXplck5hbWUgPSB0aGlzLiNpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQgPyBuYW1lIDogXCJcIjtcbiAgfVxuICAjc2V0UmVzaXplclRhYkluZGV4KHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLiNhbGxSZXNpemVyRGl2cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGRpdiBvZiB0aGlzLiNhbGxSZXNpemVyRGl2cykge1xuICAgICAgZGl2LnRhYkluZGV4ID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIF9yZXNpemVXaXRoS2V5Ym9hcmQoeCwgeSkge1xuICAgIGlmICghdGhpcy4jaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3Jlc2l6ZXJQb2ludGVybW92ZSh0aGlzLiNmb2N1c2VkUmVzaXplck5hbWUsIHtcbiAgICAgIGRlbHRhWDogeCxcbiAgICAgIGRlbHRhWTogeSxcbiAgICAgIGZyb21LZXlib2FyZDogdHJ1ZVxuICAgIH0pO1xuICB9XG4gICNzdG9wUmVzaXppbmcoKSB7XG4gICAgdGhpcy4jaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkID0gZmFsc2U7XG4gICAgdGhpcy4jc2V0UmVzaXplclRhYkluZGV4KC0xKTtcbiAgICB0aGlzLiNhZGRSZXNpemVUb1VuZG9TdGFjaygpO1xuICB9XG4gIF9zdG9wUmVzaXppbmdXaXRoS2V5Ym9hcmQoKSB7XG4gICAgdGhpcy4jc3RvcFJlc2l6aW5nKCk7XG4gICAgdGhpcy5kaXYuZm9jdXMoKTtcbiAgfVxuICBzZWxlY3QoKSB7XG4gICAgdGhpcy5tYWtlUmVzaXphYmxlKCk7XG4gICAgdGhpcy5kaXY/LmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZEVkaXRvclwiKTtcbiAgICBpZiAoIXRoaXMuX2VkaXRUb29sYmFyKSB7XG4gICAgICB0aGlzLmFkZEVkaXRUb29sYmFyKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmRpdj8uY2xhc3NMaXN0LmNvbnRhaW5zKFwic2VsZWN0ZWRFZGl0b3JcIikpIHtcbiAgICAgICAgICB0aGlzLl9lZGl0VG9vbGJhcj8uc2hvdygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZWRpdFRvb2xiYXI/LnNob3coKTtcbiAgICB0aGlzLiNhbHRUZXh0Py50b2dnbGVBbHRUZXh0QmFkZ2UoZmFsc2UpO1xuICB9XG4gIHVuc2VsZWN0KCkge1xuICAgIHRoaXMuI3Jlc2l6ZXJzRGl2Py5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpO1xuICAgIHRoaXMuZGl2Py5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRFZGl0b3JcIik7XG4gICAgaWYgKHRoaXMuZGl2Py5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmN1cnJlbnRMYXllci5kaXYuZm9jdXMoe1xuICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fZWRpdFRvb2xiYXI/LmhpZGUoKTtcbiAgICB0aGlzLiNhbHRUZXh0Py50b2dnbGVBbHRUZXh0QmFkZ2UodHJ1ZSk7XG4gIH1cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7fVxuICBkaXNhYmxlRWRpdGluZygpIHt9XG4gIGVuYWJsZUVkaXRpbmcoKSB7fVxuICBlbnRlckluRWRpdE1vZGUoKSB7fVxuICBnZXRFbGVtZW50Rm9yQWx0VGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgZ2V0IGNvbnRlbnREaXYoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gIGdldCBpc0VkaXRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lzRWRpdGluZztcbiAgfVxuICBzZXQgaXNFZGl0aW5nKHZhbHVlKSB7XG4gICAgdGhpcy4jaXNFZGl0aW5nID0gdmFsdWU7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgICAgdGhpcy5wYXJlbnQuc2V0QWN0aXZlRWRpdG9yKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhcmVudC5zZXRBY3RpdmVFZGl0b3IobnVsbCk7XG4gICAgfVxuICB9XG4gIHNldEFzcGVjdFJhdGlvKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLiNrZWVwQXNwZWN0UmF0aW8gPSB0cnVlO1xuICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy5kaXY7XG4gICAgc3R5bGUuYXNwZWN0UmF0aW8gPSBhc3BlY3RSYXRpbztcbiAgICBzdHlsZS5oZWlnaHQgPSBcImF1dG9cIjtcbiAgfVxuICBzdGF0aWMgZ2V0IE1JTl9TSVpFKCkge1xuICAgIHJldHVybiAxNjtcbiAgfVxuICBzdGF0aWMgY2FuQ3JlYXRlTmV3RW1wdHlFZGl0b3IoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0IHRlbGVtZXRyeUluaXRpYWxEYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhY3Rpb246IFwiYWRkZWRcIlxuICAgIH07XG4gIH1cbiAgZ2V0IHRlbGVtZXRyeUZpbmFsRGF0YSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBfcmVwb3J0VGVsZW1ldHJ5KGRhdGEsIG11c3RXYWl0ID0gZmFsc2UpIHtcbiAgICBpZiAobXVzdFdhaXQpIHtcbiAgICAgIHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzIHx8PSBuZXcgTWFwKCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFjdGlvblxuICAgICAgfSA9IGRhdGE7XG4gICAgICBsZXQgdGltZW91dCA9IHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzLmdldChhY3Rpb24pO1xuICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoZGF0YSk7XG4gICAgICAgIHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzLmRlbGV0ZShhY3Rpb24pO1xuICAgICAgICBpZiAodGhpcy4jdGVsZW1ldHJ5VGltZW91dHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSwgQW5ub3RhdGlvbkVkaXRvci5fdGVsZW1ldHJ5VGltZW91dCk7XG4gICAgICB0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cy5zZXQoYWN0aW9uLCB0aW1lb3V0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGF0YS50eXBlIHx8PSB0aGlzLmVkaXRvclR5cGU7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLl9ldmVudEJ1cy5kaXNwYXRjaChcInJlcG9ydHRlbGVtZXRyeVwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBkZXRhaWxzOiB7XG4gICAgICAgIHR5cGU6IFwiZWRpdGluZ1wiLFxuICAgICAgICBkYXRhXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc2hvdyh2aXNpYmxlID0gdGhpcy5faXNWaXNpYmxlKSB7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImhpZGRlblwiLCAhdmlzaWJsZSk7XG4gICAgdGhpcy5faXNWaXNpYmxlID0gdmlzaWJsZTtcbiAgfVxuICBlbmFibGUoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICB0aGlzLmRpdi50YWJJbmRleCA9IDA7XG4gICAgfVxuICAgIHRoaXMuI2Rpc2FibGVkID0gZmFsc2U7XG4gIH1cbiAgZGlzYWJsZSgpIHtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHRoaXMuZGl2LnRhYkluZGV4ID0gLTE7XG4gICAgfVxuICAgIHRoaXMuI2Rpc2FibGVkID0gdHJ1ZTtcbiAgfVxuICByZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBhbm5vdGF0aW9uLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiLmFubm90YXRpb25Db250ZW50XCIpO1xuICAgIGlmICghY29udGVudCkge1xuICAgICAgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoXCJhbm5vdGF0aW9uQ29udGVudFwiLCB0aGlzLmVkaXRvclR5cGUpO1xuICAgICAgYW5ub3RhdGlvbi5jb250YWluZXIucHJlcGVuZChjb250ZW50KTtcbiAgICB9IGVsc2UgaWYgKGNvbnRlbnQubm9kZU5hbWUgPT09IFwiQ0FOVkFTXCIpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRlbnQ7XG4gICAgICBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZChcImFubm90YXRpb25Db250ZW50XCIsIHRoaXMuZWRpdG9yVHlwZSk7XG4gICAgICBjYW52YXMuYmVmb3JlKGNvbnRlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICByZXNldEFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICBmaXJzdENoaWxkXG4gICAgfSA9IGFubm90YXRpb24uY29udGFpbmVyO1xuICAgIGlmIChmaXJzdENoaWxkPy5ub2RlTmFtZSA9PT0gXCJESVZcIiAmJiBmaXJzdENoaWxkLmNsYXNzTGlzdC5jb250YWlucyhcImFubm90YXRpb25Db250ZW50XCIpKSB7XG4gICAgICBmaXJzdENoaWxkLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgRmFrZUVkaXRvciBleHRlbmRzIEFubm90YXRpb25FZGl0b3Ige1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcihwYXJhbXMpO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IHBhcmFtcy5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgIHRoaXMuZGVsZXRlZCA9IHRydWU7XG4gIH1cbiAgc2VyaWFsaXplKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZURlbGV0ZWQoKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvc2hhcmVkL211cm11cmhhc2gzLmpzXG5jb25zdCBTRUVEID0gMHhjM2QyZTFmMDtcbmNvbnN0IE1BU0tfSElHSCA9IDB4ZmZmZjAwMDA7XG5jb25zdCBNQVNLX0xPVyA9IDB4ZmZmZjtcbmNsYXNzIE11cm11ckhhc2gzXzY0IHtcbiAgY29uc3RydWN0b3Ioc2VlZCkge1xuICAgIHRoaXMuaDEgPSBzZWVkID8gc2VlZCAmIDB4ZmZmZmZmZmYgOiBTRUVEO1xuICAgIHRoaXMuaDIgPSBzZWVkID8gc2VlZCAmIDB4ZmZmZmZmZmYgOiBTRUVEO1xuICB9XG4gIHVwZGF0ZShpbnB1dCkge1xuICAgIGxldCBkYXRhLCBsZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KGlucHV0Lmxlbmd0aCAqIDIpO1xuICAgICAgbGVuZ3RoID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGlucHV0Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgY29uc3QgY29kZSA9IGlucHV0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlIDw9IDB4ZmYpIHtcbiAgICAgICAgICBkYXRhW2xlbmd0aCsrXSA9IGNvZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YVtsZW5ndGgrK10gPSBjb2RlID4+PiA4O1xuICAgICAgICAgIGRhdGFbbGVuZ3RoKytdID0gY29kZSAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhpbnB1dCkpIHtcbiAgICAgIGRhdGEgPSBpbnB1dC5zbGljZSgpO1xuICAgICAgbGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgZm9ybWF0LCBtdXN0IGJlIGEgc3RyaW5nIG9yIFR5cGVkQXJyYXkuXCIpO1xuICAgIH1cbiAgICBjb25zdCBibG9ja0NvdW50cyA9IGxlbmd0aCA+PiAyO1xuICAgIGNvbnN0IHRhaWxMZW5ndGggPSBsZW5ndGggLSBibG9ja0NvdW50cyAqIDQ7XG4gICAgY29uc3QgZGF0YVVpbnQzMiA9IG5ldyBVaW50MzJBcnJheShkYXRhLmJ1ZmZlciwgMCwgYmxvY2tDb3VudHMpO1xuICAgIGxldCBrMSA9IDAsXG4gICAgICBrMiA9IDA7XG4gICAgbGV0IGgxID0gdGhpcy5oMSxcbiAgICAgIGgyID0gdGhpcy5oMjtcbiAgICBjb25zdCBDMSA9IDB4Y2M5ZTJkNTEsXG4gICAgICBDMiA9IDB4MWI4NzM1OTM7XG4gICAgY29uc3QgQzFfTE9XID0gQzEgJiBNQVNLX0xPVyxcbiAgICAgIEMyX0xPVyA9IEMyICYgTUFTS19MT1c7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja0NvdW50czsgaSsrKSB7XG4gICAgICBpZiAoaSAmIDEpIHtcbiAgICAgICAgazEgPSBkYXRhVWludDMyW2ldO1xuICAgICAgICBrMSA9IGsxICogQzEgJiBNQVNLX0hJR0ggfCBrMSAqIEMxX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBrMSA9IGsxIDw8IDE1IHwgazEgPj4+IDE3O1xuICAgICAgICBrMSA9IGsxICogQzIgJiBNQVNLX0hJR0ggfCBrMSAqIEMyX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBoMSBePSBrMTtcbiAgICAgICAgaDEgPSBoMSA8PCAxMyB8IGgxID4+PiAxOTtcbiAgICAgICAgaDEgPSBoMSAqIDUgKyAweGU2NTQ2YjY0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgazIgPSBkYXRhVWludDMyW2ldO1xuICAgICAgICBrMiA9IGsyICogQzEgJiBNQVNLX0hJR0ggfCBrMiAqIEMxX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBrMiA9IGsyIDw8IDE1IHwgazIgPj4+IDE3O1xuICAgICAgICBrMiA9IGsyICogQzIgJiBNQVNLX0hJR0ggfCBrMiAqIEMyX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBoMiBePSBrMjtcbiAgICAgICAgaDIgPSBoMiA8PCAxMyB8IGgyID4+PiAxOTtcbiAgICAgICAgaDIgPSBoMiAqIDUgKyAweGU2NTQ2YjY0O1xuICAgICAgfVxuICAgIH1cbiAgICBrMSA9IDA7XG4gICAgc3dpdGNoICh0YWlsTGVuZ3RoKSB7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGsxIF49IGRhdGFbYmxvY2tDb3VudHMgKiA0ICsgMl0gPDwgMTY7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGsxIF49IGRhdGFbYmxvY2tDb3VudHMgKiA0ICsgMV0gPDwgODtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgazEgXj0gZGF0YVtibG9ja0NvdW50cyAqIDRdO1xuICAgICAgICBrMSA9IGsxICogQzEgJiBNQVNLX0hJR0ggfCBrMSAqIEMxX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBrMSA9IGsxIDw8IDE1IHwgazEgPj4+IDE3O1xuICAgICAgICBrMSA9IGsxICogQzIgJiBNQVNLX0hJR0ggfCBrMSAqIEMyX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBpZiAoYmxvY2tDb3VudHMgJiAxKSB7XG4gICAgICAgICAgaDEgXj0gazE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaDIgXj0gazE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5oMSA9IGgxO1xuICAgIHRoaXMuaDIgPSBoMjtcbiAgfVxuICBoZXhkaWdlc3QoKSB7XG4gICAgbGV0IGgxID0gdGhpcy5oMSxcbiAgICAgIGgyID0gdGhpcy5oMjtcbiAgICBoMSBePSBoMiA+Pj4gMTtcbiAgICBoMSA9IGgxICogMHhlZDU1OGNjZCAmIE1BU0tfSElHSCB8IGgxICogMHg4Y2NkICYgTUFTS19MT1c7XG4gICAgaDIgPSBoMiAqIDB4ZmY1MWFmZDcgJiBNQVNLX0hJR0ggfCAoKGgyIDw8IDE2IHwgaDEgPj4+IDE2KSAqIDB4YWZkN2VkNTUgJiBNQVNLX0hJR0gpID4+PiAxNjtcbiAgICBoMSBePSBoMiA+Pj4gMTtcbiAgICBoMSA9IGgxICogMHgxYTg1ZWM1MyAmIE1BU0tfSElHSCB8IGgxICogMHhlYzUzICYgTUFTS19MT1c7XG4gICAgaDIgPSBoMiAqIDB4YzRjZWI5ZmUgJiBNQVNLX0hJR0ggfCAoKGgyIDw8IDE2IHwgaDEgPj4+IDE2KSAqIDB4YjlmZTFhODUgJiBNQVNLX0hJR0gpID4+PiAxNjtcbiAgICBoMSBePSBoMiA+Pj4gMTtcbiAgICByZXR1cm4gKGgxID4+PiAwKS50b1N0cmluZygxNikucGFkU3RhcnQoOCwgXCIwXCIpICsgKGgyID4+PiAwKS50b1N0cmluZygxNikucGFkU3RhcnQoOCwgXCIwXCIpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2Fubm90YXRpb25fc3RvcmFnZS5qc1xuXG5cblxuY29uc3QgU2VyaWFsaXphYmxlRW1wdHkgPSBPYmplY3QuZnJlZXplKHtcbiAgbWFwOiBudWxsLFxuICBoYXNoOiBcIlwiLFxuICB0cmFuc2ZlcjogdW5kZWZpbmVkXG59KTtcbmNsYXNzIEFubm90YXRpb25TdG9yYWdlIHtcbiAgI21vZGlmaWVkID0gZmFsc2U7XG4gICNtb2RpZmllZElkcyA9IG51bGw7XG4gICNzdG9yYWdlID0gbmV3IE1hcCgpO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm9uU2V0TW9kaWZpZWQgPSBudWxsO1xuICAgIHRoaXMub25SZXNldE1vZGlmaWVkID0gbnVsbDtcbiAgICB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvciA9IG51bGw7XG4gIH1cbiAgZ2V0VmFsdWUoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3N0b3JhZ2UuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRlZmF1bHRWYWx1ZSwgdmFsdWUpO1xuICB9XG4gIGdldFJhd1ZhbHVlKGtleSkge1xuICAgIHJldHVybiB0aGlzLiNzdG9yYWdlLmdldChrZXkpO1xuICB9XG4gIHJlbW92ZShrZXkpIHtcbiAgICB0aGlzLiNzdG9yYWdlLmRlbGV0ZShrZXkpO1xuICAgIGlmICh0aGlzLiNzdG9yYWdlLnNpemUgPT09IDApIHtcbiAgICAgIHRoaXMucmVzZXRNb2RpZmllZCgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy4jc3RvcmFnZS52YWx1ZXMoKSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBbm5vdGF0aW9uRWRpdG9yKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvcihudWxsKTtcbiAgICB9XG4gIH1cbiAgc2V0VmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IG9iaiA9IHRoaXMuI3N0b3JhZ2UuZ2V0KGtleSk7XG4gICAgbGV0IG1vZGlmaWVkID0gZmFsc2U7XG4gICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKGNvbnN0IFtlbnRyeSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKG9ialtlbnRyeV0gIT09IHZhbCkge1xuICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICBvYmpbZW50cnldID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuI3N0b3JhZ2Uuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZWQpIHtcbiAgICAgIHRoaXMuI3NldE1vZGlmaWVkKCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFubm90YXRpb25FZGl0b3IgJiYgdHlwZW9mIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yKHZhbHVlLmNvbnN0cnVjdG9yLl90eXBlKTtcbiAgICB9XG4gIH1cbiAgaGFzKGtleSkge1xuICAgIHJldHVybiB0aGlzLiNzdG9yYWdlLmhhcyhrZXkpO1xuICB9XG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLiNzdG9yYWdlLnNpemU7XG4gIH1cbiAgI3NldE1vZGlmaWVkKCkge1xuICAgIGlmICghdGhpcy4jbW9kaWZpZWQpIHtcbiAgICAgIHRoaXMuI21vZGlmaWVkID0gdHJ1ZTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vblNldE1vZGlmaWVkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5vblNldE1vZGlmaWVkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlc2V0TW9kaWZpZWQoKSB7XG4gICAgaWYgKHRoaXMuI21vZGlmaWVkKSB7XG4gICAgICB0aGlzLiNtb2RpZmllZCA9IGZhbHNlO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uUmVzZXRNb2RpZmllZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub25SZXNldE1vZGlmaWVkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBwcmludCgpIHtcbiAgICByZXR1cm4gbmV3IFByaW50QW5ub3RhdGlvblN0b3JhZ2UodGhpcyk7XG4gIH1cbiAgZ2V0IHNlcmlhbGl6YWJsZSgpIHtcbiAgICBpZiAodGhpcy4jc3RvcmFnZS5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gU2VyaWFsaXphYmxlRW1wdHk7XG4gICAgfVxuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKSxcbiAgICAgIGhhc2ggPSBuZXcgTXVybXVySGFzaDNfNjQoKSxcbiAgICAgIHRyYW5zZmVyID0gW107XG4gICAgY29uc3QgY29udGV4dCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGhhc0JpdG1hcCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiB0aGlzLiNzdG9yYWdlKSB7XG4gICAgICBjb25zdCBzZXJpYWxpemVkID0gdmFsIGluc3RhbmNlb2YgQW5ub3RhdGlvbkVkaXRvciA/IHZhbC5zZXJpYWxpemUoZmFsc2UsIGNvbnRleHQpIDogdmFsO1xuICAgICAgaWYgKHNlcmlhbGl6ZWQpIHtcbiAgICAgICAgbWFwLnNldChrZXksIHNlcmlhbGl6ZWQpO1xuICAgICAgICBoYXNoLnVwZGF0ZShgJHtrZXl9OiR7SlNPTi5zdHJpbmdpZnkoc2VyaWFsaXplZCl9YCk7XG4gICAgICAgIGhhc0JpdG1hcCB8fD0gISFzZXJpYWxpemVkLmJpdG1hcDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc0JpdG1hcCkge1xuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBtYXAudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKHZhbHVlLmJpdG1hcCkge1xuICAgICAgICAgIHRyYW5zZmVyLnB1c2godmFsdWUuYml0bWFwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwLnNpemUgPiAwID8ge1xuICAgICAgbWFwLFxuICAgICAgaGFzaDogaGFzaC5oZXhkaWdlc3QoKSxcbiAgICAgIHRyYW5zZmVyXG4gICAgfSA6IFNlcmlhbGl6YWJsZUVtcHR5O1xuICB9XG4gIGdldCBlZGl0b3JTdGF0cygpIHtcbiAgICBsZXQgc3RhdHMgPSBudWxsO1xuICAgIGNvbnN0IHR5cGVUb0VkaXRvciA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMuI3N0b3JhZ2UudmFsdWVzKCkpIHtcbiAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgQW5ub3RhdGlvbkVkaXRvcikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBlZGl0b3JTdGF0cyA9IHZhbHVlLnRlbGVtZXRyeUZpbmFsRGF0YTtcbiAgICAgIGlmICghZWRpdG9yU3RhdHMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIHR5cGVcbiAgICAgIH0gPSBlZGl0b3JTdGF0cztcbiAgICAgIGlmICghdHlwZVRvRWRpdG9yLmhhcyh0eXBlKSkge1xuICAgICAgICB0eXBlVG9FZGl0b3Iuc2V0KHR5cGUsIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkuY29uc3RydWN0b3IpO1xuICAgICAgfVxuICAgICAgc3RhdHMgfHw9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBjb25zdCBtYXAgPSBzdGF0c1t0eXBlXSB8fD0gbmV3IE1hcCgpO1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKGVkaXRvclN0YXRzKSkge1xuICAgICAgICBpZiAoa2V5ID09PSBcInR5cGVcIikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb3VudGVycyA9IG1hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFjb3VudGVycykge1xuICAgICAgICAgIGNvdW50ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgIG1hcC5zZXQoa2V5LCBjb3VudGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY291bnQgPSBjb3VudGVycy5nZXQodmFsKSA/PyAwO1xuICAgICAgICBjb3VudGVycy5zZXQodmFsLCBjb3VudCArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IFt0eXBlLCBlZGl0b3JdIG9mIHR5cGVUb0VkaXRvcikge1xuICAgICAgc3RhdHNbdHlwZV0gPSBlZGl0b3IuY29tcHV0ZVRlbGVtZXRyeUZpbmFsRGF0YShzdGF0c1t0eXBlXSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0cztcbiAgfVxuICByZXNldE1vZGlmaWVkSWRzKCkge1xuICAgIHRoaXMuI21vZGlmaWVkSWRzID0gbnVsbDtcbiAgfVxuICBnZXQgbW9kaWZpZWRJZHMoKSB7XG4gICAgaWYgKHRoaXMuI21vZGlmaWVkSWRzKSB7XG4gICAgICByZXR1cm4gdGhpcy4jbW9kaWZpZWRJZHM7XG4gICAgfVxuICAgIGNvbnN0IGlkcyA9IFtdO1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy4jc3RvcmFnZS52YWx1ZXMoKSkge1xuICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBBbm5vdGF0aW9uRWRpdG9yKSB8fCAhdmFsdWUuYW5ub3RhdGlvbkVsZW1lbnRJZCB8fCAhdmFsdWUuc2VyaWFsaXplKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZHMucHVzaCh2YWx1ZS5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI21vZGlmaWVkSWRzID0ge1xuICAgICAgaWRzOiBuZXcgU2V0KGlkcyksXG4gICAgICBoYXNoOiBpZHMuam9pbihcIixcIilcbiAgICB9O1xuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLiNzdG9yYWdlLmVudHJpZXMoKTtcbiAgfVxufVxuY2xhc3MgUHJpbnRBbm5vdGF0aW9uU3RvcmFnZSBleHRlbmRzIEFubm90YXRpb25TdG9yYWdlIHtcbiAgI3NlcmlhbGl6YWJsZTtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCB7XG4gICAgICBtYXAsXG4gICAgICBoYXNoLFxuICAgICAgdHJhbnNmZXJcbiAgICB9ID0gcGFyZW50LnNlcmlhbGl6YWJsZTtcbiAgICBjb25zdCBjbG9uZSA9IHN0cnVjdHVyZWRDbG9uZShtYXAsIHRyYW5zZmVyID8ge1xuICAgICAgdHJhbnNmZXJcbiAgICB9IDogbnVsbCk7XG4gICAgdGhpcy4jc2VyaWFsaXphYmxlID0ge1xuICAgICAgbWFwOiBjbG9uZSxcbiAgICAgIGhhc2gsXG4gICAgICB0cmFuc2ZlclxuICAgIH07XG4gIH1cbiAgZ2V0IHByaW50KCkge1xuICAgIHVucmVhY2hhYmxlKFwiU2hvdWxkIG5vdCBjYWxsIFByaW50QW5ub3RhdGlvblN0b3JhZ2UucHJpbnRcIik7XG4gIH1cbiAgZ2V0IHNlcmlhbGl6YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VyaWFsaXphYmxlO1xuICB9XG4gIGdldCBtb2RpZmllZElkcygpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwibW9kaWZpZWRJZHNcIiwge1xuICAgICAgaWRzOiBuZXcgU2V0KCksXG4gICAgICBoYXNoOiBcIlwiXG4gICAgfSk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZm9udF9sb2FkZXIuanNcblxuY2xhc3MgRm9udExvYWRlciB7XG4gICNzeXN0ZW1Gb250cyA9IG5ldyBTZXQoKTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxUaGlzLmRvY3VtZW50LFxuICAgIHN0eWxlRWxlbWVudCA9IG51bGxcbiAgfSkge1xuICAgIHRoaXMuX2RvY3VtZW50ID0gb3duZXJEb2N1bWVudDtcbiAgICB0aGlzLm5hdGl2ZUZvbnRGYWNlcyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLnN0eWxlRWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5sb2FkaW5nUmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLmxvYWRUZXN0Rm9udElkID0gMDtcbiAgfVxuICBhZGROYXRpdmVGb250RmFjZShuYXRpdmVGb250RmFjZSkge1xuICAgIHRoaXMubmF0aXZlRm9udEZhY2VzLmFkZChuYXRpdmVGb250RmFjZSk7XG4gICAgdGhpcy5fZG9jdW1lbnQuZm9udHMuYWRkKG5hdGl2ZUZvbnRGYWNlKTtcbiAgfVxuICByZW1vdmVOYXRpdmVGb250RmFjZShuYXRpdmVGb250RmFjZSkge1xuICAgIHRoaXMubmF0aXZlRm9udEZhY2VzLmRlbGV0ZShuYXRpdmVGb250RmFjZSk7XG4gICAgdGhpcy5fZG9jdW1lbnQuZm9udHMuZGVsZXRlKG5hdGl2ZUZvbnRGYWNlKTtcbiAgfVxuICBpbnNlcnRSdWxlKHJ1bGUpIHtcbiAgICBpZiAoIXRoaXMuc3R5bGVFbGVtZW50KSB7XG4gICAgICB0aGlzLnN0eWxlRWxlbWVudCA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgIHRoaXMuX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0uYXBwZW5kKHRoaXMuc3R5bGVFbGVtZW50KTtcbiAgICB9XG4gICAgY29uc3Qgc3R5bGVTaGVldCA9IHRoaXMuc3R5bGVFbGVtZW50LnNoZWV0O1xuICAgIHN0eWxlU2hlZXQuaW5zZXJ0UnVsZShydWxlLCBzdHlsZVNoZWV0LmNzc1J1bGVzLmxlbmd0aCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChjb25zdCBuYXRpdmVGb250RmFjZSBvZiB0aGlzLm5hdGl2ZUZvbnRGYWNlcykge1xuICAgICAgdGhpcy5fZG9jdW1lbnQuZm9udHMuZGVsZXRlKG5hdGl2ZUZvbnRGYWNlKTtcbiAgICB9XG4gICAgdGhpcy5uYXRpdmVGb250RmFjZXMuY2xlYXIoKTtcbiAgICB0aGlzLiNzeXN0ZW1Gb250cy5jbGVhcigpO1xuICAgIGlmICh0aGlzLnN0eWxlRWxlbWVudCkge1xuICAgICAgdGhpcy5zdHlsZUVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICB0aGlzLnN0eWxlRWxlbWVudCA9IG51bGw7XG4gICAgfVxuICB9XG4gIGFzeW5jIGxvYWRTeXN0ZW1Gb250KHtcbiAgICBzeXN0ZW1Gb250SW5mbzogaW5mbyxcbiAgICBkaXNhYmxlRm9udEZhY2UsXG4gICAgX2luc3BlY3RGb250XG4gIH0pIHtcbiAgICBpZiAoIWluZm8gfHwgdGhpcy4jc3lzdGVtRm9udHMuaGFzKGluZm8ubG9hZGVkTmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXNzZXJ0KCFkaXNhYmxlRm9udEZhY2UsIFwibG9hZFN5c3RlbUZvbnQgc2hvdWxkbid0IGJlIGNhbGxlZCB3aGVuIGBkaXNhYmxlRm9udEZhY2VgIGlzIHNldC5cIik7XG4gICAgaWYgKHRoaXMuaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsb2FkZWROYW1lLFxuICAgICAgICBzcmMsXG4gICAgICAgIHN0eWxlXG4gICAgICB9ID0gaW5mbztcbiAgICAgIGNvbnN0IGZvbnRGYWNlID0gbmV3IEZvbnRGYWNlKGxvYWRlZE5hbWUsIHNyYywgc3R5bGUpO1xuICAgICAgdGhpcy5hZGROYXRpdmVGb250RmFjZShmb250RmFjZSk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmb250RmFjZS5sb2FkKCk7XG4gICAgICAgIHRoaXMuI3N5c3RlbUZvbnRzLmFkZChsb2FkZWROYW1lKTtcbiAgICAgICAgX2luc3BlY3RGb250Py4oaW5mbyk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgd2FybihgQ2Fubm90IGxvYWQgc3lzdGVtIGZvbnQ6ICR7aW5mby5iYXNlRm9udE5hbWV9LCBpbnN0YWxsaW5nIGl0IGNvdWxkIGhlbHAgdG8gaW1wcm92ZSBQREYgcmVuZGVyaW5nLmApO1xuICAgICAgICB0aGlzLnJlbW92ZU5hdGl2ZUZvbnRGYWNlKGZvbnRGYWNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdW5yZWFjaGFibGUoXCJOb3QgaW1wbGVtZW50ZWQ6IGxvYWRTeXN0ZW1Gb250IHdpdGhvdXQgdGhlIEZvbnQgTG9hZGluZyBBUEkuXCIpO1xuICB9XG4gIGFzeW5jIGJpbmQoZm9udCkge1xuICAgIGlmIChmb250LmF0dGFjaGVkIHx8IGZvbnQubWlzc2luZ0ZpbGUgJiYgIWZvbnQuc3lzdGVtRm9udEluZm8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9udC5hdHRhY2hlZCA9IHRydWU7XG4gICAgaWYgKGZvbnQuc3lzdGVtRm9udEluZm8pIHtcbiAgICAgIGF3YWl0IHRoaXMubG9hZFN5c3RlbUZvbnQoZm9udCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRm9udExvYWRpbmdBUElTdXBwb3J0ZWQpIHtcbiAgICAgIGNvbnN0IG5hdGl2ZUZvbnRGYWNlID0gZm9udC5jcmVhdGVOYXRpdmVGb250RmFjZSgpO1xuICAgICAgaWYgKG5hdGl2ZUZvbnRGYWNlKSB7XG4gICAgICAgIHRoaXMuYWRkTmF0aXZlRm9udEZhY2UobmF0aXZlRm9udEZhY2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IG5hdGl2ZUZvbnRGYWNlLmxvYWRlZDtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICB3YXJuKGBGYWlsZWQgdG8gbG9hZCBmb250ICcke25hdGl2ZUZvbnRGYWNlLmZhbWlseX0nOiAnJHtleH0nLmApO1xuICAgICAgICAgIGZvbnQuZGlzYWJsZUZvbnRGYWNlID0gdHJ1ZTtcbiAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBydWxlID0gZm9udC5jcmVhdGVGb250RmFjZVJ1bGUoKTtcbiAgICBpZiAocnVsZSkge1xuICAgICAgdGhpcy5pbnNlcnRSdWxlKHJ1bGUpO1xuICAgICAgaWYgKHRoaXMuaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLl9xdWV1ZUxvYWRpbmdDYWxsYmFjayhyZXNvbHZlKTtcbiAgICAgICAgdGhpcy5fcHJlcGFyZUZvbnRMb2FkRXZlbnQoZm9udCwgcmVxdWVzdCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0IGlzRm9udExvYWRpbmdBUElTdXBwb3J0ZWQoKSB7XG4gICAgY29uc3QgaGFzRm9udHMgPSAhIXRoaXMuX2RvY3VtZW50Py5mb250cztcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZFwiLCBoYXNGb250cyk7XG4gIH1cbiAgZ2V0IGlzU3luY0ZvbnRMb2FkaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZFwiLCBpc05vZGVKUyB8fCB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtLmlzRmlyZWZveCk7XG4gIH1cbiAgX3F1ZXVlTG9hZGluZ0NhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgZnVuY3Rpb24gY29tcGxldGVSZXF1ZXN0KCkge1xuICAgICAgYXNzZXJ0KCFyZXF1ZXN0LmRvbmUsIFwiY29tcGxldGVSZXF1ZXN0KCkgY2Fubm90IGJlIGNhbGxlZCB0d2ljZS5cIik7XG4gICAgICByZXF1ZXN0LmRvbmUgPSB0cnVlO1xuICAgICAgd2hpbGUgKGxvYWRpbmdSZXF1ZXN0cy5sZW5ndGggPiAwICYmIGxvYWRpbmdSZXF1ZXN0c1swXS5kb25lKSB7XG4gICAgICAgIGNvbnN0IG90aGVyUmVxdWVzdCA9IGxvYWRpbmdSZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgICBzZXRUaW1lb3V0KG90aGVyUmVxdWVzdC5jYWxsYmFjaywgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGxvYWRpbmdSZXF1ZXN0c1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICBkb25lOiBmYWxzZSxcbiAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVJlcXVlc3QsXG4gICAgICBjYWxsYmFja1xuICAgIH07XG4gICAgbG9hZGluZ1JlcXVlc3RzLnB1c2gocmVxdWVzdCk7XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH1cbiAgZ2V0IF9sb2FkVGVzdEZvbnQoKSB7XG4gICAgY29uc3QgdGVzdEZvbnQgPSBhdG9iKFwiVDFSVVR3QUxBSUFBQXdBd1EwWkdJREh0Wmc0QUFBT1lBQUFBZ1VaR1ZFMWxrelp3QUFBRUhBQUFBQnhIUkVWR0FCUUFcIiArIFwiRlFBQUJEZ0FBQUFlVDFNdk1sWU5Zd2tBQUFFZ0FBQUFZR050WVhBQkRRTFVBQUFDTkFBQUFVSm9aV0ZrL3hWRkRRQUFcIiArIFwiQUx3QUFBQTJhR2hsWVFka0Erb0FBQUQwQUFBQUpHaHRkSGdENkFBQUFBQUVXQUFBQUFadFlYaHdBQUpRQUFBQUFSZ0FcIiArIFwiQUFBR2JtRnRaVmptZEg0QUFBR0FBQUFBc1hCdmMzVC9oZ0F6QUFBRGVBQUFBQ0FBQVFBQUFBRUFBTFpSRnNSZkR6ejFcIiArIFwiQUFzRDZBQUFBQURPQk9UTEFBQUFBTTRLSER3QUFBQUFBK2dESVFBQUFBZ0FBZ0FBQUFBQUFBQUJBQUFESVFBQUFGb0RcIiArIFwiNkFBQUFBQUQ2QUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFBVUFBQUFnQUFBQVFENkFIMEFBVUFBQUtLQXJ3QUFBQ01cIiArIFwiQW9vQ3ZBQUFBZUFBTVFFQ0FBQUNBQVlKQUFBQUFBQUFBQUFBQVFBQUFBQUFBQUFBQUFBQUFGQm1SV1FBd0FBdUFDNERcIiArIFwiSVA4NEFGb0RJUUFBQUFBQUFRQUFBQUFBQUFBQUFDQUFJQUFCQUFBQURnQ3VBQUVBQUFBQUFBQUFBUUFBQUFFQUFBQUFcIiArIFwiQUFFQUFRQUFBQUVBQUFBQUFBSUFBUUFBQUFFQUFBQUFBQU1BQVFBQUFBRUFBQUFBQUFRQUFRQUFBQUVBQUFBQUFBVUFcIiArIFwiQVFBQUFBRUFBQUFBQUFZQUFRQUFBQU1BQVFRSkFBQUFBZ0FCQUFNQUFRUUpBQUVBQWdBQkFBTUFBUVFKQUFJQUFnQUJcIiArIFwiQUFNQUFRUUpBQU1BQWdBQkFBTUFBUVFKQUFRQUFnQUJBQU1BQVFRSkFBVUFBZ0FCQUFNQUFRUUpBQVlBQWdBQldBQllcIiArIFwiQUFBQUFBQUFBd0FBQUFNQUFBQWNBQUVBQUFBQUFEd0FBd0FCQUFBQUhBQUVBQ0FBQUFBRUFBUUFBUUFBQUM3Ly93QUFcIiArIFwiQUM3Ly8vL1RBQUVBQUFBQUFBQUJCZ0FBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTUFBQUFBQUFEL2d3QXlBQUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQkFBUUVBQUVCQVFKWUFBRUJBU0g0RHdENEd3SEVBdmdjQS9nWEJJd01BWXVMK256NXRRWGtENWozQ0JMbkVRQUNcIiArIFwiQVFFQklWaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZQUFBQkFRQUFEd0FDQVFFRUUvdDNcIiArIFwiRG92NmZBSDZmQVQrZlBwOCtud0hEb3NNQ3ZtMUN2bTFEQXo2ZkJRQUFBQUFBQUFCQUFBQUFNbUpiekVBQUFBQXpnVGpcIiArIFwiRlFBQUFBRE9CT1FwQUFFQUFBQUFBQUFBREFBVUFBUUFBQUFCQUFBQUFnQUJBQUFBQUFBQUFBQUQ2QUFBQUFBQUFBPT1cIik7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9sb2FkVGVzdEZvbnRcIiwgdGVzdEZvbnQpO1xuICB9XG4gIF9wcmVwYXJlRm9udExvYWRFdmVudChmb250LCByZXF1ZXN0KSB7XG4gICAgZnVuY3Rpb24gaW50MzIoZGF0YSwgb2Zmc2V0KSB7XG4gICAgICByZXR1cm4gZGF0YS5jaGFyQ29kZUF0KG9mZnNldCkgPDwgMjQgfCBkYXRhLmNoYXJDb2RlQXQob2Zmc2V0ICsgMSkgPDwgMTYgfCBkYXRhLmNoYXJDb2RlQXQob2Zmc2V0ICsgMikgPDwgOCB8IGRhdGEuY2hhckNvZGVBdChvZmZzZXQgKyAzKSAmIDB4ZmY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNwbGljZVN0cmluZyhzLCBvZmZzZXQsIHJlbW92ZSwgaW5zZXJ0KSB7XG4gICAgICBjb25zdCBjaHVuazEgPSBzLnN1YnN0cmluZygwLCBvZmZzZXQpO1xuICAgICAgY29uc3QgY2h1bmsyID0gcy5zdWJzdHJpbmcob2Zmc2V0ICsgcmVtb3ZlKTtcbiAgICAgIHJldHVybiBjaHVuazEgKyBpbnNlcnQgKyBjaHVuazI7XG4gICAgfVxuICAgIGxldCBpLCBpaTtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IDE7XG4gICAgY2FudmFzLmhlaWdodCA9IDE7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBsZXQgY2FsbGVkID0gMDtcbiAgICBmdW5jdGlvbiBpc0ZvbnRSZWFkeShuYW1lLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCsrY2FsbGVkID4gMzApIHtcbiAgICAgICAgd2FybihcIkxvYWQgdGVzdCBmb250IG5ldmVyIGxvYWRlZC5cIik7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5mb250ID0gXCIzMHB4IFwiICsgbmFtZTtcbiAgICAgIGN0eC5maWxsVGV4dChcIi5cIiwgMCwgMjApO1xuICAgICAgY29uc3QgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKTtcbiAgICAgIGlmIChpbWFnZURhdGEuZGF0YVszXSA+IDApIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dChpc0ZvbnRSZWFkeS5iaW5kKG51bGwsIG5hbWUsIGNhbGxiYWNrKSk7XG4gICAgfVxuICAgIGNvbnN0IGxvYWRUZXN0Rm9udElkID0gYGx0JHtEYXRlLm5vdygpfSR7dGhpcy5sb2FkVGVzdEZvbnRJZCsrfWA7XG4gICAgbGV0IGRhdGEgPSB0aGlzLl9sb2FkVGVzdEZvbnQ7XG4gICAgY29uc3QgQ09NTUVOVF9PRkZTRVQgPSA5NzY7XG4gICAgZGF0YSA9IHNwbGljZVN0cmluZyhkYXRhLCBDT01NRU5UX09GRlNFVCwgbG9hZFRlc3RGb250SWQubGVuZ3RoLCBsb2FkVGVzdEZvbnRJZCk7XG4gICAgY29uc3QgQ0ZGX0NIRUNLU1VNX09GRlNFVCA9IDE2O1xuICAgIGNvbnN0IFhYWFhfVkFMVUUgPSAweDU4NTg1ODU4O1xuICAgIGxldCBjaGVja3N1bSA9IGludDMyKGRhdGEsIENGRl9DSEVDS1NVTV9PRkZTRVQpO1xuICAgIGZvciAoaSA9IDAsIGlpID0gbG9hZFRlc3RGb250SWQubGVuZ3RoIC0gMzsgaSA8IGlpOyBpICs9IDQpIHtcbiAgICAgIGNoZWNrc3VtID0gY2hlY2tzdW0gLSBYWFhYX1ZBTFVFICsgaW50MzIobG9hZFRlc3RGb250SWQsIGkpIHwgMDtcbiAgICB9XG4gICAgaWYgKGkgPCBsb2FkVGVzdEZvbnRJZC5sZW5ndGgpIHtcbiAgICAgIGNoZWNrc3VtID0gY2hlY2tzdW0gLSBYWFhYX1ZBTFVFICsgaW50MzIobG9hZFRlc3RGb250SWQgKyBcIlhYWFwiLCBpKSB8IDA7XG4gICAgfVxuICAgIGRhdGEgPSBzcGxpY2VTdHJpbmcoZGF0YSwgQ0ZGX0NIRUNLU1VNX09GRlNFVCwgNCwgc3RyaW5nMzIoY2hlY2tzdW0pKTtcbiAgICBjb25zdCB1cmwgPSBgdXJsKGRhdGE6Zm9udC9vcGVudHlwZTtiYXNlNjQsJHtidG9hKGRhdGEpfSk7YDtcbiAgICBjb25zdCBydWxlID0gYEBmb250LWZhY2Uge2ZvbnQtZmFtaWx5OlwiJHtsb2FkVGVzdEZvbnRJZH1cIjtzcmM6JHt1cmx9fWA7XG4gICAgdGhpcy5pbnNlcnRSdWxlKHJ1bGUpO1xuICAgIGNvbnN0IGRpdiA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgIGRpdi5zdHlsZS53aWR0aCA9IGRpdi5zdHlsZS5oZWlnaHQgPSBcIjEwcHhcIjtcbiAgICBkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgZGl2LnN0eWxlLnRvcCA9IGRpdi5zdHlsZS5sZWZ0ID0gXCIwcHhcIjtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgW2ZvbnQubG9hZGVkTmFtZSwgbG9hZFRlc3RGb250SWRdKSB7XG4gICAgICBjb25zdCBzcGFuID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBzcGFuLnRleHRDb250ZW50ID0gXCJIaVwiO1xuICAgICAgc3Bhbi5zdHlsZS5mb250RmFtaWx5ID0gbmFtZTtcbiAgICAgIGRpdi5hcHBlbmQoc3Bhbik7XG4gICAgfVxuICAgIHRoaXMuX2RvY3VtZW50LmJvZHkuYXBwZW5kKGRpdik7XG4gICAgaXNGb250UmVhZHkobG9hZFRlc3RGb250SWQsICgpID0+IHtcbiAgICAgIGRpdi5yZW1vdmUoKTtcbiAgICAgIHJlcXVlc3QuY29tcGxldGUoKTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgRm9udEZhY2VPYmplY3Qge1xuICBjb25zdHJ1Y3Rvcih0cmFuc2xhdGVkRGF0YSwgaW5zcGVjdEZvbnQgPSBudWxsKSB7XG4gICAgdGhpcy5jb21waWxlZEdseXBocyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChjb25zdCBpIGluIHRyYW5zbGF0ZWREYXRhKSB7XG4gICAgICB0aGlzW2ldID0gdHJhbnNsYXRlZERhdGFbaV07XG4gICAgfVxuICAgIHRoaXMuX2luc3BlY3RGb250ID0gaW5zcGVjdEZvbnQ7XG4gIH1cbiAgY3JlYXRlTmF0aXZlRm9udEZhY2UoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEgfHwgdGhpcy5kaXNhYmxlRm9udEZhY2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgbmF0aXZlRm9udEZhY2U7XG4gICAgaWYgKCF0aGlzLmNzc0ZvbnRJbmZvKSB7XG4gICAgICBuYXRpdmVGb250RmFjZSA9IG5ldyBGb250RmFjZSh0aGlzLmxvYWRlZE5hbWUsIHRoaXMuZGF0YSwge30pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjc3MgPSB7XG4gICAgICAgIHdlaWdodDogdGhpcy5jc3NGb250SW5mby5mb250V2VpZ2h0XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuY3NzRm9udEluZm8uaXRhbGljQW5nbGUpIHtcbiAgICAgICAgY3NzLnN0eWxlID0gYG9ibGlxdWUgJHt0aGlzLmNzc0ZvbnRJbmZvLml0YWxpY0FuZ2xlfWRlZ2A7XG4gICAgICB9XG4gICAgICBuYXRpdmVGb250RmFjZSA9IG5ldyBGb250RmFjZSh0aGlzLmNzc0ZvbnRJbmZvLmZvbnRGYW1pbHksIHRoaXMuZGF0YSwgY3NzKTtcbiAgICB9XG4gICAgdGhpcy5faW5zcGVjdEZvbnQ/Lih0aGlzKTtcbiAgICByZXR1cm4gbmF0aXZlRm9udEZhY2U7XG4gIH1cbiAgY3JlYXRlRm9udEZhY2VSdWxlKCkge1xuICAgIGlmICghdGhpcy5kYXRhIHx8IHRoaXMuZGlzYWJsZUZvbnRGYWNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gYHVybChkYXRhOiR7dGhpcy5taW1ldHlwZX07YmFzZTY0LCR7dG9CYXNlNjRVdGlsKHRoaXMuZGF0YSl9KTtgO1xuICAgIGxldCBydWxlO1xuICAgIGlmICghdGhpcy5jc3NGb250SW5mbykge1xuICAgICAgcnVsZSA9IGBAZm9udC1mYWNlIHtmb250LWZhbWlseTpcIiR7dGhpcy5sb2FkZWROYW1lfVwiO3NyYzoke3VybH19YDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNzcyA9IGBmb250LXdlaWdodDogJHt0aGlzLmNzc0ZvbnRJbmZvLmZvbnRXZWlnaHR9O2A7XG4gICAgICBpZiAodGhpcy5jc3NGb250SW5mby5pdGFsaWNBbmdsZSkge1xuICAgICAgICBjc3MgKz0gYGZvbnQtc3R5bGU6IG9ibGlxdWUgJHt0aGlzLmNzc0ZvbnRJbmZvLml0YWxpY0FuZ2xlfWRlZztgO1xuICAgICAgfVxuICAgICAgcnVsZSA9IGBAZm9udC1mYWNlIHtmb250LWZhbWlseTpcIiR7dGhpcy5jc3NGb250SW5mby5mb250RmFtaWx5fVwiOyR7Y3NzfXNyYzoke3VybH19YDtcbiAgICB9XG4gICAgdGhpcy5faW5zcGVjdEZvbnQ/Lih0aGlzLCB1cmwpO1xuICAgIHJldHVybiBydWxlO1xuICB9XG4gIGdldFBhdGhHZW5lcmF0b3Iob2JqcywgY2hhcmFjdGVyKSB7XG4gICAgaWYgKHRoaXMuY29tcGlsZWRHbHlwaHNbY2hhcmFjdGVyXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdO1xuICAgIH1cbiAgICBjb25zdCBvYmpJZCA9IHRoaXMubG9hZGVkTmFtZSArIFwiX3BhdGhfXCIgKyBjaGFyYWN0ZXI7XG4gICAgbGV0IGNtZHM7XG4gICAgdHJ5IHtcbiAgICAgIGNtZHMgPSBvYmpzLmdldChvYmpJZCk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHdhcm4oYGdldFBhdGhHZW5lcmF0b3IgLSBpZ25vcmluZyBjaGFyYWN0ZXI6IFwiJHtleH1cIi5gKTtcbiAgICB9XG4gICAgY29uc3QgcGF0aCA9IG5ldyBQYXRoMkQoY21kcyB8fCBcIlwiKTtcbiAgICBpZiAoIXRoaXMuZm9udEV4dHJhUHJvcGVydGllcykge1xuICAgICAgb2Jqcy5kZWxldGUob2JqSWQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdID0gcGF0aDtcbiAgfVxufVxuXG47Ly8gLi9zcmMvc2hhcmVkL21lc3NhZ2VfaGFuZGxlci5qc1xuXG5jb25zdCBDYWxsYmFja0tpbmQgPSB7XG4gIERBVEE6IDEsXG4gIEVSUk9SOiAyXG59O1xuY29uc3QgU3RyZWFtS2luZCA9IHtcbiAgQ0FOQ0VMOiAxLFxuICBDQU5DRUxfQ09NUExFVEU6IDIsXG4gIENMT1NFOiAzLFxuICBFTlFVRVVFOiA0LFxuICBFUlJPUjogNSxcbiAgUFVMTDogNixcbiAgUFVMTF9DT01QTEVURTogNyxcbiAgU1RBUlRfQ09NUExFVEU6IDhcbn07XG5mdW5jdGlvbiBvbkZuKCkge31cbmZ1bmN0aW9uIHdyYXBSZWFzb24oZXgpIHtcbiAgaWYgKGV4IGluc3RhbmNlb2YgQWJvcnRFeGNlcHRpb24gfHwgZXggaW5zdGFuY2VvZiBJbnZhbGlkUERGRXhjZXB0aW9uIHx8IGV4IGluc3RhbmNlb2YgUGFzc3dvcmRFeGNlcHRpb24gfHwgZXggaW5zdGFuY2VvZiBSZXNwb25zZUV4Y2VwdGlvbiB8fCBleCBpbnN0YW5jZW9mIFVua25vd25FcnJvckV4Y2VwdGlvbikge1xuICAgIHJldHVybiBleDtcbiAgfVxuICBpZiAoIShleCBpbnN0YW5jZW9mIEVycm9yIHx8IHR5cGVvZiBleCA9PT0gXCJvYmplY3RcIiAmJiBleCAhPT0gbnVsbCkpIHtcbiAgICB1bnJlYWNoYWJsZSgnd3JhcFJlYXNvbjogRXhwZWN0ZWQgXCJyZWFzb25cIiB0byBiZSBhIChwb3NzaWJseSBjbG9uZWQpIEVycm9yLicpO1xuICB9XG4gIHN3aXRjaCAoZXgubmFtZSkge1xuICAgIGNhc2UgXCJBYm9ydEV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBBYm9ydEV4Y2VwdGlvbihleC5tZXNzYWdlKTtcbiAgICBjYXNlIFwiSW52YWxpZFBERkV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkUERGRXhjZXB0aW9uKGV4Lm1lc3NhZ2UpO1xuICAgIGNhc2UgXCJQYXNzd29yZEV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBQYXNzd29yZEV4Y2VwdGlvbihleC5tZXNzYWdlLCBleC5jb2RlKTtcbiAgICBjYXNlIFwiUmVzcG9uc2VFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2VFeGNlcHRpb24oZXgubWVzc2FnZSwgZXguc3RhdHVzLCBleC5taXNzaW5nKTtcbiAgICBjYXNlIFwiVW5rbm93bkVycm9yRXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IFVua25vd25FcnJvckV4Y2VwdGlvbihleC5tZXNzYWdlLCBleC5kZXRhaWxzKTtcbiAgfVxuICByZXR1cm4gbmV3IFVua25vd25FcnJvckV4Y2VwdGlvbihleC5tZXNzYWdlLCBleC50b1N0cmluZygpKTtcbn1cbmNsYXNzIE1lc3NhZ2VIYW5kbGVyIHtcbiAgI21lc3NhZ2VBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgY29uc3RydWN0b3Ioc291cmNlTmFtZSwgdGFyZ2V0TmFtZSwgY29tT2JqKSB7XG4gICAgdGhpcy5zb3VyY2VOYW1lID0gc291cmNlTmFtZTtcbiAgICB0aGlzLnRhcmdldE5hbWUgPSB0YXJnZXROYW1lO1xuICAgIHRoaXMuY29tT2JqID0gY29tT2JqO1xuICAgIHRoaXMuY2FsbGJhY2tJZCA9IDE7XG4gICAgdGhpcy5zdHJlYW1JZCA9IDE7XG4gICAgdGhpcy5zdHJlYW1TaW5rcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5jYWxsYmFja0NhcGFiaWxpdGllcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5hY3Rpb25IYW5kbGVyID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb21PYmouYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy4jb25NZXNzYWdlLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbDogdGhpcy4jbWVzc2FnZUFDLnNpZ25hbFxuICAgIH0pO1xuICB9XG4gICNvbk1lc3NhZ2Uoe1xuICAgIGRhdGFcbiAgfSkge1xuICAgIGlmIChkYXRhLnRhcmdldE5hbWUgIT09IHRoaXMuc291cmNlTmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGF0YS5zdHJlYW0pIHtcbiAgICAgIHRoaXMuI3Byb2Nlc3NTdHJlYW1NZXNzYWdlKGRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGF0YS5jYWxsYmFjaykge1xuICAgICAgY29uc3QgY2FsbGJhY2tJZCA9IGRhdGEuY2FsbGJhY2tJZDtcbiAgICAgIGNvbnN0IGNhcGFiaWxpdHkgPSB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzW2NhbGxiYWNrSWRdO1xuICAgICAgaWYgKCFjYXBhYmlsaXR5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlc29sdmUgY2FsbGJhY2sgJHtjYWxsYmFja0lkfWApO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXNbY2FsbGJhY2tJZF07XG4gICAgICBpZiAoZGF0YS5jYWxsYmFjayA9PT0gQ2FsbGJhY2tLaW5kLkRBVEEpIHtcbiAgICAgICAgY2FwYWJpbGl0eS5yZXNvbHZlKGRhdGEuZGF0YSk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEuY2FsbGJhY2sgPT09IENhbGxiYWNrS2luZC5FUlJPUikge1xuICAgICAgICBjYXBhYmlsaXR5LnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGNhbGxiYWNrIGNhc2VcIik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMuYWN0aW9uSGFuZGxlcltkYXRhLmFjdGlvbl07XG4gICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBhY3Rpb24gZnJvbSB3b3JrZXI6ICR7ZGF0YS5hY3Rpb259YCk7XG4gICAgfVxuICAgIGlmIChkYXRhLmNhbGxiYWNrSWQpIHtcbiAgICAgIGNvbnN0IHNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICAgIHRhcmdldE5hbWUgPSBkYXRhLnNvdXJjZU5hbWUsXG4gICAgICAgIGNvbU9iaiA9IHRoaXMuY29tT2JqO1xuICAgICAgUHJvbWlzZS50cnkoYWN0aW9uLCBkYXRhLmRhdGEpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBjYWxsYmFjazogQ2FsbGJhY2tLaW5kLkRBVEEsXG4gICAgICAgICAgY2FsbGJhY2tJZDogZGF0YS5jYWxsYmFja0lkLFxuICAgICAgICAgIGRhdGE6IHJlc3VsdFxuICAgICAgICB9KTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgY2FsbGJhY2s6IENhbGxiYWNrS2luZC5FUlJPUixcbiAgICAgICAgICBjYWxsYmFja0lkOiBkYXRhLmNhbGxiYWNrSWQsXG4gICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRhdGEuc3RyZWFtSWQpIHtcbiAgICAgIHRoaXMuI2NyZWF0ZVN0cmVhbVNpbmsoZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFjdGlvbihkYXRhLmRhdGEpO1xuICB9XG4gIG9uKGFjdGlvbk5hbWUsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBhaCA9IHRoaXMuYWN0aW9uSGFuZGxlcjtcbiAgICBpZiAoYWhbYWN0aW9uTmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgYWxyZWFkeSBhbiBhY3Rpb25OYW1lIGNhbGxlZCBcIiR7YWN0aW9uTmFtZX1cImApO1xuICAgIH1cbiAgICBhaFthY3Rpb25OYW1lXSA9IGhhbmRsZXI7XG4gIH1cbiAgc2VuZChhY3Rpb25OYW1lLCBkYXRhLCB0cmFuc2ZlcnMpIHtcbiAgICB0aGlzLmNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICBzb3VyY2VOYW1lOiB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICB0YXJnZXROYW1lOiB0aGlzLnRhcmdldE5hbWUsXG4gICAgICBhY3Rpb246IGFjdGlvbk5hbWUsXG4gICAgICBkYXRhXG4gICAgfSwgdHJhbnNmZXJzKTtcbiAgfVxuICBzZW5kV2l0aFByb21pc2UoYWN0aW9uTmFtZSwgZGF0YSwgdHJhbnNmZXJzKSB7XG4gICAgY29uc3QgY2FsbGJhY2tJZCA9IHRoaXMuY2FsbGJhY2tJZCsrO1xuICAgIGNvbnN0IGNhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzW2NhbGxiYWNrSWRdID0gY2FwYWJpbGl0eTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5jb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBzb3VyY2VOYW1lOiB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICAgIHRhcmdldE5hbWU6IHRoaXMudGFyZ2V0TmFtZSxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb25OYW1lLFxuICAgICAgICBjYWxsYmFja0lkLFxuICAgICAgICBkYXRhXG4gICAgICB9LCB0cmFuc2ZlcnMpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBjYXBhYmlsaXR5LnJlamVjdChleCk7XG4gICAgfVxuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgc2VuZFdpdGhTdHJlYW0oYWN0aW9uTmFtZSwgZGF0YSwgcXVldWVpbmdTdHJhdGVneSwgdHJhbnNmZXJzKSB7XG4gICAgY29uc3Qgc3RyZWFtSWQgPSB0aGlzLnN0cmVhbUlkKyssXG4gICAgICBzb3VyY2VOYW1lID0gdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgdGFyZ2V0TmFtZSA9IHRoaXMudGFyZ2V0TmFtZSxcbiAgICAgIGNvbU9iaiA9IHRoaXMuY29tT2JqO1xuICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgc3RhcnQ6IGNvbnRyb2xsZXIgPT4ge1xuICAgICAgICBjb25zdCBzdGFydENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0gPSB7XG4gICAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgICBzdGFydENhbGw6IHN0YXJ0Q2FwYWJpbGl0eSxcbiAgICAgICAgICBwdWxsQ2FsbDogbnVsbCxcbiAgICAgICAgICBjYW5jZWxDYWxsOiBudWxsLFxuICAgICAgICAgIGlzQ2xvc2VkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbk5hbWUsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBkZXNpcmVkU2l6ZTogY29udHJvbGxlci5kZXNpcmVkU2l6ZVxuICAgICAgICB9LCB0cmFuc2ZlcnMpO1xuICAgICAgICByZXR1cm4gc3RhcnRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9LFxuICAgICAgcHVsbDogY29udHJvbGxlciA9PiB7XG4gICAgICAgIGNvbnN0IHB1bGxDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLnB1bGxDYWxsID0gcHVsbENhcGFiaWxpdHk7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5QVUxMLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIGRlc2lyZWRTaXplOiBjb250cm9sbGVyLmRlc2lyZWRTaXplXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHVsbENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgIH0sXG4gICAgICBjYW5jZWw6IHJlYXNvbiA9PiB7XG4gICAgICAgIGFzc2VydChyZWFzb24gaW5zdGFuY2VvZiBFcnJvciwgXCJjYW5jZWwgbXVzdCBoYXZlIGEgdmFsaWQgcmVhc29uXCIpO1xuICAgICAgICBjb25zdCBjYW5jZWxDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLmNhbmNlbENhbGwgPSBjYW5jZWxDYXBhYmlsaXR5O1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5pc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DQU5DRUwsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjYW5jZWxDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9XG4gICAgfSwgcXVldWVpbmdTdHJhdGVneSk7XG4gIH1cbiAgI2NyZWF0ZVN0cmVhbVNpbmsoZGF0YSkge1xuICAgIGNvbnN0IHN0cmVhbUlkID0gZGF0YS5zdHJlYW1JZCxcbiAgICAgIHNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICB0YXJnZXROYW1lID0gZGF0YS5zb3VyY2VOYW1lLFxuICAgICAgY29tT2JqID0gdGhpcy5jb21PYmo7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMsXG4gICAgICBhY3Rpb24gPSB0aGlzLmFjdGlvbkhhbmRsZXJbZGF0YS5hY3Rpb25dO1xuICAgIGNvbnN0IHN0cmVhbVNpbmsgPSB7XG4gICAgICBlbnF1ZXVlKGNodW5rLCBzaXplID0gMSwgdHJhbnNmZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhc3REZXNpcmVkU2l6ZSA9IHRoaXMuZGVzaXJlZFNpemU7XG4gICAgICAgIHRoaXMuZGVzaXJlZFNpemUgLT0gc2l6ZTtcbiAgICAgICAgaWYgKGxhc3REZXNpcmVkU2l6ZSA+IDAgJiYgdGhpcy5kZXNpcmVkU2l6ZSA8PSAwKSB7XG4gICAgICAgICAgdGhpcy5zaW5rQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgICAgIHRoaXMucmVhZHkgPSB0aGlzLnNpbmtDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkVOUVVFVUUsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgY2h1bmtcbiAgICAgICAgfSwgdHJhbnNmZXJzKTtcbiAgICAgIH0sXG4gICAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DTE9TRSxcbiAgICAgICAgICBzdHJlYW1JZFxuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIHNlbGYuc3RyZWFtU2lua3Nbc3RyZWFtSWRdO1xuICAgICAgfSxcbiAgICAgIGVycm9yKHJlYXNvbikge1xuICAgICAgICBhc3NlcnQocmVhc29uIGluc3RhbmNlb2YgRXJyb3IsIFwiZXJyb3IgbXVzdCBoYXZlIGEgdmFsaWQgcmVhc29uXCIpO1xuICAgICAgICBpZiAodGhpcy5pc0NhbmNlbGxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkVSUk9SLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHNpbmtDYXBhYmlsaXR5OiBQcm9taXNlLndpdGhSZXNvbHZlcnMoKSxcbiAgICAgIG9uUHVsbDogbnVsbCxcbiAgICAgIG9uQ2FuY2VsOiBudWxsLFxuICAgICAgaXNDYW5jZWxsZWQ6IGZhbHNlLFxuICAgICAgZGVzaXJlZFNpemU6IGRhdGEuZGVzaXJlZFNpemUsXG4gICAgICByZWFkeTogbnVsbFxuICAgIH07XG4gICAgc3RyZWFtU2luay5zaW5rQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgc3RyZWFtU2luay5yZWFkeSA9IHN0cmVhbVNpbmsuc2lua0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB0aGlzLnN0cmVhbVNpbmtzW3N0cmVhbUlkXSA9IHN0cmVhbVNpbms7XG4gICAgUHJvbWlzZS50cnkoYWN0aW9uLCBkYXRhLmRhdGEsIHN0cmVhbVNpbmspLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlNUQVJUX0NPTVBMRVRFLFxuICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlNUQVJUX0NPTVBMRVRFLFxuICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gICNwcm9jZXNzU3RyZWFtTWVzc2FnZShkYXRhKSB7XG4gICAgY29uc3Qgc3RyZWFtSWQgPSBkYXRhLnN0cmVhbUlkLFxuICAgICAgc291cmNlTmFtZSA9IHRoaXMuc291cmNlTmFtZSxcbiAgICAgIHRhcmdldE5hbWUgPSBkYXRhLnNvdXJjZU5hbWUsXG4gICAgICBjb21PYmogPSB0aGlzLmNvbU9iajtcbiAgICBjb25zdCBzdHJlYW1Db250cm9sbGVyID0gdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0sXG4gICAgICBzdHJlYW1TaW5rID0gdGhpcy5zdHJlYW1TaW5rc1tzdHJlYW1JZF07XG4gICAgc3dpdGNoIChkYXRhLnN0cmVhbSkge1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLlNUQVJUX0NPTVBMRVRFOlxuICAgICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5zdGFydENhbGwucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuc3RhcnRDYWxsLnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuUFVMTF9DT01QTEVURTpcbiAgICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIucHVsbENhbGwucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIucHVsbENhbGwucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5QVUxMOlxuICAgICAgICBpZiAoIXN0cmVhbVNpbmspIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuUFVMTF9DT01QTEVURSxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW1TaW5rLmRlc2lyZWRTaXplIDw9IDAgJiYgZGF0YS5kZXNpcmVkU2l6ZSA+IDApIHtcbiAgICAgICAgICBzdHJlYW1TaW5rLnNpbmtDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW1TaW5rLmRlc2lyZWRTaXplID0gZGF0YS5kZXNpcmVkU2l6ZTtcbiAgICAgICAgUHJvbWlzZS50cnkoc3RyZWFtU2luay5vblB1bGwgfHwgb25GbikudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5QVUxMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuRU5RVUVVRTpcbiAgICAgICAgYXNzZXJ0KHN0cmVhbUNvbnRyb2xsZXIsIFwiZW5xdWV1ZSBzaG91bGQgaGF2ZSBzdHJlYW0gY29udHJvbGxlclwiKTtcbiAgICAgICAgaWYgKHN0cmVhbUNvbnRyb2xsZXIuaXNDbG9zZWQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNvbnRyb2xsZXIuZW5xdWV1ZShkYXRhLmNodW5rKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuQ0xPU0U6XG4gICAgICAgIGFzc2VydChzdHJlYW1Db250cm9sbGVyLCBcImNsb3NlIHNob3VsZCBoYXZlIHN0cmVhbSBjb250cm9sbGVyXCIpO1xuICAgICAgICBpZiAoc3RyZWFtQ29udHJvbGxlci5pc0Nsb3NlZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgdGhpcy4jZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkVSUk9SOlxuICAgICAgICBhc3NlcnQoc3RyZWFtQ29udHJvbGxlciwgXCJlcnJvciBzaG91bGQgaGF2ZSBzdHJlYW0gY29udHJvbGxlclwiKTtcbiAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jb250cm9sbGVyLmVycm9yKHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgdGhpcy4jZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkNBTkNFTF9DT01QTEVURTpcbiAgICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY2FuY2VsQ2FsbC5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jYW5jZWxDYWxsLnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkNBTkNFTDpcbiAgICAgICAgaWYgKCFzdHJlYW1TaW5rKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YVJlYXNvbiA9IHdyYXBSZWFzb24oZGF0YS5yZWFzb24pO1xuICAgICAgICBQcm9taXNlLnRyeShzdHJlYW1TaW5rLm9uQ2FuY2VsIHx8IG9uRm4sIGRhdGFSZWFzb24pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DQU5DRUxfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DQU5DRUxfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdHJlYW1TaW5rLnNpbmtDYXBhYmlsaXR5LnJlamVjdChkYXRhUmVhc29uKTtcbiAgICAgICAgc3RyZWFtU2luay5pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnN0cmVhbVNpbmtzW3N0cmVhbUlkXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHN0cmVhbSBjYXNlXCIpO1xuICAgIH1cbiAgfVxuICBhc3luYyAjZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChbc3RyZWFtQ29udHJvbGxlci5zdGFydENhbGw/LnByb21pc2UsIHN0cmVhbUNvbnRyb2xsZXIucHVsbENhbGw/LnByb21pc2UsIHN0cmVhbUNvbnRyb2xsZXIuY2FuY2VsQ2FsbD8ucHJvbWlzZV0pO1xuICAgIGRlbGV0ZSB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI21lc3NhZ2VBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNtZXNzYWdlQUMgPSBudWxsO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2NhbnZhc19mYWN0b3J5LmpzXG5cbmNsYXNzIEJhc2VDYW52YXNGYWN0b3J5IHtcbiAgI2VuYWJsZUhXQSA9IGZhbHNlO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZW5hYmxlSFdBID0gZmFsc2VcbiAgfSkge1xuICAgIHRoaXMuI2VuYWJsZUhXQSA9IGVuYWJsZUhXQTtcbiAgfVxuICBjcmVhdGUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNhbnZhcyBzaXplXCIpO1xuICAgIH1cbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhcyxcbiAgICAgIGNvbnRleHQ6IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6ICF0aGlzLiNlbmFibGVIV0FcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICByZXNldChjYW52YXNBbmRDb250ZXh0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKCFjYW52YXNBbmRDb250ZXh0LmNhbnZhcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIGlzIG5vdCBzcGVjaWZpZWRcIik7XG4gICAgfVxuICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNhbnZhcyBzaXplXCIpO1xuICAgIH1cbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxuICBkZXN0cm95KGNhbnZhc0FuZENvbnRleHQpIHtcbiAgICBpZiAoIWNhbnZhc0FuZENvbnRleHQuY2FudmFzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgaXMgbm90IHNwZWNpZmllZFwiKTtcbiAgICB9XG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMud2lkdGggPSAwO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLmhlaWdodCA9IDA7XG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMgPSBudWxsO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY29udGV4dCA9IG51bGw7XG4gIH1cbiAgX2NyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYF9jcmVhdGVDYW52YXNgIGNhbGxlZC5cIik7XG4gIH1cbn1cbmNsYXNzIERPTUNhbnZhc0ZhY3RvcnkgZXh0ZW5kcyBCYXNlQ2FudmFzRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBvd25lckRvY3VtZW50ID0gZ2xvYmFsVGhpcy5kb2N1bWVudCxcbiAgICBlbmFibGVIV0EgPSBmYWxzZVxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgZW5hYmxlSFdBXG4gICAgfSk7XG4gICAgdGhpcy5fZG9jdW1lbnQgPSBvd25lckRvY3VtZW50O1xuICB9XG4gIF9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2NtYXBfcmVhZGVyX2ZhY3RvcnkuanNcblxuXG5jbGFzcyBCYXNlQ01hcFJlYWRlckZhY3Rvcnkge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYmFzZVVybCA9IG51bGwsXG4gICAgaXNDb21wcmVzc2VkID0gdHJ1ZVxuICB9KSB7XG4gICAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgICB0aGlzLmlzQ29tcHJlc3NlZCA9IGlzQ29tcHJlc3NlZDtcbiAgfVxuICBhc3luYyBmZXRjaCh7XG4gICAgbmFtZVxuICB9KSB7XG4gICAgaWYgKCF0aGlzLmJhc2VVcmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGF0IHRoZSBgY01hcFVybGAgYW5kIGBjTWFwUGFja2VkYCBBUEkgcGFyYW1ldGVycyBhcmUgcHJvdmlkZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNNYXAgbmFtZSBtdXN0IGJlIHNwZWNpZmllZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IHRoaXMuYmFzZVVybCArIG5hbWUgKyAodGhpcy5pc0NvbXByZXNzZWQgPyBcIi5iY21hcFwiIDogXCJcIik7XG4gICAgcmV0dXJuIHRoaXMuX2ZldGNoKHVybCkudGhlbihjTWFwRGF0YSA9PiAoe1xuICAgICAgY01hcERhdGEsXG4gICAgICBpc0NvbXByZXNzZWQ6IHRoaXMuaXNDb21wcmVzc2VkXG4gICAgfSkpLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBsb2FkICR7dGhpcy5pc0NvbXByZXNzZWQgPyBcImJpbmFyeSBcIiA6IFwiXCJ9Q01hcCBhdDogJHt1cmx9YCk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBfZmV0Y2hgIGNhbGxlZC5cIik7XG4gIH1cbn1cbmNsYXNzIERPTUNNYXBSZWFkZXJGYWN0b3J5IGV4dGVuZHMgQmFzZUNNYXBSZWFkZXJGYWN0b3J5IHtcbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBmZXRjaERhdGEodXJsLCB0aGlzLmlzQ29tcHJlc3NlZCA/IFwiYXJyYXlidWZmZXJcIiA6IFwidGV4dFwiKTtcbiAgICByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gbmV3IFVpbnQ4QXJyYXkoZGF0YSkgOiBzdHJpbmdUb0J5dGVzKGRhdGEpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2ZpbHRlcl9mYWN0b3J5LmpzXG5cblxuY2xhc3MgQmFzZUZpbHRlckZhY3Rvcnkge1xuICBhZGRGaWx0ZXIobWFwcykge1xuICAgIHJldHVybiBcIm5vbmVcIjtcbiAgfVxuICBhZGRIQ01GaWx0ZXIoZmdDb2xvciwgYmdDb2xvcikge1xuICAgIHJldHVybiBcIm5vbmVcIjtcbiAgfVxuICBhZGRBbHBoYUZpbHRlcihtYXApIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgYWRkTHVtaW5vc2l0eUZpbHRlcihtYXApIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0SENNRmlsdGVyKGZpbHRlck5hbWUsIGZnQ29sb3IsIGJnQ29sb3IsIG5ld0ZnQ29sb3IsIG5ld0JnQ29sb3IpIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgZGVzdHJveShrZWVwSENNID0gZmFsc2UpIHt9XG59XG5jbGFzcyBET01GaWx0ZXJGYWN0b3J5IGV4dGVuZHMgQmFzZUZpbHRlckZhY3Rvcnkge1xuICAjYmFzZVVybDtcbiAgI19jYWNoZTtcbiAgI19kZWZzO1xuICAjZG9jSWQ7XG4gICNkb2N1bWVudDtcbiAgI19oY21DYWNoZTtcbiAgI2lkID0gMDtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRvY0lkLFxuICAgIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxUaGlzLmRvY3VtZW50XG4gIH0pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuI2RvY0lkID0gZG9jSWQ7XG4gICAgdGhpcy4jZG9jdW1lbnQgPSBvd25lckRvY3VtZW50O1xuICB9XG4gIGdldCAjY2FjaGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI19jYWNoZSB8fD0gbmV3IE1hcCgpO1xuICB9XG4gIGdldCAjaGNtQ2FjaGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI19oY21DYWNoZSB8fD0gbmV3IE1hcCgpO1xuICB9XG4gIGdldCAjZGVmcygpIHtcbiAgICBpZiAoIXRoaXMuI19kZWZzKSB7XG4gICAgICBjb25zdCBkaXYgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdHlsZVxuICAgICAgfSA9IGRpdjtcbiAgICAgIHN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgc3R5bGUuY29udGFpbiA9IFwic3RyaWN0XCI7XG4gICAgICBzdHlsZS53aWR0aCA9IHN0eWxlLmhlaWdodCA9IDA7XG4gICAgICBzdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgIHN0eWxlLnRvcCA9IHN0eWxlLmxlZnQgPSAwO1xuICAgICAgc3R5bGUuekluZGV4ID0gLTE7XG4gICAgICBjb25zdCBzdmcgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcInN2Z1wiKTtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCAwKTtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgMCk7XG4gICAgICB0aGlzLiNfZGVmcyA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwiZGVmc1wiKTtcbiAgICAgIGRpdi5hcHBlbmQoc3ZnKTtcbiAgICAgIHN2Zy5hcHBlbmQodGhpcy4jX2RlZnMpO1xuICAgICAgdGhpcy4jZG9jdW1lbnQuYm9keS5hcHBlbmQoZGl2KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI19kZWZzO1xuICB9XG4gICNjcmVhdGVUYWJsZXMobWFwcykge1xuICAgIGlmIChtYXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgbWFwUiA9IG1hcHNbMF07XG4gICAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgYnVmZmVyW2ldID0gbWFwUltpXSAvIDI1NTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhYmxlID0gYnVmZmVyLmpvaW4oXCIsXCIpO1xuICAgICAgcmV0dXJuIFt0YWJsZSwgdGFibGUsIHRhYmxlXTtcbiAgICB9XG4gICAgY29uc3QgW21hcFIsIG1hcEcsIG1hcEJdID0gbWFwcztcbiAgICBjb25zdCBidWZmZXJSID0gbmV3IEFycmF5KDI1Nik7XG4gICAgY29uc3QgYnVmZmVyRyA9IG5ldyBBcnJheSgyNTYpO1xuICAgIGNvbnN0IGJ1ZmZlckIgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBidWZmZXJSW2ldID0gbWFwUltpXSAvIDI1NTtcbiAgICAgIGJ1ZmZlckdbaV0gPSBtYXBHW2ldIC8gMjU1O1xuICAgICAgYnVmZmVyQltpXSA9IG1hcEJbaV0gLyAyNTU7XG4gICAgfVxuICAgIHJldHVybiBbYnVmZmVyUi5qb2luKFwiLFwiKSwgYnVmZmVyRy5qb2luKFwiLFwiKSwgYnVmZmVyQi5qb2luKFwiLFwiKV07XG4gIH1cbiAgI2NyZWF0ZVVybChpZCkge1xuICAgIGlmICh0aGlzLiNiYXNlVXJsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuI2Jhc2VVcmwgPSBcIlwiO1xuICAgICAgY29uc3QgdXJsID0gdGhpcy4jZG9jdW1lbnQuVVJMO1xuICAgICAgaWYgKHVybCAhPT0gdGhpcy4jZG9jdW1lbnQuYmFzZVVSSSkge1xuICAgICAgICBpZiAoaXNEYXRhU2NoZW1lKHVybCkpIHtcbiAgICAgICAgICB3YXJuKCcjY3JlYXRlVXJsOiBpZ25vcmUgXCJkYXRhOlwiLVVSTCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiNiYXNlVXJsID0gdXBkYXRlVXJsSGFzaCh1cmwsIFwiXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBgdXJsKCR7dGhpcy4jYmFzZVVybH0jJHtpZH0pYDtcbiAgfVxuICBhZGRGaWx0ZXIobWFwcykge1xuICAgIGlmICghbWFwcykge1xuICAgICAgcmV0dXJuIFwibm9uZVwiO1xuICAgIH1cbiAgICBsZXQgdmFsdWUgPSB0aGlzLiNjYWNoZS5nZXQobWFwcyk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IFt0YWJsZVIsIHRhYmxlRywgdGFibGVCXSA9IHRoaXMuI2NyZWF0ZVRhYmxlcyhtYXBzKTtcbiAgICBjb25zdCBrZXkgPSBtYXBzLmxlbmd0aCA9PT0gMSA/IHRhYmxlUiA6IGAke3RhYmxlUn0ke3RhYmxlR30ke3RhYmxlQn1gO1xuICAgIHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLiNjYWNoZS5zZXQobWFwcywgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IGBnXyR7dGhpcy4jZG9jSWR9X3RyYW5zZmVyX21hcF8ke3RoaXMuI2lkKyt9YDtcbiAgICBjb25zdCB1cmwgPSB0aGlzLiNjcmVhdGVVcmwoaWQpO1xuICAgIHRoaXMuI2NhY2hlLnNldChtYXBzLCB1cmwpO1xuICAgIHRoaXMuI2NhY2hlLnNldChrZXksIHVybCk7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy4jY3JlYXRlRmlsdGVyKGlkKTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24odGFibGVSLCB0YWJsZUcsIHRhYmxlQiwgZmlsdGVyKTtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGFkZEhDTUZpbHRlcihmZ0NvbG9yLCBiZ0NvbG9yKSB7XG4gICAgY29uc3Qga2V5ID0gYCR7ZmdDb2xvcn0tJHtiZ0NvbG9yfWA7XG4gICAgY29uc3QgZmlsdGVyTmFtZSA9IFwiYmFzZVwiO1xuICAgIGxldCBpbmZvID0gdGhpcy4jaGNtQ2FjaGUuZ2V0KGZpbHRlck5hbWUpO1xuICAgIGlmIChpbmZvPy5rZXkgPT09IGtleSkge1xuICAgICAgcmV0dXJuIGluZm8udXJsO1xuICAgIH1cbiAgICBpZiAoaW5mbykge1xuICAgICAgaW5mby5maWx0ZXI/LnJlbW92ZSgpO1xuICAgICAgaW5mby5rZXkgPSBrZXk7XG4gICAgICBpbmZvLnVybCA9IFwibm9uZVwiO1xuICAgICAgaW5mby5maWx0ZXIgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvID0ge1xuICAgICAgICBrZXksXG4gICAgICAgIHVybDogXCJub25lXCIsXG4gICAgICAgIGZpbHRlcjogbnVsbFxuICAgICAgfTtcbiAgICAgIHRoaXMuI2hjbUNhY2hlLnNldChmaWx0ZXJOYW1lLCBpbmZvKTtcbiAgICB9XG4gICAgaWYgKCFmZ0NvbG9yIHx8ICFiZ0NvbG9yKSB7XG4gICAgICByZXR1cm4gaW5mby51cmw7XG4gICAgfVxuICAgIGNvbnN0IGZnUkdCID0gdGhpcy4jZ2V0UkdCKGZnQ29sb3IpO1xuICAgIGZnQ29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvciguLi5mZ1JHQik7XG4gICAgY29uc3QgYmdSR0IgPSB0aGlzLiNnZXRSR0IoYmdDb2xvcik7XG4gICAgYmdDb2xvciA9IFV0aWwubWFrZUhleENvbG9yKC4uLmJnUkdCKTtcbiAgICB0aGlzLiNkZWZzLnN0eWxlLmNvbG9yID0gXCJcIjtcbiAgICBpZiAoZmdDb2xvciA9PT0gXCIjMDAwMDAwXCIgJiYgYmdDb2xvciA9PT0gXCIjZmZmZmZmXCIgfHwgZmdDb2xvciA9PT0gYmdDb2xvcikge1xuICAgICAgcmV0dXJuIGluZm8udXJsO1xuICAgIH1cbiAgICBjb25zdCBtYXAgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAyNTU7IGkrKykge1xuICAgICAgY29uc3QgeCA9IGkgLyAyNTU7XG4gICAgICBtYXBbaV0gPSB4IDw9IDAuMDM5MjggPyB4IC8gMTIuOTIgOiAoKHggKyAwLjA1NSkgLyAxLjA1NSkgKiogMi40O1xuICAgIH1cbiAgICBjb25zdCB0YWJsZSA9IG1hcC5qb2luKFwiLFwiKTtcbiAgICBjb25zdCBpZCA9IGBnXyR7dGhpcy4jZG9jSWR9X2hjbV9maWx0ZXJgO1xuICAgIGNvbnN0IGZpbHRlciA9IGluZm8uZmlsdGVyID0gdGhpcy4jY3JlYXRlRmlsdGVyKGlkKTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24odGFibGUsIHRhYmxlLCB0YWJsZSwgZmlsdGVyKTtcbiAgICB0aGlzLiNhZGRHcmF5Q29udmVyc2lvbihmaWx0ZXIpO1xuICAgIGNvbnN0IGdldFN0ZXBzID0gKGMsIG4pID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gZmdSR0JbY10gLyAyNTU7XG4gICAgICBjb25zdCBlbmQgPSBiZ1JHQltjXSAvIDI1NTtcbiAgICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheShuICsgMSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBuOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gc3RhcnQgKyBpIC8gbiAqIChlbmQgLSBzdGFydCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyLmpvaW4oXCIsXCIpO1xuICAgIH07XG4gICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKGdldFN0ZXBzKDAsIDUpLCBnZXRTdGVwcygxLCA1KSwgZ2V0U3RlcHMoMiwgNSksIGZpbHRlcik7XG4gICAgaW5mby51cmwgPSB0aGlzLiNjcmVhdGVVcmwoaWQpO1xuICAgIHJldHVybiBpbmZvLnVybDtcbiAgfVxuICBhZGRBbHBoYUZpbHRlcihtYXApIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLiNjYWNoZS5nZXQobWFwKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgW3RhYmxlQV0gPSB0aGlzLiNjcmVhdGVUYWJsZXMoW21hcF0pO1xuICAgIGNvbnN0IGtleSA9IGBhbHBoYV8ke3RhYmxlQX1gO1xuICAgIHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLiNjYWNoZS5zZXQobWFwLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gYGdfJHt0aGlzLiNkb2NJZH1fYWxwaGFfbWFwXyR7dGhpcy4jaWQrK31gO1xuICAgIGNvbnN0IHVybCA9IHRoaXMuI2NyZWF0ZVVybChpZCk7XG4gICAgdGhpcy4jY2FjaGUuc2V0KG1hcCwgdXJsKTtcbiAgICB0aGlzLiNjYWNoZS5zZXQoa2V5LCB1cmwpO1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuI2NyZWF0ZUZpbHRlcihpZCk7XG4gICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBBbHBoYUNvbnZlcnNpb24odGFibGVBLCBmaWx0ZXIpO1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgYWRkTHVtaW5vc2l0eUZpbHRlcihtYXApIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLiNjYWNoZS5nZXQobWFwIHx8IFwibHVtaW5vc2l0eVwiKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgbGV0IHRhYmxlQSwga2V5O1xuICAgIGlmIChtYXApIHtcbiAgICAgIFt0YWJsZUFdID0gdGhpcy4jY3JlYXRlVGFibGVzKFttYXBdKTtcbiAgICAgIGtleSA9IGBsdW1pbm9zaXR5XyR7dGFibGVBfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IFwibHVtaW5vc2l0eVwiO1xuICAgIH1cbiAgICB2YWx1ZSA9IHRoaXMuI2NhY2hlLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy4jY2FjaGUuc2V0KG1hcCwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IGBnXyR7dGhpcy4jZG9jSWR9X2x1bWlub3NpdHlfbWFwXyR7dGhpcy4jaWQrK31gO1xuICAgIGNvbnN0IHVybCA9IHRoaXMuI2NyZWF0ZVVybChpZCk7XG4gICAgdGhpcy4jY2FjaGUuc2V0KG1hcCwgdXJsKTtcbiAgICB0aGlzLiNjYWNoZS5zZXQoa2V5LCB1cmwpO1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuI2NyZWF0ZUZpbHRlcihpZCk7XG4gICAgdGhpcy4jYWRkTHVtaW5vc2l0eUNvbnZlcnNpb24oZmlsdGVyKTtcbiAgICBpZiAobWFwKSB7XG4gICAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcEFscGhhQ29udmVyc2lvbih0YWJsZUEsIGZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0SENNRmlsdGVyKGZpbHRlck5hbWUsIGZnQ29sb3IsIGJnQ29sb3IsIG5ld0ZnQ29sb3IsIG5ld0JnQ29sb3IpIHtcbiAgICBjb25zdCBrZXkgPSBgJHtmZ0NvbG9yfS0ke2JnQ29sb3J9LSR7bmV3RmdDb2xvcn0tJHtuZXdCZ0NvbG9yfWA7XG4gICAgbGV0IGluZm8gPSB0aGlzLiNoY21DYWNoZS5nZXQoZmlsdGVyTmFtZSk7XG4gICAgaWYgKGluZm8/LmtleSA9PT0ga2V5KSB7XG4gICAgICByZXR1cm4gaW5mby51cmw7XG4gICAgfVxuICAgIGlmIChpbmZvKSB7XG4gICAgICBpbmZvLmZpbHRlcj8ucmVtb3ZlKCk7XG4gICAgICBpbmZvLmtleSA9IGtleTtcbiAgICAgIGluZm8udXJsID0gXCJub25lXCI7XG4gICAgICBpbmZvLmZpbHRlciA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gPSB7XG4gICAgICAgIGtleSxcbiAgICAgICAgdXJsOiBcIm5vbmVcIixcbiAgICAgICAgZmlsdGVyOiBudWxsXG4gICAgICB9O1xuICAgICAgdGhpcy4jaGNtQ2FjaGUuc2V0KGZpbHRlck5hbWUsIGluZm8pO1xuICAgIH1cbiAgICBpZiAoIWZnQ29sb3IgfHwgIWJnQ29sb3IpIHtcbiAgICAgIHJldHVybiBpbmZvLnVybDtcbiAgICB9XG4gICAgY29uc3QgW2ZnUkdCLCBiZ1JHQl0gPSBbZmdDb2xvciwgYmdDb2xvcl0ubWFwKHRoaXMuI2dldFJHQi5iaW5kKHRoaXMpKTtcbiAgICBsZXQgZmdHcmF5ID0gTWF0aC5yb3VuZCgwLjIxMjYgKiBmZ1JHQlswXSArIDAuNzE1MiAqIGZnUkdCWzFdICsgMC4wNzIyICogZmdSR0JbMl0pO1xuICAgIGxldCBiZ0dyYXkgPSBNYXRoLnJvdW5kKDAuMjEyNiAqIGJnUkdCWzBdICsgMC43MTUyICogYmdSR0JbMV0gKyAwLjA3MjIgKiBiZ1JHQlsyXSk7XG4gICAgbGV0IFtuZXdGZ1JHQiwgbmV3QmdSR0JdID0gW25ld0ZnQ29sb3IsIG5ld0JnQ29sb3JdLm1hcCh0aGlzLiNnZXRSR0IuYmluZCh0aGlzKSk7XG4gICAgaWYgKGJnR3JheSA8IGZnR3JheSkge1xuICAgICAgW2ZnR3JheSwgYmdHcmF5LCBuZXdGZ1JHQiwgbmV3QmdSR0JdID0gW2JnR3JheSwgZmdHcmF5LCBuZXdCZ1JHQiwgbmV3RmdSR0JdO1xuICAgIH1cbiAgICB0aGlzLiNkZWZzLnN0eWxlLmNvbG9yID0gXCJcIjtcbiAgICBjb25zdCBnZXRTdGVwcyA9IChmZywgYmcsIG4pID0+IHtcbiAgICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgY29uc3Qgc3RlcCA9IChiZ0dyYXkgLSBmZ0dyYXkpIC8gbjtcbiAgICAgIGNvbnN0IG5ld1N0YXJ0ID0gZmcgLyAyNTU7XG4gICAgICBjb25zdCBuZXdTdGVwID0gKGJnIC0gZmcpIC8gKDI1NSAqIG4pO1xuICAgICAgbGV0IHByZXYgPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGsgPSBNYXRoLnJvdW5kKGZnR3JheSArIGkgKiBzdGVwKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBuZXdTdGFydCArIGkgKiBuZXdTdGVwO1xuICAgICAgICBmb3IgKGxldCBqID0gcHJldjsgaiA8PSBrOyBqKyspIHtcbiAgICAgICAgICBhcnJbal0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2ID0gayArIDE7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gcHJldjsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGFycltwcmV2IC0gMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyLmpvaW4oXCIsXCIpO1xuICAgIH07XG4gICAgY29uc3QgaWQgPSBgZ18ke3RoaXMuI2RvY0lkfV9oY21fJHtmaWx0ZXJOYW1lfV9maWx0ZXJgO1xuICAgIGNvbnN0IGZpbHRlciA9IGluZm8uZmlsdGVyID0gdGhpcy4jY3JlYXRlRmlsdGVyKGlkKTtcbiAgICB0aGlzLiNhZGRHcmF5Q29udmVyc2lvbihmaWx0ZXIpO1xuICAgIHRoaXMuI2FkZFRyYW5zZmVyTWFwQ29udmVyc2lvbihnZXRTdGVwcyhuZXdGZ1JHQlswXSwgbmV3QmdSR0JbMF0sIDUpLCBnZXRTdGVwcyhuZXdGZ1JHQlsxXSwgbmV3QmdSR0JbMV0sIDUpLCBnZXRTdGVwcyhuZXdGZ1JHQlsyXSwgbmV3QmdSR0JbMl0sIDUpLCBmaWx0ZXIpO1xuICAgIGluZm8udXJsID0gdGhpcy4jY3JlYXRlVXJsKGlkKTtcbiAgICByZXR1cm4gaW5mby51cmw7XG4gIH1cbiAgZGVzdHJveShrZWVwSENNID0gZmFsc2UpIHtcbiAgICBpZiAoa2VlcEhDTSAmJiB0aGlzLiNfaGNtQ2FjaGU/LnNpemUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jX2RlZnM/LnBhcmVudE5vZGUucGFyZW50Tm9kZS5yZW1vdmUoKTtcbiAgICB0aGlzLiNfZGVmcyA9IG51bGw7XG4gICAgdGhpcy4jX2NhY2hlPy5jbGVhcigpO1xuICAgIHRoaXMuI19jYWNoZSA9IG51bGw7XG4gICAgdGhpcy4jX2hjbUNhY2hlPy5jbGVhcigpO1xuICAgIHRoaXMuI19oY21DYWNoZSA9IG51bGw7XG4gICAgdGhpcy4jaWQgPSAwO1xuICB9XG4gICNhZGRMdW1pbm9zaXR5Q29udmVyc2lvbihmaWx0ZXIpIHtcbiAgICBjb25zdCBmZUNvbG9yTWF0cml4ID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJmZUNvbG9yTWF0cml4XCIpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcIm1hdHJpeFwiKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZShcInZhbHVlc1wiLCBcIjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAuMyAwLjU5IDAuMTEgMCAwXCIpO1xuICAgIGZpbHRlci5hcHBlbmQoZmVDb2xvck1hdHJpeCk7XG4gIH1cbiAgI2FkZEdyYXlDb252ZXJzaW9uKGZpbHRlcikge1xuICAgIGNvbnN0IGZlQ29sb3JNYXRyaXggPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImZlQ29sb3JNYXRyaXhcIik7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwibWF0cml4XCIpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKFwidmFsdWVzXCIsIFwiMC4yMTI2IDAuNzE1MiAwLjA3MjIgMCAwIDAuMjEyNiAwLjcxNTIgMC4wNzIyIDAgMCAwLjIxMjYgMC43MTUyIDAuMDcyMiAwIDAgMCAwIDAgMSAwXCIpO1xuICAgIGZpbHRlci5hcHBlbmQoZmVDb2xvck1hdHJpeCk7XG4gIH1cbiAgI2NyZWF0ZUZpbHRlcihpZCkge1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwiZmlsdGVyXCIpO1xuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoXCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIiwgXCJzUkdCXCIpO1xuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBpZCk7XG4gICAgdGhpcy4jZGVmcy5hcHBlbmQoZmlsdGVyKTtcbiAgICByZXR1cm4gZmlsdGVyO1xuICB9XG4gICNhcHBlbmRGZUZ1bmMoZmVDb21wb25lbnRUcmFuc2ZlciwgZnVuYywgdGFibGUpIHtcbiAgICBjb25zdCBmZUZ1bmMgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBmdW5jKTtcbiAgICBmZUZ1bmMuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImRpc2NyZXRlXCIpO1xuICAgIGZlRnVuYy5zZXRBdHRyaWJ1dGUoXCJ0YWJsZVZhbHVlc1wiLCB0YWJsZSk7XG4gICAgZmVDb21wb25lbnRUcmFuc2Zlci5hcHBlbmQoZmVGdW5jKTtcbiAgfVxuICAjYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKHJUYWJsZSwgZ1RhYmxlLCBiVGFibGUsIGZpbHRlcikge1xuICAgIGNvbnN0IGZlQ29tcG9uZW50VHJhbnNmZXIgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImZlQ29tcG9uZW50VHJhbnNmZXJcIik7XG4gICAgZmlsdGVyLmFwcGVuZChmZUNvbXBvbmVudFRyYW5zZmVyKTtcbiAgICB0aGlzLiNhcHBlbmRGZUZ1bmMoZmVDb21wb25lbnRUcmFuc2ZlciwgXCJmZUZ1bmNSXCIsIHJUYWJsZSk7XG4gICAgdGhpcy4jYXBwZW5kRmVGdW5jKGZlQ29tcG9uZW50VHJhbnNmZXIsIFwiZmVGdW5jR1wiLCBnVGFibGUpO1xuICAgIHRoaXMuI2FwcGVuZEZlRnVuYyhmZUNvbXBvbmVudFRyYW5zZmVyLCBcImZlRnVuY0JcIiwgYlRhYmxlKTtcbiAgfVxuICAjYWRkVHJhbnNmZXJNYXBBbHBoYUNvbnZlcnNpb24oYVRhYmxlLCBmaWx0ZXIpIHtcbiAgICBjb25zdCBmZUNvbXBvbmVudFRyYW5zZmVyID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJmZUNvbXBvbmVudFRyYW5zZmVyXCIpO1xuICAgIGZpbHRlci5hcHBlbmQoZmVDb21wb25lbnRUcmFuc2Zlcik7XG4gICAgdGhpcy4jYXBwZW5kRmVGdW5jKGZlQ29tcG9uZW50VHJhbnNmZXIsIFwiZmVGdW5jQVwiLCBhVGFibGUpO1xuICB9XG4gICNnZXRSR0IoY29sb3IpIHtcbiAgICB0aGlzLiNkZWZzLnN0eWxlLmNvbG9yID0gY29sb3I7XG4gICAgcmV0dXJuIGdldFJHQihnZXRDb21wdXRlZFN0eWxlKHRoaXMuI2RlZnMpLmdldFByb3BlcnR5VmFsdWUoXCJjb2xvclwiKSk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvc3RhbmRhcmRfZm9udGRhdGFfZmFjdG9yeS5qc1xuXG5cbmNsYXNzIEJhc2VTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBiYXNlVXJsID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgfVxuICBhc3luYyBmZXRjaCh7XG4gICAgZmlsZW5hbWVcbiAgfSkge1xuICAgIGlmICghdGhpcy5iYXNlVXJsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhhdCB0aGUgYHN0YW5kYXJkRm9udERhdGFVcmxgIEFQSSBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIWZpbGVuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGb250IGZpbGVuYW1lIG11c3QgYmUgc3BlY2lmaWVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gYCR7dGhpcy5iYXNlVXJsfSR7ZmlsZW5hbWV9YDtcbiAgICByZXR1cm4gdGhpcy5fZmV0Y2godXJsKS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gbG9hZCBmb250IGRhdGEgYXQ6ICR7dXJsfWApO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgX2ZldGNoYCBjYWxsZWQuXCIpO1xuICB9XG59XG5jbGFzcyBET01TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSBleHRlbmRzIEJhc2VTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSB7XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgZmV0Y2hEYXRhKHVybCwgXCJhcnJheWJ1ZmZlclwiKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvd2FzbV9mYWN0b3J5LmpzXG5cblxuY2xhc3MgQmFzZVdhc21GYWN0b3J5IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGJhc2VVcmwgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICB9XG4gIGFzeW5jIGZldGNoKHtcbiAgICBmaWxlbmFtZVxuICB9KSB7XG4gICAgaWYgKCF0aGlzLmJhc2VVcmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGF0IHRoZSBgd2FzbVVybGAgQVBJIHBhcmFtZXRlciBpcyBwcm92aWRlZC5cIik7XG4gICAgfVxuICAgIGlmICghZmlsZW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldhc20gZmlsZW5hbWUgbXVzdCBiZSBzcGVjaWZpZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmJhc2VVcmx9JHtmaWxlbmFtZX1gO1xuICAgIHJldHVybiB0aGlzLl9mZXRjaCh1cmwpLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBsb2FkIHdhc20gZGF0YSBhdDogJHt1cmx9YCk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBfZmV0Y2hgIGNhbGxlZC5cIik7XG4gIH1cbn1cbmNsYXNzIERPTVdhc21GYWN0b3J5IGV4dGVuZHMgQmFzZVdhc21GYWN0b3J5IHtcbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBmZXRjaERhdGEodXJsLCBcImFycmF5YnVmZmVyXCIpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9ub2RlX3V0aWxzLmpzXG5cblxuXG5cblxuXG5pZiAoaXNOb2RlSlMpIHtcbiAgd2FybihcIlBsZWFzZSB1c2UgdGhlIGBsZWdhY3lgIGJ1aWxkIGluIE5vZGUuanMgZW52aXJvbm1lbnRzLlwiKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG5vZGVfdXRpbHNfZmV0Y2hEYXRhKHVybCkge1xuICBjb25zdCBmcyA9IHByb2Nlc3MuZ2V0QnVpbHRpbk1vZHVsZShcImZzXCIpO1xuICBjb25zdCBkYXRhID0gYXdhaXQgZnMucHJvbWlzZXMucmVhZEZpbGUodXJsKTtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGEpO1xufVxuY2xhc3MgTm9kZUZpbHRlckZhY3RvcnkgZXh0ZW5kcyBCYXNlRmlsdGVyRmFjdG9yeSB7fVxuY2xhc3MgTm9kZUNhbnZhc0ZhY3RvcnkgZXh0ZW5kcyBCYXNlQ2FudmFzRmFjdG9yeSB7XG4gIF9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHJlcXVpcmUgPSBwcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGUoXCJtb2R1bGVcIikuY3JlYXRlUmVxdWlyZShpbXBvcnQubWV0YS51cmwpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHJlcXVpcmUoXCJAbmFwaS1ycy9jYW52YXNcIik7XG4gICAgcmV0dXJuIGNhbnZhcy5jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCk7XG4gIH1cbn1cbmNsYXNzIE5vZGVDTWFwUmVhZGVyRmFjdG9yeSBleHRlbmRzIEJhc2VDTWFwUmVhZGVyRmFjdG9yeSB7XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICByZXR1cm4gbm9kZV91dGlsc19mZXRjaERhdGEodXJsKTtcbiAgfVxufVxuY2xhc3MgTm9kZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IGV4dGVuZHMgQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IHtcbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIHJldHVybiBub2RlX3V0aWxzX2ZldGNoRGF0YSh1cmwpO1xuICB9XG59XG5jbGFzcyBOb2RlV2FzbUZhY3RvcnkgZXh0ZW5kcyBCYXNlV2FzbUZhY3Rvcnkge1xuICBhc3luYyBfZmV0Y2godXJsKSB7XG4gICAgcmV0dXJuIG5vZGVfdXRpbHNfZmV0Y2hEYXRhKHVybCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvcGF0dGVybl9oZWxwZXIuanNcblxuXG5jb25zdCBQYXRoVHlwZSA9IHtcbiAgRklMTDogXCJGaWxsXCIsXG4gIFNUUk9LRTogXCJTdHJva2VcIixcbiAgU0hBRElORzogXCJTaGFkaW5nXCJcbn07XG5mdW5jdGlvbiBhcHBseUJvdW5kaW5nQm94KGN0eCwgYmJveCkge1xuICBpZiAoIWJib3gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgd2lkdGggPSBiYm94WzJdIC0gYmJveFswXTtcbiAgY29uc3QgaGVpZ2h0ID0gYmJveFszXSAtIGJib3hbMV07XG4gIGNvbnN0IHJlZ2lvbiA9IG5ldyBQYXRoMkQoKTtcbiAgcmVnaW9uLnJlY3QoYmJveFswXSwgYmJveFsxXSwgd2lkdGgsIGhlaWdodCk7XG4gIGN0eC5jbGlwKHJlZ2lvbik7XG59XG5jbGFzcyBCYXNlU2hhZGluZ1BhdHRlcm4ge1xuICBpc01vZGlmeWluZ0N1cnJlbnRUcmFuc2Zvcm0oKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldFBhdHRlcm4oKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYGdldFBhdHRlcm5gIGNhbGxlZC5cIik7XG4gIH1cbn1cbmNsYXNzIFJhZGlhbEF4aWFsU2hhZGluZ1BhdHRlcm4gZXh0ZW5kcyBCYXNlU2hhZGluZ1BhdHRlcm4ge1xuICBjb25zdHJ1Y3RvcihJUikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fdHlwZSA9IElSWzFdO1xuICAgIHRoaXMuX2Jib3ggPSBJUlsyXTtcbiAgICB0aGlzLl9jb2xvclN0b3BzID0gSVJbM107XG4gICAgdGhpcy5fcDAgPSBJUls0XTtcbiAgICB0aGlzLl9wMSA9IElSWzVdO1xuICAgIHRoaXMuX3IwID0gSVJbNl07XG4gICAgdGhpcy5fcjEgPSBJUls3XTtcbiAgICB0aGlzLm1hdHJpeCA9IG51bGw7XG4gIH1cbiAgX2NyZWF0ZUdyYWRpZW50KGN0eCkge1xuICAgIGxldCBncmFkO1xuICAgIGlmICh0aGlzLl90eXBlID09PSBcImF4aWFsXCIpIHtcbiAgICAgIGdyYWQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQodGhpcy5fcDBbMF0sIHRoaXMuX3AwWzFdLCB0aGlzLl9wMVswXSwgdGhpcy5fcDFbMV0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fdHlwZSA9PT0gXCJyYWRpYWxcIikge1xuICAgICAgZ3JhZCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudCh0aGlzLl9wMFswXSwgdGhpcy5fcDBbMV0sIHRoaXMuX3IwLCB0aGlzLl9wMVswXSwgdGhpcy5fcDFbMV0sIHRoaXMuX3IxKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjb2xvclN0b3Agb2YgdGhpcy5fY29sb3JTdG9wcykge1xuICAgICAgZ3JhZC5hZGRDb2xvclN0b3AoY29sb3JTdG9wWzBdLCBjb2xvclN0b3BbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gZ3JhZDtcbiAgfVxuICBnZXRQYXR0ZXJuKGN0eCwgb3duZXIsIGludmVyc2UsIHBhdGhUeXBlKSB7XG4gICAgbGV0IHBhdHRlcm47XG4gICAgaWYgKHBhdGhUeXBlID09PSBQYXRoVHlwZS5TVFJPS0UgfHwgcGF0aFR5cGUgPT09IFBhdGhUeXBlLkZJTEwpIHtcbiAgICAgIGNvbnN0IG93bmVyQkJveCA9IG93bmVyLmN1cnJlbnQuZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveChwYXRoVHlwZSwgZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpKSB8fCBbMCwgMCwgMCwgMF07XG4gICAgICBjb25zdCB3aWR0aCA9IE1hdGguY2VpbChvd25lckJCb3hbMl0gLSBvd25lckJCb3hbMF0pIHx8IDE7XG4gICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmNlaWwob3duZXJCQm94WzNdIC0gb3duZXJCQm94WzFdKSB8fCAxO1xuICAgICAgY29uc3QgdG1wQ2FudmFzID0gb3duZXIuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwicGF0dGVyblwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgdG1wQ3R4LmNsZWFyUmVjdCgwLCAwLCB0bXBDdHguY2FudmFzLndpZHRoLCB0bXBDdHguY2FudmFzLmhlaWdodCk7XG4gICAgICB0bXBDdHguYmVnaW5QYXRoKCk7XG4gICAgICB0bXBDdHgucmVjdCgwLCAwLCB0bXBDdHguY2FudmFzLndpZHRoLCB0bXBDdHguY2FudmFzLmhlaWdodCk7XG4gICAgICB0bXBDdHgudHJhbnNsYXRlKC1vd25lckJCb3hbMF0sIC1vd25lckJCb3hbMV0pO1xuICAgICAgaW52ZXJzZSA9IFV0aWwudHJhbnNmb3JtKGludmVyc2UsIFsxLCAwLCAwLCAxLCBvd25lckJCb3hbMF0sIG93bmVyQkJveFsxXV0pO1xuICAgICAgdG1wQ3R4LnRyYW5zZm9ybSguLi5vd25lci5iYXNlVHJhbnNmb3JtKTtcbiAgICAgIGlmICh0aGlzLm1hdHJpeCkge1xuICAgICAgICB0bXBDdHgudHJhbnNmb3JtKC4uLnRoaXMubWF0cml4KTtcbiAgICAgIH1cbiAgICAgIGFwcGx5Qm91bmRpbmdCb3godG1wQ3R4LCB0aGlzLl9iYm94KTtcbiAgICAgIHRtcEN0eC5maWxsU3R5bGUgPSB0aGlzLl9jcmVhdGVHcmFkaWVudCh0bXBDdHgpO1xuICAgICAgdG1wQ3R4LmZpbGwoKTtcbiAgICAgIHBhdHRlcm4gPSBjdHguY3JlYXRlUGF0dGVybih0bXBDYW52YXMuY2FudmFzLCBcIm5vLXJlcGVhdFwiKTtcbiAgICAgIGNvbnN0IGRvbU1hdHJpeCA9IG5ldyBET01NYXRyaXgoaW52ZXJzZSk7XG4gICAgICBwYXR0ZXJuLnNldFRyYW5zZm9ybShkb21NYXRyaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcHBseUJvdW5kaW5nQm94KGN0eCwgdGhpcy5fYmJveCk7XG4gICAgICBwYXR0ZXJuID0gdGhpcy5fY3JlYXRlR3JhZGllbnQoY3R4KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cbn1cbmZ1bmN0aW9uIGRyYXdUcmlhbmdsZShkYXRhLCBjb250ZXh0LCBwMSwgcDIsIHAzLCBjMSwgYzIsIGMzKSB7XG4gIGNvbnN0IGNvb3JkcyA9IGNvbnRleHQuY29vcmRzLFxuICAgIGNvbG9ycyA9IGNvbnRleHQuY29sb3JzO1xuICBjb25zdCBieXRlcyA9IGRhdGEuZGF0YSxcbiAgICByb3dTaXplID0gZGF0YS53aWR0aCAqIDQ7XG4gIGxldCB0bXA7XG4gIGlmIChjb29yZHNbcDEgKyAxXSA+IGNvb3Jkc1twMiArIDFdKSB7XG4gICAgdG1wID0gcDE7XG4gICAgcDEgPSBwMjtcbiAgICBwMiA9IHRtcDtcbiAgICB0bXAgPSBjMTtcbiAgICBjMSA9IGMyO1xuICAgIGMyID0gdG1wO1xuICB9XG4gIGlmIChjb29yZHNbcDIgKyAxXSA+IGNvb3Jkc1twMyArIDFdKSB7XG4gICAgdG1wID0gcDI7XG4gICAgcDIgPSBwMztcbiAgICBwMyA9IHRtcDtcbiAgICB0bXAgPSBjMjtcbiAgICBjMiA9IGMzO1xuICAgIGMzID0gdG1wO1xuICB9XG4gIGlmIChjb29yZHNbcDEgKyAxXSA+IGNvb3Jkc1twMiArIDFdKSB7XG4gICAgdG1wID0gcDE7XG4gICAgcDEgPSBwMjtcbiAgICBwMiA9IHRtcDtcbiAgICB0bXAgPSBjMTtcbiAgICBjMSA9IGMyO1xuICAgIGMyID0gdG1wO1xuICB9XG4gIGNvbnN0IHgxID0gKGNvb3Jkc1twMV0gKyBjb250ZXh0Lm9mZnNldFgpICogY29udGV4dC5zY2FsZVg7XG4gIGNvbnN0IHkxID0gKGNvb3Jkc1twMSArIDFdICsgY29udGV4dC5vZmZzZXRZKSAqIGNvbnRleHQuc2NhbGVZO1xuICBjb25zdCB4MiA9IChjb29yZHNbcDJdICsgY29udGV4dC5vZmZzZXRYKSAqIGNvbnRleHQuc2NhbGVYO1xuICBjb25zdCB5MiA9IChjb29yZHNbcDIgKyAxXSArIGNvbnRleHQub2Zmc2V0WSkgKiBjb250ZXh0LnNjYWxlWTtcbiAgY29uc3QgeDMgPSAoY29vcmRzW3AzXSArIGNvbnRleHQub2Zmc2V0WCkgKiBjb250ZXh0LnNjYWxlWDtcbiAgY29uc3QgeTMgPSAoY29vcmRzW3AzICsgMV0gKyBjb250ZXh0Lm9mZnNldFkpICogY29udGV4dC5zY2FsZVk7XG4gIGlmICh5MSA+PSB5Mykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjMXIgPSBjb2xvcnNbYzFdLFxuICAgIGMxZyA9IGNvbG9yc1tjMSArIDFdLFxuICAgIGMxYiA9IGNvbG9yc1tjMSArIDJdO1xuICBjb25zdCBjMnIgPSBjb2xvcnNbYzJdLFxuICAgIGMyZyA9IGNvbG9yc1tjMiArIDFdLFxuICAgIGMyYiA9IGNvbG9yc1tjMiArIDJdO1xuICBjb25zdCBjM3IgPSBjb2xvcnNbYzNdLFxuICAgIGMzZyA9IGNvbG9yc1tjMyArIDFdLFxuICAgIGMzYiA9IGNvbG9yc1tjMyArIDJdO1xuICBjb25zdCBtaW5ZID0gTWF0aC5yb3VuZCh5MSksXG4gICAgbWF4WSA9IE1hdGgucm91bmQoeTMpO1xuICBsZXQgeGEsIGNhciwgY2FnLCBjYWI7XG4gIGxldCB4YiwgY2JyLCBjYmcsIGNiYjtcbiAgZm9yIChsZXQgeSA9IG1pblk7IHkgPD0gbWF4WTsgeSsrKSB7XG4gICAgaWYgKHkgPCB5Mikge1xuICAgICAgY29uc3QgayA9IHkgPCB5MSA/IDAgOiAoeTEgLSB5KSAvICh5MSAtIHkyKTtcbiAgICAgIHhhID0geDEgLSAoeDEgLSB4MikgKiBrO1xuICAgICAgY2FyID0gYzFyIC0gKGMxciAtIGMycikgKiBrO1xuICAgICAgY2FnID0gYzFnIC0gKGMxZyAtIGMyZykgKiBrO1xuICAgICAgY2FiID0gYzFiIC0gKGMxYiAtIGMyYikgKiBrO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgaztcbiAgICAgIGlmICh5ID4geTMpIHtcbiAgICAgICAgayA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHkyID09PSB5Mykge1xuICAgICAgICBrID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGsgPSAoeTIgLSB5KSAvICh5MiAtIHkzKTtcbiAgICAgIH1cbiAgICAgIHhhID0geDIgLSAoeDIgLSB4MykgKiBrO1xuICAgICAgY2FyID0gYzJyIC0gKGMyciAtIGMzcikgKiBrO1xuICAgICAgY2FnID0gYzJnIC0gKGMyZyAtIGMzZykgKiBrO1xuICAgICAgY2FiID0gYzJiIC0gKGMyYiAtIGMzYikgKiBrO1xuICAgIH1cbiAgICBsZXQgaztcbiAgICBpZiAoeSA8IHkxKSB7XG4gICAgICBrID0gMDtcbiAgICB9IGVsc2UgaWYgKHkgPiB5Mykge1xuICAgICAgayA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGsgPSAoeTEgLSB5KSAvICh5MSAtIHkzKTtcbiAgICB9XG4gICAgeGIgPSB4MSAtICh4MSAtIHgzKSAqIGs7XG4gICAgY2JyID0gYzFyIC0gKGMxciAtIGMzcikgKiBrO1xuICAgIGNiZyA9IGMxZyAtIChjMWcgLSBjM2cpICogaztcbiAgICBjYmIgPSBjMWIgLSAoYzFiIC0gYzNiKSAqIGs7XG4gICAgY29uc3QgeDFfID0gTWF0aC5yb3VuZChNYXRoLm1pbih4YSwgeGIpKTtcbiAgICBjb25zdCB4Ml8gPSBNYXRoLnJvdW5kKE1hdGgubWF4KHhhLCB4YikpO1xuICAgIGxldCBqID0gcm93U2l6ZSAqIHkgKyB4MV8gKiA0O1xuICAgIGZvciAobGV0IHggPSB4MV87IHggPD0geDJfOyB4KyspIHtcbiAgICAgIGsgPSAoeGEgLSB4KSAvICh4YSAtIHhiKTtcbiAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICBrID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoayA+IDEpIHtcbiAgICAgICAgayA9IDE7XG4gICAgICB9XG4gICAgICBieXRlc1tqKytdID0gY2FyIC0gKGNhciAtIGNicikgKiBrIHwgMDtcbiAgICAgIGJ5dGVzW2orK10gPSBjYWcgLSAoY2FnIC0gY2JnKSAqIGsgfCAwO1xuICAgICAgYnl0ZXNbaisrXSA9IGNhYiAtIChjYWIgLSBjYmIpICogayB8IDA7XG4gICAgICBieXRlc1tqKytdID0gMjU1O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZHJhd0ZpZ3VyZShkYXRhLCBmaWd1cmUsIGNvbnRleHQpIHtcbiAgY29uc3QgcHMgPSBmaWd1cmUuY29vcmRzO1xuICBjb25zdCBjcyA9IGZpZ3VyZS5jb2xvcnM7XG4gIGxldCBpLCBpaTtcbiAgc3dpdGNoIChmaWd1cmUudHlwZSkge1xuICAgIGNhc2UgXCJsYXR0aWNlXCI6XG4gICAgICBjb25zdCB2ZXJ0aWNlc1BlclJvdyA9IGZpZ3VyZS52ZXJ0aWNlc1BlclJvdztcbiAgICAgIGNvbnN0IHJvd3MgPSBNYXRoLmZsb29yKHBzLmxlbmd0aCAvIHZlcnRpY2VzUGVyUm93KSAtIDE7XG4gICAgICBjb25zdCBjb2xzID0gdmVydGljZXNQZXJSb3cgLSAxO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICBsZXQgcSA9IGkgKiB2ZXJ0aWNlc1BlclJvdztcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xzOyBqKyssIHErKykge1xuICAgICAgICAgIGRyYXdUcmlhbmdsZShkYXRhLCBjb250ZXh0LCBwc1txXSwgcHNbcSArIDFdLCBwc1txICsgdmVydGljZXNQZXJSb3ddLCBjc1txXSwgY3NbcSArIDFdLCBjc1txICsgdmVydGljZXNQZXJSb3ddKTtcbiAgICAgICAgICBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcHNbcSArIHZlcnRpY2VzUGVyUm93ICsgMV0sIHBzW3EgKyAxXSwgcHNbcSArIHZlcnRpY2VzUGVyUm93XSwgY3NbcSArIHZlcnRpY2VzUGVyUm93ICsgMV0sIGNzW3EgKyAxXSwgY3NbcSArIHZlcnRpY2VzUGVyUm93XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0cmlhbmdsZXNcIjpcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gcHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMykge1xuICAgICAgICBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcHNbaV0sIHBzW2kgKyAxXSwgcHNbaSArIDJdLCBjc1tpXSwgY3NbaSArIDFdLCBjc1tpICsgMl0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgZmlndXJlXCIpO1xuICB9XG59XG5jbGFzcyBNZXNoU2hhZGluZ1BhdHRlcm4gZXh0ZW5kcyBCYXNlU2hhZGluZ1BhdHRlcm4ge1xuICBjb25zdHJ1Y3RvcihJUikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fY29vcmRzID0gSVJbMl07XG4gICAgdGhpcy5fY29sb3JzID0gSVJbM107XG4gICAgdGhpcy5fZmlndXJlcyA9IElSWzRdO1xuICAgIHRoaXMuX2JvdW5kcyA9IElSWzVdO1xuICAgIHRoaXMuX2Jib3ggPSBJUls2XTtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kID0gSVJbN107XG4gICAgdGhpcy5tYXRyaXggPSBudWxsO1xuICB9XG4gIF9jcmVhdGVNZXNoQ2FudmFzKGNvbWJpbmVkU2NhbGUsIGJhY2tncm91bmRDb2xvciwgY2FjaGVkQ2FudmFzZXMpIHtcbiAgICBjb25zdCBFWFBFQ1RFRF9TQ0FMRSA9IDEuMTtcbiAgICBjb25zdCBNQVhfUEFUVEVSTl9TSVpFID0gMzAwMDtcbiAgICBjb25zdCBCT1JERVJfU0laRSA9IDI7XG4gICAgY29uc3Qgb2Zmc2V0WCA9IE1hdGguZmxvb3IodGhpcy5fYm91bmRzWzBdKTtcbiAgICBjb25zdCBvZmZzZXRZID0gTWF0aC5mbG9vcih0aGlzLl9ib3VuZHNbMV0pO1xuICAgIGNvbnN0IGJvdW5kc1dpZHRoID0gTWF0aC5jZWlsKHRoaXMuX2JvdW5kc1syXSkgLSBvZmZzZXRYO1xuICAgIGNvbnN0IGJvdW5kc0hlaWdodCA9IE1hdGguY2VpbCh0aGlzLl9ib3VuZHNbM10pIC0gb2Zmc2V0WTtcbiAgICBjb25zdCB3aWR0aCA9IE1hdGgubWluKE1hdGguY2VpbChNYXRoLmFicyhib3VuZHNXaWR0aCAqIGNvbWJpbmVkU2NhbGVbMF0gKiBFWFBFQ1RFRF9TQ0FMRSkpLCBNQVhfUEFUVEVSTl9TSVpFKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1pbihNYXRoLmNlaWwoTWF0aC5hYnMoYm91bmRzSGVpZ2h0ICogY29tYmluZWRTY2FsZVsxXSAqIEVYUEVDVEVEX1NDQUxFKSksIE1BWF9QQVRURVJOX1NJWkUpO1xuICAgIGNvbnN0IHNjYWxlWCA9IGJvdW5kc1dpZHRoIC8gd2lkdGg7XG4gICAgY29uc3Qgc2NhbGVZID0gYm91bmRzSGVpZ2h0IC8gaGVpZ2h0O1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBjb29yZHM6IHRoaXMuX2Nvb3JkcyxcbiAgICAgIGNvbG9yczogdGhpcy5fY29sb3JzLFxuICAgICAgb2Zmc2V0WDogLW9mZnNldFgsXG4gICAgICBvZmZzZXRZOiAtb2Zmc2V0WSxcbiAgICAgIHNjYWxlWDogMSAvIHNjYWxlWCxcbiAgICAgIHNjYWxlWTogMSAvIHNjYWxlWVxuICAgIH07XG4gICAgY29uc3QgcGFkZGVkV2lkdGggPSB3aWR0aCArIEJPUkRFUl9TSVpFICogMjtcbiAgICBjb25zdCBwYWRkZWRIZWlnaHQgPSBoZWlnaHQgKyBCT1JERVJfU0laRSAqIDI7XG4gICAgY29uc3QgdG1wQ2FudmFzID0gY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwibWVzaFwiLCBwYWRkZWRXaWR0aCwgcGFkZGVkSGVpZ2h0KTtcbiAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICBjb25zdCBkYXRhID0gdG1wQ3R4LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBjb25zdCBieXRlcyA9IGRhdGEuZGF0YTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGJ5dGVzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDQpIHtcbiAgICAgICAgYnl0ZXNbaV0gPSBiYWNrZ3JvdW5kQ29sb3JbMF07XG4gICAgICAgIGJ5dGVzW2kgKyAxXSA9IGJhY2tncm91bmRDb2xvclsxXTtcbiAgICAgICAgYnl0ZXNbaSArIDJdID0gYmFja2dyb3VuZENvbG9yWzJdO1xuICAgICAgICBieXRlc1tpICsgM10gPSAyNTU7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgZmlndXJlIG9mIHRoaXMuX2ZpZ3VyZXMpIHtcbiAgICAgIGRyYXdGaWd1cmUoZGF0YSwgZmlndXJlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgdG1wQ3R4LnB1dEltYWdlRGF0YShkYXRhLCBCT1JERVJfU0laRSwgQk9SREVSX1NJWkUpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRtcENhbnZhcy5jYW52YXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhcyxcbiAgICAgIG9mZnNldFg6IG9mZnNldFggLSBCT1JERVJfU0laRSAqIHNjYWxlWCxcbiAgICAgIG9mZnNldFk6IG9mZnNldFkgLSBCT1JERVJfU0laRSAqIHNjYWxlWSxcbiAgICAgIHNjYWxlWCxcbiAgICAgIHNjYWxlWVxuICAgIH07XG4gIH1cbiAgaXNNb2RpZnlpbmdDdXJyZW50VHJhbnNmb3JtKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldFBhdHRlcm4oY3R4LCBvd25lciwgaW52ZXJzZSwgcGF0aFR5cGUpIHtcbiAgICBhcHBseUJvdW5kaW5nQm94KGN0eCwgdGhpcy5fYmJveCk7XG4gICAgY29uc3Qgc2NhbGUgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuICAgIGlmIChwYXRoVHlwZSA9PT0gUGF0aFR5cGUuU0hBRElORykge1xuICAgICAgVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCksIHNjYWxlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0cml4KSB7XG4gICAgICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRoaXMubWF0cml4LCBzY2FsZSk7XG4gICAgICBjb25zdCBbbWF0cml4U2NhbGVYLCBtYXRyaXhTY2FsZVldID0gc2NhbGU7XG4gICAgICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKG93bmVyLmJhc2VUcmFuc2Zvcm0sIHNjYWxlKTtcbiAgICAgIHNjYWxlWzBdICo9IG1hdHJpeFNjYWxlWDtcbiAgICAgIHNjYWxlWzFdICo9IG1hdHJpeFNjYWxlWTtcbiAgICB9IGVsc2Uge1xuICAgICAgVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShvd25lci5iYXNlVHJhbnNmb3JtLCBzY2FsZSk7XG4gICAgfVxuICAgIGNvbnN0IHRlbXBvcmFyeVBhdHRlcm5DYW52YXMgPSB0aGlzLl9jcmVhdGVNZXNoQ2FudmFzKHNjYWxlLCBwYXRoVHlwZSA9PT0gUGF0aFR5cGUuU0hBRElORyA/IG51bGwgOiB0aGlzLl9iYWNrZ3JvdW5kLCBvd25lci5jYWNoZWRDYW52YXNlcyk7XG4gICAgaWYgKHBhdGhUeXBlICE9PSBQYXRoVHlwZS5TSEFESU5HKSB7XG4gICAgICBjdHguc2V0VHJhbnNmb3JtKC4uLm93bmVyLmJhc2VUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRoaXMubWF0cml4KSB7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0oLi4udGhpcy5tYXRyaXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHgudHJhbnNsYXRlKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMub2Zmc2V0WCwgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5vZmZzZXRZKTtcbiAgICBjdHguc2NhbGUodGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5zY2FsZVgsIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuc2NhbGVZKTtcbiAgICByZXR1cm4gY3R4LmNyZWF0ZVBhdHRlcm4odGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5jYW52YXMsIFwibm8tcmVwZWF0XCIpO1xuICB9XG59XG5jbGFzcyBEdW1teVNoYWRpbmdQYXR0ZXJuIGV4dGVuZHMgQmFzZVNoYWRpbmdQYXR0ZXJuIHtcbiAgZ2V0UGF0dGVybigpIHtcbiAgICByZXR1cm4gXCJob3RwaW5rXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFNoYWRpbmdQYXR0ZXJuKElSKSB7XG4gIHN3aXRjaCAoSVJbMF0pIHtcbiAgICBjYXNlIFwiUmFkaWFsQXhpYWxcIjpcbiAgICAgIHJldHVybiBuZXcgUmFkaWFsQXhpYWxTaGFkaW5nUGF0dGVybihJUik7XG4gICAgY2FzZSBcIk1lc2hcIjpcbiAgICAgIHJldHVybiBuZXcgTWVzaFNoYWRpbmdQYXR0ZXJuKElSKTtcbiAgICBjYXNlIFwiRHVtbXlcIjpcbiAgICAgIHJldHVybiBuZXcgRHVtbXlTaGFkaW5nUGF0dGVybigpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBJUiB0eXBlOiAke0lSWzBdfWApO1xufVxuY29uc3QgUGFpbnRUeXBlID0ge1xuICBDT0xPUkVEOiAxLFxuICBVTkNPTE9SRUQ6IDJcbn07XG5jbGFzcyBUaWxpbmdQYXR0ZXJuIHtcbiAgc3RhdGljIE1BWF9QQVRURVJOX1NJWkUgPSAzMDAwO1xuICBjb25zdHJ1Y3RvcihJUiwgY3R4LCBjYW52YXNHcmFwaGljc0ZhY3RvcnksIGJhc2VUcmFuc2Zvcm0pIHtcbiAgICB0aGlzLmNvbG9yID0gSVJbMV07XG4gICAgdGhpcy5vcGVyYXRvckxpc3QgPSBJUlsyXTtcbiAgICB0aGlzLm1hdHJpeCA9IElSWzNdO1xuICAgIHRoaXMuYmJveCA9IElSWzRdO1xuICAgIHRoaXMueHN0ZXAgPSBJUls1XTtcbiAgICB0aGlzLnlzdGVwID0gSVJbNl07XG4gICAgdGhpcy5wYWludFR5cGUgPSBJUls3XTtcbiAgICB0aGlzLnRpbGluZ1R5cGUgPSBJUls4XTtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmNhbnZhc0dyYXBoaWNzRmFjdG9yeSA9IGNhbnZhc0dyYXBoaWNzRmFjdG9yeTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSBiYXNlVHJhbnNmb3JtO1xuICB9XG4gIGNyZWF0ZVBhdHRlcm5DYW52YXMob3duZXIpIHtcbiAgICBjb25zdCB7XG4gICAgICBiYm94LFxuICAgICAgb3BlcmF0b3JMaXN0LFxuICAgICAgcGFpbnRUeXBlLFxuICAgICAgdGlsaW5nVHlwZSxcbiAgICAgIGNvbG9yLFxuICAgICAgY2FudmFzR3JhcGhpY3NGYWN0b3J5XG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHtcbiAgICAgIHhzdGVwLFxuICAgICAgeXN0ZXBcbiAgICB9ID0gdGhpcztcbiAgICB4c3RlcCA9IE1hdGguYWJzKHhzdGVwKTtcbiAgICB5c3RlcCA9IE1hdGguYWJzKHlzdGVwKTtcbiAgICBpbmZvKFwiVGlsaW5nVHlwZTogXCIgKyB0aWxpbmdUeXBlKTtcbiAgICBjb25zdCB4MCA9IGJib3hbMF0sXG4gICAgICB5MCA9IGJib3hbMV0sXG4gICAgICB4MSA9IGJib3hbMl0sXG4gICAgICB5MSA9IGJib3hbM107XG4gICAgY29uc3Qgd2lkdGggPSB4MSAtIHgwO1xuICAgIGNvbnN0IGhlaWdodCA9IHkxIC0geTA7XG4gICAgY29uc3Qgc2NhbGUgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuICAgIFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodGhpcy5tYXRyaXgsIHNjYWxlKTtcbiAgICBjb25zdCBbbWF0cml4U2NhbGVYLCBtYXRyaXhTY2FsZVldID0gc2NhbGU7XG4gICAgVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSh0aGlzLmJhc2VUcmFuc2Zvcm0sIHNjYWxlKTtcbiAgICBjb25zdCBjb21iaW5lZFNjYWxlWCA9IG1hdHJpeFNjYWxlWCAqIHNjYWxlWzBdO1xuICAgIGNvbnN0IGNvbWJpbmVkU2NhbGVZID0gbWF0cml4U2NhbGVZICogc2NhbGVbMV07XG4gICAgbGV0IGNhbnZhc1dpZHRoID0gd2lkdGgsXG4gICAgICBjYW52YXNIZWlnaHQgPSBoZWlnaHQsXG4gICAgICByZWRyYXdIb3Jpem9udGFsbHkgPSBmYWxzZSxcbiAgICAgIHJlZHJhd1ZlcnRpY2FsbHkgPSBmYWxzZTtcbiAgICBjb25zdCB4U2NhbGVkU3RlcCA9IE1hdGguY2VpbCh4c3RlcCAqIGNvbWJpbmVkU2NhbGVYKTtcbiAgICBjb25zdCB5U2NhbGVkU3RlcCA9IE1hdGguY2VpbCh5c3RlcCAqIGNvbWJpbmVkU2NhbGVZKTtcbiAgICBjb25zdCB4U2NhbGVkV2lkdGggPSBNYXRoLmNlaWwod2lkdGggKiBjb21iaW5lZFNjYWxlWCk7XG4gICAgY29uc3QgeVNjYWxlZEhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgKiBjb21iaW5lZFNjYWxlWSk7XG4gICAgaWYgKHhTY2FsZWRTdGVwID49IHhTY2FsZWRXaWR0aCkge1xuICAgICAgY2FudmFzV2lkdGggPSB4c3RlcDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVkcmF3SG9yaXpvbnRhbGx5ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHlTY2FsZWRTdGVwID49IHlTY2FsZWRIZWlnaHQpIHtcbiAgICAgIGNhbnZhc0hlaWdodCA9IHlzdGVwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWRyYXdWZXJ0aWNhbGx5ID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgZGlteCA9IHRoaXMuZ2V0U2l6ZUFuZFNjYWxlKGNhbnZhc1dpZHRoLCB0aGlzLmN0eC5jYW52YXMud2lkdGgsIGNvbWJpbmVkU2NhbGVYKTtcbiAgICBjb25zdCBkaW15ID0gdGhpcy5nZXRTaXplQW5kU2NhbGUoY2FudmFzSGVpZ2h0LCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0LCBjb21iaW5lZFNjYWxlWSk7XG4gICAgY29uc3QgdG1wQ2FudmFzID0gb3duZXIuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwicGF0dGVyblwiLCBkaW14LnNpemUsIGRpbXkuc2l6ZSk7XG4gICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgY29uc3QgZ3JhcGhpY3MgPSBjYW52YXNHcmFwaGljc0ZhY3RvcnkuY3JlYXRlQ2FudmFzR3JhcGhpY3ModG1wQ3R4KTtcbiAgICBncmFwaGljcy5ncm91cExldmVsID0gb3duZXIuZ3JvdXBMZXZlbDtcbiAgICB0aGlzLnNldEZpbGxBbmRTdHJva2VTdHlsZVRvQ29udGV4dChncmFwaGljcywgcGFpbnRUeXBlLCBjb2xvcik7XG4gICAgdG1wQ3R4LnRyYW5zbGF0ZSgtZGlteC5zY2FsZSAqIHgwLCAtZGlteS5zY2FsZSAqIHkwKTtcbiAgICBncmFwaGljcy50cmFuc2Zvcm0oZGlteC5zY2FsZSwgMCwgMCwgZGlteS5zY2FsZSwgMCwgMCk7XG4gICAgdG1wQ3R4LnNhdmUoKTtcbiAgICB0aGlzLmNsaXBCYm94KGdyYXBoaWNzLCB4MCwgeTAsIHgxLCB5MSk7XG4gICAgZ3JhcGhpY3MuYmFzZVRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0oZ3JhcGhpY3MuY3R4KTtcbiAgICBncmFwaGljcy5leGVjdXRlT3BlcmF0b3JMaXN0KG9wZXJhdG9yTGlzdCk7XG4gICAgZ3JhcGhpY3MuZW5kRHJhd2luZygpO1xuICAgIHRtcEN0eC5yZXN0b3JlKCk7XG4gICAgaWYgKHJlZHJhd0hvcml6b250YWxseSB8fCByZWRyYXdWZXJ0aWNhbGx5KSB7XG4gICAgICBjb25zdCBpbWFnZSA9IHRtcENhbnZhcy5jYW52YXM7XG4gICAgICBpZiAocmVkcmF3SG9yaXpvbnRhbGx5KSB7XG4gICAgICAgIGNhbnZhc1dpZHRoID0geHN0ZXA7XG4gICAgICB9XG4gICAgICBpZiAocmVkcmF3VmVydGljYWxseSkge1xuICAgICAgICBjYW52YXNIZWlnaHQgPSB5c3RlcDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpbXgyID0gdGhpcy5nZXRTaXplQW5kU2NhbGUoY2FudmFzV2lkdGgsIHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgY29tYmluZWRTY2FsZVgpO1xuICAgICAgY29uc3QgZGlteTIgPSB0aGlzLmdldFNpemVBbmRTY2FsZShjYW52YXNIZWlnaHQsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQsIGNvbWJpbmVkU2NhbGVZKTtcbiAgICAgIGNvbnN0IHhTaXplID0gZGlteDIuc2l6ZTtcbiAgICAgIGNvbnN0IHlTaXplID0gZGlteTIuc2l6ZTtcbiAgICAgIGNvbnN0IHRtcENhbnZhczIgPSBvd25lci5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJwYXR0ZXJuLXdvcmthcm91bmRcIiwgeFNpemUsIHlTaXplKTtcbiAgICAgIGNvbnN0IHRtcEN0eDIgPSB0bXBDYW52YXMyLmNvbnRleHQ7XG4gICAgICBjb25zdCBpaSA9IHJlZHJhd0hvcml6b250YWxseSA/IE1hdGguZmxvb3Iod2lkdGggLyB4c3RlcCkgOiAwO1xuICAgICAgY29uc3QgamogPSByZWRyYXdWZXJ0aWNhbGx5ID8gTWF0aC5mbG9vcihoZWlnaHQgLyB5c3RlcCkgOiAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gaWk7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8PSBqajsgaisrKSB7XG4gICAgICAgICAgdG1wQ3R4Mi5kcmF3SW1hZ2UoaW1hZ2UsIHhTaXplICogaSwgeVNpemUgKiBqLCB4U2l6ZSwgeVNpemUsIDAsIDAsIHhTaXplLCB5U2l6ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbnZhczogdG1wQ2FudmFzMi5jYW52YXMsXG4gICAgICAgIHNjYWxlWDogZGlteDIuc2NhbGUsXG4gICAgICAgIHNjYWxlWTogZGlteTIuc2NhbGUsXG4gICAgICAgIG9mZnNldFg6IHgwLFxuICAgICAgICBvZmZzZXRZOiB5MFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhczogdG1wQ2FudmFzLmNhbnZhcyxcbiAgICAgIHNjYWxlWDogZGlteC5zY2FsZSxcbiAgICAgIHNjYWxlWTogZGlteS5zY2FsZSxcbiAgICAgIG9mZnNldFg6IHgwLFxuICAgICAgb2Zmc2V0WTogeTBcbiAgICB9O1xuICB9XG4gIGdldFNpemVBbmRTY2FsZShzdGVwLCByZWFsT3V0cHV0U2l6ZSwgc2NhbGUpIHtcbiAgICBjb25zdCBtYXhTaXplID0gTWF0aC5tYXgoVGlsaW5nUGF0dGVybi5NQVhfUEFUVEVSTl9TSVpFLCByZWFsT3V0cHV0U2l6ZSk7XG4gICAgbGV0IHNpemUgPSBNYXRoLmNlaWwoc3RlcCAqIHNjYWxlKTtcbiAgICBpZiAoc2l6ZSA+PSBtYXhTaXplKSB7XG4gICAgICBzaXplID0gbWF4U2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUgPSBzaXplIC8gc3RlcDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjYWxlLFxuICAgICAgc2l6ZVxuICAgIH07XG4gIH1cbiAgY2xpcEJib3goZ3JhcGhpY3MsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgY29uc3QgYmJveFdpZHRoID0geDEgLSB4MDtcbiAgICBjb25zdCBiYm94SGVpZ2h0ID0geTEgLSB5MDtcbiAgICBncmFwaGljcy5jdHgucmVjdCh4MCwgeTAsIGJib3hXaWR0aCwgYmJveEhlaWdodCk7XG4gICAgVXRpbC5heGlhbEFsaWduZWRCb3VuZGluZ0JveChbeDAsIHkwLCB4MSwgeTFdLCBnZXRDdXJyZW50VHJhbnNmb3JtKGdyYXBoaWNzLmN0eCksIGdyYXBoaWNzLmN1cnJlbnQubWluTWF4KTtcbiAgICBncmFwaGljcy5jbGlwKCk7XG4gICAgZ3JhcGhpY3MuZW5kUGF0aCgpO1xuICB9XG4gIHNldEZpbGxBbmRTdHJva2VTdHlsZVRvQ29udGV4dChncmFwaGljcywgcGFpbnRUeXBlLCBjb2xvcikge1xuICAgIGNvbnN0IGNvbnRleHQgPSBncmFwaGljcy5jdHgsXG4gICAgICBjdXJyZW50ID0gZ3JhcGhpY3MuY3VycmVudDtcbiAgICBzd2l0Y2ggKHBhaW50VHlwZSkge1xuICAgICAgY2FzZSBQYWludFR5cGUuQ09MT1JFRDpcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY3R4LmZpbGxTdHlsZTtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGN0eC5zdHJva2VTdHlsZTtcbiAgICAgICAgY3VycmVudC5maWxsQ29sb3IgPSBjdHguZmlsbFN0eWxlO1xuICAgICAgICBjdXJyZW50LnN0cm9rZUNvbG9yID0gY3R4LnN0cm9rZVN0eWxlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUGFpbnRUeXBlLlVOQ09MT1JFRDpcbiAgICAgICAgY29uc3QgY3NzQ29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvcihjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdKTtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBjc3NDb2xvcjtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNzc0NvbG9yO1xuICAgICAgICBjdXJyZW50LmZpbGxDb2xvciA9IGNzc0NvbG9yO1xuICAgICAgICBjdXJyZW50LnN0cm9rZUNvbG9yID0gY3NzQ29sb3I7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBVbnN1cHBvcnRlZCBwYWludCB0eXBlOiAke3BhaW50VHlwZX1gKTtcbiAgICB9XG4gIH1cbiAgaXNNb2RpZnlpbmdDdXJyZW50VHJhbnNmb3JtKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXRQYXR0ZXJuKGN0eCwgb3duZXIsIGludmVyc2UsIHBhdGhUeXBlKSB7XG4gICAgbGV0IG1hdHJpeCA9IGludmVyc2U7XG4gICAgaWYgKHBhdGhUeXBlICE9PSBQYXRoVHlwZS5TSEFESU5HKSB7XG4gICAgICBtYXRyaXggPSBVdGlsLnRyYW5zZm9ybShtYXRyaXgsIG93bmVyLmJhc2VUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRoaXMubWF0cml4KSB7XG4gICAgICAgIG1hdHJpeCA9IFV0aWwudHJhbnNmb3JtKG1hdHJpeCwgdGhpcy5tYXRyaXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzID0gdGhpcy5jcmVhdGVQYXR0ZXJuQ2FudmFzKG93bmVyKTtcbiAgICBsZXQgZG9tTWF0cml4ID0gbmV3IERPTU1hdHJpeChtYXRyaXgpO1xuICAgIGRvbU1hdHJpeCA9IGRvbU1hdHJpeC50cmFuc2xhdGUodGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5vZmZzZXRYLCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLm9mZnNldFkpO1xuICAgIGRvbU1hdHJpeCA9IGRvbU1hdHJpeC5zY2FsZSgxIC8gdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5zY2FsZVgsIDEgLyB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLnNjYWxlWSk7XG4gICAgY29uc3QgcGF0dGVybiA9IGN0eC5jcmVhdGVQYXR0ZXJuKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuY2FudmFzLCBcInJlcGVhdFwiKTtcbiAgICBwYXR0ZXJuLnNldFRyYW5zZm9ybShkb21NYXRyaXgpO1xuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG59XG5cbjsvLyAuL3NyYy9zaGFyZWQvaW1hZ2VfdXRpbHMuanNcblxuZnVuY3Rpb24gY29udmVydFRvUkdCQShwYXJhbXMpIHtcbiAgc3dpdGNoIChwYXJhbXMua2luZCkge1xuICAgIGNhc2UgSW1hZ2VLaW5kLkdSQVlTQ0FMRV8xQlBQOlxuICAgICAgcmV0dXJuIGNvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBKHBhcmFtcyk7XG4gICAgY2FzZSBJbWFnZUtpbmQuUkdCXzI0QlBQOlxuICAgICAgcmV0dXJuIGNvbnZlcnRSR0JUb1JHQkEocGFyYW1zKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBKHtcbiAgc3JjLFxuICBzcmNQb3MgPSAwLFxuICBkZXN0LFxuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICBub25CbGFja0NvbG9yID0gMHhmZmZmZmZmZixcbiAgaW52ZXJzZURlY29kZSA9IGZhbHNlXG59KSB7XG4gIGNvbnN0IGJsYWNrID0gdXRpbF9GZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbiA/IDB4ZmYwMDAwMDAgOiAweDAwMDAwMGZmO1xuICBjb25zdCBbemVyb01hcHBpbmcsIG9uZU1hcHBpbmddID0gaW52ZXJzZURlY29kZSA/IFtub25CbGFja0NvbG9yLCBibGFja10gOiBbYmxhY2ssIG5vbkJsYWNrQ29sb3JdO1xuICBjb25zdCB3aWR0aEluU291cmNlID0gd2lkdGggPj4gMztcbiAgY29uc3Qgd2lkdGhSZW1haW5kZXIgPSB3aWR0aCAmIDc7XG4gIGNvbnN0IHNyY0xlbmd0aCA9IHNyYy5sZW5ndGg7XG4gIGRlc3QgPSBuZXcgVWludDMyQXJyYXkoZGVzdC5idWZmZXIpO1xuICBsZXQgZGVzdFBvcyA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICBmb3IgKGNvbnN0IG1heCA9IHNyY1BvcyArIHdpZHRoSW5Tb3VyY2U7IHNyY1BvcyA8IG1heDsgc3JjUG9zKyspIHtcbiAgICAgIGNvbnN0IGVsZW0gPSBzcmNQb3MgPCBzcmNMZW5ndGggPyBzcmNbc3JjUG9zXSA6IDI1NTtcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAwMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMDAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMSA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICB9XG4gICAgaWYgKHdpZHRoUmVtYWluZGVyID09PSAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgZWxlbSA9IHNyY1BvcyA8IHNyY0xlbmd0aCA/IHNyY1tzcmNQb3MrK10gOiAyNTU7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aWR0aFJlbWFpbmRlcjsgaisrKSB7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMSA8PCA3IC0gaiA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzcmNQb3MsXG4gICAgZGVzdFBvc1xuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFJHQlRvUkdCQSh7XG4gIHNyYyxcbiAgc3JjUG9zID0gMCxcbiAgZGVzdCxcbiAgZGVzdFBvcyA9IDAsXG4gIHdpZHRoLFxuICBoZWlnaHRcbn0pIHtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCBsZW4gPSB3aWR0aCAqIGhlaWdodCAqIDM7XG4gIGNvbnN0IGxlbjMyID0gbGVuID4+IDI7XG4gIGNvbnN0IHNyYzMyID0gbmV3IFVpbnQzMkFycmF5KHNyYy5idWZmZXIsIHNyY1BvcywgbGVuMzIpO1xuICBpZiAoRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4pIHtcbiAgICBmb3IgKDsgaSA8IGxlbjMyIC0gMjsgaSArPSAzLCBkZXN0UG9zICs9IDQpIHtcbiAgICAgIGNvbnN0IHMxID0gc3JjMzJbaV07XG4gICAgICBjb25zdCBzMiA9IHNyYzMyW2kgKyAxXTtcbiAgICAgIGNvbnN0IHMzID0gc3JjMzJbaSArIDJdO1xuICAgICAgZGVzdFtkZXN0UG9zXSA9IHMxIHwgMHhmZjAwMDAwMDtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDFdID0gczEgPj4+IDI0IHwgczIgPDwgOCB8IDB4ZmYwMDAwMDA7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAyXSA9IHMyID4+PiAxNiB8IHMzIDw8IDE2IHwgMHhmZjAwMDAwMDtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDNdID0gczMgPj4+IDggfCAweGZmMDAwMDAwO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gaSAqIDQsIGpqID0gc3JjUG9zICsgbGVuOyBqIDwgamo7IGogKz0gMykge1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW2pdIHwgc3JjW2ogKyAxXSA8PCA4IHwgc3JjW2ogKyAyXSA8PCAxNiB8IDB4ZmYwMDAwMDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoOyBpIDwgbGVuMzIgLSAyOyBpICs9IDMsIGRlc3RQb3MgKz0gNCkge1xuICAgICAgY29uc3QgczEgPSBzcmMzMltpXTtcbiAgICAgIGNvbnN0IHMyID0gc3JjMzJbaSArIDFdO1xuICAgICAgY29uc3QgczMgPSBzcmMzMltpICsgMl07XG4gICAgICBkZXN0W2Rlc3RQb3NdID0gczEgfCAweGZmO1xuICAgICAgZGVzdFtkZXN0UG9zICsgMV0gPSBzMSA8PCAyNCB8IHMyID4+PiA4IHwgMHhmZjtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDJdID0gczIgPDwgMTYgfCBzMyA+Pj4gMTYgfCAweGZmO1xuICAgICAgZGVzdFtkZXN0UG9zICsgM10gPSBzMyA8PCA4IHwgMHhmZjtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IGkgKiA0LCBqaiA9IHNyY1BvcyArIGxlbjsgaiA8IGpqOyBqICs9IDMpIHtcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tqXSA8PCAyNCB8IHNyY1tqICsgMV0gPDwgMTYgfCBzcmNbaiArIDJdIDw8IDggfCAweGZmO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHNyY1Bvczogc3JjUG9zICsgbGVuLFxuICAgIGRlc3RQb3NcbiAgfTtcbn1cbmZ1bmN0aW9uIGdyYXlUb1JHQkEoc3JjLCBkZXN0KSB7XG4gIGlmIChGZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbikge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNyYy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBkZXN0W2ldID0gc3JjW2ldICogMHgxMDEwMSB8IDB4ZmYwMDAwMDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNyYy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBkZXN0W2ldID0gc3JjW2ldICogMHgxMDEwMTAwIHwgMHgwMDAwMDBmZjtcbiAgICB9XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvY2FudmFzLmpzXG5cblxuXG5cbmNvbnN0IE1JTl9GT05UX1NJWkUgPSAxNjtcbmNvbnN0IE1BWF9GT05UX1NJWkUgPSAxMDA7XG5jb25zdCBFWEVDVVRJT05fVElNRSA9IDE1O1xuY29uc3QgRVhFQ1VUSU9OX1NURVBTID0gMTA7XG5jb25zdCBGVUxMX0NIVU5LX0hFSUdIVCA9IDE2O1xuY29uc3QgU0NBTEVfTUFUUklYID0gbmV3IERPTU1hdHJpeCgpO1xuY29uc3QgWFkgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuY29uc3QgTUlOX01BWF9JTklUID0gbmV3IEZsb2F0MzJBcnJheShbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV0pO1xuZnVuY3Rpb24gbWlycm9yQ29udGV4dE9wZXJhdGlvbnMoY3R4LCBkZXN0Q3R4KSB7XG4gIGlmIChjdHguX3JlbW92ZU1pcnJvcmluZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRleHQgaXMgYWxyZWFkeSBmb3J3YXJkaW5nIG9wZXJhdGlvbnMuXCIpO1xuICB9XG4gIGN0eC5fX29yaWdpbmFsU2F2ZSA9IGN0eC5zYXZlO1xuICBjdHguX19vcmlnaW5hbFJlc3RvcmUgPSBjdHgucmVzdG9yZTtcbiAgY3R4Ll9fb3JpZ2luYWxSb3RhdGUgPSBjdHgucm90YXRlO1xuICBjdHguX19vcmlnaW5hbFNjYWxlID0gY3R4LnNjYWxlO1xuICBjdHguX19vcmlnaW5hbFRyYW5zbGF0ZSA9IGN0eC50cmFuc2xhdGU7XG4gIGN0eC5fX29yaWdpbmFsVHJhbnNmb3JtID0gY3R4LnRyYW5zZm9ybTtcbiAgY3R4Ll9fb3JpZ2luYWxTZXRUcmFuc2Zvcm0gPSBjdHguc2V0VHJhbnNmb3JtO1xuICBjdHguX19vcmlnaW5hbFJlc2V0VHJhbnNmb3JtID0gY3R4LnJlc2V0VHJhbnNmb3JtO1xuICBjdHguX19vcmlnaW5hbENsaXAgPSBjdHguY2xpcDtcbiAgY3R4Ll9fb3JpZ2luYWxNb3ZlVG8gPSBjdHgubW92ZVRvO1xuICBjdHguX19vcmlnaW5hbExpbmVUbyA9IGN0eC5saW5lVG87XG4gIGN0eC5fX29yaWdpbmFsQmV6aWVyQ3VydmVUbyA9IGN0eC5iZXppZXJDdXJ2ZVRvO1xuICBjdHguX19vcmlnaW5hbFJlY3QgPSBjdHgucmVjdDtcbiAgY3R4Ll9fb3JpZ2luYWxDbG9zZVBhdGggPSBjdHguY2xvc2VQYXRoO1xuICBjdHguX19vcmlnaW5hbEJlZ2luUGF0aCA9IGN0eC5iZWdpblBhdGg7XG4gIGN0eC5fcmVtb3ZlTWlycm9yaW5nID0gKCkgPT4ge1xuICAgIGN0eC5zYXZlID0gY3R4Ll9fb3JpZ2luYWxTYXZlO1xuICAgIGN0eC5yZXN0b3JlID0gY3R4Ll9fb3JpZ2luYWxSZXN0b3JlO1xuICAgIGN0eC5yb3RhdGUgPSBjdHguX19vcmlnaW5hbFJvdGF0ZTtcbiAgICBjdHguc2NhbGUgPSBjdHguX19vcmlnaW5hbFNjYWxlO1xuICAgIGN0eC50cmFuc2xhdGUgPSBjdHguX19vcmlnaW5hbFRyYW5zbGF0ZTtcbiAgICBjdHgudHJhbnNmb3JtID0gY3R4Ll9fb3JpZ2luYWxUcmFuc2Zvcm07XG4gICAgY3R4LnNldFRyYW5zZm9ybSA9IGN0eC5fX29yaWdpbmFsU2V0VHJhbnNmb3JtO1xuICAgIGN0eC5yZXNldFRyYW5zZm9ybSA9IGN0eC5fX29yaWdpbmFsUmVzZXRUcmFuc2Zvcm07XG4gICAgY3R4LmNsaXAgPSBjdHguX19vcmlnaW5hbENsaXA7XG4gICAgY3R4Lm1vdmVUbyA9IGN0eC5fX29yaWdpbmFsTW92ZVRvO1xuICAgIGN0eC5saW5lVG8gPSBjdHguX19vcmlnaW5hbExpbmVUbztcbiAgICBjdHguYmV6aWVyQ3VydmVUbyA9IGN0eC5fX29yaWdpbmFsQmV6aWVyQ3VydmVUbztcbiAgICBjdHgucmVjdCA9IGN0eC5fX29yaWdpbmFsUmVjdDtcbiAgICBjdHguY2xvc2VQYXRoID0gY3R4Ll9fb3JpZ2luYWxDbG9zZVBhdGg7XG4gICAgY3R4LmJlZ2luUGF0aCA9IGN0eC5fX29yaWdpbmFsQmVnaW5QYXRoO1xuICAgIGRlbGV0ZSBjdHguX3JlbW92ZU1pcnJvcmluZztcbiAgfTtcbiAgY3R4LnNhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVzdEN0eC5zYXZlKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsU2F2ZSgpO1xuICB9O1xuICBjdHgucmVzdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBkZXN0Q3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxSZXN0b3JlKCk7XG4gIH07XG4gIGN0eC50cmFuc2xhdGUgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGRlc3RDdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgIHRoaXMuX19vcmlnaW5hbFRyYW5zbGF0ZSh4LCB5KTtcbiAgfTtcbiAgY3R4LnNjYWxlID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBkZXN0Q3R4LnNjYWxlKHgsIHkpO1xuICAgIHRoaXMuX19vcmlnaW5hbFNjYWxlKHgsIHkpO1xuICB9O1xuICBjdHgudHJhbnNmb3JtID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBkZXN0Q3R4LnRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gIH07XG4gIGN0eC5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSwgZikge1xuICAgIGRlc3RDdHguc2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgIHRoaXMuX19vcmlnaW5hbFNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgfTtcbiAgY3R4LnJlc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgIGRlc3RDdHgucmVzZXRUcmFuc2Zvcm0oKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxSZXNldFRyYW5zZm9ybSgpO1xuICB9O1xuICBjdHgucm90YXRlID0gZnVuY3Rpb24gKGFuZ2xlKSB7XG4gICAgZGVzdEN0eC5yb3RhdGUoYW5nbGUpO1xuICAgIHRoaXMuX19vcmlnaW5hbFJvdGF0ZShhbmdsZSk7XG4gIH07XG4gIGN0eC5jbGlwID0gZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICBkZXN0Q3R4LmNsaXAocnVsZSk7XG4gICAgdGhpcy5fX29yaWdpbmFsQ2xpcChydWxlKTtcbiAgfTtcbiAgY3R4Lm1vdmVUbyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgZGVzdEN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgdGhpcy5fX29yaWdpbmFsTW92ZVRvKHgsIHkpO1xuICB9O1xuICBjdHgubGluZVRvID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBkZXN0Q3R4LmxpbmVUbyh4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxMaW5lVG8oeCwgeSk7XG4gIH07XG4gIGN0eC5iZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24gKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpIHtcbiAgICBkZXN0Q3R4LmJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSk7XG4gICAgdGhpcy5fX29yaWdpbmFsQmV6aWVyQ3VydmVUbyhjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KTtcbiAgfTtcbiAgY3R4LnJlY3QgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIGRlc3RDdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICB9O1xuICBjdHguY2xvc2VQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgIGRlc3RDdHguY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsQ2xvc2VQYXRoKCk7XG4gIH07XG4gIGN0eC5iZWdpblBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVzdEN0eC5iZWdpblBhdGgoKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxCZWdpblBhdGgoKTtcbiAgfTtcbn1cbmNsYXNzIENhY2hlZENhbnZhc2VzIHtcbiAgY29uc3RydWN0b3IoY2FudmFzRmFjdG9yeSkge1xuICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGNhbnZhc0ZhY3Rvcnk7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgZ2V0Q2FudmFzKGlkLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgbGV0IGNhbnZhc0VudHJ5O1xuICAgIGlmICh0aGlzLmNhY2hlW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYW52YXNFbnRyeSA9IHRoaXMuY2FjaGVbaWRdO1xuICAgICAgdGhpcy5jYW52YXNGYWN0b3J5LnJlc2V0KGNhbnZhc0VudHJ5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FudmFzRW50cnkgPSB0aGlzLmNhbnZhc0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5jYWNoZVtpZF0gPSBjYW52YXNFbnRyeTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbnZhc0VudHJ5O1xuICB9XG4gIGRlbGV0ZShpZCkge1xuICAgIGRlbGV0ZSB0aGlzLmNhY2hlW2lkXTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBmb3IgKGNvbnN0IGlkIGluIHRoaXMuY2FjaGUpIHtcbiAgICAgIGNvbnN0IGNhbnZhc0VudHJ5ID0gdGhpcy5jYWNoZVtpZF07XG4gICAgICB0aGlzLmNhbnZhc0ZhY3RvcnkuZGVzdHJveShjYW52YXNFbnRyeSk7XG4gICAgICBkZWxldGUgdGhpcy5jYWNoZVtpZF07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoY3R4LCBzcmNJbWcsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIGRlc3RYLCBkZXN0WSwgZGVzdFcsIGRlc3RIKSB7XG4gIGNvbnN0IFthLCBiLCBjLCBkLCB0eCwgdHldID0gZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpO1xuICBpZiAoYiA9PT0gMCAmJiBjID09PSAwKSB7XG4gICAgY29uc3QgdGxYID0gZGVzdFggKiBhICsgdHg7XG4gICAgY29uc3QgclRsWCA9IE1hdGgucm91bmQodGxYKTtcbiAgICBjb25zdCB0bFkgPSBkZXN0WSAqIGQgKyB0eTtcbiAgICBjb25zdCByVGxZID0gTWF0aC5yb3VuZCh0bFkpO1xuICAgIGNvbnN0IGJyWCA9IChkZXN0WCArIGRlc3RXKSAqIGEgKyB0eDtcbiAgICBjb25zdCByV2lkdGggPSBNYXRoLmFicyhNYXRoLnJvdW5kKGJyWCkgLSByVGxYKSB8fCAxO1xuICAgIGNvbnN0IGJyWSA9IChkZXN0WSArIGRlc3RIKSAqIGQgKyB0eTtcbiAgICBjb25zdCBySGVpZ2h0ID0gTWF0aC5hYnMoTWF0aC5yb3VuZChiclkpIC0gclRsWSkgfHwgMTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKE1hdGguc2lnbihhKSwgMCwgMCwgTWF0aC5zaWduKGQpLCByVGxYLCByVGxZKTtcbiAgICBjdHguZHJhd0ltYWdlKHNyY0ltZywgc3JjWCwgc3JjWSwgc3JjVywgc3JjSCwgMCwgMCwgcldpZHRoLCBySGVpZ2h0KTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIHR4LCB0eSk7XG4gICAgcmV0dXJuIFtyV2lkdGgsIHJIZWlnaHRdO1xuICB9XG4gIGlmIChhID09PSAwICYmIGQgPT09IDApIHtcbiAgICBjb25zdCB0bFggPSBkZXN0WSAqIGMgKyB0eDtcbiAgICBjb25zdCByVGxYID0gTWF0aC5yb3VuZCh0bFgpO1xuICAgIGNvbnN0IHRsWSA9IGRlc3RYICogYiArIHR5O1xuICAgIGNvbnN0IHJUbFkgPSBNYXRoLnJvdW5kKHRsWSk7XG4gICAgY29uc3QgYnJYID0gKGRlc3RZICsgZGVzdEgpICogYyArIHR4O1xuICAgIGNvbnN0IHJXaWR0aCA9IE1hdGguYWJzKE1hdGgucm91bmQoYnJYKSAtIHJUbFgpIHx8IDE7XG4gICAgY29uc3QgYnJZID0gKGRlc3RYICsgZGVzdFcpICogYiArIHR5O1xuICAgIGNvbnN0IHJIZWlnaHQgPSBNYXRoLmFicyhNYXRoLnJvdW5kKGJyWSkgLSByVGxZKSB8fCAxO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMCwgTWF0aC5zaWduKGIpLCBNYXRoLnNpZ24oYyksIDAsIHJUbFgsIHJUbFkpO1xuICAgIGN0eC5kcmF3SW1hZ2Uoc3JjSW1nLCBzcmNYLCBzcmNZLCBzcmNXLCBzcmNILCAwLCAwLCBySGVpZ2h0LCByV2lkdGgpO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgdHgsIHR5KTtcbiAgICByZXR1cm4gW3JIZWlnaHQsIHJXaWR0aF07XG4gIH1cbiAgY3R4LmRyYXdJbWFnZShzcmNJbWcsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIGRlc3RYLCBkZXN0WSwgZGVzdFcsIGRlc3RIKTtcbiAgY29uc3Qgc2NhbGVYID0gTWF0aC5oeXBvdChhLCBiKTtcbiAgY29uc3Qgc2NhbGVZID0gTWF0aC5oeXBvdChjLCBkKTtcbiAgcmV0dXJuIFtzY2FsZVggKiBkZXN0Vywgc2NhbGVZICogZGVzdEhdO1xufVxuY2xhc3MgQ2FudmFzRXh0cmFTdGF0ZSB7XG4gIGFscGhhSXNTaGFwZSA9IGZhbHNlO1xuICBmb250U2l6ZSA9IDA7XG4gIGZvbnRTaXplU2NhbGUgPSAxO1xuICB0ZXh0TWF0cml4ID0gbnVsbDtcbiAgdGV4dE1hdHJpeFNjYWxlID0gMTtcbiAgZm9udE1hdHJpeCA9IEZPTlRfSURFTlRJVFlfTUFUUklYO1xuICBsZWFkaW5nID0gMDtcbiAgeCA9IDA7XG4gIHkgPSAwO1xuICBsaW5lWCA9IDA7XG4gIGxpbmVZID0gMDtcbiAgY2hhclNwYWNpbmcgPSAwO1xuICB3b3JkU3BhY2luZyA9IDA7XG4gIHRleHRIU2NhbGUgPSAxO1xuICB0ZXh0UmVuZGVyaW5nTW9kZSA9IFRleHRSZW5kZXJpbmdNb2RlLkZJTEw7XG4gIHRleHRSaXNlID0gMDtcbiAgZmlsbENvbG9yID0gXCIjMDAwMDAwXCI7XG4gIHN0cm9rZUNvbG9yID0gXCIjMDAwMDAwXCI7XG4gIHBhdHRlcm5GaWxsID0gZmFsc2U7XG4gIHBhdHRlcm5TdHJva2UgPSBmYWxzZTtcbiAgZmlsbEFscGhhID0gMTtcbiAgc3Ryb2tlQWxwaGEgPSAxO1xuICBsaW5lV2lkdGggPSAxO1xuICBhY3RpdmVTTWFzayA9IG51bGw7XG4gIHRyYW5zZmVyTWFwcyA9IFwibm9uZVwiO1xuICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5jbGlwQm94ID0gbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgd2lkdGgsIGhlaWdodF0pO1xuICAgIHRoaXMubWluTWF4ID0gTUlOX01BWF9JTklULnNsaWNlKCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBPYmplY3QuY3JlYXRlKHRoaXMpO1xuICAgIGNsb25lLmNsaXBCb3ggPSB0aGlzLmNsaXBCb3guc2xpY2UoKTtcbiAgICBjbG9uZS5taW5NYXggPSB0aGlzLm1pbk1heC5zbGljZSgpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuICBnZXRQYXRoQm91bmRpbmdCb3gocGF0aFR5cGUgPSBQYXRoVHlwZS5GSUxMLCB0cmFuc2Zvcm0gPSBudWxsKSB7XG4gICAgY29uc3QgYm94ID0gdGhpcy5taW5NYXguc2xpY2UoKTtcbiAgICBpZiAocGF0aFR5cGUgPT09IFBhdGhUeXBlLlNUUk9LRSkge1xuICAgICAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICAgICAgdW5yZWFjaGFibGUoXCJTdHJva2UgYm91bmRpbmcgYm94IG11c3QgaW5jbHVkZSB0cmFuc2Zvcm0uXCIpO1xuICAgICAgfVxuICAgICAgVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSh0cmFuc2Zvcm0sIFhZKTtcbiAgICAgIGNvbnN0IHhTdHJva2VQYWQgPSBYWVswXSAqIHRoaXMubGluZVdpZHRoIC8gMjtcbiAgICAgIGNvbnN0IHlTdHJva2VQYWQgPSBYWVsxXSAqIHRoaXMubGluZVdpZHRoIC8gMjtcbiAgICAgIGJveFswXSAtPSB4U3Ryb2tlUGFkO1xuICAgICAgYm94WzFdIC09IHlTdHJva2VQYWQ7XG4gICAgICBib3hbMl0gKz0geFN0cm9rZVBhZDtcbiAgICAgIGJveFszXSArPSB5U3Ryb2tlUGFkO1xuICAgIH1cbiAgICByZXR1cm4gYm94O1xuICB9XG4gIHVwZGF0ZUNsaXBGcm9tUGF0aCgpIHtcbiAgICBjb25zdCBpbnRlcnNlY3QgPSBVdGlsLmludGVyc2VjdCh0aGlzLmNsaXBCb3gsIHRoaXMuZ2V0UGF0aEJvdW5kaW5nQm94KCkpO1xuICAgIHRoaXMuc3RhcnROZXdQYXRoQW5kQ2xpcEJveChpbnRlcnNlY3QgfHwgWzAsIDAsIDAsIDBdKTtcbiAgfVxuICBpc0VtcHR5Q2xpcCgpIHtcbiAgICByZXR1cm4gdGhpcy5taW5NYXhbMF0gPT09IEluZmluaXR5O1xuICB9XG4gIHN0YXJ0TmV3UGF0aEFuZENsaXBCb3goYm94KSB7XG4gICAgdGhpcy5jbGlwQm94LnNldChib3gsIDApO1xuICAgIHRoaXMubWluTWF4LnNldChNSU5fTUFYX0lOSVQsIDApO1xuICB9XG4gIGdldENsaXBwZWRQYXRoQm91bmRpbmdCb3gocGF0aFR5cGUgPSBQYXRoVHlwZS5GSUxMLCB0cmFuc2Zvcm0gPSBudWxsKSB7XG4gICAgcmV0dXJuIFV0aWwuaW50ZXJzZWN0KHRoaXMuY2xpcEJveCwgdGhpcy5nZXRQYXRoQm91bmRpbmdCb3gocGF0aFR5cGUsIHRyYW5zZm9ybSkpO1xuICB9XG59XG5mdW5jdGlvbiBwdXRCaW5hcnlJbWFnZURhdGEoY3R4LCBpbWdEYXRhKSB7XG4gIGlmIChpbWdEYXRhIGluc3RhbmNlb2YgSW1hZ2VEYXRhKSB7XG4gICAgY3R4LnB1dEltYWdlRGF0YShpbWdEYXRhLCAwLCAwKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQsXG4gICAgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICBjb25zdCBwYXJ0aWFsQ2h1bmtIZWlnaHQgPSBoZWlnaHQgJSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgY29uc3QgZnVsbENodW5rcyA9IChoZWlnaHQgLSBwYXJ0aWFsQ2h1bmtIZWlnaHQpIC8gRlVMTF9DSFVOS19IRUlHSFQ7XG4gIGNvbnN0IHRvdGFsQ2h1bmtzID0gcGFydGlhbENodW5rSGVpZ2h0ID09PSAwID8gZnVsbENodW5rcyA6IGZ1bGxDaHVua3MgKyAxO1xuICBjb25zdCBjaHVua0ltZ0RhdGEgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gIGxldCBzcmNQb3MgPSAwLFxuICAgIGRlc3RQb3M7XG4gIGNvbnN0IHNyYyA9IGltZ0RhdGEuZGF0YTtcbiAgY29uc3QgZGVzdCA9IGNodW5rSW1nRGF0YS5kYXRhO1xuICBsZXQgaSwgaiwgdGhpc0NodW5rSGVpZ2h0LCBlbGVtc0luVGhpc0NodW5rO1xuICBpZiAoaW1nRGF0YS5raW5kID09PSB1dGlsX0ltYWdlS2luZC5HUkFZU0NBTEVfMUJQUCkge1xuICAgIGNvbnN0IHNyY0xlbmd0aCA9IHNyYy5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IGRlc3QzMiA9IG5ldyBVaW50MzJBcnJheShkZXN0LmJ1ZmZlciwgMCwgZGVzdC5ieXRlTGVuZ3RoID4+IDIpO1xuICAgIGNvbnN0IGRlc3QzMkRhdGFMZW5ndGggPSBkZXN0MzIubGVuZ3RoO1xuICAgIGNvbnN0IGZ1bGxTcmNEaWZmID0gd2lkdGggKyA3ID4+IDM7XG4gICAgY29uc3Qgd2hpdGUgPSAweGZmZmZmZmZmO1xuICAgIGNvbnN0IGJsYWNrID0gdXRpbF9GZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbiA/IDB4ZmYwMDAwMDAgOiAweDAwMDAwMGZmO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbENodW5rczsgaSsrKSB7XG4gICAgICB0aGlzQ2h1bmtIZWlnaHQgPSBpIDwgZnVsbENodW5rcyA/IEZVTExfQ0hVTktfSEVJR0hUIDogcGFydGlhbENodW5rSGVpZ2h0O1xuICAgICAgZGVzdFBvcyA9IDA7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgdGhpc0NodW5rSGVpZ2h0OyBqKyspIHtcbiAgICAgICAgY29uc3Qgc3JjRGlmZiA9IHNyY0xlbmd0aCAtIHNyY1BvcztcbiAgICAgICAgbGV0IGsgPSAwO1xuICAgICAgICBjb25zdCBrRW5kID0gc3JjRGlmZiA+IGZ1bGxTcmNEaWZmID8gd2lkdGggOiBzcmNEaWZmICogOCAtIDc7XG4gICAgICAgIGNvbnN0IGtFbmRVbnJvbGxlZCA9IGtFbmQgJiB+NztcbiAgICAgICAgbGV0IG1hc2sgPSAwO1xuICAgICAgICBsZXQgc3JjQnl0ZSA9IDA7XG4gICAgICAgIGZvciAoOyBrIDwga0VuZFVucm9sbGVkOyBrICs9IDgpIHtcbiAgICAgICAgICBzcmNCeXRlID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAxMjggPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDY0ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAzMiA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMTYgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDggPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDQgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDIgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDEgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBrIDwga0VuZDsgaysrKSB7XG4gICAgICAgICAgaWYgKG1hc2sgPT09IDApIHtcbiAgICAgICAgICAgIHNyY0J5dGUgPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICAgICAgbWFzayA9IDEyODtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgbWFzayA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgbWFzayA+Pj0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKGRlc3RQb3MgPCBkZXN0MzJEYXRhTGVuZ3RoKSB7XG4gICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gMDtcbiAgICAgIH1cbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBpICogRlVMTF9DSFVOS19IRUlHSFQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpbWdEYXRhLmtpbmQgPT09IHV0aWxfSW1hZ2VLaW5kLlJHQkFfMzJCUFApIHtcbiAgICBqID0gMDtcbiAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiBGVUxMX0NIVU5LX0hFSUdIVCAqIDQ7XG4gICAgZm9yIChpID0gMDsgaSA8IGZ1bGxDaHVua3M7IGkrKykge1xuICAgICAgZGVzdC5zZXQoc3JjLnN1YmFycmF5KHNyY1Bvcywgc3JjUG9zICsgZWxlbXNJblRoaXNDaHVuaykpO1xuICAgICAgc3JjUG9zICs9IGVsZW1zSW5UaGlzQ2h1bms7XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaik7XG4gICAgICBqICs9IEZVTExfQ0hVTktfSEVJR0hUO1xuICAgIH1cbiAgICBpZiAoaSA8IHRvdGFsQ2h1bmtzKSB7XG4gICAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiBwYXJ0aWFsQ2h1bmtIZWlnaHQgKiA0O1xuICAgICAgZGVzdC5zZXQoc3JjLnN1YmFycmF5KHNyY1Bvcywgc3JjUG9zICsgZWxlbXNJblRoaXNDaHVuaykpO1xuICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGopO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpbWdEYXRhLmtpbmQgPT09IHV0aWxfSW1hZ2VLaW5kLlJHQl8yNEJQUCkge1xuICAgIHRoaXNDaHVua0hlaWdodCA9IEZVTExfQ0hVTktfSEVJR0hUO1xuICAgIGVsZW1zSW5UaGlzQ2h1bmsgPSB3aWR0aCAqIHRoaXNDaHVua0hlaWdodDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxDaHVua3M7IGkrKykge1xuICAgICAgaWYgKGkgPj0gZnVsbENodW5rcykge1xuICAgICAgICB0aGlzQ2h1bmtIZWlnaHQgPSBwYXJ0aWFsQ2h1bmtIZWlnaHQ7XG4gICAgICAgIGVsZW1zSW5UaGlzQ2h1bmsgPSB3aWR0aCAqIHRoaXNDaHVua0hlaWdodDtcbiAgICAgIH1cbiAgICAgIGRlc3RQb3MgPSAwO1xuICAgICAgZm9yIChqID0gZWxlbXNJblRoaXNDaHVuazsgai0tOykge1xuICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSAyNTU7XG4gICAgICB9XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaSAqIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBiYWQgaW1hZ2Uga2luZDogJHtpbWdEYXRhLmtpbmR9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHB1dEJpbmFyeUltYWdlTWFzayhjdHgsIGltZ0RhdGEpIHtcbiAgaWYgKGltZ0RhdGEuYml0bWFwKSB7XG4gICAgY3R4LmRyYXdJbWFnZShpbWdEYXRhLmJpdG1hcCwgMCwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0LFxuICAgIHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgY29uc3QgcGFydGlhbENodW5rSGVpZ2h0ID0gaGVpZ2h0ICUgRlVMTF9DSFVOS19IRUlHSFQ7XG4gIGNvbnN0IGZ1bGxDaHVua3MgPSAoaGVpZ2h0IC0gcGFydGlhbENodW5rSGVpZ2h0KSAvIEZVTExfQ0hVTktfSEVJR0hUO1xuICBjb25zdCB0b3RhbENodW5rcyA9IHBhcnRpYWxDaHVua0hlaWdodCA9PT0gMCA/IGZ1bGxDaHVua3MgOiBmdWxsQ2h1bmtzICsgMTtcbiAgY29uc3QgY2h1bmtJbWdEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgRlVMTF9DSFVOS19IRUlHSFQpO1xuICBsZXQgc3JjUG9zID0gMDtcbiAgY29uc3Qgc3JjID0gaW1nRGF0YS5kYXRhO1xuICBjb25zdCBkZXN0ID0gY2h1bmtJbWdEYXRhLmRhdGE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxDaHVua3M7IGkrKykge1xuICAgIGNvbnN0IHRoaXNDaHVua0hlaWdodCA9IGkgPCBmdWxsQ2h1bmtzID8gRlVMTF9DSFVOS19IRUlHSFQgOiBwYXJ0aWFsQ2h1bmtIZWlnaHQ7XG4gICAgKHtcbiAgICAgIHNyY1Bvc1xuICAgIH0gPSBjb252ZXJ0QmxhY2tBbmRXaGl0ZVRvUkdCQSh7XG4gICAgICBzcmMsXG4gICAgICBzcmNQb3MsXG4gICAgICBkZXN0LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXNDaHVua0hlaWdodCxcbiAgICAgIG5vbkJsYWNrQ29sb3I6IDBcbiAgICB9KSk7XG4gICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGkgKiBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvcHlDdHhTdGF0ZShzb3VyY2VDdHgsIGRlc3RDdHgpIHtcbiAgY29uc3QgcHJvcGVydGllcyA9IFtcInN0cm9rZVN0eWxlXCIsIFwiZmlsbFN0eWxlXCIsIFwiZmlsbFJ1bGVcIiwgXCJnbG9iYWxBbHBoYVwiLCBcImxpbmVXaWR0aFwiLCBcImxpbmVDYXBcIiwgXCJsaW5lSm9pblwiLCBcIm1pdGVyTGltaXRcIiwgXCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cIiwgXCJmb250XCIsIFwiZmlsdGVyXCJdO1xuICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoc291cmNlQ3R4W3Byb3BlcnR5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZXN0Q3R4W3Byb3BlcnR5XSA9IHNvdXJjZUN0eFtwcm9wZXJ0eV07XG4gICAgfVxuICB9XG4gIGlmIChzb3VyY2VDdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgIGRlc3RDdHguc2V0TGluZURhc2goc291cmNlQ3R4LmdldExpbmVEYXNoKCkpO1xuICAgIGRlc3RDdHgubGluZURhc2hPZmZzZXQgPSBzb3VyY2VDdHgubGluZURhc2hPZmZzZXQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc2V0Q3R4VG9EZWZhdWx0KGN0eCkge1xuICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlID0gXCIjMDAwMDAwXCI7XG4gIGN0eC5maWxsUnVsZSA9IFwibm9uemVyb1wiO1xuICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICBjdHgubGluZVdpZHRoID0gMTtcbiAgY3R4LmxpbmVDYXAgPSBcImJ1dHRcIjtcbiAgY3R4LmxpbmVKb2luID0gXCJtaXRlclwiO1xuICBjdHgubWl0ZXJMaW1pdCA9IDEwO1xuICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2Utb3ZlclwiO1xuICBjdHguZm9udCA9IFwiMTBweCBzYW5zLXNlcmlmXCI7XG4gIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgIGN0eC5zZXRMaW5lRGFzaChbXSk7XG4gICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gMDtcbiAgfVxuICBjb25zdCB7XG4gICAgZmlsdGVyXG4gIH0gPSBjdHg7XG4gIGlmIChmaWx0ZXIgIT09IFwibm9uZVwiICYmIGZpbHRlciAhPT0gXCJcIikge1xuICAgIGN0eC5maWx0ZXIgPSBcIm5vbmVcIjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0SW1hZ2VTbW9vdGhpbmdFbmFibGVkKHRyYW5zZm9ybSwgaW50ZXJwb2xhdGUpIHtcbiAgaWYgKGludGVycG9sYXRlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSh0cmFuc2Zvcm0sIFhZKTtcbiAgY29uc3QgYWN0dWFsU2NhbGUgPSBNYXRoLmZyb3VuZChPdXRwdXRTY2FsZS5waXhlbFJhdGlvICogUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTKTtcbiAgcmV0dXJuIFhZWzBdIDw9IGFjdHVhbFNjYWxlICYmIFhZWzFdIDw9IGFjdHVhbFNjYWxlO1xufVxuY29uc3QgTElORV9DQVBfU1RZTEVTID0gW1wiYnV0dFwiLCBcInJvdW5kXCIsIFwic3F1YXJlXCJdO1xuY29uc3QgTElORV9KT0lOX1NUWUxFUyA9IFtcIm1pdGVyXCIsIFwicm91bmRcIiwgXCJiZXZlbFwiXTtcbmNvbnN0IE5PUk1BTF9DTElQID0ge307XG5jb25zdCBFT19DTElQID0ge307XG5jbGFzcyBDYW52YXNHcmFwaGljcyB7XG4gIGNvbnN0cnVjdG9yKGNhbnZhc0N0eCwgY29tbW9uT2Jqcywgb2JqcywgY2FudmFzRmFjdG9yeSwgZmlsdGVyRmFjdG9yeSwge1xuICAgIG9wdGlvbmFsQ29udGVudENvbmZpZyxcbiAgICBtYXJrZWRDb250ZW50U3RhY2sgPSBudWxsXG4gIH0sIGFubm90YXRpb25DYW52YXNNYXAsIHBhZ2VDb2xvcnMpIHtcbiAgICB0aGlzLmN0eCA9IGNhbnZhc0N0eDtcbiAgICB0aGlzLmN1cnJlbnQgPSBuZXcgQ2FudmFzRXh0cmFTdGF0ZSh0aGlzLmN0eC5jYW52YXMud2lkdGgsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgIHRoaXMuc3RhdGVTdGFjayA9IFtdO1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IGZhbHNlO1xuICAgIHRoaXMucmVzID0gbnVsbDtcbiAgICB0aGlzLnhvYmpzID0gbnVsbDtcbiAgICB0aGlzLmNvbW1vbk9ianMgPSBjb21tb25PYmpzO1xuICAgIHRoaXMub2JqcyA9IG9ianM7XG4gICAgdGhpcy5jYW52YXNGYWN0b3J5ID0gY2FudmFzRmFjdG9yeTtcbiAgICB0aGlzLmZpbHRlckZhY3RvcnkgPSBmaWx0ZXJGYWN0b3J5O1xuICAgIHRoaXMuZ3JvdXBTdGFjayA9IFtdO1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IG51bGw7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtU3RhY2sgPSBbXTtcbiAgICB0aGlzLmdyb3VwTGV2ZWwgPSAwO1xuICAgIHRoaXMuc21hc2tTdGFjayA9IFtdO1xuICAgIHRoaXMuc21hc2tDb3VudGVyID0gMDtcbiAgICB0aGlzLnRlbXBTTWFzayA9IG51bGw7XG4gICAgdGhpcy5zdXNwZW5kZWRDdHggPSBudWxsO1xuICAgIHRoaXMuY29udGVudFZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrID0gbWFya2VkQ29udGVudFN0YWNrIHx8IFtdO1xuICAgIHRoaXMub3B0aW9uYWxDb250ZW50Q29uZmlnID0gb3B0aW9uYWxDb250ZW50Q29uZmlnO1xuICAgIHRoaXMuY2FjaGVkQ2FudmFzZXMgPSBuZXcgQ2FjaGVkQ2FudmFzZXModGhpcy5jYW52YXNGYWN0b3J5KTtcbiAgICB0aGlzLmNhY2hlZFBhdHRlcm5zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcCA9IGFubm90YXRpb25DYW52YXNNYXA7XG4gICAgdGhpcy52aWV3cG9ydFNjYWxlID0gMTtcbiAgICB0aGlzLm91dHB1dFNjYWxlWCA9IDE7XG4gICAgdGhpcy5vdXRwdXRTY2FsZVkgPSAxO1xuICAgIHRoaXMucGFnZUNvbG9ycyA9IHBhZ2VDb2xvcnM7XG4gICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZyA9IFstMSwgMF07XG4gICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IG51bGw7XG4gICAgdGhpcy5fY2FjaGVkQml0bWFwc01hcCA9IG5ldyBNYXAoKTtcbiAgfVxuICBnZXRPYmplY3QoZGF0YSwgZmFsbGJhY2sgPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZGF0YS5zdGFydHNXaXRoKFwiZ19cIikgPyB0aGlzLmNvbW1vbk9ianMuZ2V0KGRhdGEpIDogdGhpcy5vYmpzLmdldChkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbGxiYWNrO1xuICB9XG4gIGJlZ2luRHJhd2luZyh7XG4gICAgdHJhbnNmb3JtLFxuICAgIHZpZXdwb3J0LFxuICAgIHRyYW5zcGFyZW5jeSA9IGZhbHNlLFxuICAgIGJhY2tncm91bmQgPSBudWxsXG4gIH0pIHtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuY3R4LmNhbnZhcy53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0O1xuICAgIGNvbnN0IHNhdmVkRmlsbFN0eWxlID0gdGhpcy5jdHguZmlsbFN0eWxlO1xuICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmQgfHwgXCIjZmZmZmZmXCI7XG4gICAgdGhpcy5jdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gc2F2ZWRGaWxsU3R5bGU7XG4gICAgaWYgKHRyYW5zcGFyZW5jeSkge1xuICAgICAgY29uc3QgdHJhbnNwYXJlbnRDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcInRyYW5zcGFyZW50XCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5jb21wb3NpdGVDdHggPSB0aGlzLmN0eDtcbiAgICAgIHRoaXMudHJhbnNwYXJlbnRDYW52YXMgPSB0cmFuc3BhcmVudENhbnZhcy5jYW52YXM7XG4gICAgICB0aGlzLmN0eCA9IHRyYW5zcGFyZW50Q2FudmFzLmNvbnRleHQ7XG4gICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICB0aGlzLmN0eC50cmFuc2Zvcm0oLi4uZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmNvbXBvc2l0ZUN0eCkpO1xuICAgIH1cbiAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgcmVzZXRDdHhUb0RlZmF1bHQodGhpcy5jdHgpO1xuICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgIHRoaXMuY3R4LnRyYW5zZm9ybSguLi50cmFuc2Zvcm0pO1xuICAgICAgdGhpcy5vdXRwdXRTY2FsZVggPSB0cmFuc2Zvcm1bMF07XG4gICAgICB0aGlzLm91dHB1dFNjYWxlWSA9IHRyYW5zZm9ybVswXTtcbiAgICB9XG4gICAgdGhpcy5jdHgudHJhbnNmb3JtKC4uLnZpZXdwb3J0LnRyYW5zZm9ybSk7XG4gICAgdGhpcy52aWV3cG9ydFNjYWxlID0gdmlld3BvcnQuc2NhbGU7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmN0eCk7XG4gIH1cbiAgZXhlY3V0ZU9wZXJhdG9yTGlzdChvcGVyYXRvckxpc3QsIGV4ZWN1dGlvblN0YXJ0SWR4LCBjb250aW51ZUNhbGxiYWNrLCBzdGVwcGVyKSB7XG4gICAgY29uc3QgYXJnc0FycmF5ID0gb3BlcmF0b3JMaXN0LmFyZ3NBcnJheTtcbiAgICBjb25zdCBmbkFycmF5ID0gb3BlcmF0b3JMaXN0LmZuQXJyYXk7XG4gICAgbGV0IGkgPSBleGVjdXRpb25TdGFydElkeCB8fCAwO1xuICAgIGNvbnN0IGFyZ3NBcnJheUxlbiA9IGFyZ3NBcnJheS5sZW5ndGg7XG4gICAgaWYgKGFyZ3NBcnJheUxlbiA9PT0gaSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rT3BlcmF0aW9ucyA9IGFyZ3NBcnJheUxlbiAtIGkgPiBFWEVDVVRJT05fU1RFUFMgJiYgdHlwZW9mIGNvbnRpbnVlQ2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIjtcbiAgICBjb25zdCBlbmRUaW1lID0gY2h1bmtPcGVyYXRpb25zID8gRGF0ZS5ub3coKSArIEVYRUNVVElPTl9USU1FIDogMDtcbiAgICBsZXQgc3RlcHMgPSAwO1xuICAgIGNvbnN0IGNvbW1vbk9ianMgPSB0aGlzLmNvbW1vbk9ianM7XG4gICAgY29uc3Qgb2JqcyA9IHRoaXMub2JqcztcbiAgICBsZXQgZm5JZDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKHN0ZXBwZXIgIT09IHVuZGVmaW5lZCAmJiBpID09PSBzdGVwcGVyLm5leHRCcmVha1BvaW50KSB7XG4gICAgICAgIHN0ZXBwZXIuYnJlYWtJdChpLCBjb250aW51ZUNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgICBmbklkID0gZm5BcnJheVtpXTtcbiAgICAgIGlmIChmbklkICE9PSBPUFMuZGVwZW5kZW5jeSkge1xuICAgICAgICB0aGlzW2ZuSWRdLmFwcGx5KHRoaXMsIGFyZ3NBcnJheVtpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGRlcE9iaklkIG9mIGFyZ3NBcnJheVtpXSkge1xuICAgICAgICAgIGNvbnN0IG9ianNQb29sID0gZGVwT2JqSWQuc3RhcnRzV2l0aChcImdfXCIpID8gY29tbW9uT2JqcyA6IG9ianM7XG4gICAgICAgICAgaWYgKCFvYmpzUG9vbC5oYXMoZGVwT2JqSWQpKSB7XG4gICAgICAgICAgICBvYmpzUG9vbC5nZXQoZGVwT2JqSWQsIGNvbnRpbnVlQ2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgICBpZiAoaSA9PT0gYXJnc0FycmF5TGVuKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgICAgaWYgKGNodW5rT3BlcmF0aW9ucyAmJiArK3N0ZXBzID4gRVhFQ1VUSU9OX1NURVBTKSB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpID4gZW5kVGltZSkge1xuICAgICAgICAgIGNvbnRpbnVlQ2FsbGJhY2soKTtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICBzdGVwcyA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNyZXN0b3JlSW5pdGlhbFN0YXRlKCkge1xuICAgIHdoaWxlICh0aGlzLnN0YXRlU3RhY2subGVuZ3RoIHx8IHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgPSBudWxsO1xuICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICBpZiAodGhpcy50cmFuc3BhcmVudENhbnZhcykge1xuICAgICAgdGhpcy5jdHggPSB0aGlzLmNvbXBvc2l0ZUN0eDtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZSh0aGlzLnRyYW5zcGFyZW50Q2FudmFzLCAwLCAwKTtcbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMudHJhbnNwYXJlbnRDYW52YXMgPSBudWxsO1xuICAgIH1cbiAgfVxuICBlbmREcmF3aW5nKCkge1xuICAgIHRoaXMuI3Jlc3RvcmVJbml0aWFsU3RhdGUoKTtcbiAgICB0aGlzLmNhY2hlZENhbnZhc2VzLmNsZWFyKCk7XG4gICAgdGhpcy5jYWNoZWRQYXR0ZXJucy5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgY2FjaGUgb2YgdGhpcy5fY2FjaGVkQml0bWFwc01hcC52YWx1ZXMoKSkge1xuICAgICAgZm9yIChjb25zdCBjYW52YXMgb2YgY2FjaGUudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwLmNsZWFyKCk7XG4gICAgdGhpcy4jZHJhd0ZpbHRlcigpO1xuICB9XG4gICNkcmF3RmlsdGVyKCkge1xuICAgIGlmICh0aGlzLnBhZ2VDb2xvcnMpIHtcbiAgICAgIGNvbnN0IGhjbUZpbHRlcklkID0gdGhpcy5maWx0ZXJGYWN0b3J5LmFkZEhDTUZpbHRlcih0aGlzLnBhZ2VDb2xvcnMuZm9yZWdyb3VuZCwgdGhpcy5wYWdlQ29sb3JzLmJhY2tncm91bmQpO1xuICAgICAgaWYgKGhjbUZpbHRlcklkICE9PSBcIm5vbmVcIikge1xuICAgICAgICBjb25zdCBzYXZlZEZpbHRlciA9IHRoaXMuY3R4LmZpbHRlcjtcbiAgICAgICAgdGhpcy5jdHguZmlsdGVyID0gaGNtRmlsdGVySWQ7XG4gICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZSh0aGlzLmN0eC5jYW52YXMsIDAsIDApO1xuICAgICAgICB0aGlzLmN0eC5maWx0ZXIgPSBzYXZlZEZpbHRlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3NjYWxlSW1hZ2UoaW1nLCBpbnZlcnNlVHJhbnNmb3JtKSB7XG4gICAgY29uc3Qgd2lkdGggPSBpbWcud2lkdGggPz8gaW1nLmRpc3BsYXlXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWcuaGVpZ2h0ID8/IGltZy5kaXNwbGF5SGVpZ2h0O1xuICAgIGxldCB3aWR0aFNjYWxlID0gTWF0aC5tYXgoTWF0aC5oeXBvdChpbnZlcnNlVHJhbnNmb3JtWzBdLCBpbnZlcnNlVHJhbnNmb3JtWzFdKSwgMSk7XG4gICAgbGV0IGhlaWdodFNjYWxlID0gTWF0aC5tYXgoTWF0aC5oeXBvdChpbnZlcnNlVHJhbnNmb3JtWzJdLCBpbnZlcnNlVHJhbnNmb3JtWzNdKSwgMSk7XG4gICAgbGV0IHBhaW50V2lkdGggPSB3aWR0aCxcbiAgICAgIHBhaW50SGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGxldCB0bXBDYW52YXNJZCA9IFwicHJlc2NhbGUxXCI7XG4gICAgbGV0IHRtcENhbnZhcywgdG1wQ3R4O1xuICAgIHdoaWxlICh3aWR0aFNjYWxlID4gMiAmJiBwYWludFdpZHRoID4gMSB8fCBoZWlnaHRTY2FsZSA+IDIgJiYgcGFpbnRIZWlnaHQgPiAxKSB7XG4gICAgICBsZXQgbmV3V2lkdGggPSBwYWludFdpZHRoLFxuICAgICAgICBuZXdIZWlnaHQgPSBwYWludEhlaWdodDtcbiAgICAgIGlmICh3aWR0aFNjYWxlID4gMiAmJiBwYWludFdpZHRoID4gMSkge1xuICAgICAgICBuZXdXaWR0aCA9IHBhaW50V2lkdGggPj0gMTYzODQgPyBNYXRoLmZsb29yKHBhaW50V2lkdGggLyAyKSAtIDEgfHwgMSA6IE1hdGguY2VpbChwYWludFdpZHRoIC8gMik7XG4gICAgICAgIHdpZHRoU2NhbGUgLz0gcGFpbnRXaWR0aCAvIG5ld1dpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodFNjYWxlID4gMiAmJiBwYWludEhlaWdodCA+IDEpIHtcbiAgICAgICAgbmV3SGVpZ2h0ID0gcGFpbnRIZWlnaHQgPj0gMTYzODQgPyBNYXRoLmZsb29yKHBhaW50SGVpZ2h0IC8gMikgLSAxIHx8IDEgOiBNYXRoLmNlaWwocGFpbnRIZWlnaHQpIC8gMjtcbiAgICAgICAgaGVpZ2h0U2NhbGUgLz0gcGFpbnRIZWlnaHQgLyBuZXdIZWlnaHQ7XG4gICAgICB9XG4gICAgICB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyh0bXBDYW52YXNJZCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICAgIHRtcEN0eC5jbGVhclJlY3QoMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICB0bXBDdHguZHJhd0ltYWdlKGltZywgMCwgMCwgcGFpbnRXaWR0aCwgcGFpbnRIZWlnaHQsIDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgaW1nID0gdG1wQ2FudmFzLmNhbnZhcztcbiAgICAgIHBhaW50V2lkdGggPSBuZXdXaWR0aDtcbiAgICAgIHBhaW50SGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgdG1wQ2FudmFzSWQgPSB0bXBDYW52YXNJZCA9PT0gXCJwcmVzY2FsZTFcIiA/IFwicHJlc2NhbGUyXCIgOiBcInByZXNjYWxlMVwiO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaW1nLFxuICAgICAgcGFpbnRXaWR0aCxcbiAgICAgIHBhaW50SGVpZ2h0XG4gICAgfTtcbiAgfVxuICBfY3JlYXRlTWFza0NhbnZhcyhpbWcpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBpbWc7XG4gICAgY29uc3QgZmlsbENvbG9yID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvcjtcbiAgICBjb25zdCBpc1BhdHRlcm5GaWxsID0gdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCk7XG4gICAgbGV0IGNhY2hlLCBjYWNoZUtleSwgc2NhbGVkLCBtYXNrQ2FudmFzO1xuICAgIGlmICgoaW1nLmJpdG1hcCB8fCBpbWcuZGF0YSkgJiYgaW1nLmNvdW50ID4gMSkge1xuICAgICAgY29uc3QgbWFpbktleSA9IGltZy5iaXRtYXAgfHwgaW1nLmRhdGEuYnVmZmVyO1xuICAgICAgY2FjaGVLZXkgPSBKU09OLnN0cmluZ2lmeShpc1BhdHRlcm5GaWxsID8gY3VycmVudFRyYW5zZm9ybSA6IFtjdXJyZW50VHJhbnNmb3JtLnNsaWNlKDAsIDQpLCBmaWxsQ29sb3JdKTtcbiAgICAgIGNhY2hlID0gdGhpcy5fY2FjaGVkQml0bWFwc01hcC5nZXQobWFpbktleSk7XG4gICAgICBpZiAoIWNhY2hlKSB7XG4gICAgICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwLnNldChtYWluS2V5LCBjYWNoZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjYWNoZWRJbWFnZSA9IGNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICBpZiAoY2FjaGVkSW1hZ2UgJiYgIWlzUGF0dGVybkZpbGwpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IE1hdGgucm91bmQoTWF0aC5taW4oY3VycmVudFRyYW5zZm9ybVswXSwgY3VycmVudFRyYW5zZm9ybVsyXSkgKyBjdXJyZW50VHJhbnNmb3JtWzRdKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGgucm91bmQoTWF0aC5taW4oY3VycmVudFRyYW5zZm9ybVsxXSwgY3VycmVudFRyYW5zZm9ybVszXSkgKyBjdXJyZW50VHJhbnNmb3JtWzVdKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjYW52YXM6IGNhY2hlZEltYWdlLFxuICAgICAgICAgIG9mZnNldFgsXG4gICAgICAgICAgb2Zmc2V0WVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgc2NhbGVkID0gY2FjaGVkSW1hZ2U7XG4gICAgfVxuICAgIGlmICghc2NhbGVkKSB7XG4gICAgICBtYXNrQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJtYXNrQ2FudmFzXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgcHV0QmluYXJ5SW1hZ2VNYXNrKG1hc2tDYW52YXMuY29udGV4dCwgaW1nKTtcbiAgICB9XG4gICAgbGV0IG1hc2tUb0NhbnZhcyA9IFV0aWwudHJhbnNmb3JtKGN1cnJlbnRUcmFuc2Zvcm0sIFsxIC8gd2lkdGgsIDAsIDAsIC0xIC8gaGVpZ2h0LCAwLCAwXSk7XG4gICAgbWFza1RvQ2FudmFzID0gVXRpbC50cmFuc2Zvcm0obWFza1RvQ2FudmFzLCBbMSwgMCwgMCwgMSwgMCwgLWhlaWdodF0pO1xuICAgIGNvbnN0IG1pbk1heCA9IE1JTl9NQVhfSU5JVC5zbGljZSgpO1xuICAgIFV0aWwuYXhpYWxBbGlnbmVkQm91bmRpbmdCb3goWzAsIDAsIHdpZHRoLCBoZWlnaHRdLCBtYXNrVG9DYW52YXMsIG1pbk1heCk7XG4gICAgY29uc3QgW21pblgsIG1pblksIG1heFgsIG1heFldID0gbWluTWF4O1xuICAgIGNvbnN0IGRyYXduV2lkdGggPSBNYXRoLnJvdW5kKG1heFggLSBtaW5YKSB8fCAxO1xuICAgIGNvbnN0IGRyYXduSGVpZ2h0ID0gTWF0aC5yb3VuZChtYXhZIC0gbWluWSkgfHwgMTtcbiAgICBjb25zdCBmaWxsQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJmaWxsQ2FudmFzXCIsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0KTtcbiAgICBjb25zdCBmaWxsQ3R4ID0gZmlsbENhbnZhcy5jb250ZXh0O1xuICAgIGNvbnN0IG9mZnNldFggPSBtaW5YO1xuICAgIGNvbnN0IG9mZnNldFkgPSBtaW5ZO1xuICAgIGZpbGxDdHgudHJhbnNsYXRlKC1vZmZzZXRYLCAtb2Zmc2V0WSk7XG4gICAgZmlsbEN0eC50cmFuc2Zvcm0oLi4ubWFza1RvQ2FudmFzKTtcbiAgICBpZiAoIXNjYWxlZCkge1xuICAgICAgc2NhbGVkID0gdGhpcy5fc2NhbGVJbWFnZShtYXNrQ2FudmFzLmNhbnZhcywgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoZmlsbEN0eCkpO1xuICAgICAgc2NhbGVkID0gc2NhbGVkLmltZztcbiAgICAgIGlmIChjYWNoZSAmJiBpc1BhdHRlcm5GaWxsKSB7XG4gICAgICAgIGNhY2hlLnNldChjYWNoZUtleSwgc2NhbGVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmlsbEN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQoZ2V0Q3VycmVudFRyYW5zZm9ybShmaWxsQ3R4KSwgaW1nLmludGVycG9sYXRlKTtcbiAgICBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoZmlsbEN0eCwgc2NhbGVkLCAwLCAwLCBzY2FsZWQud2lkdGgsIHNjYWxlZC5oZWlnaHQsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGZpbGxDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2UtaW5cIjtcbiAgICBjb25zdCBpbnZlcnNlID0gVXRpbC50cmFuc2Zvcm0oZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoZmlsbEN0eCksIFsxLCAwLCAwLCAxLCAtb2Zmc2V0WCwgLW9mZnNldFldKTtcbiAgICBmaWxsQ3R4LmZpbGxTdHlsZSA9IGlzUGF0dGVybkZpbGwgPyBmaWxsQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsIGludmVyc2UsIFBhdGhUeXBlLkZJTEwpIDogZmlsbENvbG9yO1xuICAgIGZpbGxDdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKGNhY2hlICYmICFpc1BhdHRlcm5GaWxsKSB7XG4gICAgICB0aGlzLmNhY2hlZENhbnZhc2VzLmRlbGV0ZShcImZpbGxDYW52YXNcIik7XG4gICAgICBjYWNoZS5zZXQoY2FjaGVLZXksIGZpbGxDYW52YXMuY2FudmFzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhczogZmlsbENhbnZhcy5jYW52YXMsXG4gICAgICBvZmZzZXRYOiBNYXRoLnJvdW5kKG9mZnNldFgpLFxuICAgICAgb2Zmc2V0WTogTWF0aC5yb3VuZChvZmZzZXRZKVxuICAgIH07XG4gIH1cbiAgc2V0TGluZVdpZHRoKHdpZHRoKSB7XG4gICAgaWYgKHdpZHRoICE9PSB0aGlzLmN1cnJlbnQubGluZVdpZHRoKSB7XG4gICAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gLTE7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5saW5lV2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmN0eC5saW5lV2lkdGggPSB3aWR0aDtcbiAgfVxuICBzZXRMaW5lQ2FwKHN0eWxlKSB7XG4gICAgdGhpcy5jdHgubGluZUNhcCA9IExJTkVfQ0FQX1NUWUxFU1tzdHlsZV07XG4gIH1cbiAgc2V0TGluZUpvaW4oc3R5bGUpIHtcbiAgICB0aGlzLmN0eC5saW5lSm9pbiA9IExJTkVfSk9JTl9TVFlMRVNbc3R5bGVdO1xuICB9XG4gIHNldE1pdGVyTGltaXQobGltaXQpIHtcbiAgICB0aGlzLmN0eC5taXRlckxpbWl0ID0gbGltaXQ7XG4gIH1cbiAgc2V0RGFzaChkYXNoQXJyYXksIGRhc2hQaGFzZSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hBcnJheSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBkYXNoUGhhc2U7XG4gICAgfVxuICB9XG4gIHNldFJlbmRlcmluZ0ludGVudChpbnRlbnQpIHt9XG4gIHNldEZsYXRuZXNzKGZsYXRuZXNzKSB7fVxuICBzZXRHU3RhdGUoc3RhdGVzKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3RhdGVzKSB7XG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlIFwiTFdcIjpcbiAgICAgICAgICB0aGlzLnNldExpbmVXaWR0aCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJMQ1wiOlxuICAgICAgICAgIHRoaXMuc2V0TGluZUNhcCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJMSlwiOlxuICAgICAgICAgIHRoaXMuc2V0TGluZUpvaW4odmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTUxcIjpcbiAgICAgICAgICB0aGlzLnNldE1pdGVyTGltaXQodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRFwiOlxuICAgICAgICAgIHRoaXMuc2V0RGFzaCh2YWx1ZVswXSwgdmFsdWVbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiUklcIjpcbiAgICAgICAgICB0aGlzLnNldFJlbmRlcmluZ0ludGVudCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJGTFwiOlxuICAgICAgICAgIHRoaXMuc2V0RmxhdG5lc3ModmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRm9udFwiOlxuICAgICAgICAgIHRoaXMuc2V0Rm9udCh2YWx1ZVswXSwgdmFsdWVbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQ0FcIjpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQWxwaGEgPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNhXCI6XG4gICAgICAgICAgdGhpcy5jdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmN1cnJlbnQuZmlsbEFscGhhID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJCTVwiOlxuICAgICAgICAgIHRoaXMuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiU01hc2tcIjpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgPSB2YWx1ZSA/IHRoaXMudGVtcFNNYXNrIDogbnVsbDtcbiAgICAgICAgICB0aGlzLnRlbXBTTWFzayA9IG51bGw7XG4gICAgICAgICAgdGhpcy5jaGVja1NNYXNrU3RhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlRSXCI6XG4gICAgICAgICAgdGhpcy5jdHguZmlsdGVyID0gdGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcyA9IHRoaXMuZmlsdGVyRmFjdG9yeS5hZGRGaWx0ZXIodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgaW5TTWFza01vZGUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5zdXNwZW5kZWRDdHg7XG4gIH1cbiAgY2hlY2tTTWFza1N0YXRlKCkge1xuICAgIGNvbnN0IGluU01hc2tNb2RlID0gdGhpcy5pblNNYXNrTW9kZTtcbiAgICBpZiAodGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrICYmICFpblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5iZWdpblNNYXNrTW9kZSgpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuY3VycmVudC5hY3RpdmVTTWFzayAmJiBpblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5lbmRTTWFza01vZGUoKTtcbiAgICB9XG4gIH1cbiAgYmVnaW5TTWFza01vZGUoKSB7XG4gICAgaWYgKHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImJlZ2luU01hc2tNb2RlIGNhbGxlZCB3aGlsZSBhbHJlYWR5IGluIHNtYXNrIG1vZGVcIik7XG4gICAgfVxuICAgIGNvbnN0IGRyYXduV2lkdGggPSB0aGlzLmN0eC5jYW52YXMud2lkdGg7XG4gICAgY29uc3QgZHJhd25IZWlnaHQgPSB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0O1xuICAgIGNvbnN0IGNhY2hlSWQgPSBcInNtYXNrR3JvdXBBdFwiICsgdGhpcy5ncm91cExldmVsO1xuICAgIGNvbnN0IHNjcmF0Y2hDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhjYWNoZUlkLCBkcmF3bldpZHRoLCBkcmF3bkhlaWdodCk7XG4gICAgdGhpcy5zdXNwZW5kZWRDdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eCA9IHNjcmF0Y2hDYW52YXMuY29udGV4dDtcbiAgICBjdHguc2V0VHJhbnNmb3JtKHRoaXMuc3VzcGVuZGVkQ3R4LmdldFRyYW5zZm9ybSgpKTtcbiAgICBjb3B5Q3R4U3RhdGUodGhpcy5zdXNwZW5kZWRDdHgsIGN0eCk7XG4gICAgbWlycm9yQ29udGV4dE9wZXJhdGlvbnMoY3R4LCB0aGlzLnN1c3BlbmRlZEN0eCk7XG4gICAgdGhpcy5zZXRHU3RhdGUoW1tcIkJNXCIsIFwic291cmNlLW92ZXJcIl1dKTtcbiAgfVxuICBlbmRTTWFza01vZGUoKSB7XG4gICAgaWYgKCF0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbmRTTWFza01vZGUgY2FsbGVkIHdoaWxlIG5vdCBpbiBzbWFzayBtb2RlXCIpO1xuICAgIH1cbiAgICB0aGlzLmN0eC5fcmVtb3ZlTWlycm9yaW5nKCk7XG4gICAgY29weUN0eFN0YXRlKHRoaXMuY3R4LCB0aGlzLnN1c3BlbmRlZEN0eCk7XG4gICAgdGhpcy5jdHggPSB0aGlzLnN1c3BlbmRlZEN0eDtcbiAgICB0aGlzLnN1c3BlbmRlZEN0eCA9IG51bGw7XG4gIH1cbiAgY29tcG9zZShkaXJ0eUJveCkge1xuICAgIGlmICghdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghZGlydHlCb3gpIHtcbiAgICAgIGRpcnR5Qm94ID0gWzAsIDAsIHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgdGhpcy5jdHguY2FudmFzLmhlaWdodF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpcnR5Qm94WzBdID0gTWF0aC5mbG9vcihkaXJ0eUJveFswXSk7XG4gICAgICBkaXJ0eUJveFsxXSA9IE1hdGguZmxvb3IoZGlydHlCb3hbMV0pO1xuICAgICAgZGlydHlCb3hbMl0gPSBNYXRoLmNlaWwoZGlydHlCb3hbMl0pO1xuICAgICAgZGlydHlCb3hbM10gPSBNYXRoLmNlaWwoZGlydHlCb3hbM10pO1xuICAgIH1cbiAgICBjb25zdCBzbWFzayA9IHRoaXMuY3VycmVudC5hY3RpdmVTTWFzaztcbiAgICBjb25zdCBzdXNwZW5kZWRDdHggPSB0aGlzLnN1c3BlbmRlZEN0eDtcbiAgICB0aGlzLmNvbXBvc2VTTWFzayhzdXNwZW5kZWRDdHgsIHNtYXNrLCB0aGlzLmN0eCwgZGlydHlCb3gpO1xuICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCk7XG4gICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICB9XG4gIGNvbXBvc2VTTWFzayhjdHgsIHNtYXNrLCBsYXllckN0eCwgbGF5ZXJCb3gpIHtcbiAgICBjb25zdCBsYXllck9mZnNldFggPSBsYXllckJveFswXTtcbiAgICBjb25zdCBsYXllck9mZnNldFkgPSBsYXllckJveFsxXTtcbiAgICBjb25zdCBsYXllcldpZHRoID0gbGF5ZXJCb3hbMl0gLSBsYXllck9mZnNldFg7XG4gICAgY29uc3QgbGF5ZXJIZWlnaHQgPSBsYXllckJveFszXSAtIGxheWVyT2Zmc2V0WTtcbiAgICBpZiAobGF5ZXJXaWR0aCA9PT0gMCB8fCBsYXllckhlaWdodCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmdlbmVyaWNDb21wb3NlU01hc2soc21hc2suY29udGV4dCwgbGF5ZXJDdHgsIGxheWVyV2lkdGgsIGxheWVySGVpZ2h0LCBzbWFzay5zdWJ0eXBlLCBzbWFzay5iYWNrZHJvcCwgc21hc2sudHJhbnNmZXJNYXAsIGxheWVyT2Zmc2V0WCwgbGF5ZXJPZmZzZXRZLCBzbWFzay5vZmZzZXRYLCBzbWFzay5vZmZzZXRZKTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLW92ZXJcIjtcbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIGN0eC5kcmF3SW1hZ2UobGF5ZXJDdHguY2FudmFzLCAwLCAwKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG4gIGdlbmVyaWNDb21wb3NlU01hc2sobWFza0N0eCwgbGF5ZXJDdHgsIHdpZHRoLCBoZWlnaHQsIHN1YnR5cGUsIGJhY2tkcm9wLCB0cmFuc2Zlck1hcCwgbGF5ZXJPZmZzZXRYLCBsYXllck9mZnNldFksIG1hc2tPZmZzZXRYLCBtYXNrT2Zmc2V0WSkge1xuICAgIGxldCBtYXNrQ2FudmFzID0gbWFza0N0eC5jYW52YXM7XG4gICAgbGV0IG1hc2tYID0gbGF5ZXJPZmZzZXRYIC0gbWFza09mZnNldFg7XG4gICAgbGV0IG1hc2tZID0gbGF5ZXJPZmZzZXRZIC0gbWFza09mZnNldFk7XG4gICAgaWYgKGJhY2tkcm9wKSB7XG4gICAgICBjb25zdCBiYWNrZHJvcFJHQiA9IFV0aWwubWFrZUhleENvbG9yKC4uLmJhY2tkcm9wKTtcbiAgICAgIGlmIChtYXNrWCA8IDAgfHwgbWFza1kgPCAwIHx8IG1hc2tYICsgd2lkdGggPiBtYXNrQ2FudmFzLndpZHRoIHx8IG1hc2tZICsgaGVpZ2h0ID4gbWFza0NhbnZhcy5oZWlnaHQpIHtcbiAgICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJtYXNrRXh0ZW5zaW9uXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuY29udGV4dDtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShtYXNrQ2FudmFzLCAtbWFza1gsIC1tYXNrWSk7XG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImRlc3RpbmF0aW9uLWF0b3BcIjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tkcm9wUkdCO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1vdmVyXCI7XG4gICAgICAgIG1hc2tDYW52YXMgPSBjYW52YXMuY2FudmFzO1xuICAgICAgICBtYXNrWCA9IG1hc2tZID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hc2tDdHguc2F2ZSgpO1xuICAgICAgICBtYXNrQ3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICAgICAgbWFza0N0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgIGNvbnN0IGNsaXAgPSBuZXcgUGF0aDJEKCk7XG4gICAgICAgIGNsaXAucmVjdChtYXNrWCwgbWFza1ksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBtYXNrQ3R4LmNsaXAoY2xpcCk7XG4gICAgICAgIG1hc2tDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1hdG9wXCI7XG4gICAgICAgIG1hc2tDdHguZmlsbFN0eWxlID0gYmFja2Ryb3BSR0I7XG4gICAgICAgIG1hc2tDdHguZmlsbFJlY3QobWFza1gsIG1hc2tZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgbWFza0N0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxheWVyQ3R4LnNhdmUoKTtcbiAgICBsYXllckN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgbGF5ZXJDdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIGlmIChzdWJ0eXBlID09PSBcIkFscGhhXCIgJiYgdHJhbnNmZXJNYXApIHtcbiAgICAgIGxheWVyQ3R4LmZpbHRlciA9IHRoaXMuZmlsdGVyRmFjdG9yeS5hZGRBbHBoYUZpbHRlcih0cmFuc2Zlck1hcCk7XG4gICAgfSBlbHNlIGlmIChzdWJ0eXBlID09PSBcIkx1bWlub3NpdHlcIikge1xuICAgICAgbGF5ZXJDdHguZmlsdGVyID0gdGhpcy5maWx0ZXJGYWN0b3J5LmFkZEx1bWlub3NpdHlGaWx0ZXIodHJhbnNmZXJNYXApO1xuICAgIH1cbiAgICBjb25zdCBjbGlwID0gbmV3IFBhdGgyRCgpO1xuICAgIGNsaXAucmVjdChsYXllck9mZnNldFgsIGxheWVyT2Zmc2V0WSwgd2lkdGgsIGhlaWdodCk7XG4gICAgbGF5ZXJDdHguY2xpcChjbGlwKTtcbiAgICBsYXllckN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImRlc3RpbmF0aW9uLWluXCI7XG4gICAgbGF5ZXJDdHguZHJhd0ltYWdlKG1hc2tDYW52YXMsIG1hc2tYLCBtYXNrWSwgd2lkdGgsIGhlaWdodCwgbGF5ZXJPZmZzZXRYLCBsYXllck9mZnNldFksIHdpZHRoLCBoZWlnaHQpO1xuICAgIGxheWVyQ3R4LnJlc3RvcmUoKTtcbiAgfVxuICBzYXZlKCkge1xuICAgIGlmICh0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICBjb3B5Q3R4U3RhdGUodGhpcy5jdHgsIHRoaXMuc3VzcGVuZGVkQ3R4KTtcbiAgICB9XG4gICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgIGNvbnN0IG9sZCA9IHRoaXMuY3VycmVudDtcbiAgICB0aGlzLnN0YXRlU3RhY2sucHVzaChvbGQpO1xuICAgIHRoaXMuY3VycmVudCA9IG9sZC5jbG9uZSgpO1xuICB9XG4gIHJlc3RvcmUoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGVTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmICh0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICAgIHRoaXMuZW5kU01hc2tNb2RlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY3VycmVudCA9IHRoaXMuc3RhdGVTdGFjay5wb3AoKTtcbiAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgaWYgKHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIGNvcHlDdHhTdGF0ZSh0aGlzLnN1c3BlbmRlZEN0eCwgdGhpcy5jdHgpO1xuICAgIH1cbiAgICB0aGlzLmNoZWNrU01hc2tTdGF0ZSgpO1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPSAtMTtcbiAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgfVxuICB0cmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZikge1xuICAgIHRoaXMuY3R4LnRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gLTE7XG4gICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IG51bGw7XG4gIH1cbiAgY29uc3RydWN0UGF0aChvcCwgZGF0YSwgbWluTWF4KSB7XG4gICAgbGV0IFtwYXRoXSA9IGRhdGE7XG4gICAgaWYgKCFtaW5NYXgpIHtcbiAgICAgIHBhdGggfHw9IGRhdGFbMF0gPSBuZXcgUGF0aDJEKCk7XG4gICAgICB0aGlzW29wXShwYXRoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEocGF0aCBpbnN0YW5jZW9mIFBhdGgyRCkpIHtcbiAgICAgIGNvbnN0IHBhdGgyZCA9IGRhdGFbMF0gPSBuZXcgUGF0aDJEKCk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwYXRoLmxlbmd0aDsgaSA8IGlpOykge1xuICAgICAgICBzd2l0Y2ggKHBhdGhbaSsrXSkge1xuICAgICAgICAgIGNhc2UgRHJhd09QUy5tb3ZlVG86XG4gICAgICAgICAgICBwYXRoMmQubW92ZVRvKHBhdGhbaSsrXSwgcGF0aFtpKytdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRHJhd09QUy5saW5lVG86XG4gICAgICAgICAgICBwYXRoMmQubGluZVRvKHBhdGhbaSsrXSwgcGF0aFtpKytdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRHJhd09QUy5jdXJ2ZVRvOlxuICAgICAgICAgICAgcGF0aDJkLmJlemllckN1cnZlVG8ocGF0aFtpKytdLCBwYXRoW2krK10sIHBhdGhbaSsrXSwgcGF0aFtpKytdLCBwYXRoW2krK10sIHBhdGhbaSsrXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIERyYXdPUFMuY2xvc2VQYXRoOlxuICAgICAgICAgICAgcGF0aDJkLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHdhcm4oYFVucmVjb2duaXplZCBkcmF3aW5nIHBhdGggb3BlcmF0b3I6ICR7cGF0aFtpIC0gMV19YCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGF0aCA9IHBhdGgyZDtcbiAgICB9XG4gICAgVXRpbC5heGlhbEFsaWduZWRCb3VuZGluZ0JveChtaW5NYXgsIGdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jdHgpLCB0aGlzLmN1cnJlbnQubWluTWF4KTtcbiAgICB0aGlzW29wXShwYXRoKTtcbiAgfVxuICBjbG9zZVBhdGgoKSB7XG4gICAgdGhpcy5jdHguY2xvc2VQYXRoKCk7XG4gIH1cbiAgc3Ryb2tlKHBhdGgsIGNvbnN1bWVQYXRoID0gdHJ1ZSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHN0cm9rZUNvbG9yID0gdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yO1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuY3VycmVudC5zdHJva2VBbHBoYTtcbiAgICBpZiAodGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgaWYgKHR5cGVvZiBzdHJva2VDb2xvciA9PT0gXCJvYmplY3RcIiAmJiBzdHJva2VDb2xvcj8uZ2V0UGF0dGVybikge1xuICAgICAgICBjb25zdCBiYXNlVHJhbnNmb3JtID0gc3Ryb2tlQ29sb3IuaXNNb2RpZnlpbmdDdXJyZW50VHJhbnNmb3JtKCkgPyBjdHguZ2V0VHJhbnNmb3JtKCkgOiBudWxsO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VDb2xvci5nZXRQYXR0ZXJuKGN0eCwgdGhpcywgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSwgUGF0aFR5cGUuU1RST0tFKTtcbiAgICAgICAgaWYgKGJhc2VUcmFuc2Zvcm0pIHtcbiAgICAgICAgICBjb25zdCBuZXdQYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgICAgICAgIG5ld1BhdGguYWRkUGF0aChwYXRoLCBjdHguZ2V0VHJhbnNmb3JtKCkuaW52ZXJ0U2VsZigpLm11bHRpcGx5U2VsZihiYXNlVHJhbnNmb3JtKSk7XG4gICAgICAgICAgcGF0aCA9IG5ld1BhdGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNjYWxlQW5kU3Ryb2tlKHBhdGgsIGZhbHNlKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVzY2FsZUFuZFN0cm9rZShwYXRoLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbnN1bWVQYXRoKSB7XG4gICAgICB0aGlzLmNvbnN1bWVQYXRoKHBhdGgsIHRoaXMuY3VycmVudC5nZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KFBhdGhUeXBlLlNUUk9LRSwgZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmN0eCkpKTtcbiAgICB9XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5jdXJyZW50LmZpbGxBbHBoYTtcbiAgfVxuICBjbG9zZVN0cm9rZShwYXRoKSB7XG4gICAgdGhpcy5zdHJva2UocGF0aCk7XG4gIH1cbiAgZmlsbChwYXRoLCBjb25zdW1lUGF0aCA9IHRydWUpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBmaWxsQ29sb3IgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yO1xuICAgIGNvbnN0IGlzUGF0dGVybkZpbGwgPSB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgbGV0IG5lZWRSZXN0b3JlID0gZmFsc2U7XG4gICAgaWYgKGlzUGF0dGVybkZpbGwpIHtcbiAgICAgIGNvbnN0IGJhc2VUcmFuc2Zvcm0gPSBmaWxsQ29sb3IuaXNNb2RpZnlpbmdDdXJyZW50VHJhbnNmb3JtKCkgPyBjdHguZ2V0VHJhbnNmb3JtKCkgOiBudWxsO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCksIFBhdGhUeXBlLkZJTEwpO1xuICAgICAgaWYgKGJhc2VUcmFuc2Zvcm0pIHtcbiAgICAgICAgY29uc3QgbmV3UGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgbmV3UGF0aC5hZGRQYXRoKHBhdGgsIGN0eC5nZXRUcmFuc2Zvcm0oKS5pbnZlcnRTZWxmKCkubXVsdGlwbHlTZWxmKGJhc2VUcmFuc2Zvcm0pKTtcbiAgICAgICAgcGF0aCA9IG5ld1BhdGg7XG4gICAgICB9XG4gICAgICBuZWVkUmVzdG9yZSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGludGVyc2VjdCA9IHRoaXMuY3VycmVudC5nZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KCk7XG4gICAgaWYgKHRoaXMuY29udGVudFZpc2libGUgJiYgaW50ZXJzZWN0ICE9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5wZW5kaW5nRU9GaWxsKSB7XG4gICAgICAgIGN0eC5maWxsKHBhdGgsIFwiZXZlbm9kZFwiKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nRU9GaWxsID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHguZmlsbChwYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5lZWRSZXN0b3JlKSB7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICBpZiAoY29uc3VtZVBhdGgpIHtcbiAgICAgIHRoaXMuY29uc3VtZVBhdGgocGF0aCwgaW50ZXJzZWN0KTtcbiAgICB9XG4gIH1cbiAgZW9GaWxsKHBhdGgpIHtcbiAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSB0cnVlO1xuICAgIHRoaXMuZmlsbChwYXRoKTtcbiAgfVxuICBmaWxsU3Ryb2tlKHBhdGgpIHtcbiAgICB0aGlzLmZpbGwocGF0aCwgZmFsc2UpO1xuICAgIHRoaXMuc3Ryb2tlKHBhdGgsIGZhbHNlKTtcbiAgICB0aGlzLmNvbnN1bWVQYXRoKHBhdGgpO1xuICB9XG4gIGVvRmlsbFN0cm9rZShwYXRoKSB7XG4gICAgdGhpcy5wZW5kaW5nRU9GaWxsID0gdHJ1ZTtcbiAgICB0aGlzLmZpbGxTdHJva2UocGF0aCk7XG4gIH1cbiAgY2xvc2VGaWxsU3Ryb2tlKHBhdGgpIHtcbiAgICB0aGlzLmZpbGxTdHJva2UocGF0aCk7XG4gIH1cbiAgY2xvc2VFT0ZpbGxTdHJva2UocGF0aCkge1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IHRydWU7XG4gICAgdGhpcy5maWxsU3Ryb2tlKHBhdGgpO1xuICB9XG4gIGVuZFBhdGgocGF0aCkge1xuICAgIHRoaXMuY29uc3VtZVBhdGgocGF0aCk7XG4gIH1cbiAgcmF3RmlsbFBhdGgocGF0aCkge1xuICAgIHRoaXMuY3R4LmZpbGwocGF0aCk7XG4gIH1cbiAgY2xpcCgpIHtcbiAgICB0aGlzLnBlbmRpbmdDbGlwID0gTk9STUFMX0NMSVA7XG4gIH1cbiAgZW9DbGlwKCkge1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBFT19DTElQO1xuICB9XG4gIGJlZ2luVGV4dCgpIHtcbiAgICB0aGlzLmN1cnJlbnQudGV4dE1hdHJpeCA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50LnRleHRNYXRyaXhTY2FsZSA9IDE7XG4gICAgdGhpcy5jdXJyZW50LnggPSB0aGlzLmN1cnJlbnQubGluZVggPSAwO1xuICAgIHRoaXMuY3VycmVudC55ID0gdGhpcy5jdXJyZW50LmxpbmVZID0gMDtcbiAgfVxuICBlbmRUZXh0KCkge1xuICAgIGNvbnN0IHBhdGhzID0gdGhpcy5wZW5kaW5nVGV4dFBhdGhzO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGlmIChwYXRocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5ld1BhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgY29uc3QgaW52VHJhbnNmID0gY3R4LmdldFRyYW5zZm9ybSgpLmludmVydFNlbGYoKTtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgZm9udFNpemUsXG4gICAgICBwYXRoXG4gICAgfSBvZiBwYXRocykge1xuICAgICAgbmV3UGF0aC5hZGRQYXRoKHBhdGgsIG5ldyBET01NYXRyaXgodHJhbnNmb3JtKS5wcmVNdWx0aXBseVNlbGYoaW52VHJhbnNmKS50cmFuc2xhdGUoeCwgeSkuc2NhbGUoZm9udFNpemUsIC1mb250U2l6ZSkpO1xuICAgIH1cbiAgICBjdHguY2xpcChuZXdQYXRoKTtcbiAgICBkZWxldGUgdGhpcy5wZW5kaW5nVGV4dFBhdGhzO1xuICB9XG4gIHNldENoYXJTcGFjaW5nKHNwYWNpbmcpIHtcbiAgICB0aGlzLmN1cnJlbnQuY2hhclNwYWNpbmcgPSBzcGFjaW5nO1xuICB9XG4gIHNldFdvcmRTcGFjaW5nKHNwYWNpbmcpIHtcbiAgICB0aGlzLmN1cnJlbnQud29yZFNwYWNpbmcgPSBzcGFjaW5nO1xuICB9XG4gIHNldEhTY2FsZShzY2FsZSkge1xuICAgIHRoaXMuY3VycmVudC50ZXh0SFNjYWxlID0gc2NhbGUgLyAxMDA7XG4gIH1cbiAgc2V0TGVhZGluZyhsZWFkaW5nKSB7XG4gICAgdGhpcy5jdXJyZW50LmxlYWRpbmcgPSAtbGVhZGluZztcbiAgfVxuICBzZXRGb250KGZvbnRSZWZOYW1lLCBzaXplKSB7XG4gICAgY29uc3QgZm9udE9iaiA9IHRoaXMuY29tbW9uT2Jqcy5nZXQoZm9udFJlZk5hbWUpO1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgaWYgKCFmb250T2JqKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGZpbmQgZm9udCBmb3IgJHtmb250UmVmTmFtZX1gKTtcbiAgICB9XG4gICAgY3VycmVudC5mb250TWF0cml4ID0gZm9udE9iai5mb250TWF0cml4IHx8IEZPTlRfSURFTlRJVFlfTUFUUklYO1xuICAgIGlmIChjdXJyZW50LmZvbnRNYXRyaXhbMF0gPT09IDAgfHwgY3VycmVudC5mb250TWF0cml4WzNdID09PSAwKSB7XG4gICAgICB3YXJuKFwiSW52YWxpZCBmb250IG1hdHJpeCBmb3IgZm9udCBcIiArIGZvbnRSZWZOYW1lKTtcbiAgICB9XG4gICAgaWYgKHNpemUgPCAwKSB7XG4gICAgICBzaXplID0gLXNpemU7XG4gICAgICBjdXJyZW50LmZvbnREaXJlY3Rpb24gPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudC5mb250RGlyZWN0aW9uID0gMTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LmZvbnQgPSBmb250T2JqO1xuICAgIHRoaXMuY3VycmVudC5mb250U2l6ZSA9IHNpemU7XG4gICAgaWYgKGZvbnRPYmouaXNUeXBlM0ZvbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IGZvbnRPYmoubG9hZGVkTmFtZSB8fCBcInNhbnMtc2VyaWZcIjtcbiAgICBjb25zdCB0eXBlZmFjZSA9IGZvbnRPYmouc3lzdGVtRm9udEluZm8/LmNzcyB8fCBgXCIke25hbWV9XCIsICR7Zm9udE9iai5mYWxsYmFja05hbWV9YDtcbiAgICBsZXQgYm9sZCA9IFwibm9ybWFsXCI7XG4gICAgaWYgKGZvbnRPYmouYmxhY2spIHtcbiAgICAgIGJvbGQgPSBcIjkwMFwiO1xuICAgIH0gZWxzZSBpZiAoZm9udE9iai5ib2xkKSB7XG4gICAgICBib2xkID0gXCJib2xkXCI7XG4gICAgfVxuICAgIGNvbnN0IGl0YWxpYyA9IGZvbnRPYmouaXRhbGljID8gXCJpdGFsaWNcIiA6IFwibm9ybWFsXCI7XG4gICAgbGV0IGJyb3dzZXJGb250U2l6ZSA9IHNpemU7XG4gICAgaWYgKHNpemUgPCBNSU5fRk9OVF9TSVpFKSB7XG4gICAgICBicm93c2VyRm9udFNpemUgPSBNSU5fRk9OVF9TSVpFO1xuICAgIH0gZWxzZSBpZiAoc2l6ZSA+IE1BWF9GT05UX1NJWkUpIHtcbiAgICAgIGJyb3dzZXJGb250U2l6ZSA9IE1BWF9GT05UX1NJWkU7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5mb250U2l6ZVNjYWxlID0gc2l6ZSAvIGJyb3dzZXJGb250U2l6ZTtcbiAgICB0aGlzLmN0eC5mb250ID0gYCR7aXRhbGljfSAke2JvbGR9ICR7YnJvd3NlckZvbnRTaXplfXB4ICR7dHlwZWZhY2V9YDtcbiAgfVxuICBzZXRUZXh0UmVuZGVyaW5nTW9kZShtb2RlKSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlID0gbW9kZTtcbiAgfVxuICBzZXRUZXh0UmlzZShyaXNlKSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRSaXNlID0gcmlzZTtcbiAgfVxuICBtb3ZlVGV4dCh4LCB5KSB7XG4gICAgdGhpcy5jdXJyZW50LnggPSB0aGlzLmN1cnJlbnQubGluZVggKz0geDtcbiAgICB0aGlzLmN1cnJlbnQueSA9IHRoaXMuY3VycmVudC5saW5lWSArPSB5O1xuICB9XG4gIHNldExlYWRpbmdNb3ZlVGV4dCh4LCB5KSB7XG4gICAgdGhpcy5zZXRMZWFkaW5nKC15KTtcbiAgICB0aGlzLm1vdmVUZXh0KHgsIHkpO1xuICB9XG4gIHNldFRleHRNYXRyaXgobWF0cml4KSB7XG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudFxuICAgIH0gPSB0aGlzO1xuICAgIGN1cnJlbnQudGV4dE1hdHJpeCA9IG1hdHJpeDtcbiAgICBjdXJyZW50LnRleHRNYXRyaXhTY2FsZSA9IE1hdGguaHlwb3QobWF0cml4WzBdLCBtYXRyaXhbMV0pO1xuICAgIGN1cnJlbnQueCA9IGN1cnJlbnQubGluZVggPSAwO1xuICAgIGN1cnJlbnQueSA9IGN1cnJlbnQubGluZVkgPSAwO1xuICB9XG4gIG5leHRMaW5lKCkge1xuICAgIHRoaXMubW92ZVRleHQoMCwgdGhpcy5jdXJyZW50LmxlYWRpbmcpO1xuICB9XG4gICNnZXRTY2FsZWRQYXRoKHBhdGgsIGN1cnJlbnRUcmFuc2Zvcm0sIHRyYW5zZm9ybSkge1xuICAgIGNvbnN0IG5ld1BhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgbmV3UGF0aC5hZGRQYXRoKHBhdGgsIG5ldyBET01NYXRyaXgodHJhbnNmb3JtKS5pbnZlcnRTZWxmKCkubXVsdGlwbHlTZWxmKGN1cnJlbnRUcmFuc2Zvcm0pKTtcbiAgICByZXR1cm4gbmV3UGF0aDtcbiAgfVxuICBwYWludENoYXIoY2hhcmFjdGVyLCB4LCB5LCBwYXR0ZXJuRmlsbFRyYW5zZm9ybSwgcGF0dGVyblN0cm9rZVRyYW5zZm9ybSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgY29uc3QgZm9udCA9IGN1cnJlbnQuZm9udDtcbiAgICBjb25zdCB0ZXh0UmVuZGVyaW5nTW9kZSA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGU7XG4gICAgY29uc3QgZm9udFNpemUgPSBjdXJyZW50LmZvbnRTaXplIC8gY3VycmVudC5mb250U2l6ZVNjYWxlO1xuICAgIGNvbnN0IGZpbGxTdHJva2VNb2RlID0gdGV4dFJlbmRlcmluZ01vZGUgJiBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRV9NQVNLO1xuICAgIGNvbnN0IGlzQWRkVG9QYXRoU2V0ID0gISEodGV4dFJlbmRlcmluZ01vZGUgJiBUZXh0UmVuZGVyaW5nTW9kZS5BRERfVE9fUEFUSF9GTEFHKTtcbiAgICBjb25zdCBwYXR0ZXJuRmlsbCA9IGN1cnJlbnQucGF0dGVybkZpbGwgJiYgIWZvbnQubWlzc2luZ0ZpbGU7XG4gICAgY29uc3QgcGF0dGVyblN0cm9rZSA9IGN1cnJlbnQucGF0dGVyblN0cm9rZSAmJiAhZm9udC5taXNzaW5nRmlsZTtcbiAgICBsZXQgcGF0aDtcbiAgICBpZiAoZm9udC5kaXNhYmxlRm9udEZhY2UgfHwgaXNBZGRUb1BhdGhTZXQgfHwgcGF0dGVybkZpbGwgfHwgcGF0dGVyblN0cm9rZSkge1xuICAgICAgcGF0aCA9IGZvbnQuZ2V0UGF0aEdlbmVyYXRvcih0aGlzLmNvbW1vbk9ianMsIGNoYXJhY3Rlcik7XG4gICAgfVxuICAgIGlmIChmb250LmRpc2FibGVGb250RmFjZSB8fCBwYXR0ZXJuRmlsbCB8fCBwYXR0ZXJuU3Ryb2tlKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgIGN0eC5zY2FsZShmb250U2l6ZSwgLWZvbnRTaXplKTtcbiAgICAgIGxldCBjdXJyZW50VHJhbnNmb3JtO1xuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMIHx8IGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICBpZiAocGF0dGVybkZpbGxUcmFuc2Zvcm0pIHtcbiAgICAgICAgICBjdXJyZW50VHJhbnNmb3JtID0gY3R4LmdldFRyYW5zZm9ybSgpO1xuICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oLi4ucGF0dGVybkZpbGxUcmFuc2Zvcm0pO1xuICAgICAgICAgIGN0eC5maWxsKHRoaXMuI2dldFNjYWxlZFBhdGgocGF0aCwgY3VycmVudFRyYW5zZm9ybSwgcGF0dGVybkZpbGxUcmFuc2Zvcm0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHguZmlsbChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5TVFJPS0UgfHwgZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGlmIChwYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtKSB7XG4gICAgICAgICAgY3VycmVudFRyYW5zZm9ybSB8fD0gY3R4LmdldFRyYW5zZm9ybSgpO1xuICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oLi4ucGF0dGVyblN0cm9rZVRyYW5zZm9ybSk7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgZFxuICAgICAgICAgIH0gPSBjdXJyZW50VHJhbnNmb3JtO1xuICAgICAgICAgIGNvbnN0IGludlBhdHRlcm5UcmFuc2Zvcm0gPSBVdGlsLmludmVyc2VUcmFuc2Zvcm0ocGF0dGVyblN0cm9rZVRyYW5zZm9ybSk7XG4gICAgICAgICAgY29uc3QgdHJhbnNmID0gVXRpbC50cmFuc2Zvcm0oW2EsIGIsIGMsIGQsIDAsIDBdLCBpbnZQYXR0ZXJuVHJhbnNmb3JtKTtcbiAgICAgICAgICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRyYW5zZiwgWFkpO1xuICAgICAgICAgIGN0eC5saW5lV2lkdGggKj0gTWF0aC5tYXgoWFlbMF0sIFhZWzFdKSAvIGZvbnRTaXplO1xuICAgICAgICAgIGN0eC5zdHJva2UodGhpcy4jZ2V0U2NhbGVkUGF0aChwYXRoLCBjdXJyZW50VHJhbnNmb3JtLCBwYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LmxpbmVXaWR0aCAvPSBmb250U2l6ZTtcbiAgICAgICAgICBjdHguc3Ryb2tlKHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTEwgfHwgZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dChjaGFyYWN0ZXIsIHgsIHkpO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5TVFJPS0UgfHwgZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGN0eC5zdHJva2VUZXh0KGNoYXJhY3RlciwgeCwgeSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0FkZFRvUGF0aFNldCkge1xuICAgICAgY29uc3QgcGF0aHMgPSB0aGlzLnBlbmRpbmdUZXh0UGF0aHMgfHw9IFtdO1xuICAgICAgcGF0aHMucHVzaCh7XG4gICAgICAgIHRyYW5zZm9ybTogZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgcGF0aFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCBpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0OiBjdHhcbiAgICB9ID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZFwiLCAxMCwgMTApO1xuICAgIGN0eC5zY2FsZSgxLjUsIDEpO1xuICAgIGN0eC5maWxsVGV4dChcIklcIiwgMCwgMTApO1xuICAgIGNvbnN0IGRhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEwLCAxMCkuZGF0YTtcbiAgICBsZXQgZW5hYmxlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAzOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgaWYgKGRhdGFbaV0gPiAwICYmIGRhdGFbaV0gPCAyNTUpIHtcbiAgICAgICAgZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNGb250U3VicGl4ZWxBQUVuYWJsZWRcIiwgZW5hYmxlZCk7XG4gIH1cbiAgc2hvd1RleHQoZ2x5cGhzKSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBjb25zdCBmb250ID0gY3VycmVudC5mb250O1xuICAgIGlmIChmb250LmlzVHlwZTNGb250KSB7XG4gICAgICByZXR1cm4gdGhpcy5zaG93VHlwZTNUZXh0KGdseXBocyk7XG4gICAgfVxuICAgIGNvbnN0IGZvbnRTaXplID0gY3VycmVudC5mb250U2l6ZTtcbiAgICBpZiAoZm9udFNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGZvbnRTaXplU2NhbGUgPSBjdXJyZW50LmZvbnRTaXplU2NhbGU7XG4gICAgY29uc3QgY2hhclNwYWNpbmcgPSBjdXJyZW50LmNoYXJTcGFjaW5nO1xuICAgIGNvbnN0IHdvcmRTcGFjaW5nID0gY3VycmVudC53b3JkU3BhY2luZztcbiAgICBjb25zdCBmb250RGlyZWN0aW9uID0gY3VycmVudC5mb250RGlyZWN0aW9uO1xuICAgIGNvbnN0IHRleHRIU2NhbGUgPSBjdXJyZW50LnRleHRIU2NhbGUgKiBmb250RGlyZWN0aW9uO1xuICAgIGNvbnN0IGdseXBoc0xlbmd0aCA9IGdseXBocy5sZW5ndGg7XG4gICAgY29uc3QgdmVydGljYWwgPSBmb250LnZlcnRpY2FsO1xuICAgIGNvbnN0IHNwYWNpbmdEaXIgPSB2ZXJ0aWNhbCA/IDEgOiAtMTtcbiAgICBjb25zdCBkZWZhdWx0Vk1ldHJpY3MgPSBmb250LmRlZmF1bHRWTWV0cmljcztcbiAgICBjb25zdCB3aWR0aEFkdmFuY2VTY2FsZSA9IGZvbnRTaXplICogY3VycmVudC5mb250TWF0cml4WzBdO1xuICAgIGNvbnN0IHNpbXBsZUZpbGxUZXh0ID0gY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTCAmJiAhZm9udC5kaXNhYmxlRm9udEZhY2UgJiYgIWN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBpZiAoY3VycmVudC50ZXh0TWF0cml4KSB7XG4gICAgICBjdHgudHJhbnNmb3JtKC4uLmN1cnJlbnQudGV4dE1hdHJpeCk7XG4gICAgfVxuICAgIGN0eC50cmFuc2xhdGUoY3VycmVudC54LCBjdXJyZW50LnkgKyBjdXJyZW50LnRleHRSaXNlKTtcbiAgICBpZiAoZm9udERpcmVjdGlvbiA+IDApIHtcbiAgICAgIGN0eC5zY2FsZSh0ZXh0SFNjYWxlLCAtMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5zY2FsZSh0ZXh0SFNjYWxlLCAxKTtcbiAgICB9XG4gICAgbGV0IHBhdHRlcm5GaWxsVHJhbnNmb3JtLCBwYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtO1xuICAgIGlmIChjdXJyZW50LnBhdHRlcm5GaWxsKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY29uc3QgcGF0dGVybiA9IGN1cnJlbnQuZmlsbENvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzLCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpLCBQYXRoVHlwZS5GSUxMKTtcbiAgICAgIHBhdHRlcm5GaWxsVHJhbnNmb3JtID0gZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBwYXR0ZXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudC5wYXR0ZXJuU3Ryb2tlKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY29uc3QgcGF0dGVybiA9IGN1cnJlbnQuc3Ryb2tlQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCksIFBhdGhUeXBlLlNUUk9LRSk7XG4gICAgICBwYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtID0gZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHBhdHRlcm47XG4gICAgfVxuICAgIGxldCBsaW5lV2lkdGggPSBjdXJyZW50LmxpbmVXaWR0aDtcbiAgICBjb25zdCBzY2FsZSA9IGN1cnJlbnQudGV4dE1hdHJpeFNjYWxlO1xuICAgIGlmIChzY2FsZSA9PT0gMCB8fCBsaW5lV2lkdGggPT09IDApIHtcbiAgICAgIGNvbnN0IGZpbGxTdHJva2VNb2RlID0gY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSAmIFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFX01BU0s7XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgbGluZVdpZHRoID0gdGhpcy5nZXRTaW5nbGVQaXhlbFdpZHRoKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVXaWR0aCAvPSBzY2FsZTtcbiAgICB9XG4gICAgaWYgKGZvbnRTaXplU2NhbGUgIT09IDEuMCkge1xuICAgICAgY3R4LnNjYWxlKGZvbnRTaXplU2NhbGUsIGZvbnRTaXplU2NhbGUpO1xuICAgICAgbGluZVdpZHRoIC89IGZvbnRTaXplU2NhbGU7XG4gICAgfVxuICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgaWYgKGZvbnQuaXNJbnZhbGlkUERGanNGb250KSB7XG4gICAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgICAgbGV0IHdpZHRoID0gMDtcbiAgICAgIGZvciAoY29uc3QgZ2x5cGggb2YgZ2x5cGhzKSB7XG4gICAgICAgIGNoYXJzLnB1c2goZ2x5cGgudW5pY29kZSk7XG4gICAgICAgIHdpZHRoICs9IGdseXBoLndpZHRoO1xuICAgICAgfVxuICAgICAgY3R4LmZpbGxUZXh0KGNoYXJzLmpvaW4oXCJcIiksIDAsIDApO1xuICAgICAgY3VycmVudC54ICs9IHdpZHRoICogd2lkdGhBZHZhbmNlU2NhbGUgKiB0ZXh0SFNjYWxlO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuY29tcG9zZSgpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IHggPSAwLFxuICAgICAgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzTGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBnbHlwaCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB4ICs9IHNwYWNpbmdEaXIgKiBnbHlwaCAqIGZvbnRTaXplIC8gMTAwMDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgcmVzdG9yZU5lZWRlZCA9IGZhbHNlO1xuICAgICAgY29uc3Qgc3BhY2luZyA9IChnbHlwaC5pc1NwYWNlID8gd29yZFNwYWNpbmcgOiAwKSArIGNoYXJTcGFjaW5nO1xuICAgICAgY29uc3QgY2hhcmFjdGVyID0gZ2x5cGguZm9udENoYXI7XG4gICAgICBjb25zdCBhY2NlbnQgPSBnbHlwaC5hY2NlbnQ7XG4gICAgICBsZXQgc2NhbGVkWCwgc2NhbGVkWTtcbiAgICAgIGxldCB3aWR0aCA9IGdseXBoLndpZHRoO1xuICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgIGNvbnN0IHZtZXRyaWMgPSBnbHlwaC52bWV0cmljIHx8IGRlZmF1bHRWTWV0cmljcztcbiAgICAgICAgY29uc3QgdnggPSAtKGdseXBoLnZtZXRyaWMgPyB2bWV0cmljWzFdIDogd2lkdGggKiAwLjUpICogd2lkdGhBZHZhbmNlU2NhbGU7XG4gICAgICAgIGNvbnN0IHZ5ID0gdm1ldHJpY1syXSAqIHdpZHRoQWR2YW5jZVNjYWxlO1xuICAgICAgICB3aWR0aCA9IHZtZXRyaWMgPyAtdm1ldHJpY1swXSA6IHdpZHRoO1xuICAgICAgICBzY2FsZWRYID0gdnggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICBzY2FsZWRZID0gKHggKyB2eSkgLyBmb250U2l6ZVNjYWxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NhbGVkWCA9IHggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICBzY2FsZWRZID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChmb250LnJlbWVhc3VyZSAmJiB3aWR0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbWVhc3VyZWRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChjaGFyYWN0ZXIpLndpZHRoICogMTAwMCAvIGZvbnRTaXplICogZm9udFNpemVTY2FsZTtcbiAgICAgICAgaWYgKHdpZHRoIDwgbWVhc3VyZWRXaWR0aCAmJiB0aGlzLmlzRm9udFN1YnBpeGVsQUFFbmFibGVkKSB7XG4gICAgICAgICAgY29uc3QgY2hhcmFjdGVyU2NhbGVYID0gd2lkdGggLyBtZWFzdXJlZFdpZHRoO1xuICAgICAgICAgIHJlc3RvcmVOZWVkZWQgPSB0cnVlO1xuICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgY3R4LnNjYWxlKGNoYXJhY3RlclNjYWxlWCwgMSk7XG4gICAgICAgICAgc2NhbGVkWCAvPSBjaGFyYWN0ZXJTY2FsZVg7XG4gICAgICAgIH0gZWxzZSBpZiAod2lkdGggIT09IG1lYXN1cmVkV2lkdGgpIHtcbiAgICAgICAgICBzY2FsZWRYICs9ICh3aWR0aCAtIG1lYXN1cmVkV2lkdGgpIC8gMjAwMCAqIGZvbnRTaXplIC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29udGVudFZpc2libGUgJiYgKGdseXBoLmlzSW5Gb250IHx8IGZvbnQubWlzc2luZ0ZpbGUpKSB7XG4gICAgICAgIGlmIChzaW1wbGVGaWxsVGV4dCAmJiAhYWNjZW50KSB7XG4gICAgICAgICAgY3R4LmZpbGxUZXh0KGNoYXJhY3Rlciwgc2NhbGVkWCwgc2NhbGVkWSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wYWludENoYXIoY2hhcmFjdGVyLCBzY2FsZWRYLCBzY2FsZWRZLCBwYXR0ZXJuRmlsbFRyYW5zZm9ybSwgcGF0dGVyblN0cm9rZVRyYW5zZm9ybSk7XG4gICAgICAgICAgaWYgKGFjY2VudCkge1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVkQWNjZW50WCA9IHNjYWxlZFggKyBmb250U2l6ZSAqIGFjY2VudC5vZmZzZXQueCAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWRBY2NlbnRZID0gc2NhbGVkWSAtIGZvbnRTaXplICogYWNjZW50Lm9mZnNldC55IC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgICAgIHRoaXMucGFpbnRDaGFyKGFjY2VudC5mb250Q2hhciwgc2NhbGVkQWNjZW50WCwgc2NhbGVkQWNjZW50WSwgcGF0dGVybkZpbGxUcmFuc2Zvcm0sIHBhdHRlcm5TdHJva2VUcmFuc2Zvcm0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY2hhcldpZHRoID0gdmVydGljYWwgPyB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlIC0gc3BhY2luZyAqIGZvbnREaXJlY3Rpb24gOiB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlICsgc3BhY2luZyAqIGZvbnREaXJlY3Rpb247XG4gICAgICB4ICs9IGNoYXJXaWR0aDtcbiAgICAgIGlmIChyZXN0b3JlTmVlZGVkKSB7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgY3VycmVudC55IC09IHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQueCArPSB4ICogdGV4dEhTY2FsZTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHNob3dUeXBlM1RleHQoZ2x5cGhzKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBjb25zdCBmb250ID0gY3VycmVudC5mb250O1xuICAgIGNvbnN0IGZvbnRTaXplID0gY3VycmVudC5mb250U2l6ZTtcbiAgICBjb25zdCBmb250RGlyZWN0aW9uID0gY3VycmVudC5mb250RGlyZWN0aW9uO1xuICAgIGNvbnN0IHNwYWNpbmdEaXIgPSBmb250LnZlcnRpY2FsID8gMSA6IC0xO1xuICAgIGNvbnN0IGNoYXJTcGFjaW5nID0gY3VycmVudC5jaGFyU3BhY2luZztcbiAgICBjb25zdCB3b3JkU3BhY2luZyA9IGN1cnJlbnQud29yZFNwYWNpbmc7XG4gICAgY29uc3QgdGV4dEhTY2FsZSA9IGN1cnJlbnQudGV4dEhTY2FsZSAqIGZvbnREaXJlY3Rpb247XG4gICAgY29uc3QgZm9udE1hdHJpeCA9IGN1cnJlbnQuZm9udE1hdHJpeCB8fCBGT05UX0lERU5USVRZX01BVFJJWDtcbiAgICBjb25zdCBnbHlwaHNMZW5ndGggPSBnbHlwaHMubGVuZ3RoO1xuICAgIGNvbnN0IGlzVGV4dEludmlzaWJsZSA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLklOVklTSUJMRTtcbiAgICBsZXQgaSwgZ2x5cGgsIHdpZHRoLCBzcGFjaW5nTGVuZ3RoO1xuICAgIGlmIChpc1RleHRJbnZpc2libGUgfHwgZm9udFNpemUgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9IC0xO1xuICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBudWxsO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgaWYgKGN1cnJlbnQudGV4dE1hdHJpeCkge1xuICAgICAgY3R4LnRyYW5zZm9ybSguLi5jdXJyZW50LnRleHRNYXRyaXgpO1xuICAgIH1cbiAgICBjdHgudHJhbnNsYXRlKGN1cnJlbnQueCwgY3VycmVudC55ICsgY3VycmVudC50ZXh0UmlzZSk7XG4gICAgY3R4LnNjYWxlKHRleHRIU2NhbGUsIGZvbnREaXJlY3Rpb24pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBnbHlwaHNMZW5ndGg7ICsraSkge1xuICAgICAgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICBpZiAodHlwZW9mIGdseXBoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHNwYWNpbmdMZW5ndGggPSBzcGFjaW5nRGlyICogZ2x5cGggKiBmb250U2l6ZSAvIDEwMDA7XG4gICAgICAgIHRoaXMuY3R4LnRyYW5zbGF0ZShzcGFjaW5nTGVuZ3RoLCAwKTtcbiAgICAgICAgY3VycmVudC54ICs9IHNwYWNpbmdMZW5ndGggKiB0ZXh0SFNjYWxlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNwYWNpbmcgPSAoZ2x5cGguaXNTcGFjZSA/IHdvcmRTcGFjaW5nIDogMCkgKyBjaGFyU3BhY2luZztcbiAgICAgIGNvbnN0IG9wZXJhdG9yTGlzdCA9IGZvbnQuY2hhclByb2NPcGVyYXRvckxpc3RbZ2x5cGgub3BlcmF0b3JMaXN0SWRdO1xuICAgICAgaWYgKCFvcGVyYXRvckxpc3QpIHtcbiAgICAgICAgd2FybihgVHlwZTMgY2hhcmFjdGVyIFwiJHtnbHlwaC5vcGVyYXRvckxpc3RJZH1cIiBpcyBub3QgYXZhaWxhYmxlLmApO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgICBjdHguc2NhbGUoZm9udFNpemUsIGZvbnRTaXplKTtcbiAgICAgICAgY3R4LnRyYW5zZm9ybSguLi5mb250TWF0cml4KTtcbiAgICAgICAgdGhpcy5leGVjdXRlT3BlcmF0b3JMaXN0KG9wZXJhdG9yTGlzdCk7XG4gICAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgcCA9IFtnbHlwaC53aWR0aCwgMF07XG4gICAgICBVdGlsLmFwcGx5VHJhbnNmb3JtKHAsIGZvbnRNYXRyaXgpO1xuICAgICAgd2lkdGggPSBwWzBdICogZm9udFNpemUgKyBzcGFjaW5nO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh3aWR0aCwgMCk7XG4gICAgICBjdXJyZW50LnggKz0gd2lkdGggKiB0ZXh0SFNjYWxlO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG4gIHNldENoYXJXaWR0aCh4V2lkdGgsIHlXaWR0aCkge31cbiAgc2V0Q2hhcldpZHRoQW5kQm91bmRzKHhXaWR0aCwgeVdpZHRoLCBsbHgsIGxseSwgdXJ4LCB1cnkpIHtcbiAgICBjb25zdCBjbGlwID0gbmV3IFBhdGgyRCgpO1xuICAgIGNsaXAucmVjdChsbHgsIGxseSwgdXJ4IC0gbGx4LCB1cnkgLSBsbHkpO1xuICAgIHRoaXMuY3R4LmNsaXAoY2xpcCk7XG4gICAgdGhpcy5lbmRQYXRoKCk7XG4gIH1cbiAgZ2V0Q29sb3JOX1BhdHRlcm4oSVIpIHtcbiAgICBsZXQgcGF0dGVybjtcbiAgICBpZiAoSVJbMF0gPT09IFwiVGlsaW5nUGF0dGVyblwiKSB7XG4gICAgICBjb25zdCBiYXNlVHJhbnNmb3JtID0gdGhpcy5iYXNlVHJhbnNmb3JtIHx8IGdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jdHgpO1xuICAgICAgY29uc3QgY2FudmFzR3JhcGhpY3NGYWN0b3J5ID0ge1xuICAgICAgICBjcmVhdGVDYW52YXNHcmFwaGljczogY3R4ID0+IG5ldyBDYW52YXNHcmFwaGljcyhjdHgsIHRoaXMuY29tbW9uT2JqcywgdGhpcy5vYmpzLCB0aGlzLmNhbnZhc0ZhY3RvcnksIHRoaXMuZmlsdGVyRmFjdG9yeSwge1xuICAgICAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZzogdGhpcy5vcHRpb25hbENvbnRlbnRDb25maWcsXG4gICAgICAgICAgbWFya2VkQ29udGVudFN0YWNrOiB0aGlzLm1hcmtlZENvbnRlbnRTdGFja1xuICAgICAgICB9KVxuICAgICAgfTtcbiAgICAgIHBhdHRlcm4gPSBuZXcgVGlsaW5nUGF0dGVybihJUiwgdGhpcy5jdHgsIGNhbnZhc0dyYXBoaWNzRmFjdG9yeSwgYmFzZVRyYW5zZm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdHRlcm4gPSB0aGlzLl9nZXRQYXR0ZXJuKElSWzFdLCBJUlsyXSk7XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG4gIHNldFN0cm9rZUNvbG9yTigpIHtcbiAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSB0aGlzLmdldENvbG9yTl9QYXR0ZXJuKGFyZ3VtZW50cyk7XG4gICAgdGhpcy5jdXJyZW50LnBhdHRlcm5TdHJva2UgPSB0cnVlO1xuICB9XG4gIHNldEZpbGxDb2xvck4oKSB7XG4gICAgdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IHRoaXMuZ2V0Q29sb3JOX1BhdHRlcm4oYXJndW1lbnRzKTtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGwgPSB0cnVlO1xuICB9XG4gIHNldFN0cm9rZVJHQkNvbG9yKHIsIGcsIGIpIHtcbiAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY3VycmVudC5zdHJva2VDb2xvciA9IFV0aWwubWFrZUhleENvbG9yKHIsIGcsIGIpO1xuICAgIHRoaXMuY3VycmVudC5wYXR0ZXJuU3Ryb2tlID0gZmFsc2U7XG4gIH1cbiAgc2V0U3Ryb2tlVHJhbnNwYXJlbnQoKSB7XG4gICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG4gICAgdGhpcy5jdXJyZW50LnBhdHRlcm5TdHJva2UgPSBmYWxzZTtcbiAgfVxuICBzZXRGaWxsUkdCQ29sb3IociwgZywgYikge1xuICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvcihyLCBnLCBiKTtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGwgPSBmYWxzZTtcbiAgfVxuICBzZXRGaWxsVHJhbnNwYXJlbnQoKSB7XG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGwgPSBmYWxzZTtcbiAgfVxuICBfZ2V0UGF0dGVybihvYmpJZCwgbWF0cml4ID0gbnVsbCkge1xuICAgIGxldCBwYXR0ZXJuO1xuICAgIGlmICh0aGlzLmNhY2hlZFBhdHRlcm5zLmhhcyhvYmpJZCkpIHtcbiAgICAgIHBhdHRlcm4gPSB0aGlzLmNhY2hlZFBhdHRlcm5zLmdldChvYmpJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdHRlcm4gPSBnZXRTaGFkaW5nUGF0dGVybih0aGlzLmdldE9iamVjdChvYmpJZCkpO1xuICAgICAgdGhpcy5jYWNoZWRQYXR0ZXJucy5zZXQob2JqSWQsIHBhdHRlcm4pO1xuICAgIH1cbiAgICBpZiAobWF0cml4KSB7XG4gICAgICBwYXR0ZXJuLm1hdHJpeCA9IG1hdHJpeDtcbiAgICB9XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cbiAgc2hhZGluZ0ZpbGwob2JqSWQpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgdGhpcy5zYXZlKCk7XG4gICAgY29uc3QgcGF0dGVybiA9IHRoaXMuX2dldFBhdHRlcm4ob2JqSWQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBwYXR0ZXJuLmdldFBhdHRlcm4oY3R4LCB0aGlzLCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpLCBQYXRoVHlwZS5TSEFESU5HKTtcbiAgICBjb25zdCBpbnYgPSBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpO1xuICAgIGlmIChpbnYpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IGN0eC5jYW52YXM7XG4gICAgICBjb25zdCBtaW5NYXggPSBNSU5fTUFYX0lOSVQuc2xpY2UoKTtcbiAgICAgIFV0aWwuYXhpYWxBbGlnbmVkQm91bmRpbmdCb3goWzAsIDAsIHdpZHRoLCBoZWlnaHRdLCBpbnYsIG1pbk1heCk7XG4gICAgICBjb25zdCBbeDAsIHkwLCB4MSwgeTFdID0gbWluTWF4O1xuICAgICAgdGhpcy5jdHguZmlsbFJlY3QoeDAsIHkwLCB4MSAtIHgwLCB5MSAtIHkwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHguZmlsbFJlY3QoLTFlMTAsIC0xZTEwLCAyZTEwLCAyZTEwKTtcbiAgICB9XG4gICAgdGhpcy5jb21wb3NlKHRoaXMuY3VycmVudC5nZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KCkpO1xuICAgIHRoaXMucmVzdG9yZSgpO1xuICB9XG4gIGJlZ2luSW5saW5lSW1hZ2UoKSB7XG4gICAgdW5yZWFjaGFibGUoXCJTaG91bGQgbm90IGNhbGwgYmVnaW5JbmxpbmVJbWFnZVwiKTtcbiAgfVxuICBiZWdpbkltYWdlRGF0YSgpIHtcbiAgICB1bnJlYWNoYWJsZShcIlNob3VsZCBub3QgY2FsbCBiZWdpbkltYWdlRGF0YVwiKTtcbiAgfVxuICBwYWludEZvcm1YT2JqZWN0QmVnaW4obWF0cml4LCBiYm94KSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2F2ZSgpO1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybVN0YWNrLnB1c2godGhpcy5iYXNlVHJhbnNmb3JtKTtcbiAgICBpZiAobWF0cml4KSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybSguLi5tYXRyaXgpO1xuICAgIH1cbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY3R4KTtcbiAgICBpZiAoYmJveCkge1xuICAgICAgVXRpbC5heGlhbEFsaWduZWRCb3VuZGluZ0JveChiYm94LCB0aGlzLmJhc2VUcmFuc2Zvcm0sIHRoaXMuY3VycmVudC5taW5NYXgpO1xuICAgICAgY29uc3QgW3gwLCB5MCwgeDEsIHkxXSA9IGJib3g7XG4gICAgICBjb25zdCBjbGlwID0gbmV3IFBhdGgyRCgpO1xuICAgICAgY2xpcC5yZWN0KHgwLCB5MCwgeDEgLSB4MCwgeTEgLSB5MCk7XG4gICAgICB0aGlzLmN0eC5jbGlwKGNsaXApO1xuICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgfVxuICB9XG4gIHBhaW50Rm9ybVhPYmplY3RFbmQoKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IHRoaXMuYmFzZVRyYW5zZm9ybVN0YWNrLnBvcCgpO1xuICB9XG4gIGJlZ2luR3JvdXAoZ3JvdXApIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zYXZlKCk7XG4gICAgaWYgKHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIHRoaXMuZW5kU01hc2tNb2RlKCk7XG4gICAgICB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50Q3R4ID0gdGhpcy5jdHg7XG4gICAgaWYgKCFncm91cC5pc29sYXRlZCkge1xuICAgICAgaW5mbyhcIlRPRE86IFN1cHBvcnQgbm9uLWlzb2xhdGVkIGdyb3Vwcy5cIik7XG4gICAgfVxuICAgIGlmIChncm91cC5rbm9ja291dCkge1xuICAgICAgd2FybihcIktub2Nrb3V0IGdyb3VwcyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0oY3VycmVudEN0eCk7XG4gICAgaWYgKGdyb3VwLm1hdHJpeCkge1xuICAgICAgY3VycmVudEN0eC50cmFuc2Zvcm0oLi4uZ3JvdXAubWF0cml4KTtcbiAgICB9XG4gICAgaWYgKCFncm91cC5iYm94KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCb3VuZGluZyBib3ggaXMgcmVxdWlyZWQuXCIpO1xuICAgIH1cbiAgICBsZXQgYm91bmRzID0gTUlOX01BWF9JTklULnNsaWNlKCk7XG4gICAgVXRpbC5heGlhbEFsaWduZWRCb3VuZGluZ0JveChncm91cC5iYm94LCBnZXRDdXJyZW50VHJhbnNmb3JtKGN1cnJlbnRDdHgpLCBib3VuZHMpO1xuICAgIGNvbnN0IGNhbnZhc0JvdW5kcyA9IFswLCAwLCBjdXJyZW50Q3R4LmNhbnZhcy53aWR0aCwgY3VycmVudEN0eC5jYW52YXMuaGVpZ2h0XTtcbiAgICBib3VuZHMgPSBVdGlsLmludGVyc2VjdChib3VuZHMsIGNhbnZhc0JvdW5kcykgfHwgWzAsIDAsIDAsIDBdO1xuICAgIGNvbnN0IG9mZnNldFggPSBNYXRoLmZsb29yKGJvdW5kc1swXSk7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGguZmxvb3IoYm91bmRzWzFdKTtcbiAgICBjb25zdCBkcmF3bldpZHRoID0gTWF0aC5tYXgoTWF0aC5jZWlsKGJvdW5kc1syXSkgLSBvZmZzZXRYLCAxKTtcbiAgICBjb25zdCBkcmF3bkhlaWdodCA9IE1hdGgubWF4KE1hdGguY2VpbChib3VuZHNbM10pIC0gb2Zmc2V0WSwgMSk7XG4gICAgdGhpcy5jdXJyZW50LnN0YXJ0TmV3UGF0aEFuZENsaXBCb3goWzAsIDAsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0XSk7XG4gICAgbGV0IGNhY2hlSWQgPSBcImdyb3VwQXRcIiArIHRoaXMuZ3JvdXBMZXZlbDtcbiAgICBpZiAoZ3JvdXAuc21hc2spIHtcbiAgICAgIGNhY2hlSWQgKz0gXCJfc21hc2tfXCIgKyB0aGlzLnNtYXNrQ291bnRlcisrICUgMjtcbiAgICB9XG4gICAgY29uc3Qgc2NyYXRjaENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKGNhY2hlSWQsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0KTtcbiAgICBjb25zdCBncm91cEN0eCA9IHNjcmF0Y2hDYW52YXMuY29udGV4dDtcbiAgICBncm91cEN0eC50cmFuc2xhdGUoLW9mZnNldFgsIC1vZmZzZXRZKTtcbiAgICBncm91cEN0eC50cmFuc2Zvcm0oLi4uY3VycmVudFRyYW5zZm9ybSk7XG4gICAgbGV0IGNsaXAgPSBuZXcgUGF0aDJEKCk7XG4gICAgY29uc3QgW3gwLCB5MCwgeDEsIHkxXSA9IGdyb3VwLmJib3g7XG4gICAgY2xpcC5yZWN0KHgwLCB5MCwgeDEgLSB4MCwgeTEgLSB5MCk7XG4gICAgaWYgKGdyb3VwLm1hdHJpeCkge1xuICAgICAgY29uc3QgcGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgIHBhdGguYWRkUGF0aChjbGlwLCBuZXcgRE9NTWF0cml4KGdyb3VwLm1hdHJpeCkpO1xuICAgICAgY2xpcCA9IHBhdGg7XG4gICAgfVxuICAgIGdyb3VwQ3R4LmNsaXAoY2xpcCk7XG4gICAgaWYgKGdyb3VwLnNtYXNrKSB7XG4gICAgICB0aGlzLnNtYXNrU3RhY2sucHVzaCh7XG4gICAgICAgIGNhbnZhczogc2NyYXRjaENhbnZhcy5jYW52YXMsXG4gICAgICAgIGNvbnRleHQ6IGdyb3VwQ3R4LFxuICAgICAgICBvZmZzZXRYLFxuICAgICAgICBvZmZzZXRZLFxuICAgICAgICBzdWJ0eXBlOiBncm91cC5zbWFzay5zdWJ0eXBlLFxuICAgICAgICBiYWNrZHJvcDogZ3JvdXAuc21hc2suYmFja2Ryb3AsXG4gICAgICAgIHRyYW5zZmVyTWFwOiBncm91cC5zbWFzay50cmFuc2Zlck1hcCB8fCBudWxsLFxuICAgICAgICBzdGFydFRyYW5zZm9ybUludmVyc2U6IG51bGxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Q3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIGN1cnJlbnRDdHgudHJhbnNsYXRlKG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgY3VycmVudEN0eC5zYXZlKCk7XG4gICAgfVxuICAgIGNvcHlDdHhTdGF0ZShjdXJyZW50Q3R4LCBncm91cEN0eCk7XG4gICAgdGhpcy5jdHggPSBncm91cEN0eDtcbiAgICB0aGlzLnNldEdTdGF0ZShbW1wiQk1cIiwgXCJzb3VyY2Utb3ZlclwiXSwgW1wiY2FcIiwgMV0sIFtcIkNBXCIsIDFdXSk7XG4gICAgdGhpcy5ncm91cFN0YWNrLnB1c2goY3VycmVudEN0eCk7XG4gICAgdGhpcy5ncm91cExldmVsKys7XG4gIH1cbiAgZW5kR3JvdXAoZ3JvdXApIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5ncm91cExldmVsLS07XG4gICAgY29uc3QgZ3JvdXBDdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmdyb3VwU3RhY2sucG9wKCk7XG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5jdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgaWYgKGdyb3VwLnNtYXNrKSB7XG4gICAgICB0aGlzLnRlbXBTTWFzayA9IHRoaXMuc21hc2tTdGFjay5wb3AoKTtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICBjb25zdCBjdXJyZW50TXR4ID0gZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmN0eCk7XG4gICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSguLi5jdXJyZW50TXR4KTtcbiAgICAgIGNvbnN0IGRpcnR5Qm94ID0gTUlOX01BWF9JTklULnNsaWNlKCk7XG4gICAgICBVdGlsLmF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KFswLCAwLCBncm91cEN0eC5jYW52YXMud2lkdGgsIGdyb3VwQ3R4LmNhbnZhcy5oZWlnaHRdLCBjdXJyZW50TXR4LCBkaXJ0eUJveCk7XG4gICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoZ3JvdXBDdHguY2FudmFzLCAwLCAwKTtcbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuY29tcG9zZShkaXJ0eUJveCk7XG4gICAgfVxuICB9XG4gIGJlZ2luQW5ub3RhdGlvbihpZCwgcmVjdCwgdHJhbnNmb3JtLCBtYXRyaXgsIGhhc093bkNhbnZhcykge1xuICAgIHRoaXMuI3Jlc3RvcmVJbml0aWFsU3RhdGUoKTtcbiAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCk7XG4gICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgIHRoaXMuc2F2ZSgpO1xuICAgIGlmICh0aGlzLmJhc2VUcmFuc2Zvcm0pIHtcbiAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSguLi50aGlzLmJhc2VUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBpZiAocmVjdCkge1xuICAgICAgY29uc3Qgd2lkdGggPSByZWN0WzJdIC0gcmVjdFswXTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHJlY3RbM10gLSByZWN0WzFdO1xuICAgICAgaWYgKGhhc093bkNhbnZhcyAmJiB0aGlzLmFubm90YXRpb25DYW52YXNNYXApIHtcbiAgICAgICAgdHJhbnNmb3JtID0gdHJhbnNmb3JtLnNsaWNlKCk7XG4gICAgICAgIHRyYW5zZm9ybVs0XSAtPSByZWN0WzBdO1xuICAgICAgICB0cmFuc2Zvcm1bNV0gLT0gcmVjdFsxXTtcbiAgICAgICAgcmVjdCA9IHJlY3Quc2xpY2UoKTtcbiAgICAgICAgcmVjdFswXSA9IHJlY3RbMV0gPSAwO1xuICAgICAgICByZWN0WzJdID0gd2lkdGg7XG4gICAgICAgIHJlY3RbM10gPSBoZWlnaHQ7XG4gICAgICAgIFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUoZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmN0eCksIFhZKTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHZpZXdwb3J0U2NhbGVcbiAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gTWF0aC5jZWlsKHdpZHRoICogdGhpcy5vdXRwdXRTY2FsZVggKiB2aWV3cG9ydFNjYWxlKTtcbiAgICAgICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCAqIHRoaXMub3V0cHV0U2NhbGVZICogdmlld3BvcnRTY2FsZSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhcyA9IHRoaXMuY2FudmFzRmFjdG9yeS5jcmVhdGUoY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjYW52YXMsXG4gICAgICAgICAgY29udGV4dFxuICAgICAgICB9ID0gdGhpcy5hbm5vdGF0aW9uQ2FudmFzO1xuICAgICAgICB0aGlzLmFubm90YXRpb25DYW52YXNNYXAuc2V0KGlkLCBjYW52YXMpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25DYW52YXMuc2F2ZWRDdHggPSB0aGlzLmN0eDtcbiAgICAgICAgdGhpcy5jdHggPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybShYWVswXSwgMCwgMCwgLVhZWzFdLCAwLCBoZWlnaHQgKiBYWVsxXSk7XG4gICAgICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4KTtcbiAgICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgICAgIGNvbnN0IGNsaXAgPSBuZXcgUGF0aDJEKCk7XG4gICAgICAgIGNsaXAucmVjdChyZWN0WzBdLCByZWN0WzFdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5jdHguY2xpcChjbGlwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jdXJyZW50ID0gbmV3IENhbnZhc0V4dHJhU3RhdGUodGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICB0aGlzLnRyYW5zZm9ybSguLi50cmFuc2Zvcm0pO1xuICAgIHRoaXMudHJhbnNmb3JtKC4uLm1hdHJpeCk7XG4gIH1cbiAgZW5kQW5ub3RhdGlvbigpIHtcbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uQ2FudmFzKSB7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLiNkcmF3RmlsdGVyKCk7XG4gICAgICB0aGlzLmN0eCA9IHRoaXMuYW5ub3RhdGlvbkNhbnZhcy5zYXZlZEN0eDtcbiAgICAgIGRlbGV0ZSB0aGlzLmFubm90YXRpb25DYW52YXMuc2F2ZWRDdHg7XG4gICAgICBkZWxldGUgdGhpcy5hbm5vdGF0aW9uQ2FudmFzO1xuICAgIH1cbiAgfVxuICBwYWludEltYWdlTWFza1hPYmplY3QoaW1nKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvdW50ID0gaW1nLmNvdW50O1xuICAgIGltZyA9IHRoaXMuZ2V0T2JqZWN0KGltZy5kYXRhLCBpbWcpO1xuICAgIGltZy5jb3VudCA9IGNvdW50O1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IG1hc2sgPSB0aGlzLl9jcmVhdGVNYXNrQ2FudmFzKGltZyk7XG4gICAgY29uc3QgbWFza0NhbnZhcyA9IG1hc2suY2FudmFzO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICBjdHguZHJhd0ltYWdlKG1hc2tDYW52YXMsIG1hc2sub2Zmc2V0WCwgbWFzay5vZmZzZXRZKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICB9XG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdFJlcGVhdChpbWcsIHNjYWxlWCwgc2tld1ggPSAwLCBza2V3WSA9IDAsIHNjYWxlWSwgcG9zaXRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGltZyA9IHRoaXMuZ2V0T2JqZWN0KGltZy5kYXRhLCBpbWcpO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KTtcbiAgICBjdHgudHJhbnNmb3JtKHNjYWxlWCwgc2tld1gsIHNrZXdZLCBzY2FsZVksIDAsIDApO1xuICAgIGNvbnN0IG1hc2sgPSB0aGlzLl9jcmVhdGVNYXNrQ2FudmFzKGltZyk7XG4gICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCBtYXNrLm9mZnNldFggLSBjdXJyZW50VHJhbnNmb3JtWzRdLCBtYXNrLm9mZnNldFkgLSBjdXJyZW50VHJhbnNmb3JtWzVdKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgY29uc3QgdHJhbnMgPSBVdGlsLnRyYW5zZm9ybShjdXJyZW50VHJhbnNmb3JtLCBbc2NhbGVYLCBza2V3WCwgc2tld1ksIHNjYWxlWSwgcG9zaXRpb25zW2ldLCBwb3NpdGlvbnNbaSArIDFdXSk7XG4gICAgICBjdHguZHJhd0ltYWdlKG1hc2suY2FudmFzLCB0cmFuc1s0XSwgdHJhbnNbNV0pO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICB9XG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdEdyb3VwKGltYWdlcykge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBmaWxsQ29sb3IgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yO1xuICAgIGNvbnN0IGlzUGF0dGVybkZpbGwgPSB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgZm9yIChjb25zdCBpbWFnZSBvZiBpbWFnZXMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgdHJhbnNmb3JtXG4gICAgICB9ID0gaW1hZ2U7XG4gICAgICBjb25zdCBtYXNrQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJtYXNrQ2FudmFzXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3QgbWFza0N0eCA9IG1hc2tDYW52YXMuY29udGV4dDtcbiAgICAgIG1hc2tDdHguc2F2ZSgpO1xuICAgICAgY29uc3QgaW1nID0gdGhpcy5nZXRPYmplY3QoZGF0YSwgaW1hZ2UpO1xuICAgICAgcHV0QmluYXJ5SW1hZ2VNYXNrKG1hc2tDdHgsIGltZyk7XG4gICAgICBtYXNrQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLWluXCI7XG4gICAgICBtYXNrQ3R4LmZpbGxTdHlsZSA9IGlzUGF0dGVybkZpbGwgPyBmaWxsQ29sb3IuZ2V0UGF0dGVybihtYXNrQ3R4LCB0aGlzLCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpLCBQYXRoVHlwZS5GSUxMKSA6IGZpbGxDb2xvcjtcbiAgICAgIG1hc2tDdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBtYXNrQ3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNmb3JtKC4uLnRyYW5zZm9ybSk7XG4gICAgICBjdHguc2NhbGUoMSwgLTEpO1xuICAgICAgZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzKGN0eCwgbWFza0NhbnZhcy5jYW52YXMsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIDAsIC0xLCAxLCAxKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIHRoaXMuY29tcG9zZSgpO1xuICB9XG4gIHBhaW50SW1hZ2VYT2JqZWN0KG9iaklkKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGltZ0RhdGEgPSB0aGlzLmdldE9iamVjdChvYmpJZCk7XG4gICAgaWYgKCFpbWdEYXRhKSB7XG4gICAgICB3YXJuKFwiRGVwZW5kZW50IGltYWdlIGlzbid0IHJlYWR5IHlldFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYWludElubGluZUltYWdlWE9iamVjdChpbWdEYXRhKTtcbiAgfVxuICBwYWludEltYWdlWE9iamVjdFJlcGVhdChvYmpJZCwgc2NhbGVYLCBzY2FsZVksIHBvc2l0aW9ucykge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbWdEYXRhID0gdGhpcy5nZXRPYmplY3Qob2JqSWQpO1xuICAgIGlmICghaW1nRGF0YSkge1xuICAgICAgd2FybihcIkRlcGVuZGVudCBpbWFnZSBpc24ndCByZWFkeSB5ZXRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgICBjb25zdCBtYXAgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgbWFwLnB1c2goe1xuICAgICAgICB0cmFuc2Zvcm06IFtzY2FsZVgsIDAsIDAsIHNjYWxlWSwgcG9zaXRpb25zW2ldLCBwb3NpdGlvbnNbaSArIDFdXSxcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgdzogd2lkdGgsXG4gICAgICAgIGg6IGhlaWdodFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cChpbWdEYXRhLCBtYXApO1xuICB9XG4gIGFwcGx5VHJhbnNmZXJNYXBzVG9DYW52YXMoY3R4KSB7XG4gICAgaWYgKHRoaXMuY3VycmVudC50cmFuc2Zlck1hcHMgIT09IFwibm9uZVwiKSB7XG4gICAgICBjdHguZmlsdGVyID0gdGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcztcbiAgICAgIGN0eC5kcmF3SW1hZ2UoY3R4LmNhbnZhcywgMCwgMCk7XG4gICAgICBjdHguZmlsdGVyID0gXCJub25lXCI7XG4gICAgfVxuICAgIHJldHVybiBjdHguY2FudmFzO1xuICB9XG4gIGFwcGx5VHJhbnNmZXJNYXBzVG9CaXRtYXAoaW1nRGF0YSkge1xuICAgIGlmICh0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzID09PSBcIm5vbmVcIikge1xuICAgICAgcmV0dXJuIGltZ0RhdGEuYml0bWFwO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBiaXRtYXAsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBpbWdEYXRhO1xuICAgIGNvbnN0IHRtcENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwiaW5saW5lSW1hZ2VcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgdG1wQ3R4LmZpbHRlciA9IHRoaXMuY3VycmVudC50cmFuc2Zlck1hcHM7XG4gICAgdG1wQ3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDApO1xuICAgIHRtcEN0eC5maWx0ZXIgPSBcIm5vbmVcIjtcbiAgICByZXR1cm4gdG1wQ2FudmFzLmNhbnZhcztcbiAgfVxuICBwYWludElubGluZUltYWdlWE9iamVjdChpbWdEYXRhKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICB0aGlzLnNhdmUoKTtcbiAgICBjb25zdCB7XG4gICAgICBmaWx0ZXJcbiAgICB9ID0gY3R4O1xuICAgIGlmIChmaWx0ZXIgIT09IFwibm9uZVwiICYmIGZpbHRlciAhPT0gXCJcIikge1xuICAgICAgY3R4LmZpbHRlciA9IFwibm9uZVwiO1xuICAgIH1cbiAgICBjdHguc2NhbGUoMSAvIHdpZHRoLCAtMSAvIGhlaWdodCk7XG4gICAgbGV0IGltZ1RvUGFpbnQ7XG4gICAgaWYgKGltZ0RhdGEuYml0bWFwKSB7XG4gICAgICBpbWdUb1BhaW50ID0gdGhpcy5hcHBseVRyYW5zZmVyTWFwc1RvQml0bWFwKGltZ0RhdGEpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSBcImZ1bmN0aW9uXCIgJiYgaW1nRGF0YSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8ICFpbWdEYXRhLmRhdGEpIHtcbiAgICAgIGltZ1RvUGFpbnQgPSBpbWdEYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImlubGluZUltYWdlXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICBwdXRCaW5hcnlJbWFnZURhdGEodG1wQ3R4LCBpbWdEYXRhKTtcbiAgICAgIGltZ1RvUGFpbnQgPSB0aGlzLmFwcGx5VHJhbnNmZXJNYXBzVG9DYW52YXModG1wQ3R4KTtcbiAgICB9XG4gICAgY29uc3Qgc2NhbGVkID0gdGhpcy5fc2NhbGVJbWFnZShpbWdUb1BhaW50LCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpKTtcbiAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZ2V0SW1hZ2VTbW9vdGhpbmdFbmFibGVkKGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KSwgaW1nRGF0YS5pbnRlcnBvbGF0ZSk7XG4gICAgZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzKGN0eCwgc2NhbGVkLmltZywgMCwgMCwgc2NhbGVkLnBhaW50V2lkdGgsIHNjYWxlZC5wYWludEhlaWdodCwgMCwgLWhlaWdodCwgd2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gICAgdGhpcy5yZXN0b3JlKCk7XG4gIH1cbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cChpbWdEYXRhLCBtYXApIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgbGV0IGltZ1RvUGFpbnQ7XG4gICAgaWYgKGltZ0RhdGEuYml0bWFwKSB7XG4gICAgICBpbWdUb1BhaW50ID0gaW1nRGF0YS5iaXRtYXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHcgPSBpbWdEYXRhLndpZHRoO1xuICAgICAgY29uc3QgaCA9IGltZ0RhdGEuaGVpZ2h0O1xuICAgICAgY29uc3QgdG1wQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpbmxpbmVJbWFnZVwiLCB3LCBoKTtcbiAgICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgcHV0QmluYXJ5SW1hZ2VEYXRhKHRtcEN0eCwgaW1nRGF0YSk7XG4gICAgICBpbWdUb1BhaW50ID0gdGhpcy5hcHBseVRyYW5zZmVyTWFwc1RvQ2FudmFzKHRtcEN0eCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZW50cnkgb2YgbWFwKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSguLi5lbnRyeS50cmFuc2Zvcm0pO1xuICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcbiAgICAgIGRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyhjdHgsIGltZ1RvUGFpbnQsIGVudHJ5LngsIGVudHJ5LnksIGVudHJ5LncsIGVudHJ5LmgsIDAsIC0xLCAxLCAxKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIHRoaXMuY29tcG9zZSgpO1xuICB9XG4gIHBhaW50U29saWRDb2xvckltYWdlTWFzaygpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gIH1cbiAgbWFya1BvaW50KHRhZykge31cbiAgbWFya1BvaW50UHJvcHModGFnLCBwcm9wZXJ0aWVzKSB7fVxuICBiZWdpbk1hcmtlZENvbnRlbnQodGFnKSB7XG4gICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sucHVzaCh7XG4gICAgICB2aXNpYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgYmVnaW5NYXJrZWRDb250ZW50UHJvcHModGFnLCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKHRhZyA9PT0gXCJPQ1wiKSB7XG4gICAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5wdXNoKHtcbiAgICAgICAgdmlzaWJsZTogdGhpcy5vcHRpb25hbENvbnRlbnRDb25maWcuaXNWaXNpYmxlKHByb3BlcnRpZXMpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sucHVzaCh7XG4gICAgICAgIHZpc2libGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmNvbnRlbnRWaXNpYmxlID0gdGhpcy5pc0NvbnRlbnRWaXNpYmxlKCk7XG4gIH1cbiAgZW5kTWFya2VkQ29udGVudCgpIHtcbiAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5wb3AoKTtcbiAgICB0aGlzLmNvbnRlbnRWaXNpYmxlID0gdGhpcy5pc0NvbnRlbnRWaXNpYmxlKCk7XG4gIH1cbiAgYmVnaW5Db21wYXQoKSB7fVxuICBlbmRDb21wYXQoKSB7fVxuICBjb25zdW1lUGF0aChwYXRoLCBjbGlwQm94KSB7XG4gICAgY29uc3QgaXNFbXB0eSA9IHRoaXMuY3VycmVudC5pc0VtcHR5Q2xpcCgpO1xuICAgIGlmICh0aGlzLnBlbmRpbmdDbGlwKSB7XG4gICAgICB0aGlzLmN1cnJlbnQudXBkYXRlQ2xpcEZyb21QYXRoKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5wZW5kaW5nQ2xpcCkge1xuICAgICAgdGhpcy5jb21wb3NlKGNsaXBCb3gpO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBpZiAodGhpcy5wZW5kaW5nQ2xpcCkge1xuICAgICAgaWYgKCFpc0VtcHR5KSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdDbGlwID09PSBFT19DTElQKSB7XG4gICAgICAgICAgY3R4LmNsaXAocGF0aCwgXCJldmVub2RkXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5jbGlwKHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LnN0YXJ0TmV3UGF0aEFuZENsaXBCb3godGhpcy5jdXJyZW50LmNsaXBCb3gpO1xuICB9XG4gIGdldFNpbmdsZVBpeGVsV2lkdGgoKSB7XG4gICAgaWYgKCF0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoKSB7XG4gICAgICBjb25zdCBtID0gZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmN0eCk7XG4gICAgICBpZiAobVsxXSA9PT0gMCAmJiBtWzJdID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSAxIC8gTWF0aC5taW4oTWF0aC5hYnMobVswXSksIE1hdGguYWJzKG1bM10pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGFic0RldCA9IE1hdGguYWJzKG1bMF0gKiBtWzNdIC0gbVsyXSAqIG1bMV0pO1xuICAgICAgICBjb25zdCBub3JtWCA9IE1hdGguaHlwb3QobVswXSwgbVsyXSk7XG4gICAgICAgIGNvbnN0IG5vcm1ZID0gTWF0aC5oeXBvdChtWzFdLCBtWzNdKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IE1hdGgubWF4KG5vcm1YLCBub3JtWSkgLyBhYnNEZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoO1xuICB9XG4gIGdldFNjYWxlRm9yU3Ryb2tpbmcoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPT09IC0xKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxpbmVXaWR0aFxuICAgICAgfSA9IHRoaXMuY3VycmVudDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYSxcbiAgICAgICAgYixcbiAgICAgICAgYyxcbiAgICAgICAgZFxuICAgICAgfSA9IHRoaXMuY3R4LmdldFRyYW5zZm9ybSgpO1xuICAgICAgbGV0IHNjYWxlWCwgc2NhbGVZO1xuICAgICAgaWYgKGIgPT09IDAgJiYgYyA9PT0gMCkge1xuICAgICAgICBjb25zdCBub3JtWCA9IE1hdGguYWJzKGEpO1xuICAgICAgICBjb25zdCBub3JtWSA9IE1hdGguYWJzKGQpO1xuICAgICAgICBpZiAobm9ybVggPT09IG5vcm1ZKSB7XG4gICAgICAgICAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgc2NhbGVYID0gc2NhbGVZID0gMSAvIG5vcm1YO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWRMaW5lV2lkdGggPSBub3JtWCAqIGxpbmVXaWR0aDtcbiAgICAgICAgICAgIHNjYWxlWCA9IHNjYWxlWSA9IHNjYWxlZExpbmVXaWR0aCA8IDEgPyAxIC8gc2NhbGVkTGluZVdpZHRoIDogMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgc2NhbGVYID0gMSAvIG5vcm1YO1xuICAgICAgICAgIHNjYWxlWSA9IDEgLyBub3JtWTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBzY2FsZWRYTGluZVdpZHRoID0gbm9ybVggKiBsaW5lV2lkdGg7XG4gICAgICAgICAgY29uc3Qgc2NhbGVkWUxpbmVXaWR0aCA9IG5vcm1ZICogbGluZVdpZHRoO1xuICAgICAgICAgIHNjYWxlWCA9IHNjYWxlZFhMaW5lV2lkdGggPCAxID8gMSAvIHNjYWxlZFhMaW5lV2lkdGggOiAxO1xuICAgICAgICAgIHNjYWxlWSA9IHNjYWxlZFlMaW5lV2lkdGggPCAxID8gMSAvIHNjYWxlZFlMaW5lV2lkdGggOiAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhYnNEZXQgPSBNYXRoLmFicyhhICogZCAtIGIgKiBjKTtcbiAgICAgICAgY29uc3Qgbm9ybVggPSBNYXRoLmh5cG90KGEsIGIpO1xuICAgICAgICBjb25zdCBub3JtWSA9IE1hdGguaHlwb3QoYywgZCk7XG4gICAgICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICBzY2FsZVggPSBub3JtWSAvIGFic0RldDtcbiAgICAgICAgICBzY2FsZVkgPSBub3JtWCAvIGFic0RldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBiYXNlQXJlYSA9IGxpbmVXaWR0aCAqIGFic0RldDtcbiAgICAgICAgICBzY2FsZVggPSBub3JtWSA+IGJhc2VBcmVhID8gbm9ybVkgLyBiYXNlQXJlYSA6IDE7XG4gICAgICAgICAgc2NhbGVZID0gbm9ybVggPiBiYXNlQXJlYSA/IG5vcm1YIC8gYmFzZUFyZWEgOiAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gc2NhbGVYO1xuICAgICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1sxXSA9IHNjYWxlWTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmc7XG4gIH1cbiAgcmVzY2FsZUFuZFN0cm9rZShwYXRoLCBzYXZlUmVzdG9yZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGN0eCxcbiAgICAgIGN1cnJlbnQ6IHtcbiAgICAgICAgbGluZVdpZHRoXG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgW3NjYWxlWCwgc2NhbGVZXSA9IHRoaXMuZ2V0U2NhbGVGb3JTdHJva2luZygpO1xuICAgIGlmIChzY2FsZVggPT09IHNjYWxlWSkge1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IChsaW5lV2lkdGggfHwgMSkgKiBzY2FsZVg7XG4gICAgICBjdHguc3Ryb2tlKHBhdGgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkYXNoZXMgPSBjdHguZ2V0TGluZURhc2goKTtcbiAgICBpZiAoc2F2ZVJlc3RvcmUpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgfVxuICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgU0NBTEVfTUFUUklYLmEgPSAxIC8gc2NhbGVYO1xuICAgIFNDQUxFX01BVFJJWC5kID0gMSAvIHNjYWxlWTtcbiAgICBjb25zdCBuZXdQYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgIG5ld1BhdGguYWRkUGF0aChwYXRoLCBTQ0FMRV9NQVRSSVgpO1xuICAgIGlmIChkYXNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgc2NhbGUgPSBNYXRoLm1heChzY2FsZVgsIHNjYWxlWSk7XG4gICAgICBjdHguc2V0TGluZURhc2goZGFzaGVzLm1hcCh4ID0+IHggLyBzY2FsZSkpO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0IC89IHNjYWxlO1xuICAgIH1cbiAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoIHx8IDE7XG4gICAgY3R4LnN0cm9rZShuZXdQYXRoKTtcbiAgICBpZiAoc2F2ZVJlc3RvcmUpIHtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG4gIGlzQ29udGVudFZpc2libGUoKSB7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMubWFya2VkQ29udGVudFN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoIXRoaXMubWFya2VkQ29udGVudFN0YWNrW2ldLnZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuZm9yIChjb25zdCBvcCBpbiBPUFMpIHtcbiAgaWYgKENhbnZhc0dyYXBoaWNzLnByb3RvdHlwZVtvcF0gIT09IHVuZGVmaW5lZCkge1xuICAgIENhbnZhc0dyYXBoaWNzLnByb3RvdHlwZVtPUFNbb3BdXSA9IENhbnZhc0dyYXBoaWNzLnByb3RvdHlwZVtvcF07XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvd29ya2VyX29wdGlvbnMuanNcbmNsYXNzIEdsb2JhbFdvcmtlck9wdGlvbnMge1xuICBzdGF0aWMgI3BvcnQgPSBudWxsO1xuICBzdGF0aWMgI3NyYyA9IFwiXCI7XG4gIHN0YXRpYyBnZXQgd29ya2VyUG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9ydDtcbiAgfVxuICBzdGF0aWMgc2V0IHdvcmtlclBvcnQodmFsKSB7XG4gICAgaWYgKCEodHlwZW9mIFdvcmtlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB2YWwgaW5zdGFuY2VvZiBXb3JrZXIpICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBgd29ya2VyUG9ydGAgdHlwZS5cIik7XG4gICAgfVxuICAgIHRoaXMuI3BvcnQgPSB2YWw7XG4gIH1cbiAgc3RhdGljIGdldCB3b3JrZXJTcmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NyYztcbiAgfVxuICBzdGF0aWMgc2V0IHdvcmtlclNyYyh2YWwpIHtcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBgd29ya2VyU3JjYCB0eXBlLlwiKTtcbiAgICB9XG4gICAgdGhpcy4jc3JjID0gdmFsO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L21ldGFkYXRhLmpzXG5jbGFzcyBNZXRhZGF0YSB7XG4gICNtYXA7XG4gICNkYXRhO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcGFyc2VkRGF0YSxcbiAgICByYXdEYXRhXG4gIH0pIHtcbiAgICB0aGlzLiNtYXAgPSBwYXJzZWREYXRhO1xuICAgIHRoaXMuI2RhdGEgPSByYXdEYXRhO1xuICB9XG4gIGdldFJhdygpIHtcbiAgICByZXR1cm4gdGhpcy4jZGF0YTtcbiAgfVxuICBnZXQobmFtZSkge1xuICAgIHJldHVybiB0aGlzLiNtYXAuZ2V0KG5hbWUpID8/IG51bGw7XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMuI21hcC5lbnRyaWVzKCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvb3B0aW9uYWxfY29udGVudF9jb25maWcuanNcblxuXG5jb25zdCBJTlRFUk5BTCA9IFN5bWJvbChcIklOVEVSTkFMXCIpO1xuY2xhc3MgT3B0aW9uYWxDb250ZW50R3JvdXAge1xuICAjaXNEaXNwbGF5ID0gZmFsc2U7XG4gICNpc1ByaW50ID0gZmFsc2U7XG4gICN1c2VyU2V0ID0gZmFsc2U7XG4gICN2aXNpYmxlID0gdHJ1ZTtcbiAgY29uc3RydWN0b3IocmVuZGVyaW5nSW50ZW50LCB7XG4gICAgbmFtZSxcbiAgICBpbnRlbnQsXG4gICAgdXNhZ2UsXG4gICAgcmJHcm91cHNcbiAgfSkge1xuICAgIHRoaXMuI2lzRGlzcGxheSA9ICEhKHJlbmRlcmluZ0ludGVudCAmIFJlbmRlcmluZ0ludGVudEZsYWcuRElTUExBWSk7XG4gICAgdGhpcy4jaXNQcmludCA9ICEhKHJlbmRlcmluZ0ludGVudCAmIFJlbmRlcmluZ0ludGVudEZsYWcuUFJJTlQpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5pbnRlbnQgPSBpbnRlbnQ7XG4gICAgdGhpcy51c2FnZSA9IHVzYWdlO1xuICAgIHRoaXMucmJHcm91cHMgPSByYkdyb3VwcztcbiAgfVxuICBnZXQgdmlzaWJsZSgpIHtcbiAgICBpZiAodGhpcy4jdXNlclNldCkge1xuICAgICAgcmV0dXJuIHRoaXMuI3Zpc2libGU7XG4gICAgfVxuICAgIGlmICghdGhpcy4jdmlzaWJsZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwcmludCxcbiAgICAgIHZpZXdcbiAgICB9ID0gdGhpcy51c2FnZTtcbiAgICBpZiAodGhpcy4jaXNEaXNwbGF5KSB7XG4gICAgICByZXR1cm4gdmlldz8udmlld1N0YXRlICE9PSBcIk9GRlwiO1xuICAgIH0gZWxzZSBpZiAodGhpcy4jaXNQcmludCkge1xuICAgICAgcmV0dXJuIHByaW50Py5wcmludFN0YXRlICE9PSBcIk9GRlwiO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBfc2V0VmlzaWJsZShpbnRlcm5hbCwgdmlzaWJsZSwgdXNlclNldCA9IGZhbHNlKSB7XG4gICAgaWYgKGludGVybmFsICE9PSBJTlRFUk5BTCkge1xuICAgICAgdW5yZWFjaGFibGUoXCJJbnRlcm5hbCBtZXRob2QgYF9zZXRWaXNpYmxlYCBjYWxsZWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLiN1c2VyU2V0ID0gdXNlclNldDtcbiAgICB0aGlzLiN2aXNpYmxlID0gdmlzaWJsZTtcbiAgfVxufVxuY2xhc3MgT3B0aW9uYWxDb250ZW50Q29uZmlnIHtcbiAgI2NhY2hlZEdldEhhc2ggPSBudWxsO1xuICAjZ3JvdXBzID0gbmV3IE1hcCgpO1xuICAjaW5pdGlhbEhhc2ggPSBudWxsO1xuICAjb3JkZXIgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihkYXRhLCByZW5kZXJpbmdJbnRlbnQgPSBSZW5kZXJpbmdJbnRlbnRGbGFnLkRJU1BMQVkpIHtcbiAgICB0aGlzLnJlbmRlcmluZ0ludGVudCA9IHJlbmRlcmluZ0ludGVudDtcbiAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgIHRoaXMuY3JlYXRvciA9IG51bGw7XG4gICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5uYW1lID0gZGF0YS5uYW1lO1xuICAgIHRoaXMuY3JlYXRvciA9IGRhdGEuY3JlYXRvcjtcbiAgICB0aGlzLiNvcmRlciA9IGRhdGEub3JkZXI7XG4gICAgZm9yIChjb25zdCBncm91cCBvZiBkYXRhLmdyb3Vwcykge1xuICAgICAgdGhpcy4jZ3JvdXBzLnNldChncm91cC5pZCwgbmV3IE9wdGlvbmFsQ29udGVudEdyb3VwKHJlbmRlcmluZ0ludGVudCwgZ3JvdXApKTtcbiAgICB9XG4gICAgaWYgKGRhdGEuYmFzZVN0YXRlID09PSBcIk9GRlwiKSB7XG4gICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIHRoaXMuI2dyb3Vwcy52YWx1ZXMoKSkge1xuICAgICAgICBncm91cC5fc2V0VmlzaWJsZShJTlRFUk5BTCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IG9uIG9mIGRhdGEub24pIHtcbiAgICAgIHRoaXMuI2dyb3Vwcy5nZXQob24pLl9zZXRWaXNpYmxlKElOVEVSTkFMLCB0cnVlKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBvZmYgb2YgZGF0YS5vZmYpIHtcbiAgICAgIHRoaXMuI2dyb3Vwcy5nZXQob2ZmKS5fc2V0VmlzaWJsZShJTlRFUk5BTCwgZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLiNpbml0aWFsSGFzaCA9IHRoaXMuZ2V0SGFzaCgpO1xuICB9XG4gICNldmFsdWF0ZVZpc2liaWxpdHlFeHByZXNzaW9uKGFycmF5KSB7XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgb3BlcmF0b3IgPSBhcnJheVswXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaV07XG4gICAgICBsZXQgc3RhdGU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50KSkge1xuICAgICAgICBzdGF0ZSA9IHRoaXMuI2V2YWx1YXRlVmlzaWJpbGl0eUV4cHJlc3Npb24oZWxlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuI2dyb3Vwcy5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgc3RhdGUgPSB0aGlzLiNncm91cHMuZ2V0KGVsZW1lbnQpLnZpc2libGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtlbGVtZW50fWApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSBcIkFuZFwiOlxuICAgICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJPclwiOlxuICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTm90XCI6XG4gICAgICAgICAgcmV0dXJuICFzdGF0ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wZXJhdG9yID09PSBcIkFuZFwiO1xuICB9XG4gIGlzVmlzaWJsZShncm91cCkge1xuICAgIGlmICh0aGlzLiNncm91cHMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghZ3JvdXApIHtcbiAgICAgIGluZm8oXCJPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAudHlwZSA9PT0gXCJPQ0dcIikge1xuICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGdyb3VwLmlkKSkge1xuICAgICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtncm91cC5pZH1gKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4jZ3JvdXBzLmdldChncm91cC5pZCkudmlzaWJsZTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09IFwiT0NNRFwiKSB7XG4gICAgICBpZiAoZ3JvdXAuZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4gdGhpcy4jZXZhbHVhdGVWaXNpYmlsaXR5RXhwcmVzc2lvbihncm91cC5leHByZXNzaW9uKTtcbiAgICAgIH1cbiAgICAgIGlmICghZ3JvdXAucG9saWN5IHx8IGdyb3VwLnBvbGljeSA9PT0gXCJBbnlPblwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgd2FybihgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLnBvbGljeSA9PT0gXCJBbGxPblwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgd2FybihgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuZ2V0KGlkKS52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChncm91cC5wb2xpY3kgPT09IFwiQW55T2ZmXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBncm91cC5pZHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLnBvbGljeSA9PT0gXCJBbGxPZmZcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGdyb3VwLmlkcykge1xuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHdhcm4oYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLiNncm91cHMuZ2V0KGlkKS52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgd2FybihgVW5rbm93biBvcHRpb25hbCBjb250ZW50IHBvbGljeSAke2dyb3VwLnBvbGljeX0uYCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgd2FybihgVW5rbm93biBncm91cCB0eXBlICR7Z3JvdXAudHlwZX0uYCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc2V0VmlzaWJpbGl0eShpZCwgdmlzaWJsZSA9IHRydWUsIHByZXNlcnZlUkIgPSB0cnVlKSB7XG4gICAgY29uc3QgZ3JvdXAgPSB0aGlzLiNncm91cHMuZ2V0KGlkKTtcbiAgICBpZiAoIWdyb3VwKSB7XG4gICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByZXNlcnZlUkIgJiYgdmlzaWJsZSAmJiBncm91cC5yYkdyb3Vwcy5sZW5ndGgpIHtcbiAgICAgIGZvciAoY29uc3QgcmJHcm91cCBvZiBncm91cC5yYkdyb3Vwcykge1xuICAgICAgICBmb3IgKGNvbnN0IG90aGVySWQgb2YgcmJHcm91cCkge1xuICAgICAgICAgIGlmIChvdGhlcklkICE9PSBpZCkge1xuICAgICAgICAgICAgdGhpcy4jZ3JvdXBzLmdldChvdGhlcklkKT8uX3NldFZpc2libGUoSU5URVJOQUwsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZ3JvdXAuX3NldFZpc2libGUoSU5URVJOQUwsICEhdmlzaWJsZSwgdHJ1ZSk7XG4gICAgdGhpcy4jY2FjaGVkR2V0SGFzaCA9IG51bGw7XG4gIH1cbiAgc2V0T0NHU3RhdGUoe1xuICAgIHN0YXRlLFxuICAgIHByZXNlcnZlUkJcbiAgfSkge1xuICAgIGxldCBvcGVyYXRvcjtcbiAgICBmb3IgKGNvbnN0IGVsZW0gb2Ygc3RhdGUpIHtcbiAgICAgIHN3aXRjaCAoZWxlbSkge1xuICAgICAgICBjYXNlIFwiT05cIjpcbiAgICAgICAgY2FzZSBcIk9GRlwiOlxuICAgICAgICBjYXNlIFwiVG9nZ2xlXCI6XG4gICAgICAgICAgb3BlcmF0b3IgPSBlbGVtO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZ3JvdXAgPSB0aGlzLiNncm91cHMuZ2V0KGVsZW0pO1xuICAgICAgaWYgKCFncm91cCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSBcIk9OXCI6XG4gICAgICAgICAgdGhpcy5zZXRWaXNpYmlsaXR5KGVsZW0sIHRydWUsIHByZXNlcnZlUkIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiT0ZGXCI6XG4gICAgICAgICAgdGhpcy5zZXRWaXNpYmlsaXR5KGVsZW0sIGZhbHNlLCBwcmVzZXJ2ZVJCKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlRvZ2dsZVwiOlxuICAgICAgICAgIHRoaXMuc2V0VmlzaWJpbGl0eShlbGVtLCAhZ3JvdXAudmlzaWJsZSwgcHJlc2VydmVSQik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2NhY2hlZEdldEhhc2ggPSBudWxsO1xuICB9XG4gIGdldCBoYXNJbml0aWFsVmlzaWJpbGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaW5pdGlhbEhhc2ggPT09IG51bGwgfHwgdGhpcy5nZXRIYXNoKCkgPT09IHRoaXMuI2luaXRpYWxIYXNoO1xuICB9XG4gIGdldE9yZGVyKCkge1xuICAgIGlmICghdGhpcy4jZ3JvdXBzLnNpemUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy4jb3JkZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLiNvcmRlci5zbGljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gWy4uLnRoaXMuI2dyb3Vwcy5rZXlzKCldO1xuICB9XG4gIGdldEdyb3VwKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2dyb3Vwcy5nZXQoaWQpIHx8IG51bGw7XG4gIH1cbiAgZ2V0SGFzaCgpIHtcbiAgICBpZiAodGhpcy4jY2FjaGVkR2V0SGFzaCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuI2NhY2hlZEdldEhhc2g7XG4gICAgfVxuICAgIGNvbnN0IGhhc2ggPSBuZXcgTXVybXVySGFzaDNfNjQoKTtcbiAgICBmb3IgKGNvbnN0IFtpZCwgZ3JvdXBdIG9mIHRoaXMuI2dyb3Vwcykge1xuICAgICAgaGFzaC51cGRhdGUoYCR7aWR9OiR7Z3JvdXAudmlzaWJsZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlZEdldEhhc2ggPSBoYXNoLmhleGRpZ2VzdCgpO1xuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLiNncm91cHMuZW50cmllcygpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L3RyYW5zcG9ydF9zdHJlYW0uanNcblxuXG5jbGFzcyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtIHtcbiAgY29uc3RydWN0b3IocGRmRGF0YVJhbmdlVHJhbnNwb3J0LCB7XG4gICAgZGlzYWJsZVJhbmdlID0gZmFsc2UsXG4gICAgZGlzYWJsZVN0cmVhbSA9IGZhbHNlXG4gIH0pIHtcbiAgICBhc3NlcnQocGRmRGF0YVJhbmdlVHJhbnNwb3J0LCAnUERGRGF0YVRyYW5zcG9ydFN0cmVhbSAtIG1pc3NpbmcgcmVxdWlyZWQgXCJwZGZEYXRhUmFuZ2VUcmFuc3BvcnRcIiBhcmd1bWVudC4nKTtcbiAgICBjb25zdCB7XG4gICAgICBsZW5ndGgsXG4gICAgICBpbml0aWFsRGF0YSxcbiAgICAgIHByb2dyZXNzaXZlRG9uZSxcbiAgICAgIGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lXG4gICAgfSA9IHBkZkRhdGFSYW5nZVRyYW5zcG9ydDtcbiAgICB0aGlzLl9xdWV1ZWRDaHVua3MgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZURvbmUgPSBwcm9ncmVzc2l2ZURvbmU7XG4gICAgdGhpcy5fY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgPSBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZTtcbiAgICBpZiAoaW5pdGlhbERhdGE/Lmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGluaXRpYWxEYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBpbml0aWFsRGF0YS5ieXRlTGVuZ3RoID09PSBpbml0aWFsRGF0YS5idWZmZXIuYnl0ZUxlbmd0aCA/IGluaXRpYWxEYXRhLmJ1ZmZlciA6IG5ldyBVaW50OEFycmF5KGluaXRpYWxEYXRhKS5idWZmZXI7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVua3MucHVzaChidWZmZXIpO1xuICAgIH1cbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQgPSBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQ7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gIWRpc2FibGVSYW5nZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yYW5nZVJlYWRlcnMgPSBbXTtcbiAgICBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUmFuZ2VMaXN0ZW5lcigoYmVnaW4sIGNodW5rKSA9PiB7XG4gICAgICB0aGlzLl9vblJlY2VpdmVEYXRhKHtcbiAgICAgICAgYmVnaW4sXG4gICAgICAgIGNodW5rXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUHJvZ3Jlc3NMaXN0ZW5lcigobG9hZGVkLCB0b3RhbCkgPT4ge1xuICAgICAgdGhpcy5fb25Qcm9ncmVzcyh7XG4gICAgICAgIGxvYWRlZCxcbiAgICAgICAgdG90YWxcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHBkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRQcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcihjaHVuayA9PiB7XG4gICAgICB0aGlzLl9vblJlY2VpdmVEYXRhKHtcbiAgICAgICAgY2h1bmtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHBkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRQcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcigoKSA9PiB7XG4gICAgICB0aGlzLl9vblByb2dyZXNzaXZlRG9uZSgpO1xuICAgIH0pO1xuICAgIHBkZkRhdGFSYW5nZVRyYW5zcG9ydC50cmFuc3BvcnRSZWFkeSgpO1xuICB9XG4gIF9vblJlY2VpdmVEYXRhKHtcbiAgICBiZWdpbixcbiAgICBjaHVua1xuICB9KSB7XG4gICAgY29uc3QgYnVmZmVyID0gY2h1bmsgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIGNodW5rLmJ5dGVMZW5ndGggPT09IGNodW5rLmJ1ZmZlci5ieXRlTGVuZ3RoID8gY2h1bmsuYnVmZmVyIDogbmV3IFVpbnQ4QXJyYXkoY2h1bmspLmJ1ZmZlcjtcbiAgICBpZiAoYmVnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyKSB7XG4gICAgICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLl9lbnF1ZXVlKGJ1ZmZlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9xdWV1ZWRDaHVua3MucHVzaChidWZmZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmb3VuZCA9IHRoaXMuX3JhbmdlUmVhZGVycy5zb21lKGZ1bmN0aW9uIChyYW5nZVJlYWRlcikge1xuICAgICAgICBpZiAocmFuZ2VSZWFkZXIuX2JlZ2luICE9PSBiZWdpbikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByYW5nZVJlYWRlci5fZW5xdWV1ZShidWZmZXIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgYXNzZXJ0KGZvdW5kLCBcIl9vblJlY2VpdmVEYXRhIC0gbm8gYFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlcmAgaW5zdGFuY2UgZm91bmQuXCIpO1xuICAgIH1cbiAgfVxuICBnZXQgX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/Ll9sb2FkZWQgPz8gMDtcbiAgfVxuICBfb25Qcm9ncmVzcyhldnQpIHtcbiAgICBpZiAoZXZ0LnRvdGFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3JhbmdlUmVhZGVyc1swXT8ub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/Lm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZCxcbiAgICAgICAgdG90YWw6IGV2dC50b3RhbFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIF9vblByb2dyZXNzaXZlRG9uZSgpIHtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8ucHJvZ3Jlc3NpdmVEb25lKCk7XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lID0gdHJ1ZTtcbiAgfVxuICBfcmVtb3ZlUmFuZ2VSZWFkZXIocmVhZGVyKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX3JhbmdlUmVhZGVycy5pbmRleE9mKHJlYWRlcik7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgdGhpcy5fcmFuZ2VSZWFkZXJzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbiAgZ2V0RnVsbFJlYWRlcigpIHtcbiAgICBhc3NlcnQoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERkRhdGFUcmFuc3BvcnRTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgY29uc3QgcXVldWVkQ2h1bmtzID0gdGhpcy5fcXVldWVkQ2h1bmtzO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rcyA9IG51bGw7XG4gICAgcmV0dXJuIG5ldyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmVhZGVyKHRoaXMsIHF1ZXVlZENodW5rcywgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lLCB0aGlzLl9jb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSk7XG4gIH1cbiAgZ2V0UmFuZ2VSZWFkZXIoYmVnaW4sIGVuZCkge1xuICAgIGlmIChlbmQgPD0gdGhpcy5fcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlcih0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQucmVxdWVzdERhdGFSYW5nZShiZWdpbiwgZW5kKTtcbiAgICB0aGlzLl9yYW5nZVJlYWRlcnMucHVzaChyZWFkZXIpO1xuICAgIHJldHVybiByZWFkZXI7XG4gIH1cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVhZGVycy5zbGljZSgwKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgIH1cbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWJvcnQoKTtcbiAgfVxufVxuY2xhc3MgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSwgcXVldWVkQ2h1bmtzLCBwcm9ncmVzc2l2ZURvbmUgPSBmYWxzZSwgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgPSBudWxsKSB7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX2RvbmUgPSBwcm9ncmVzc2l2ZURvbmUgfHwgZmFsc2U7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBpc1BkZkZpbGUoY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUpID8gY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgOiBudWxsO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rcyA9IHF1ZXVlZENodW5rcyB8fCBbXTtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIGZvciAoY29uc3QgY2h1bmsgb2YgdGhpcy5fcXVldWVkQ2h1bmtzKSB7XG4gICAgICB0aGlzLl9sb2FkZWQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9oZWFkZXJzUmVhZHkgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBzdHJlYW0uX2Z1bGxSZXF1ZXN0UmVhZGVyID0gdGhpcztcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIF9lbnF1ZXVlKGNodW5rKSB7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmtzLnB1c2goY2h1bmspO1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgfVxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzUmVhZHk7XG4gIH1cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuICBnZXQgaXNSYW5nZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtLl9pc1JhbmdlU3VwcG9ydGVkO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtLl9jb250ZW50TGVuZ3RoO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgaWYgKHRoaXMuX3F1ZXVlZENodW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjaHVuayA9IHRoaXMuX3F1ZXVlZENodW5rcy5zaGlmdCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5fcmVxdWVzdHMucHVzaChyZXF1ZXN0Q2FwYWJpbGl0eSk7XG4gICAgcmV0dXJuIHJlcXVlc3RDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgfVxuICBwcm9ncmVzc2l2ZURvbmUoKSB7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gIH1cbn1cbmNsYXNzIFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSwgYmVnaW4sIGVuZCkge1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9iZWdpbiA9IGJlZ2luO1xuICAgIHRoaXMuX2VuZCA9IGVuZDtcbiAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBfZW5xdWV1ZShjaHVuaykge1xuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gY2h1bms7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlcXVlc3RzQ2FwYWJpbGl0eSA9IHRoaXMuX3JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICByZXF1ZXN0c0NhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIH1cbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICB0aGlzLl9zdHJlYW0uX3JlbW92ZVJhbmdlUmVhZGVyKHRoaXMpO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBpZiAodGhpcy5fcXVldWVkQ2h1bmspIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcXVldWVkQ2h1bms7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3N0cmVhbS5fcmVtb3ZlUmFuZ2VSZWFkZXIodGhpcyk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvY29udGVudF9kaXNwb3NpdGlvbi5qc1xuXG5mdW5jdGlvbiBnZXRGaWxlbmFtZUZyb21Db250ZW50RGlzcG9zaXRpb25IZWFkZXIoY29udGVudERpc3Bvc2l0aW9uKSB7XG4gIGxldCBuZWVkc0VuY29kaW5nRml4dXAgPSB0cnVlO1xuICBsZXQgdG1wID0gdG9QYXJhbVJlZ0V4cChcImZpbGVuYW1lXFxcXCpcIiwgXCJpXCIpLmV4ZWMoY29udGVudERpc3Bvc2l0aW9uKTtcbiAgaWYgKHRtcCkge1xuICAgIHRtcCA9IHRtcFsxXTtcbiAgICBsZXQgZmlsZW5hbWUgPSByZmMyNjE2dW5xdW90ZSh0bXApO1xuICAgIGZpbGVuYW1lID0gdW5lc2NhcGUoZmlsZW5hbWUpO1xuICAgIGZpbGVuYW1lID0gcmZjNTk4N2RlY29kZShmaWxlbmFtZSk7XG4gICAgZmlsZW5hbWUgPSByZmMyMDQ3ZGVjb2RlKGZpbGVuYW1lKTtcbiAgICByZXR1cm4gZml4dXBFbmNvZGluZyhmaWxlbmFtZSk7XG4gIH1cbiAgdG1wID0gcmZjMjIzMWdldHBhcmFtKGNvbnRlbnREaXNwb3NpdGlvbik7XG4gIGlmICh0bXApIHtcbiAgICBjb25zdCBmaWxlbmFtZSA9IHJmYzIwNDdkZWNvZGUodG1wKTtcbiAgICByZXR1cm4gZml4dXBFbmNvZGluZyhmaWxlbmFtZSk7XG4gIH1cbiAgdG1wID0gdG9QYXJhbVJlZ0V4cChcImZpbGVuYW1lXCIsIFwiaVwiKS5leGVjKGNvbnRlbnREaXNwb3NpdGlvbik7XG4gIGlmICh0bXApIHtcbiAgICB0bXAgPSB0bXBbMV07XG4gICAgbGV0IGZpbGVuYW1lID0gcmZjMjYxNnVucXVvdGUodG1wKTtcbiAgICBmaWxlbmFtZSA9IHJmYzIwNDdkZWNvZGUoZmlsZW5hbWUpO1xuICAgIHJldHVybiBmaXh1cEVuY29kaW5nKGZpbGVuYW1lKTtcbiAgfVxuICBmdW5jdGlvbiB0b1BhcmFtUmVnRXhwKGF0dHJpYnV0ZVBhdHRlcm4sIGZsYWdzKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCIoPzpefDspXFxcXHMqXCIgKyBhdHRyaWJ1dGVQYXR0ZXJuICsgXCJcXFxccyo9XFxcXHMqXCIgKyBcIihcIiArICdbXlwiO1xcXFxzXVteO1xcXFxzXSonICsgXCJ8XCIgKyAnXCIoPzpbXlwiXFxcXFxcXFxdfFxcXFxcXFxcXCI/KStcIj8nICsgXCIpXCIsIGZsYWdzKTtcbiAgfVxuICBmdW5jdGlvbiB0ZXh0ZGVjb2RlKGVuY29kaW5nLCB2YWx1ZSkge1xuICAgIGlmIChlbmNvZGluZykge1xuICAgICAgaWYgKCEvXltcXHgwMC1cXHhGRl0rJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihlbmNvZGluZywge1xuICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBidWZmZXIgPSBzdHJpbmdUb0J5dGVzKHZhbHVlKTtcbiAgICAgICAgdmFsdWUgPSBkZWNvZGVyLmRlY29kZShidWZmZXIpO1xuICAgICAgICBuZWVkc0VuY29kaW5nRml4dXAgPSBmYWxzZTtcbiAgICAgIH0gY2F0Y2gge31cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGZpeHVwRW5jb2RpbmcodmFsdWUpIHtcbiAgICBpZiAobmVlZHNFbmNvZGluZ0ZpeHVwICYmIC9bXFx4ODAtXFx4ZmZdLy50ZXN0KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB0ZXh0ZGVjb2RlKFwidXRmLThcIiwgdmFsdWUpO1xuICAgICAgaWYgKG5lZWRzRW5jb2RpbmdGaXh1cCkge1xuICAgICAgICB2YWx1ZSA9IHRleHRkZWNvZGUoXCJpc28tODg1OS0xXCIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIHJmYzIyMzFnZXRwYXJhbShjb250ZW50RGlzcG9zaXRpb25TdHIpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgbGV0IG1hdGNoO1xuICAgIGNvbnN0IGl0ZXIgPSB0b1BhcmFtUmVnRXhwKFwiZmlsZW5hbWVcXFxcKigoPyEwXFxcXGQpXFxcXGQrKShcXFxcKj8pXCIsIFwiaWdcIik7XG4gICAgd2hpbGUgKChtYXRjaCA9IGl0ZXIuZXhlYyhjb250ZW50RGlzcG9zaXRpb25TdHIpKSAhPT0gbnVsbCkge1xuICAgICAgbGV0IFssIG4sIHF1b3QsIHBhcnRdID0gbWF0Y2g7XG4gICAgICBuID0gcGFyc2VJbnQobiwgMTApO1xuICAgICAgaWYgKG4gaW4gbWF0Y2hlcykge1xuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbWF0Y2hlc1tuXSA9IFtxdW90LCBwYXJ0XTtcbiAgICB9XG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IG1hdGNoZXMubGVuZ3RoOyArK24pIHtcbiAgICAgIGlmICghKG4gaW4gbWF0Y2hlcykpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBsZXQgW3F1b3QsIHBhcnRdID0gbWF0Y2hlc1tuXTtcbiAgICAgIHBhcnQgPSByZmMyNjE2dW5xdW90ZShwYXJ0KTtcbiAgICAgIGlmIChxdW90KSB7XG4gICAgICAgIHBhcnQgPSB1bmVzY2FwZShwYXJ0KTtcbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBwYXJ0ID0gcmZjNTk4N2RlY29kZShwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGFydHMucHVzaChwYXJ0KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gcmZjMjYxNnVucXVvdGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuc3RhcnRzV2l0aCgnXCInKSkge1xuICAgICAgY29uc3QgcGFydHMgPSB2YWx1ZS5zbGljZSgxKS5zcGxpdCgnXFxcXFwiJyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHF1b3RpbmRleCA9IHBhcnRzW2ldLmluZGV4T2YoJ1wiJyk7XG4gICAgICAgIGlmIChxdW90aW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgcGFydHNbaV0gPSBwYXJ0c1tpXS5zbGljZSgwLCBxdW90aW5kZXgpO1xuICAgICAgICAgIHBhcnRzLmxlbmd0aCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzW2ldID0gcGFydHNbaV0ucmVwbGFjZUFsbCgvXFxcXCguKS9nLCBcIiQxXCIpO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSBwYXJ0cy5qb2luKCdcIicpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gcmZjNTk4N2RlY29kZShleHR2YWx1ZSkge1xuICAgIGNvbnN0IGVuY29kaW5nZW5kID0gZXh0dmFsdWUuaW5kZXhPZihcIidcIik7XG4gICAgaWYgKGVuY29kaW5nZW5kID09PSAtMSkge1xuICAgICAgcmV0dXJuIGV4dHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBlbmNvZGluZyA9IGV4dHZhbHVlLnNsaWNlKDAsIGVuY29kaW5nZW5kKTtcbiAgICBjb25zdCBsYW5ndmFsdWUgPSBleHR2YWx1ZS5zbGljZShlbmNvZGluZ2VuZCArIDEpO1xuICAgIGNvbnN0IHZhbHVlID0gbGFuZ3ZhbHVlLnJlcGxhY2UoL15bXiddKicvLCBcIlwiKTtcbiAgICByZXR1cm4gdGV4dGRlY29kZShlbmNvZGluZywgdmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIHJmYzIwNDdkZWNvZGUodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlLnN0YXJ0c1dpdGgoXCI9P1wiKSB8fCAvW1xceDAwLVxceDE5XFx4ODAtXFx4ZmZdLy50ZXN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZUFsbCgvPVxcPyhbXFx3LV0qKVxcPyhbUXFCYl0pXFw/KCg/OlteP118XFw/KD8hPSkpKilcXD89L2csIGZ1bmN0aW9uIChtYXRjaGVzLCBjaGFyc2V0LCBlbmNvZGluZywgdGV4dCkge1xuICAgICAgaWYgKGVuY29kaW5nID09PSBcInFcIiB8fCBlbmNvZGluZyA9PT0gXCJRXCIpIHtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZUFsbChcIl9cIiwgXCIgXCIpO1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlQWxsKC89KFswLTlhLWZBLUZdezJ9KS9nLCBmdW5jdGlvbiAobWF0Y2gsIGhleCkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGhleCwgMTYpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0ZXh0ZGVjb2RlKGNoYXJzZXQsIHRleHQpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGV4dCA9IGF0b2IodGV4dCk7XG4gICAgICB9IGNhdGNoIHt9XG4gICAgICByZXR1cm4gdGV4dGRlY29kZShjaGFyc2V0LCB0ZXh0KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvbmV0d29ya191dGlscy5qc1xuXG5cblxuZnVuY3Rpb24gY3JlYXRlSGVhZGVycyhpc0h0dHAsIGh0dHBIZWFkZXJzKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICBpZiAoIWlzSHR0cCB8fCAhaHR0cEhlYWRlcnMgfHwgdHlwZW9mIGh0dHBIZWFkZXJzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGhlYWRlcnM7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gaHR0cEhlYWRlcnMpIHtcbiAgICBjb25zdCB2YWwgPSBodHRwSGVhZGVyc1trZXldO1xuICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaGVhZGVycztcbn1cbmZ1bmN0aW9uIGdldFJlc3BvbnNlT3JpZ2luKHVybCkge1xuICByZXR1cm4gVVJMLnBhcnNlKHVybCk/Lm9yaWdpbiA/PyBudWxsO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVSYW5nZVJlcXVlc3RDYXBhYmlsaXRpZXMoe1xuICByZXNwb25zZUhlYWRlcnMsXG4gIGlzSHR0cCxcbiAgcmFuZ2VDaHVua1NpemUsXG4gIGRpc2FibGVSYW5nZVxufSkge1xuICBjb25zdCByZXR1cm5WYWx1ZXMgPSB7XG4gICAgYWxsb3dSYW5nZVJlcXVlc3RzOiBmYWxzZSxcbiAgICBzdWdnZXN0ZWRMZW5ndGg6IHVuZGVmaW5lZFxuICB9O1xuICBjb25zdCBsZW5ndGggPSBwYXJzZUludChyZXNwb25zZUhlYWRlcnMuZ2V0KFwiQ29udGVudC1MZW5ndGhcIiksIDEwKTtcbiAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGxlbmd0aCkpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIHJldHVyblZhbHVlcy5zdWdnZXN0ZWRMZW5ndGggPSBsZW5ndGg7XG4gIGlmIChsZW5ndGggPD0gMiAqIHJhbmdlQ2h1bmtTaXplKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuICBpZiAoZGlzYWJsZVJhbmdlIHx8ICFpc0h0dHApIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIGlmIChyZXNwb25zZUhlYWRlcnMuZ2V0KFwiQWNjZXB0LVJhbmdlc1wiKSAhPT0gXCJieXRlc1wiKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuICBjb25zdCBjb250ZW50RW5jb2RpbmcgPSByZXNwb25zZUhlYWRlcnMuZ2V0KFwiQ29udGVudC1FbmNvZGluZ1wiKSB8fCBcImlkZW50aXR5XCI7XG4gIGlmIChjb250ZW50RW5jb2RpbmcgIT09IFwiaWRlbnRpdHlcIikge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgcmV0dXJuVmFsdWVzLmFsbG93UmFuZ2VSZXF1ZXN0cyA9IHRydWU7XG4gIHJldHVybiByZXR1cm5WYWx1ZXM7XG59XG5mdW5jdGlvbiBleHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyKHJlc3BvbnNlSGVhZGVycykge1xuICBjb25zdCBjb250ZW50RGlzcG9zaXRpb24gPSByZXNwb25zZUhlYWRlcnMuZ2V0KFwiQ29udGVudC1EaXNwb3NpdGlvblwiKTtcbiAgaWYgKGNvbnRlbnREaXNwb3NpdGlvbikge1xuICAgIGxldCBmaWxlbmFtZSA9IGdldEZpbGVuYW1lRnJvbUNvbnRlbnREaXNwb3NpdGlvbkhlYWRlcihjb250ZW50RGlzcG9zaXRpb24pO1xuICAgIGlmIChmaWxlbmFtZS5pbmNsdWRlcyhcIiVcIikpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZpbGVuYW1lID0gZGVjb2RlVVJJQ29tcG9uZW50KGZpbGVuYW1lKTtcbiAgICAgIH0gY2F0Y2gge31cbiAgICB9XG4gICAgaWYgKGlzUGRmRmlsZShmaWxlbmFtZSkpIHtcbiAgICAgIHJldHVybiBmaWxlbmFtZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjcmVhdGVSZXNwb25zZUVycm9yKHN0YXR1cywgdXJsKSB7XG4gIHJldHVybiBuZXcgUmVzcG9uc2VFeGNlcHRpb24oYFVuZXhwZWN0ZWQgc2VydmVyIHJlc3BvbnNlICgke3N0YXR1c30pIHdoaWxlIHJldHJpZXZpbmcgUERGIFwiJHt1cmx9XCIuYCwgc3RhdHVzLCBzdGF0dXMgPT09IDQwNCB8fCBzdGF0dXMgPT09IDAgJiYgdXJsLnN0YXJ0c1dpdGgoXCJmaWxlOlwiKSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVJlc3BvbnNlU3RhdHVzKHN0YXR1cykge1xuICByZXR1cm4gc3RhdHVzID09PSAyMDAgfHwgc3RhdHVzID09PSAyMDY7XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2ZldGNoX3N0cmVhbS5qc1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUZldGNoT3B0aW9ucyhoZWFkZXJzLCB3aXRoQ3JlZGVudGlhbHMsIGFib3J0Q29udHJvbGxlcikge1xuICByZXR1cm4ge1xuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBoZWFkZXJzLFxuICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICBtb2RlOiBcImNvcnNcIixcbiAgICBjcmVkZW50aWFsczogd2l0aENyZWRlbnRpYWxzID8gXCJpbmNsdWRlXCIgOiBcInNhbWUtb3JpZ2luXCIsXG4gICAgcmVkaXJlY3Q6IFwiZm9sbG93XCJcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEFycmF5QnVmZmVyKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiB2YWwuYnVmZmVyO1xuICB9XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgd2FybihgZ2V0QXJyYXlCdWZmZXIgLSB1bmV4cGVjdGVkIGRhdGEgZm9ybWF0OiAke3ZhbH1gKTtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHZhbCkuYnVmZmVyO1xufVxuY2xhc3MgUERGRmV0Y2hTdHJlYW0ge1xuICBfcmVzcG9uc2VPcmlnaW4gPSBudWxsO1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLmlzSHR0cCA9IC9eaHR0cHM/Oi9pLnRlc3Qoc291cmNlLnVybCk7XG4gICAgdGhpcy5oZWFkZXJzID0gY3JlYXRlSGVhZGVycyh0aGlzLmlzSHR0cCwgc291cmNlLmh0dHBIZWFkZXJzKTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycyA9IFtdO1xuICB9XG4gIGdldCBfcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uX2xvYWRlZCA/PyAwO1xuICB9XG4gIGdldEZ1bGxSZWFkZXIoKSB7XG4gICAgYXNzZXJ0KCF0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciwgXCJQREZGZXRjaFN0cmVhbS5nZXRGdWxsUmVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLlwiKTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG5ldyBQREZGZXRjaFN0cmVhbVJlYWRlcih0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI7XG4gIH1cbiAgZ2V0UmFuZ2VSZWFkZXIoYmVnaW4sIGVuZCkge1xuICAgIGlmIChlbmQgPD0gdGhpcy5fcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IFBERkZldGNoU3RyZWFtUmFuZ2VSZWFkZXIodGhpcywgYmVnaW4sIGVuZCk7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5wdXNoKHJlYWRlcik7XG4gICAgcmV0dXJuIHJlYWRlcjtcbiAgfVxuICBjYW5jZWxBbGxSZXF1ZXN0cyhyZWFzb24pIHtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgZm9yIChjb25zdCByZWFkZXIgb2YgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5zbGljZSgwKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgUERGRmV0Y2hTdHJlYW1SZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fcmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gbnVsbDtcbiAgICBjb25zdCBzb3VyY2UgPSBzdHJlYW0uc291cmNlO1xuICAgIHRoaXMuX3dpdGhDcmVkZW50aWFscyA9IHNvdXJjZS53aXRoQ3JlZGVudGlhbHMgfHwgZmFsc2U7XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSBzb3VyY2UuZGlzYWJsZVJhbmdlIHx8IGZhbHNlO1xuICAgIHRoaXMuX3JhbmdlQ2h1bmtTaXplID0gc291cmNlLnJhbmdlQ2h1bmtTaXplO1xuICAgIGlmICghdGhpcy5fcmFuZ2VDaHVua1NpemUgJiYgIXRoaXMuX2Rpc2FibGVSYW5nZSkge1xuICAgICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVSYW5nZTtcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoc3RyZWFtLmhlYWRlcnMpO1xuICAgIGNvbnN0IHVybCA9IHNvdXJjZS51cmw7XG4gICAgZmV0Y2godXJsLCBjcmVhdGVGZXRjaE9wdGlvbnMoaGVhZGVycywgdGhpcy5fd2l0aENyZWRlbnRpYWxzLCB0aGlzLl9hYm9ydENvbnRyb2xsZXIpKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgIHN0cmVhbS5fcmVzcG9uc2VPcmlnaW4gPSBnZXRSZXNwb25zZU9yaWdpbihyZXNwb25zZS51cmwpO1xuICAgICAgaWYgKCF2YWxpZGF0ZVJlc3BvbnNlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlUmVzcG9uc2VFcnJvcihyZXNwb25zZS5zdGF0dXMsIHVybCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2UuaGVhZGVycztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWxsb3dSYW5nZVJlcXVlc3RzLFxuICAgICAgICBzdWdnZXN0ZWRMZW5ndGhcbiAgICAgIH0gPSB2YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyh7XG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgaXNIdHRwOiBzdHJlYW0uaXNIdHRwLFxuICAgICAgICByYW5nZUNodW5rU2l6ZTogdGhpcy5fcmFuZ2VDaHVua1NpemUsXG4gICAgICAgIGRpc2FibGVSYW5nZTogdGhpcy5fZGlzYWJsZVJhbmdlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSBhbGxvd1JhbmdlUmVxdWVzdHM7XG4gICAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc3VnZ2VzdGVkTGVuZ3RoIHx8IHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gICAgICB0aGlzLl9maWxlbmFtZSA9IGV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXIocmVzcG9uc2VIZWFkZXJzKTtcbiAgICAgIGlmICghdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgJiYgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCkge1xuICAgICAgICB0aGlzLmNhbmNlbChuZXcgQWJvcnRFeGNlcHRpb24oXCJTdHJlYW1pbmcgaXMgZGlzYWJsZWQuXCIpKTtcbiAgICAgIH1cbiAgICB9KS5jYXRjaCh0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QpO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgZ2V0IGhlYWRlcnNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBnZXQgZmlsZW5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVuYW1lO1xuICB9XG4gIGdldCBjb250ZW50TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICB9XG4gIGdldCBpc1JhbmdlU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBhd2FpdCB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHZhbHVlLFxuICAgICAgZG9uZVxuICAgIH0gPSBhd2FpdCB0aGlzLl9yZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZG9uZVxuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgbG9hZGVkOiB0aGlzLl9sb2FkZWQsXG4gICAgICB0b3RhbDogdGhpcy5fY29udGVudExlbmd0aFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogZ2V0QXJyYXlCdWZmZXIodmFsdWUpLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9yZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICB9XG59XG5jbGFzcyBQREZGZXRjaFN0cmVhbVJhbmdlUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBiZWdpbiwgZW5kKSB7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX3JlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICBjb25zdCBzb3VyY2UgPSBzdHJlYW0uc291cmNlO1xuICAgIHRoaXMuX3dpdGhDcmVkZW50aWFscyA9IHNvdXJjZS53aXRoQ3JlZGVudGlhbHMgfHwgZmFsc2U7XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHN0cmVhbS5oZWFkZXJzKTtcbiAgICBoZWFkZXJzLmFwcGVuZChcIlJhbmdlXCIsIGBieXRlcz0ke2JlZ2lufS0ke2VuZCAtIDF9YCk7XG4gICAgY29uc3QgdXJsID0gc291cmNlLnVybDtcbiAgICBmZXRjaCh1cmwsIGNyZWF0ZUZldGNoT3B0aW9ucyhoZWFkZXJzLCB0aGlzLl93aXRoQ3JlZGVudGlhbHMsIHRoaXMuX2Fib3J0Q29udHJvbGxlcikpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgY29uc3QgcmVzcG9uc2VPcmlnaW4gPSBnZXRSZXNwb25zZU9yaWdpbihyZXNwb25zZS51cmwpO1xuICAgICAgaWYgKHJlc3BvbnNlT3JpZ2luICE9PSBzdHJlYW0uX3Jlc3BvbnNlT3JpZ2luKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgcmFuZ2UgcmVzcG9uc2Utb3JpZ2luIFwiJHtyZXNwb25zZU9yaWdpbn1cIiB0byBtYXRjaCBcIiR7c3RyZWFtLl9yZXNwb25zZU9yaWdpbn1cIi5gKTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsaWRhdGVSZXNwb25zZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZVJlc3BvbnNlRXJyb3IocmVzcG9uc2Uuc3RhdHVzLCB1cmwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgdGhpcy5fcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICB9KS5jYXRjaCh0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZWplY3QpO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX3JlYWRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWUsXG4gICAgICBkb25lXG4gICAgfSA9IGF3YWl0IHRoaXMuX3JlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkb25lXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogZ2V0QXJyYXlCdWZmZXIodmFsdWUpLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9yZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L25ldHdvcmsuanNcblxuXG5jb25zdCBPS19SRVNQT05TRSA9IDIwMDtcbmNvbnN0IFBBUlRJQUxfQ09OVEVOVF9SRVNQT05TRSA9IDIwNjtcbmZ1bmN0aW9uIG5ldHdvcmtfZ2V0QXJyYXlCdWZmZXIoeGhyKSB7XG4gIGNvbnN0IGRhdGEgPSB4aHIucmVzcG9uc2U7XG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIHJldHVybiBzdHJpbmdUb0J5dGVzKGRhdGEpLmJ1ZmZlcjtcbn1cbmNsYXNzIE5ldHdvcmtNYW5hZ2VyIHtcbiAgX3Jlc3BvbnNlT3JpZ2luID0gbnVsbDtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHVybCxcbiAgICBodHRwSGVhZGVycyxcbiAgICB3aXRoQ3JlZGVudGlhbHNcbiAgfSkge1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMuaXNIdHRwID0gL15odHRwcz86L2kudGVzdCh1cmwpO1xuICAgIHRoaXMuaGVhZGVycyA9IGNyZWF0ZUhlYWRlcnModGhpcy5pc0h0dHAsIGh0dHBIZWFkZXJzKTtcbiAgICB0aGlzLndpdGhDcmVkZW50aWFscyA9IHdpdGhDcmVkZW50aWFscyB8fCBmYWxzZTtcbiAgICB0aGlzLmN1cnJYaHJJZCA9IDA7XG4gICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIHJlcXVlc3QoYXJncykge1xuICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIGNvbnN0IHhocklkID0gdGhpcy5jdXJyWGhySWQrKztcbiAgICBjb25zdCBwZW5kaW5nUmVxdWVzdCA9IHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXSA9IHtcbiAgICAgIHhoclxuICAgIH07XG4gICAgeGhyLm9wZW4oXCJHRVRcIiwgdGhpcy51cmwpO1xuICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLndpdGhDcmVkZW50aWFscztcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcy5oZWFkZXJzKSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzSHR0cCAmJiBcImJlZ2luXCIgaW4gYXJncyAmJiBcImVuZFwiIGluIGFyZ3MpIHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiUmFuZ2VcIiwgYGJ5dGVzPSR7YXJncy5iZWdpbn0tJHthcmdzLmVuZCAtIDF9YCk7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5leHBlY3RlZFN0YXR1cyA9IFBBUlRJQUxfQ09OVEVOVF9SRVNQT05TRTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVuZGluZ1JlcXVlc3QuZXhwZWN0ZWRTdGF0dXMgPSBPS19SRVNQT05TRTtcbiAgICB9XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgICBhc3NlcnQoYXJncy5vbkVycm9yLCBcIkV4cGVjdGVkIGBvbkVycm9yYCBjYWxsYmFjayB0byBiZSBwcm92aWRlZC5cIik7XG4gICAgeGhyLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICBhcmdzLm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgfTtcbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5vblN0YXRlQ2hhbmdlLmJpbmQodGhpcywgeGhySWQpO1xuICAgIHhoci5vbnByb2dyZXNzID0gdGhpcy5vblByb2dyZXNzLmJpbmQodGhpcywgeGhySWQpO1xuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkID0gYXJncy5vbkhlYWRlcnNSZWNlaXZlZDtcbiAgICBwZW5kaW5nUmVxdWVzdC5vbkRvbmUgPSBhcmdzLm9uRG9uZTtcbiAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yID0gYXJncy5vbkVycm9yO1xuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uUHJvZ3Jlc3MgPSBhcmdzLm9uUHJvZ3Jlc3M7XG4gICAgeGhyLnNlbmQobnVsbCk7XG4gICAgcmV0dXJuIHhocklkO1xuICB9XG4gIG9uUHJvZ3Jlc3MoeGhySWQsIGV2dCkge1xuICAgIGNvbnN0IHBlbmRpbmdSZXF1ZXN0ID0gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdO1xuICAgIGlmICghcGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGVuZGluZ1JlcXVlc3Qub25Qcm9ncmVzcz8uKGV2dCk7XG4gIH1cbiAgb25TdGF0ZUNoYW5nZSh4aHJJZCwgZXZ0KSB7XG4gICAgY29uc3QgcGVuZGluZ1JlcXVlc3QgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG4gICAgaWYgKCFwZW5kaW5nUmVxdWVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB4aHIgPSBwZW5kaW5nUmVxdWVzdC54aHI7XG4gICAgaWYgKHhoci5yZWFkeVN0YXRlID49IDIgJiYgcGVuZGluZ1JlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQpIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkKCk7XG4gICAgICBkZWxldGUgcGVuZGluZ1JlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQ7XG4gICAgfVxuICAgIGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoISh4aHJJZCBpbiB0aGlzLnBlbmRpbmdSZXF1ZXN0cykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXTtcbiAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMCAmJiB0aGlzLmlzSHR0cCkge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvcih4aHIuc3RhdHVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeGhyU3RhdHVzID0geGhyLnN0YXR1cyB8fCBPS19SRVNQT05TRTtcbiAgICBjb25zdCBva19yZXNwb25zZV9vbl9yYW5nZV9yZXF1ZXN0ID0geGhyU3RhdHVzID09PSBPS19SRVNQT05TRSAmJiBwZW5kaW5nUmVxdWVzdC5leHBlY3RlZFN0YXR1cyA9PT0gUEFSVElBTF9DT05URU5UX1JFU1BPTlNFO1xuICAgIGlmICghb2tfcmVzcG9uc2Vfb25fcmFuZ2VfcmVxdWVzdCAmJiB4aHJTdGF0dXMgIT09IHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzKSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yKHhoci5zdGF0dXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjaHVuayA9IG5ldHdvcmtfZ2V0QXJyYXlCdWZmZXIoeGhyKTtcbiAgICBpZiAoeGhyU3RhdHVzID09PSBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0UpIHtcbiAgICAgIGNvbnN0IHJhbmdlSGVhZGVyID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1SYW5nZVwiKTtcbiAgICAgIGNvbnN0IG1hdGNoZXMgPSAvYnl0ZXMgKFxcZCspLShcXGQrKVxcLyhcXGQrKS8uZXhlYyhyYW5nZUhlYWRlcik7XG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICBwZW5kaW5nUmVxdWVzdC5vbkRvbmUoe1xuICAgICAgICAgIGJlZ2luOiBwYXJzZUludChtYXRjaGVzWzFdLCAxMCksXG4gICAgICAgICAgY2h1bmtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKGBNaXNzaW5nIG9yIGludmFsaWQgXCJDb250ZW50LVJhbmdlXCIgaGVhZGVyLmApO1xuICAgICAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yKDApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2h1bmspIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRG9uZSh7XG4gICAgICAgIGJlZ2luOiAwLFxuICAgICAgICBjaHVua1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgfVxuICB9XG4gIGdldFJlcXVlc3RYaHIoeGhySWQpIHtcbiAgICByZXR1cm4gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdLnhocjtcbiAgfVxuICBpc1BlbmRpbmdSZXF1ZXN0KHhocklkKSB7XG4gICAgcmV0dXJuIHhocklkIGluIHRoaXMucGVuZGluZ1JlcXVlc3RzO1xuICB9XG4gIGFib3J0UmVxdWVzdCh4aHJJZCkge1xuICAgIGNvbnN0IHhociA9IHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXS54aHI7XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXTtcbiAgICB4aHIuYWJvcnQoKTtcbiAgfVxufVxuY2xhc3MgUERGTmV0d29ya1N0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLl9tYW5hZ2VyID0gbmV3IE5ldHdvcmtNYW5hZ2VyKHNvdXJjZSk7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMgPSBbXTtcbiAgfVxuICBfb25SYW5nZVJlcXVlc3RSZWFkZXJDbG9zZWQocmVhZGVyKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuaW5kZXhPZihyZWFkZXIpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxuICBnZXRGdWxsUmVhZGVyKCkge1xuICAgIGFzc2VydCghdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIsIFwiUERGTmV0d29ya1N0cmVhbS5nZXRGdWxsUmVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLlwiKTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG5ldyBQREZOZXR3b3JrU3RyZWFtRnVsbFJlcXVlc3RSZWFkZXIodGhpcy5fbWFuYWdlciwgdGhpcy5fc291cmNlKTtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI7XG4gIH1cbiAgZ2V0UmFuZ2VSZWFkZXIoYmVnaW4sIGVuZCkge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBQREZOZXR3b3JrU3RyZWFtUmFuZ2VSZXF1ZXN0UmVhZGVyKHRoaXMuX21hbmFnZXIsIGJlZ2luLCBlbmQpO1xuICAgIHJlYWRlci5vbkNsb3NlZCA9IHRoaXMuX29uUmFuZ2VSZXF1ZXN0UmVhZGVyQ2xvc2VkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5wdXNoKHJlYWRlcik7XG4gICAgcmV0dXJuIHJlYWRlcjtcbiAgfVxuICBjYW5jZWxBbGxSZXF1ZXN0cyhyZWFzb24pIHtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgZm9yIChjb25zdCByZWFkZXIgb2YgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5zbGljZSgwKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgUERGTmV0d29ya1N0cmVhbUZ1bGxSZXF1ZXN0UmVhZGVyIHtcbiAgY29uc3RydWN0b3IobWFuYWdlciwgc291cmNlKSB7XG4gICAgdGhpcy5fbWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5fdXJsID0gc291cmNlLnVybDtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdElkID0gbWFuYWdlci5yZXF1ZXN0KHtcbiAgICAgIG9uSGVhZGVyc1JlY2VpdmVkOiB0aGlzLl9vbkhlYWRlcnNSZWNlaXZlZC5iaW5kKHRoaXMpLFxuICAgICAgb25Eb25lOiB0aGlzLl9vbkRvbmUuYmluZCh0aGlzKSxcbiAgICAgIG9uRXJyb3I6IHRoaXMuX29uRXJyb3IuYmluZCh0aGlzKSxcbiAgICAgIG9uUHJvZ3Jlc3M6IHRoaXMuX29uUHJvZ3Jlc3MuYmluZCh0aGlzKVxuICAgIH0pO1xuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gc291cmNlLmRpc2FibGVSYW5nZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICB0aGlzLl9yYW5nZUNodW5rU2l6ZSA9IHNvdXJjZS5yYW5nZUNodW5rU2l6ZTtcbiAgICBpZiAoIXRoaXMuX3JhbmdlQ2h1bmtTaXplICYmICF0aGlzLl9kaXNhYmxlUmFuZ2UpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2NhY2hlZENodW5rcyA9IFtdO1xuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gbnVsbDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIF9vbkhlYWRlcnNSZWNlaXZlZCgpIHtcbiAgICBjb25zdCBmdWxsUmVxdWVzdFhocklkID0gdGhpcy5fZnVsbFJlcXVlc3RJZDtcbiAgICBjb25zdCBmdWxsUmVxdWVzdFhociA9IHRoaXMuX21hbmFnZXIuZ2V0UmVxdWVzdFhocihmdWxsUmVxdWVzdFhocklkKTtcbiAgICB0aGlzLl9tYW5hZ2VyLl9yZXNwb25zZU9yaWdpbiA9IGdldFJlc3BvbnNlT3JpZ2luKGZ1bGxSZXF1ZXN0WGhyLnJlc3BvbnNlVVJMKTtcbiAgICBjb25zdCByYXdSZXNwb25zZUhlYWRlcnMgPSBmdWxsUmVxdWVzdFhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKTtcbiAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBuZXcgSGVhZGVycyhyYXdSZXNwb25zZUhlYWRlcnMgPyByYXdSZXNwb25zZUhlYWRlcnMudHJpbVN0YXJ0KCkucmVwbGFjZSgvW15cXFMgXSskLywgXCJcIikuc3BsaXQoL1tcXHJcXG5dKy8pLm1hcCh4ID0+IHtcbiAgICAgIGNvbnN0IFtrZXksIC4uLnZhbF0gPSB4LnNwbGl0KFwiOiBcIik7XG4gICAgICByZXR1cm4gW2tleSwgdmFsLmpvaW4oXCI6IFwiKV07XG4gICAgfSkgOiBbXSk7XG4gICAgY29uc3Qge1xuICAgICAgYWxsb3dSYW5nZVJlcXVlc3RzLFxuICAgICAgc3VnZ2VzdGVkTGVuZ3RoXG4gICAgfSA9IHZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKHtcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIGlzSHR0cDogdGhpcy5fbWFuYWdlci5pc0h0dHAsXG4gICAgICByYW5nZUNodW5rU2l6ZTogdGhpcy5fcmFuZ2VDaHVua1NpemUsXG4gICAgICBkaXNhYmxlUmFuZ2U6IHRoaXMuX2Rpc2FibGVSYW5nZVxuICAgIH0pO1xuICAgIGlmIChhbGxvd1JhbmdlUmVxdWVzdHMpIHtcbiAgICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc3VnZ2VzdGVkTGVuZ3RoIHx8IHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBleHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyKHJlc3BvbnNlSGVhZGVycyk7XG4gICAgaWYgKHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMuX21hbmFnZXIuYWJvcnRSZXF1ZXN0KGZ1bGxSZXF1ZXN0WGhySWQpO1xuICAgIH1cbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgX29uRG9uZShkYXRhKSB7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIGlmICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IGRhdGEuY2h1bmssXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jYWNoZWRDaHVua3MucHVzaChkYXRhLmNodW5rKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgaWYgKHRoaXMuX2NhY2hlZENodW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgfVxuICBfb25FcnJvcihzdGF0dXMpIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IGNyZWF0ZVJlc3BvbnNlRXJyb3Ioc3RhdHVzLCB0aGlzLl91cmwpO1xuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdCh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVqZWN0KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9jYWNoZWRDaHVua3MubGVuZ3RoID0gMDtcbiAgfVxuICBfb25Qcm9ncmVzcyhldnQpIHtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IGV2dC5sb2FkZWQsXG4gICAgICB0b3RhbDogZXZ0Lmxlbmd0aENvbXB1dGFibGUgPyBldnQudG90YWwgOiB0aGlzLl9jb250ZW50TGVuZ3RoXG4gICAgfSk7XG4gIH1cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuICBnZXQgaXNSYW5nZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNSYW5nZVN1cHBvcnRlZDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGdldCBjb250ZW50TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICB9XG4gIGdldCBoZWFkZXJzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBhd2FpdCB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIGlmICh0aGlzLl9jYWNoZWRDaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9jYWNoZWRDaHVua3Muc2hpZnQoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX3JlcXVlc3RzLnB1c2gocmVxdWVzdENhcGFiaWxpdHkpO1xuICAgIHJldHVybiByZXF1ZXN0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgaWYgKHRoaXMuX21hbmFnZXIuaXNQZW5kaW5nUmVxdWVzdCh0aGlzLl9mdWxsUmVxdWVzdElkKSkge1xuICAgICAgdGhpcy5fbWFuYWdlci5hYm9ydFJlcXVlc3QodGhpcy5fZnVsbFJlcXVlc3RJZCk7XG4gICAgfVxuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgfVxufVxuY2xhc3MgUERGTmV0d29ya1N0cmVhbVJhbmdlUmVxdWVzdFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIsIGJlZ2luLCBlbmQpIHtcbiAgICB0aGlzLl9tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLl91cmwgPSBtYW5hZ2VyLnVybDtcbiAgICB0aGlzLl9yZXF1ZXN0SWQgPSBtYW5hZ2VyLnJlcXVlc3Qoe1xuICAgICAgYmVnaW4sXG4gICAgICBlbmQsXG4gICAgICBvbkhlYWRlcnNSZWNlaXZlZDogdGhpcy5fb25IZWFkZXJzUmVjZWl2ZWQuYmluZCh0aGlzKSxcbiAgICAgIG9uRG9uZTogdGhpcy5fb25Eb25lLmJpbmQodGhpcyksXG4gICAgICBvbkVycm9yOiB0aGlzLl9vbkVycm9yLmJpbmQodGhpcyksXG4gICAgICBvblByb2dyZXNzOiB0aGlzLl9vblByb2dyZXNzLmJpbmQodGhpcylcbiAgICB9KTtcbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgICB0aGlzLm9uQ2xvc2VkID0gbnVsbDtcbiAgfVxuICBfb25IZWFkZXJzUmVjZWl2ZWQoKSB7XG4gICAgY29uc3QgcmVzcG9uc2VPcmlnaW4gPSBnZXRSZXNwb25zZU9yaWdpbih0aGlzLl9tYW5hZ2VyLmdldFJlcXVlc3RYaHIodGhpcy5fcmVxdWVzdElkKT8ucmVzcG9uc2VVUkwpO1xuICAgIGlmIChyZXNwb25zZU9yaWdpbiAhPT0gdGhpcy5fbWFuYWdlci5fcmVzcG9uc2VPcmlnaW4pIHtcbiAgICAgIHRoaXMuX3N0b3JlZEVycm9yID0gbmV3IEVycm9yKGBFeHBlY3RlZCByYW5nZSByZXNwb25zZS1vcmlnaW4gXCIke3Jlc3BvbnNlT3JpZ2lufVwiIHRvIG1hdGNoIFwiJHt0aGlzLl9tYW5hZ2VyLl9yZXNwb25zZU9yaWdpbn1cIi5gKTtcbiAgICAgIHRoaXMuX29uRXJyb3IoMCk7XG4gICAgfVxuICB9XG4gIF9jbG9zZSgpIHtcbiAgICB0aGlzLm9uQ2xvc2VkPy4odGhpcyk7XG4gIH1cbiAgX29uRG9uZShkYXRhKSB7XG4gICAgY29uc3QgY2h1bmsgPSBkYXRhLmNodW5rO1xuICAgIGlmICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IHRoaXMuX3JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gY2h1bms7XG4gICAgfVxuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9jbG9zZSgpO1xuICB9XG4gIF9vbkVycm9yKHN0YXR1cykge1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID8/PSBjcmVhdGVSZXNwb25zZUVycm9yKHN0YXR1cywgdGhpcy5fdXJsKTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZWplY3QodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgfVxuICBfb25Qcm9ncmVzcyhldnQpIHtcbiAgICBpZiAoIXRoaXMuaXNTdHJlYW1pbmdTdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIGlmICh0aGlzLl9xdWV1ZWRDaHVuayAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9xdWV1ZWRDaHVuaztcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX3JlcXVlc3RzLnB1c2gocmVxdWVzdENhcGFiaWxpdHkpO1xuICAgIHJldHVybiByZXF1ZXN0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgaWYgKHRoaXMuX21hbmFnZXIuaXNQZW5kaW5nUmVxdWVzdCh0aGlzLl9yZXF1ZXN0SWQpKSB7XG4gICAgICB0aGlzLl9tYW5hZ2VyLmFib3J0UmVxdWVzdCh0aGlzLl9yZXF1ZXN0SWQpO1xuICAgIH1cbiAgICB0aGlzLl9jbG9zZSgpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L25vZGVfc3RyZWFtLmpzXG5cblxuY29uc3QgdXJsUmVnZXggPSAvXlthLXpdW2EtejAtOVxcLSsuXSs6L2k7XG5mdW5jdGlvbiBwYXJzZVVybE9yUGF0aChzb3VyY2VVcmwpIHtcbiAgaWYgKHVybFJlZ2V4LnRlc3Qoc291cmNlVXJsKSkge1xuICAgIHJldHVybiBuZXcgVVJMKHNvdXJjZVVybCk7XG4gIH1cbiAgY29uc3QgdXJsID0gcHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlKFwidXJsXCIpO1xuICByZXR1cm4gbmV3IFVSTCh1cmwucGF0aFRvRmlsZVVSTChzb3VyY2VVcmwpKTtcbn1cbmNsYXNzIFBERk5vZGVTdHJlYW0ge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLnVybCA9IHBhcnNlVXJsT3JQYXRoKHNvdXJjZS51cmwpO1xuICAgIGFzc2VydCh0aGlzLnVybC5wcm90b2NvbCA9PT0gXCJmaWxlOlwiLCBcIlBERk5vZGVTdHJlYW0gb25seSBzdXBwb3J0cyBmaWxlOi8vIFVSTHMuXCIpO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzID0gW107XG4gIH1cbiAgZ2V0IF9wcm9ncmVzc2l2ZURhdGFMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5fbG9hZGVkID8/IDA7XG4gIH1cbiAgZ2V0RnVsbFJlYWRlcigpIHtcbiAgICBhc3NlcnQoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERk5vZGVTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBuZXcgUERGTm9kZVN0cmVhbUZzRnVsbFJlYWRlcih0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI7XG4gIH1cbiAgZ2V0UmFuZ2VSZWFkZXIoc3RhcnQsIGVuZCkge1xuICAgIGlmIChlbmQgPD0gdGhpcy5fcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmFuZ2VSZWFkZXIgPSBuZXcgUERGTm9kZVN0cmVhbUZzUmFuZ2VSZWFkZXIodGhpcywgc3RhcnQsIGVuZCk7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5wdXNoKHJhbmdlUmVhZGVyKTtcbiAgICByZXR1cm4gcmFuZ2VSZWFkZXI7XG4gIH1cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFBERk5vZGVTdHJlYW1Gc0Z1bGxSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcbiAgICB0aGlzLl91cmwgPSBzdHJlYW0udXJsO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IG51bGw7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgICBjb25zdCBzb3VyY2UgPSBzdHJlYW0uc291cmNlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBudWxsO1xuICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHNvdXJjZS5kaXNhYmxlUmFuZ2UgfHwgZmFsc2U7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG4gICAgaWYgKCF0aGlzLl9yYW5nZUNodW5rU2l6ZSAmJiAhdGhpcy5fZGlzYWJsZVJhbmdlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlUmFuZ2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSBudWxsO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICBjb25zdCBmcyA9IHByb2Nlc3MuZ2V0QnVpbHRpbk1vZHVsZShcImZzXCIpO1xuICAgIGZzLnByb21pc2VzLmxzdGF0KHRoaXMuX3VybCkudGhlbihzdGF0ID0+IHtcbiAgICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzdGF0LnNpemU7XG4gICAgICB0aGlzLl9zZXRSZWFkYWJsZVN0cmVhbShmcy5jcmVhdGVSZWFkU3RyZWFtKHRoaXMuX3VybCkpO1xuICAgICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0sIGVycm9yID0+IHtcbiAgICAgIGlmIChlcnJvci5jb2RlID09PSBcIkVOT0VOVFwiKSB7XG4gICAgICAgIGVycm9yID0gY3JlYXRlUmVzcG9uc2VFcnJvcigwLCB0aGlzLl91cmwuaHJlZik7XG4gICAgICB9XG4gICAgICB0aGlzLl9zdG9yZWRFcnJvciA9IGVycm9yO1xuICAgICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KGVycm9yKTtcbiAgICB9KTtcbiAgfVxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gIH1cbiAgZ2V0IGNvbnRlbnRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gIH1cbiAgZ2V0IGlzUmFuZ2VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX3JlYWRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcmVhZGFibGVTdHJlYW0ucmVhZCgpO1xuICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgIHJldHVybiB0aGlzLnJlYWQoKTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IGNodW5rLmxlbmd0aDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZCxcbiAgICAgIHRvdGFsOiB0aGlzLl9jb250ZW50TGVuZ3RoXG4gICAgfSk7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmspLmJ1ZmZlcjtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGJ1ZmZlcixcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0cmVhbSkge1xuICAgICAgdGhpcy5fZXJyb3IocmVhc29uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0uZGVzdHJveShyZWFzb24pO1xuICB9XG4gIF9lcnJvcihyZWFzb24pIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHJlYXNvbjtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgX3NldFJlYWRhYmxlU3RyZWFtKHJlYWRhYmxlU3RyZWFtKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSByZWFkYWJsZVN0cmVhbTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcInJlYWRhYmxlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICByZWFkYWJsZVN0cmVhbS5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcImVycm9yXCIsIHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLl9lcnJvcihyZWFzb24pO1xuICAgIH0pO1xuICAgIGlmICghdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgJiYgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCkge1xuICAgICAgdGhpcy5fZXJyb3IobmV3IEFib3J0RXhjZXB0aW9uKFwic3RyZWFtaW5nIGlzIGRpc2FibGVkXCIpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbS5kZXN0cm95KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFBERk5vZGVTdHJlYW1Gc1JhbmdlUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5fdXJsID0gc3RyZWFtLnVybDtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSBudWxsO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IG51bGw7XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICBjb25zdCBzb3VyY2UgPSBzdHJlYW0uc291cmNlO1xuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlU3RyZWFtO1xuICAgIGNvbnN0IGZzID0gcHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlKFwiZnNcIik7XG4gICAgdGhpcy5fc2V0UmVhZGFibGVTdHJlYW0oZnMuY3JlYXRlUmVhZFN0cmVhbSh0aGlzLl91cmwsIHtcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kOiBlbmQgLSAxXG4gICAgfSkpO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBhd2FpdCB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuX3N0b3JlZEVycm9yO1xuICAgIH1cbiAgICBjb25zdCBjaHVuayA9IHRoaXMuX3JlYWRhYmxlU3RyZWFtLnJlYWQoKTtcbiAgICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkKCk7XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5sZW5ndGg7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgbG9hZGVkOiB0aGlzLl9sb2FkZWRcbiAgICB9KTtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShjaHVuaykuYnVmZmVyO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogYnVmZmVyLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RyZWFtKSB7XG4gICAgICB0aGlzLl9lcnJvcihyZWFzb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbS5kZXN0cm95KHJlYXNvbik7XG4gIH1cbiAgX2Vycm9yKHJlYXNvbikge1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gcmVhc29uO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgfVxuICBfc2V0UmVhZGFibGVTdHJlYW0ocmVhZGFibGVTdHJlYW0pIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IHJlYWRhYmxlU3RyZWFtO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwicmVhZGFibGVcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgIHJlYWRhYmxlU3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwiZXJyb3JcIiwgcmVhc29uID0+IHtcbiAgICAgIHRoaXMuX2Vycm9yKHJlYXNvbik7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbS5kZXN0cm95KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICB9XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvdGV4dF9sYXllci5qc1xuXG5cbmNvbnN0IE1BWF9URVhUX0RJVlNfVE9fUkVOREVSID0gMTAwMDAwO1xuY29uc3QgREVGQVVMVF9GT05UX1NJWkUgPSAzMDtcbmNsYXNzIFRleHRMYXllciB7XG4gICNjYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICNjb250YWluZXIgPSBudWxsO1xuICAjZGlzYWJsZVByb2Nlc3NJdGVtcyA9IGZhbHNlO1xuICAjZm9udEluc3BlY3RvckVuYWJsZWQgPSAhIWdsb2JhbFRoaXMuRm9udEluc3BlY3Rvcj8uZW5hYmxlZDtcbiAgI2xhbmcgPSBudWxsO1xuICAjbGF5b3V0VGV4dFBhcmFtcyA9IG51bGw7XG4gICNwYWdlSGVpZ2h0ID0gMDtcbiAgI3BhZ2VXaWR0aCA9IDA7XG4gICNyZWFkZXIgPSBudWxsO1xuICAjcm9vdENvbnRhaW5lciA9IG51bGw7XG4gICNyb3RhdGlvbiA9IDA7XG4gICNzY2FsZSA9IDA7XG4gICNzdHlsZUNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgI3RleHRDb250ZW50SXRlbXNTdHIgPSBbXTtcbiAgI3RleHRDb250ZW50U291cmNlID0gbnVsbDtcbiAgI3RleHREaXZzID0gW107XG4gICN0ZXh0RGl2UHJvcGVydGllcyA9IG5ldyBXZWFrTWFwKCk7XG4gICN0cmFuc2Zvcm0gPSBudWxsO1xuICBzdGF0aWMgI2FzY2VudENhY2hlID0gbmV3IE1hcCgpO1xuICBzdGF0aWMgI2NhbnZhc0NvbnRleHRzID0gbmV3IE1hcCgpO1xuICBzdGF0aWMgI2NhbnZhc0N0eEZvbnRzID0gbmV3IFdlYWtNYXAoKTtcbiAgc3RhdGljICNtaW5Gb250U2l6ZSA9IG51bGw7XG4gIHN0YXRpYyAjcGVuZGluZ1RleHRMYXllcnMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB0ZXh0Q29udGVudFNvdXJjZSxcbiAgICBjb250YWluZXIsXG4gICAgdmlld3BvcnRcbiAgfSkge1xuICAgIGlmICh0ZXh0Q29udGVudFNvdXJjZSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtKSB7XG4gICAgICB0aGlzLiN0ZXh0Q29udGVudFNvdXJjZSA9IHRleHRDb250ZW50U291cmNlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRleHRDb250ZW50U291cmNlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aGlzLiN0ZXh0Q29udGVudFNvdXJjZSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodGV4dENvbnRlbnRTb3VyY2UpO1xuICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gXCJ0ZXh0Q29udGVudFNvdXJjZVwiIHBhcmFtZXRlciBzcGVjaWZpZWQuJyk7XG4gICAgfVxuICAgIHRoaXMuI2NvbnRhaW5lciA9IHRoaXMuI3Jvb3RDb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy4jc2NhbGUgPSB2aWV3cG9ydC5zY2FsZSAqIE91dHB1dFNjYWxlLnBpeGVsUmF0aW87XG4gICAgdGhpcy4jcm90YXRpb24gPSB2aWV3cG9ydC5yb3RhdGlvbjtcbiAgICB0aGlzLiNsYXlvdXRUZXh0UGFyYW1zID0ge1xuICAgICAgZGl2OiBudWxsLFxuICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgIGN0eDogbnVsbFxuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodCxcbiAgICAgIHBhZ2VYLFxuICAgICAgcGFnZVlcbiAgICB9ID0gdmlld3BvcnQucmF3RGltcztcbiAgICB0aGlzLiN0cmFuc2Zvcm0gPSBbMSwgMCwgMCwgLTEsIC1wYWdlWCwgcGFnZVkgKyBwYWdlSGVpZ2h0XTtcbiAgICB0aGlzLiNwYWdlV2lkdGggPSBwYWdlV2lkdGg7XG4gICAgdGhpcy4jcGFnZUhlaWdodCA9IHBhZ2VIZWlnaHQ7XG4gICAgVGV4dExheWVyLiNlbnN1cmVNaW5Gb250U2l6ZUNvbXB1dGVkKCk7XG4gICAgc2V0TGF5ZXJEaW1lbnNpb25zKGNvbnRhaW5lciwgdmlld3BvcnQpO1xuICAgIHRoaXMuI2NhcGFiaWxpdHkucHJvbWlzZS5maW5hbGx5KCgpID0+IHtcbiAgICAgIFRleHRMYXllci4jcGVuZGluZ1RleHRMYXllcnMuZGVsZXRlKHRoaXMpO1xuICAgICAgdGhpcy4jbGF5b3V0VGV4dFBhcmFtcyA9IG51bGw7XG4gICAgICB0aGlzLiNzdHlsZUNhY2hlID0gbnVsbDtcbiAgICB9KS5jYXRjaCgoKSA9PiB7fSk7XG4gIH1cbiAgc3RhdGljIGdldCBmb250RmFtaWx5TWFwKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzV2luZG93cyxcbiAgICAgIGlzRmlyZWZveFxuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJmb250RmFtaWx5TWFwXCIsIG5ldyBNYXAoW1tcInNhbnMtc2VyaWZcIiwgYCR7aXNXaW5kb3dzICYmIGlzRmlyZWZveCA/IFwiQ2FsaWJyaSwgXCIgOiBcIlwifXNhbnMtc2VyaWZgXSwgW1wibW9ub3NwYWNlXCIsIGAke2lzV2luZG93cyAmJiBpc0ZpcmVmb3ggPyBcIkx1Y2lkYSBDb25zb2xlLCBcIiA6IFwiXCJ9bW9ub3NwYWNlYF1dKSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHB1bXAgPSAoKSA9PiB7XG4gICAgICB0aGlzLiNyZWFkZXIucmVhZCgpLnRoZW4oKHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRvbmVcbiAgICAgIH0pID0+IHtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICB0aGlzLiNjYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbGFuZyA/Pz0gdmFsdWUubGFuZztcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLiNzdHlsZUNhY2hlLCB2YWx1ZS5zdHlsZXMpO1xuICAgICAgICB0aGlzLiNwcm9jZXNzSXRlbXModmFsdWUuaXRlbXMpO1xuICAgICAgICBwdW1wKCk7XG4gICAgICB9LCB0aGlzLiNjYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgfTtcbiAgICB0aGlzLiNyZWFkZXIgPSB0aGlzLiN0ZXh0Q29udGVudFNvdXJjZS5nZXRSZWFkZXIoKTtcbiAgICBUZXh0TGF5ZXIuI3BlbmRpbmdUZXh0TGF5ZXJzLmFkZCh0aGlzKTtcbiAgICBwdW1wKCk7XG4gICAgcmV0dXJuIHRoaXMuI2NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICB1cGRhdGUoe1xuICAgIHZpZXdwb3J0LFxuICAgIG9uQmVmb3JlID0gbnVsbFxuICB9KSB7XG4gICAgY29uc3Qgc2NhbGUgPSB2aWV3cG9ydC5zY2FsZSAqIE91dHB1dFNjYWxlLnBpeGVsUmF0aW87XG4gICAgY29uc3Qgcm90YXRpb24gPSB2aWV3cG9ydC5yb3RhdGlvbjtcbiAgICBpZiAocm90YXRpb24gIT09IHRoaXMuI3JvdGF0aW9uKSB7XG4gICAgICBvbkJlZm9yZT8uKCk7XG4gICAgICB0aGlzLiNyb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgICAgc2V0TGF5ZXJEaW1lbnNpb25zKHRoaXMuI3Jvb3RDb250YWluZXIsIHtcbiAgICAgICAgcm90YXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2NhbGUgIT09IHRoaXMuI3NjYWxlKSB7XG4gICAgICBvbkJlZm9yZT8uKCk7XG4gICAgICB0aGlzLiNzY2FsZSA9IHNjYWxlO1xuICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICBkaXY6IG51bGwsXG4gICAgICAgIHByb3BlcnRpZXM6IG51bGwsXG4gICAgICAgIGN0eDogVGV4dExheWVyLiNnZXRDdHgodGhpcy4jbGFuZylcbiAgICAgIH07XG4gICAgICBmb3IgKGNvbnN0IGRpdiBvZiB0aGlzLiN0ZXh0RGl2cykge1xuICAgICAgICBwYXJhbXMucHJvcGVydGllcyA9IHRoaXMuI3RleHREaXZQcm9wZXJ0aWVzLmdldChkaXYpO1xuICAgICAgICBwYXJhbXMuZGl2ID0gZGl2O1xuICAgICAgICB0aGlzLiNsYXlvdXQocGFyYW1zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FuY2VsKCkge1xuICAgIGNvbnN0IGFib3J0RXggPSBuZXcgQWJvcnRFeGNlcHRpb24oXCJUZXh0TGF5ZXIgdGFzayBjYW5jZWxsZWQuXCIpO1xuICAgIHRoaXMuI3JlYWRlcj8uY2FuY2VsKGFib3J0RXgpLmNhdGNoKCgpID0+IHt9KTtcbiAgICB0aGlzLiNyZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuI2NhcGFiaWxpdHkucmVqZWN0KGFib3J0RXgpO1xuICB9XG4gIGdldCB0ZXh0RGl2cygpIHtcbiAgICByZXR1cm4gdGhpcy4jdGV4dERpdnM7XG4gIH1cbiAgZ2V0IHRleHRDb250ZW50SXRlbXNTdHIoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3RleHRDb250ZW50SXRlbXNTdHI7XG4gIH1cbiAgI3Byb2Nlc3NJdGVtcyhpdGVtcykge1xuICAgIGlmICh0aGlzLiNkaXNhYmxlUHJvY2Vzc0l0ZW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2xheW91dFRleHRQYXJhbXMuY3R4ID8/PSBUZXh0TGF5ZXIuI2dldEN0eCh0aGlzLiNsYW5nKTtcbiAgICBjb25zdCB0ZXh0RGl2cyA9IHRoaXMuI3RleHREaXZzLFxuICAgICAgdGV4dENvbnRlbnRJdGVtc1N0ciA9IHRoaXMuI3RleHRDb250ZW50SXRlbXNTdHI7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBpZiAodGV4dERpdnMubGVuZ3RoID4gTUFYX1RFWFRfRElWU19UT19SRU5ERVIpIHtcbiAgICAgICAgd2FybihcIklnbm9yaW5nIGFkZGl0aW9uYWwgdGV4dERpdnMgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXCIpO1xuICAgICAgICB0aGlzLiNkaXNhYmxlUHJvY2Vzc0l0ZW1zID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0uc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJiZWdpbk1hcmtlZENvbnRlbnRQcm9wc1wiIHx8IGl0ZW0udHlwZSA9PT0gXCJiZWdpbk1hcmtlZENvbnRlbnRcIikge1xuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuI2NvbnRhaW5lcjtcbiAgICAgICAgICB0aGlzLiNjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICB0aGlzLiNjb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm1hcmtlZENvbnRlbnRcIik7XG4gICAgICAgICAgaWYgKGl0ZW0uaWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuI2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBgJHtpdGVtLmlkfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnQuYXBwZW5kKHRoaXMuI2NvbnRhaW5lcik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSBcImVuZE1hcmtlZENvbnRlbnRcIikge1xuICAgICAgICAgIHRoaXMuI2NvbnRhaW5lciA9IHRoaXMuI2NvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGV4dENvbnRlbnRJdGVtc1N0ci5wdXNoKGl0ZW0uc3RyKTtcbiAgICAgIHRoaXMuI2FwcGVuZFRleHQoaXRlbSk7XG4gICAgfVxuICB9XG4gICNhcHBlbmRUZXh0KGdlb20pIHtcbiAgICBjb25zdCB0ZXh0RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgY29uc3QgdGV4dERpdlByb3BlcnRpZXMgPSB7XG4gICAgICBhbmdsZTogMCxcbiAgICAgIGNhbnZhc1dpZHRoOiAwLFxuICAgICAgaGFzVGV4dDogZ2VvbS5zdHIgIT09IFwiXCIsXG4gICAgICBoYXNFT0w6IGdlb20uaGFzRU9MLFxuICAgICAgZm9udFNpemU6IDBcbiAgICB9O1xuICAgIHRoaXMuI3RleHREaXZzLnB1c2godGV4dERpdik7XG4gICAgY29uc3QgdHggPSBVdGlsLnRyYW5zZm9ybSh0aGlzLiN0cmFuc2Zvcm0sIGdlb20udHJhbnNmb3JtKTtcbiAgICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKHR4WzFdLCB0eFswXSk7XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLiNzdHlsZUNhY2hlW2dlb20uZm9udE5hbWVdO1xuICAgIGlmIChzdHlsZS52ZXJ0aWNhbCkge1xuICAgICAgYW5nbGUgKz0gTWF0aC5QSSAvIDI7XG4gICAgfVxuICAgIGxldCBmb250RmFtaWx5ID0gdGhpcy4jZm9udEluc3BlY3RvckVuYWJsZWQgJiYgc3R5bGUuZm9udFN1YnN0aXR1dGlvbiB8fCBzdHlsZS5mb250RmFtaWx5O1xuICAgIGZvbnRGYW1pbHkgPSBUZXh0TGF5ZXIuZm9udEZhbWlseU1hcC5nZXQoZm9udEZhbWlseSkgfHwgZm9udEZhbWlseTtcbiAgICBjb25zdCBmb250SGVpZ2h0ID0gTWF0aC5oeXBvdCh0eFsyXSwgdHhbM10pO1xuICAgIGNvbnN0IGZvbnRBc2NlbnQgPSBmb250SGVpZ2h0ICogVGV4dExheWVyLiNnZXRBc2NlbnQoZm9udEZhbWlseSwgc3R5bGUsIHRoaXMuI2xhbmcpO1xuICAgIGxldCBsZWZ0LCB0b3A7XG4gICAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICBsZWZ0ID0gdHhbNF07XG4gICAgICB0b3AgPSB0eFs1XSAtIGZvbnRBc2NlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSB0eFs0XSArIGZvbnRBc2NlbnQgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICB0b3AgPSB0eFs1XSAtIGZvbnRBc2NlbnQgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgfVxuICAgIGNvbnN0IHNjYWxlRmFjdG9yU3RyID0gXCJjYWxjKHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikgKlwiO1xuICAgIGNvbnN0IGRpdlN0eWxlID0gdGV4dERpdi5zdHlsZTtcbiAgICBpZiAodGhpcy4jY29udGFpbmVyID09PSB0aGlzLiNyb290Q29udGFpbmVyKSB7XG4gICAgICBkaXZTdHlsZS5sZWZ0ID0gYCR7KDEwMCAqIGxlZnQgLyB0aGlzLiNwYWdlV2lkdGgpLnRvRml4ZWQoMil9JWA7XG4gICAgICBkaXZTdHlsZS50b3AgPSBgJHsoMTAwICogdG9wIC8gdGhpcy4jcGFnZUhlaWdodCkudG9GaXhlZCgyKX0lYDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGl2U3R5bGUubGVmdCA9IGAke3NjYWxlRmFjdG9yU3RyfSR7bGVmdC50b0ZpeGVkKDIpfXB4KWA7XG4gICAgICBkaXZTdHlsZS50b3AgPSBgJHtzY2FsZUZhY3RvclN0cn0ke3RvcC50b0ZpeGVkKDIpfXB4KWA7XG4gICAgfVxuICAgIGRpdlN0eWxlLmZvbnRTaXplID0gYCR7c2NhbGVGYWN0b3JTdHJ9JHsoVGV4dExheWVyLiNtaW5Gb250U2l6ZSAqIGZvbnRIZWlnaHQpLnRvRml4ZWQoMil9cHgpYDtcbiAgICBkaXZTdHlsZS5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICB0ZXh0RGl2UHJvcGVydGllcy5mb250U2l6ZSA9IGZvbnRIZWlnaHQ7XG4gICAgdGV4dERpdi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwicHJlc2VudGF0aW9uXCIpO1xuICAgIHRleHREaXYudGV4dENvbnRlbnQgPSBnZW9tLnN0cjtcbiAgICB0ZXh0RGl2LmRpciA9IGdlb20uZGlyO1xuICAgIGlmICh0aGlzLiNmb250SW5zcGVjdG9yRW5hYmxlZCkge1xuICAgICAgdGV4dERpdi5kYXRhc2V0LmZvbnROYW1lID0gc3R5bGUuZm9udFN1YnN0aXR1dGlvbkxvYWRlZE5hbWUgfHwgZ2VvbS5mb250TmFtZTtcbiAgICB9XG4gICAgaWYgKGFuZ2xlICE9PSAwKSB7XG4gICAgICB0ZXh0RGl2UHJvcGVydGllcy5hbmdsZSA9IGFuZ2xlICogKDE4MCAvIE1hdGguUEkpO1xuICAgIH1cbiAgICBsZXQgc2hvdWxkU2NhbGVUZXh0ID0gZmFsc2U7XG4gICAgaWYgKGdlb20uc3RyLmxlbmd0aCA+IDEpIHtcbiAgICAgIHNob3VsZFNjYWxlVGV4dCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChnZW9tLnN0ciAhPT0gXCIgXCIgJiYgZ2VvbS50cmFuc2Zvcm1bMF0gIT09IGdlb20udHJhbnNmb3JtWzNdKSB7XG4gICAgICBjb25zdCBhYnNTY2FsZVggPSBNYXRoLmFicyhnZW9tLnRyYW5zZm9ybVswXSksXG4gICAgICAgIGFic1NjYWxlWSA9IE1hdGguYWJzKGdlb20udHJhbnNmb3JtWzNdKTtcbiAgICAgIGlmIChhYnNTY2FsZVggIT09IGFic1NjYWxlWSAmJiBNYXRoLm1heChhYnNTY2FsZVgsIGFic1NjYWxlWSkgLyBNYXRoLm1pbihhYnNTY2FsZVgsIGFic1NjYWxlWSkgPiAxLjUpIHtcbiAgICAgICAgc2hvdWxkU2NhbGVUZXh0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNob3VsZFNjYWxlVGV4dCkge1xuICAgICAgdGV4dERpdlByb3BlcnRpZXMuY2FudmFzV2lkdGggPSBzdHlsZS52ZXJ0aWNhbCA/IGdlb20uaGVpZ2h0IDogZ2VvbS53aWR0aDtcbiAgICB9XG4gICAgdGhpcy4jdGV4dERpdlByb3BlcnRpZXMuc2V0KHRleHREaXYsIHRleHREaXZQcm9wZXJ0aWVzKTtcbiAgICB0aGlzLiNsYXlvdXRUZXh0UGFyYW1zLmRpdiA9IHRleHREaXY7XG4gICAgdGhpcy4jbGF5b3V0VGV4dFBhcmFtcy5wcm9wZXJ0aWVzID0gdGV4dERpdlByb3BlcnRpZXM7XG4gICAgdGhpcy4jbGF5b3V0KHRoaXMuI2xheW91dFRleHRQYXJhbXMpO1xuICAgIGlmICh0ZXh0RGl2UHJvcGVydGllcy5oYXNUZXh0KSB7XG4gICAgICB0aGlzLiNjb250YWluZXIuYXBwZW5kKHRleHREaXYpO1xuICAgIH1cbiAgICBpZiAodGV4dERpdlByb3BlcnRpZXMuaGFzRU9MKSB7XG4gICAgICBjb25zdCBiciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKTtcbiAgICAgIGJyLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJwcmVzZW50YXRpb25cIik7XG4gICAgICB0aGlzLiNjb250YWluZXIuYXBwZW5kKGJyKTtcbiAgICB9XG4gIH1cbiAgI2xheW91dChwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBkaXYsXG4gICAgICBwcm9wZXJ0aWVzLFxuICAgICAgY3R4XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSBkaXY7XG4gICAgbGV0IHRyYW5zZm9ybSA9IFwiXCI7XG4gICAgaWYgKFRleHRMYXllci4jbWluRm9udFNpemUgPiAxKSB7XG4gICAgICB0cmFuc2Zvcm0gPSBgc2NhbGUoJHsxIC8gVGV4dExheWVyLiNtaW5Gb250U2l6ZX0pYDtcbiAgICB9XG4gICAgaWYgKHByb3BlcnRpZXMuY2FudmFzV2lkdGggIT09IDAgJiYgcHJvcGVydGllcy5oYXNUZXh0KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZvbnRGYW1pbHlcbiAgICAgIH0gPSBzdHlsZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2FudmFzV2lkdGgsXG4gICAgICAgIGZvbnRTaXplXG4gICAgICB9ID0gcHJvcGVydGllcztcbiAgICAgIFRleHRMYXllci4jZW5zdXJlQ3R4Rm9udChjdHgsIGZvbnRTaXplICogdGhpcy4jc2NhbGUsIGZvbnRGYW1pbHkpO1xuICAgICAgY29uc3Qge1xuICAgICAgICB3aWR0aFxuICAgICAgfSA9IGN0eC5tZWFzdXJlVGV4dChkaXYudGV4dENvbnRlbnQpO1xuICAgICAgaWYgKHdpZHRoID4gMCkge1xuICAgICAgICB0cmFuc2Zvcm0gPSBgc2NhbGVYKCR7Y2FudmFzV2lkdGggKiB0aGlzLiNzY2FsZSAvIHdpZHRofSkgJHt0cmFuc2Zvcm19YDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BlcnRpZXMuYW5nbGUgIT09IDApIHtcbiAgICAgIHRyYW5zZm9ybSA9IGByb3RhdGUoJHtwcm9wZXJ0aWVzLmFuZ2xlfWRlZykgJHt0cmFuc2Zvcm19YDtcbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybS5sZW5ndGggPiAwKSB7XG4gICAgICBzdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgfVxuICB9XG4gIHN0YXRpYyBjbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLiNwZW5kaW5nVGV4dExheWVycy5zaXplID4gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhc2NlbnRDYWNoZS5jbGVhcigpO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgY2FudmFzXG4gICAgfSBvZiB0aGlzLiNjYW52YXNDb250ZXh0cy52YWx1ZXMoKSkge1xuICAgICAgY2FudmFzLnJlbW92ZSgpO1xuICAgIH1cbiAgICB0aGlzLiNjYW52YXNDb250ZXh0cy5jbGVhcigpO1xuICB9XG4gIHN0YXRpYyAjZ2V0Q3R4KGxhbmcgPSBudWxsKSB7XG4gICAgbGV0IGN0eCA9IHRoaXMuI2NhbnZhc0NvbnRleHRzLmdldChsYW5nIHx8PSBcIlwiKTtcbiAgICBpZiAoIWN0eCkge1xuICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgIGNhbnZhcy5jbGFzc05hbWUgPSBcImhpZGRlbkNhbnZhc0VsZW1lbnRcIjtcbiAgICAgIGNhbnZhcy5sYW5nID0gbGFuZztcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKGNhbnZhcyk7XG4gICAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgICAgYWxwaGE6IGZhbHNlLFxuICAgICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy4jY2FudmFzQ29udGV4dHMuc2V0KGxhbmcsIGN0eCk7XG4gICAgICB0aGlzLiNjYW52YXNDdHhGb250cy5zZXQoY3R4LCB7XG4gICAgICAgIHNpemU6IDAsXG4gICAgICAgIGZhbWlseTogXCJcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjdHg7XG4gIH1cbiAgc3RhdGljICNlbnN1cmVDdHhGb250KGN0eCwgc2l6ZSwgZmFtaWx5KSB7XG4gICAgY29uc3QgY2FjaGVkID0gdGhpcy4jY2FudmFzQ3R4Rm9udHMuZ2V0KGN0eCk7XG4gICAgaWYgKHNpemUgPT09IGNhY2hlZC5zaXplICYmIGZhbWlseSA9PT0gY2FjaGVkLmZhbWlseSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdHguZm9udCA9IGAke3NpemV9cHggJHtmYW1pbHl9YDtcbiAgICBjYWNoZWQuc2l6ZSA9IHNpemU7XG4gICAgY2FjaGVkLmZhbWlseSA9IGZhbWlseTtcbiAgfVxuICBzdGF0aWMgI2Vuc3VyZU1pbkZvbnRTaXplQ29tcHV0ZWQoKSB7XG4gICAgaWYgKHRoaXMuI21pbkZvbnRTaXplICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgIGRpdi5zdHlsZS5saW5lSGVpZ2h0ID0gMTtcbiAgICBkaXYuc3R5bGUuZm9udFNpemUgPSBcIjFweFwiO1xuICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBkaXYudGV4dENvbnRlbnQgPSBcIlhcIjtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZChkaXYpO1xuICAgIHRoaXMuI21pbkZvbnRTaXplID0gZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICBkaXYucmVtb3ZlKCk7XG4gIH1cbiAgc3RhdGljICNnZXRBc2NlbnQoZm9udEZhbWlseSwgc3R5bGUsIGxhbmcpIHtcbiAgICBjb25zdCBjYWNoZWRBc2NlbnQgPSB0aGlzLiNhc2NlbnRDYWNoZS5nZXQoZm9udEZhbWlseSk7XG4gICAgaWYgKGNhY2hlZEFzY2VudCkge1xuICAgICAgcmV0dXJuIGNhY2hlZEFzY2VudDtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy4jZ2V0Q3R4KGxhbmcpO1xuICAgIGN0eC5jYW52YXMud2lkdGggPSBjdHguY2FudmFzLmhlaWdodCA9IERFRkFVTFRfRk9OVF9TSVpFO1xuICAgIHRoaXMuI2Vuc3VyZUN0eEZvbnQoY3R4LCBERUZBVUxUX0ZPTlRfU0laRSwgZm9udEZhbWlseSk7XG4gICAgY29uc3QgbWV0cmljcyA9IGN0eC5tZWFzdXJlVGV4dChcIlwiKTtcbiAgICBjb25zdCBhc2NlbnQgPSBtZXRyaWNzLmZvbnRCb3VuZGluZ0JveEFzY2VudDtcbiAgICBjb25zdCBkZXNjZW50ID0gTWF0aC5hYnMobWV0cmljcy5mb250Qm91bmRpbmdCb3hEZXNjZW50KTtcbiAgICBjdHguY2FudmFzLndpZHRoID0gY3R4LmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgIGxldCByYXRpbyA9IDAuODtcbiAgICBpZiAoYXNjZW50KSB7XG4gICAgICByYXRpbyA9IGFzY2VudCAvIChhc2NlbnQgKyBkZXNjZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm0uaXNGaXJlZm94KSB7XG4gICAgICAgIHdhcm4oXCJFbmFibGUgdGhlIGBkb20udGV4dE1ldHJpY3MuZm9udEJvdW5kaW5nQm94LmVuYWJsZWRgIHByZWZlcmVuY2UgXCIgKyBcImluIGBhYm91dDpjb25maWdgIHRvIGltcHJvdmUgVGV4dExheWVyIHJlbmRlcmluZy5cIik7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGUuYXNjZW50KSB7XG4gICAgICAgIHJhdGlvID0gc3R5bGUuYXNjZW50O1xuICAgICAgfSBlbHNlIGlmIChzdHlsZS5kZXNjZW50KSB7XG4gICAgICAgIHJhdGlvID0gMSArIHN0eWxlLmRlc2NlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2FzY2VudENhY2hlLnNldChmb250RmFtaWx5LCByYXRpbyk7XG4gICAgcmV0dXJuIHJhdGlvO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L3hmYV90ZXh0LmpzXG5jbGFzcyBYZmFUZXh0IHtcbiAgc3RhdGljIHRleHRDb250ZW50KHhmYSkge1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgaXRlbXMsXG4gICAgICBzdHlsZXM6IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHdhbGsobm9kZSkge1xuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBzdHIgPSBudWxsO1xuICAgICAgY29uc3QgbmFtZSA9IG5vZGUubmFtZTtcbiAgICAgIGlmIChuYW1lID09PSBcIiN0ZXh0XCIpIHtcbiAgICAgICAgc3RyID0gbm9kZS52YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIVhmYVRleHQuc2hvdWxkQnVpbGRUZXh0KG5hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAobm9kZT8uYXR0cmlidXRlcz8udGV4dENvbnRlbnQpIHtcbiAgICAgICAgc3RyID0gbm9kZS5hdHRyaWJ1dGVzLnRleHRDb250ZW50O1xuICAgICAgfSBlbHNlIGlmIChub2RlLnZhbHVlKSB7XG4gICAgICAgIHN0ciA9IG5vZGUudmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoc3RyICE9PSBudWxsKSB7XG4gICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgIHN0clxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghbm9kZS5jaGlsZHJlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgd2FsayhjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHdhbGsoeGZhKTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIHN0YXRpYyBzaG91bGRCdWlsZFRleHQobmFtZSkge1xuICAgIHJldHVybiAhKG5hbWUgPT09IFwidGV4dGFyZWFcIiB8fCBuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJvcHRpb25cIiB8fCBuYW1lID09PSBcInNlbGVjdFwiKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9hcGkuanNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmNvbnN0IERFRkFVTFRfUkFOR0VfQ0hVTktfU0laRSA9IDY1NTM2O1xuY29uc3QgUkVOREVSSU5HX0NBTkNFTExFRF9USU1FT1VUID0gMTAwO1xuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoc3JjID0ge30pIHtcbiAgaWYgKHR5cGVvZiBzcmMgPT09IFwic3RyaW5nXCIgfHwgc3JjIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgc3JjID0ge1xuICAgICAgdXJsOiBzcmNcbiAgICB9O1xuICB9IGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhzcmMpKSB7XG4gICAgc3JjID0ge1xuICAgICAgZGF0YTogc3JjXG4gICAgfTtcbiAgfVxuICBjb25zdCB0YXNrID0gbmV3IFBERkRvY3VtZW50TG9hZGluZ1Rhc2soKTtcbiAgY29uc3Qge1xuICAgIGRvY0lkXG4gIH0gPSB0YXNrO1xuICBjb25zdCB1cmwgPSBzcmMudXJsID8gZ2V0VXJsUHJvcChzcmMudXJsKSA6IG51bGw7XG4gIGNvbnN0IGRhdGEgPSBzcmMuZGF0YSA/IGdldERhdGFQcm9wKHNyYy5kYXRhKSA6IG51bGw7XG4gIGNvbnN0IGh0dHBIZWFkZXJzID0gc3JjLmh0dHBIZWFkZXJzIHx8IG51bGw7XG4gIGNvbnN0IHdpdGhDcmVkZW50aWFscyA9IHNyYy53aXRoQ3JlZGVudGlhbHMgPT09IHRydWU7XG4gIGNvbnN0IHBhc3N3b3JkID0gc3JjLnBhc3N3b3JkID8/IG51bGw7XG4gIGNvbnN0IHJhbmdlVHJhbnNwb3J0ID0gc3JjLnJhbmdlIGluc3RhbmNlb2YgUERGRGF0YVJhbmdlVHJhbnNwb3J0ID8gc3JjLnJhbmdlIDogbnVsbDtcbiAgY29uc3QgcmFuZ2VDaHVua1NpemUgPSBOdW1iZXIuaXNJbnRlZ2VyKHNyYy5yYW5nZUNodW5rU2l6ZSkgJiYgc3JjLnJhbmdlQ2h1bmtTaXplID4gMCA/IHNyYy5yYW5nZUNodW5rU2l6ZSA6IERFRkFVTFRfUkFOR0VfQ0hVTktfU0laRTtcbiAgbGV0IHdvcmtlciA9IHNyYy53b3JrZXIgaW5zdGFuY2VvZiBQREZXb3JrZXIgPyBzcmMud29ya2VyIDogbnVsbDtcbiAgY29uc3QgdmVyYm9zaXR5ID0gc3JjLnZlcmJvc2l0eTtcbiAgY29uc3QgZG9jQmFzZVVybCA9IHR5cGVvZiBzcmMuZG9jQmFzZVVybCA9PT0gXCJzdHJpbmdcIiAmJiAhaXNEYXRhU2NoZW1lKHNyYy5kb2NCYXNlVXJsKSA/IHNyYy5kb2NCYXNlVXJsIDogbnVsbDtcbiAgY29uc3QgY01hcFVybCA9IGdldEZhY3RvcnlVcmxQcm9wKHNyYy5jTWFwVXJsKTtcbiAgY29uc3QgY01hcFBhY2tlZCA9IHNyYy5jTWFwUGFja2VkICE9PSBmYWxzZTtcbiAgY29uc3QgQ01hcFJlYWRlckZhY3RvcnkgPSBzcmMuQ01hcFJlYWRlckZhY3RvcnkgfHwgKGlzTm9kZUpTID8gTm9kZUNNYXBSZWFkZXJGYWN0b3J5IDogRE9NQ01hcFJlYWRlckZhY3RvcnkpO1xuICBjb25zdCBpY2NVcmwgPSBnZXRGYWN0b3J5VXJsUHJvcChzcmMuaWNjVXJsKTtcbiAgY29uc3Qgc3RhbmRhcmRGb250RGF0YVVybCA9IGdldEZhY3RvcnlVcmxQcm9wKHNyYy5zdGFuZGFyZEZvbnREYXRhVXJsKTtcbiAgY29uc3QgU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBzcmMuU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgfHwgKGlzTm9kZUpTID8gTm9kZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IDogRE9NU3RhbmRhcmRGb250RGF0YUZhY3RvcnkpO1xuICBjb25zdCB3YXNtVXJsID0gZ2V0RmFjdG9yeVVybFByb3Aoc3JjLndhc21VcmwpO1xuICBjb25zdCBXYXNtRmFjdG9yeSA9IHNyYy5XYXNtRmFjdG9yeSB8fCAoaXNOb2RlSlMgPyBOb2RlV2FzbUZhY3RvcnkgOiBET01XYXNtRmFjdG9yeSk7XG4gIGNvbnN0IGlnbm9yZUVycm9ycyA9IHNyYy5zdG9wQXRFcnJvcnMgIT09IHRydWU7XG4gIGNvbnN0IG1heEltYWdlU2l6ZSA9IE51bWJlci5pc0ludGVnZXIoc3JjLm1heEltYWdlU2l6ZSkgJiYgc3JjLm1heEltYWdlU2l6ZSA+IC0xID8gc3JjLm1heEltYWdlU2l6ZSA6IC0xO1xuICBjb25zdCBpc0V2YWxTdXBwb3J0ZWQgPSBzcmMuaXNFdmFsU3VwcG9ydGVkICE9PSBmYWxzZTtcbiAgY29uc3QgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQgPSB0eXBlb2Ygc3JjLmlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkID09PSBcImJvb2xlYW5cIiA/IHNyYy5pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCA6ICFpc05vZGVKUztcbiAgY29uc3QgaXNJbWFnZURlY29kZXJTdXBwb3J0ZWQgPSB0eXBlb2Ygc3JjLmlzSW1hZ2VEZWNvZGVyU3VwcG9ydGVkID09PSBcImJvb2xlYW5cIiA/IHNyYy5pc0ltYWdlRGVjb2RlclN1cHBvcnRlZCA6ICFpc05vZGVKUyAmJiAodXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybS5pc0ZpcmVmb3ggfHwgIWdsb2JhbFRoaXMuY2hyb21lKTtcbiAgY29uc3QgY2FudmFzTWF4QXJlYUluQnl0ZXMgPSBOdW1iZXIuaXNJbnRlZ2VyKHNyYy5jYW52YXNNYXhBcmVhSW5CeXRlcykgPyBzcmMuY2FudmFzTWF4QXJlYUluQnl0ZXMgOiAtMTtcbiAgY29uc3QgZGlzYWJsZUZvbnRGYWNlID0gdHlwZW9mIHNyYy5kaXNhYmxlRm9udEZhY2UgPT09IFwiYm9vbGVhblwiID8gc3JjLmRpc2FibGVGb250RmFjZSA6IGlzTm9kZUpTO1xuICBjb25zdCBmb250RXh0cmFQcm9wZXJ0aWVzID0gc3JjLmZvbnRFeHRyYVByb3BlcnRpZXMgPT09IHRydWU7XG4gIGNvbnN0IGVuYWJsZVhmYSA9IHNyYy5lbmFibGVYZmEgPT09IHRydWU7XG4gIGNvbnN0IG93bmVyRG9jdW1lbnQgPSBzcmMub3duZXJEb2N1bWVudCB8fCBnbG9iYWxUaGlzLmRvY3VtZW50O1xuICBjb25zdCBkaXNhYmxlUmFuZ2UgPSBzcmMuZGlzYWJsZVJhbmdlID09PSB0cnVlO1xuICBjb25zdCBkaXNhYmxlU3RyZWFtID0gc3JjLmRpc2FibGVTdHJlYW0gPT09IHRydWU7XG4gIGNvbnN0IGRpc2FibGVBdXRvRmV0Y2ggPSBzcmMuZGlzYWJsZUF1dG9GZXRjaCA9PT0gdHJ1ZTtcbiAgY29uc3QgcGRmQnVnID0gc3JjLnBkZkJ1ZyA9PT0gdHJ1ZTtcbiAgY29uc3QgQ2FudmFzRmFjdG9yeSA9IHNyYy5DYW52YXNGYWN0b3J5IHx8IChpc05vZGVKUyA/IE5vZGVDYW52YXNGYWN0b3J5IDogRE9NQ2FudmFzRmFjdG9yeSk7XG4gIGNvbnN0IEZpbHRlckZhY3RvcnkgPSBzcmMuRmlsdGVyRmFjdG9yeSB8fCAoaXNOb2RlSlMgPyBOb2RlRmlsdGVyRmFjdG9yeSA6IERPTUZpbHRlckZhY3RvcnkpO1xuICBjb25zdCBlbmFibGVIV0EgPSBzcmMuZW5hYmxlSFdBID09PSB0cnVlO1xuICBjb25zdCB1c2VXYXNtID0gc3JjLnVzZVdhc20gIT09IGZhbHNlO1xuICBjb25zdCBsZW5ndGggPSByYW5nZVRyYW5zcG9ydCA/IHJhbmdlVHJhbnNwb3J0Lmxlbmd0aCA6IHNyYy5sZW5ndGggPz8gTmFOO1xuICBjb25zdCB1c2VTeXN0ZW1Gb250cyA9IHR5cGVvZiBzcmMudXNlU3lzdGVtRm9udHMgPT09IFwiYm9vbGVhblwiID8gc3JjLnVzZVN5c3RlbUZvbnRzIDogIWlzTm9kZUpTICYmICFkaXNhYmxlRm9udEZhY2U7XG4gIGNvbnN0IHVzZVdvcmtlckZldGNoID0gdHlwZW9mIHNyYy51c2VXb3JrZXJGZXRjaCA9PT0gXCJib29sZWFuXCIgPyBzcmMudXNlV29ya2VyRmV0Y2ggOiAhIShDTWFwUmVhZGVyRmFjdG9yeSA9PT0gRE9NQ01hcFJlYWRlckZhY3RvcnkgJiYgU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPT09IERPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5ICYmIFdhc21GYWN0b3J5ID09PSBET01XYXNtRmFjdG9yeSAmJiBjTWFwVXJsICYmIHN0YW5kYXJkRm9udERhdGFVcmwgJiYgd2FzbVVybCAmJiBpc1ZhbGlkRmV0Y2hVcmwoY01hcFVybCwgZG9jdW1lbnQuYmFzZVVSSSkgJiYgaXNWYWxpZEZldGNoVXJsKHN0YW5kYXJkRm9udERhdGFVcmwsIGRvY3VtZW50LmJhc2VVUkkpICYmIGlzVmFsaWRGZXRjaFVybCh3YXNtVXJsLCBkb2N1bWVudC5iYXNlVVJJKSk7XG4gIGNvbnN0IHN0eWxlRWxlbWVudCA9IG51bGw7XG4gIHNldFZlcmJvc2l0eUxldmVsKHZlcmJvc2l0eSk7XG4gIGNvbnN0IHRyYW5zcG9ydEZhY3RvcnkgPSB7XG4gICAgY2FudmFzRmFjdG9yeTogbmV3IENhbnZhc0ZhY3Rvcnkoe1xuICAgICAgb3duZXJEb2N1bWVudCxcbiAgICAgIGVuYWJsZUhXQVxuICAgIH0pLFxuICAgIGZpbHRlckZhY3Rvcnk6IG5ldyBGaWx0ZXJGYWN0b3J5KHtcbiAgICAgIGRvY0lkLFxuICAgICAgb3duZXJEb2N1bWVudFxuICAgIH0pLFxuICAgIGNNYXBSZWFkZXJGYWN0b3J5OiB1c2VXb3JrZXJGZXRjaCA/IG51bGwgOiBuZXcgQ01hcFJlYWRlckZhY3Rvcnkoe1xuICAgICAgYmFzZVVybDogY01hcFVybCxcbiAgICAgIGlzQ29tcHJlc3NlZDogY01hcFBhY2tlZFxuICAgIH0pLFxuICAgIHN0YW5kYXJkRm9udERhdGFGYWN0b3J5OiB1c2VXb3JrZXJGZXRjaCA/IG51bGwgOiBuZXcgU3RhbmRhcmRGb250RGF0YUZhY3Rvcnkoe1xuICAgICAgYmFzZVVybDogc3RhbmRhcmRGb250RGF0YVVybFxuICAgIH0pLFxuICAgIHdhc21GYWN0b3J5OiB1c2VXb3JrZXJGZXRjaCA/IG51bGwgOiBuZXcgV2FzbUZhY3Rvcnkoe1xuICAgICAgYmFzZVVybDogd2FzbVVybFxuICAgIH0pXG4gIH07XG4gIGlmICghd29ya2VyKSB7XG4gICAgY29uc3Qgd29ya2VyUGFyYW1zID0ge1xuICAgICAgdmVyYm9zaXR5LFxuICAgICAgcG9ydDogR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJQb3J0XG4gICAgfTtcbiAgICB3b3JrZXIgPSB3b3JrZXJQYXJhbXMucG9ydCA/IFBERldvcmtlci5mcm9tUG9ydCh3b3JrZXJQYXJhbXMpIDogbmV3IFBERldvcmtlcih3b3JrZXJQYXJhbXMpO1xuICAgIHRhc2suX3dvcmtlciA9IHdvcmtlcjtcbiAgfVxuICBjb25zdCBkb2NQYXJhbXMgPSB7XG4gICAgZG9jSWQsXG4gICAgYXBpVmVyc2lvbjogXCI1LjIuMTMzXCIsXG4gICAgZGF0YSxcbiAgICBwYXNzd29yZCxcbiAgICBkaXNhYmxlQXV0b0ZldGNoLFxuICAgIHJhbmdlQ2h1bmtTaXplLFxuICAgIGxlbmd0aCxcbiAgICBkb2NCYXNlVXJsLFxuICAgIGVuYWJsZVhmYSxcbiAgICBldmFsdWF0b3JPcHRpb25zOiB7XG4gICAgICBtYXhJbWFnZVNpemUsXG4gICAgICBkaXNhYmxlRm9udEZhY2UsXG4gICAgICBpZ25vcmVFcnJvcnMsXG4gICAgICBpc0V2YWxTdXBwb3J0ZWQsXG4gICAgICBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCxcbiAgICAgIGlzSW1hZ2VEZWNvZGVyU3VwcG9ydGVkLFxuICAgICAgY2FudmFzTWF4QXJlYUluQnl0ZXMsXG4gICAgICBmb250RXh0cmFQcm9wZXJ0aWVzLFxuICAgICAgdXNlU3lzdGVtRm9udHMsXG4gICAgICB1c2VXYXNtLFxuICAgICAgdXNlV29ya2VyRmV0Y2gsXG4gICAgICBjTWFwVXJsLFxuICAgICAgaWNjVXJsLFxuICAgICAgc3RhbmRhcmRGb250RGF0YVVybCxcbiAgICAgIHdhc21VcmxcbiAgICB9XG4gIH07XG4gIGNvbnN0IHRyYW5zcG9ydFBhcmFtcyA9IHtcbiAgICBvd25lckRvY3VtZW50LFxuICAgIHBkZkJ1ZyxcbiAgICBzdHlsZUVsZW1lbnQsXG4gICAgbG9hZGluZ1BhcmFtczoge1xuICAgICAgZGlzYWJsZUF1dG9GZXRjaCxcbiAgICAgIGVuYWJsZVhmYVxuICAgIH1cbiAgfTtcbiAgd29ya2VyLnByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRhc2suZGVzdHJveWVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2FkaW5nIGFib3J0ZWRcIik7XG4gICAgfVxuICAgIGlmICh3b3JrZXIuZGVzdHJveWVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgd29ya2VySWRQcm9taXNlID0gd29ya2VyLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldERvY1JlcXVlc3RcIiwgZG9jUGFyYW1zLCBkYXRhID8gW2RhdGEuYnVmZmVyXSA6IG51bGwpO1xuICAgIGxldCBuZXR3b3JrU3RyZWFtO1xuICAgIGlmIChyYW5nZVRyYW5zcG9ydCkge1xuICAgICAgbmV0d29ya1N0cmVhbSA9IG5ldyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtKHJhbmdlVHJhbnNwb3J0LCB7XG4gICAgICAgIGRpc2FibGVSYW5nZSxcbiAgICAgICAgZGlzYWJsZVN0cmVhbVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghZGF0YSkge1xuICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0RG9jdW1lbnQgLSBubyBgdXJsYCBwYXJhbWV0ZXIgcHJvdmlkZWQuXCIpO1xuICAgICAgfVxuICAgICAgbGV0IE5ldHdvcmtTdHJlYW07XG4gICAgICBpZiAoaXNOb2RlSlMpIHtcbiAgICAgICAgaWYgKGlzVmFsaWRGZXRjaFVybCh1cmwpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmZXRjaCA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgUmVzcG9uc2UgPT09IFwidW5kZWZpbmVkXCIgfHwgIShcImJvZHlcIiBpbiBSZXNwb25zZS5wcm90b3R5cGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXREb2N1bWVudCAtIHRoZSBGZXRjaCBBUEkgd2FzIGRpc2FibGVkIGluIE5vZGUuanMsIHNlZSBgLS1uby1leHBlcmltZW50YWwtZmV0Y2hgLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgTmV0d29ya1N0cmVhbSA9IFBERkZldGNoU3RyZWFtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIE5ldHdvcmtTdHJlYW0gPSBQREZOb2RlU3RyZWFtO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBOZXR3b3JrU3RyZWFtID0gaXNWYWxpZEZldGNoVXJsKHVybCkgPyBQREZGZXRjaFN0cmVhbSA6IFBERk5ldHdvcmtTdHJlYW07XG4gICAgICB9XG4gICAgICBuZXR3b3JrU3RyZWFtID0gbmV3IE5ldHdvcmtTdHJlYW0oe1xuICAgICAgICB1cmwsXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgaHR0cEhlYWRlcnMsXG4gICAgICAgIHdpdGhDcmVkZW50aWFscyxcbiAgICAgICAgcmFuZ2VDaHVua1NpemUsXG4gICAgICAgIGRpc2FibGVSYW5nZSxcbiAgICAgICAgZGlzYWJsZVN0cmVhbVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB3b3JrZXJJZFByb21pc2UudGhlbih3b3JrZXJJZCA9PiB7XG4gICAgICBpZiAodGFzay5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9hZGluZyBhYm9ydGVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHdvcmtlci5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXNzYWdlSGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcihkb2NJZCwgd29ya2VySWQsIHdvcmtlci5wb3J0KTtcbiAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IG5ldyBXb3JrZXJUcmFuc3BvcnQobWVzc2FnZUhhbmRsZXIsIHRhc2ssIG5ldHdvcmtTdHJlYW0sIHRyYW5zcG9ydFBhcmFtcywgdHJhbnNwb3J0RmFjdG9yeSk7XG4gICAgICB0YXNrLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICBtZXNzYWdlSGFuZGxlci5zZW5kKFwiUmVhZHlcIiwgbnVsbCk7XG4gICAgfSk7XG4gIH0pLmNhdGNoKHRhc2suX2NhcGFiaWxpdHkucmVqZWN0KTtcbiAgcmV0dXJuIHRhc2s7XG59XG5mdW5jdGlvbiBnZXRVcmxQcm9wKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgcmV0dXJuIHZhbC5ocmVmO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKGlzTm9kZUpTKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBVUkwucGFyc2UodmFsLCB3aW5kb3cubG9jYXRpb24pO1xuICAgIGlmICh1cmwpIHtcbiAgICAgIHJldHVybiB1cmwuaHJlZjtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBQREYgdXJsIGRhdGE6IFwiICsgXCJlaXRoZXIgc3RyaW5nIG9yIFVSTC1vYmplY3QgaXMgZXhwZWN0ZWQgaW4gdGhlIHVybCBwcm9wZXJ0eS5cIik7XG59XG5mdW5jdGlvbiBnZXREYXRhUHJvcCh2YWwpIHtcbiAgaWYgKGlzTm9kZUpTICYmIHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgdmFsIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHByb3ZpZGUgYmluYXJ5IGRhdGEgYXMgYFVpbnQ4QXJyYXlgLCByYXRoZXIgdGhhbiBgQnVmZmVyYC5cIik7XG4gIH1cbiAgaWYgKHZhbCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgdmFsLmJ5dGVMZW5ndGggPT09IHZhbC5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gc3RyaW5nVG9CeXRlcyh2YWwpO1xuICB9XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKSB8fCB0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmICFpc05hTih2YWw/Lmxlbmd0aCkpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFBERiBiaW5hcnkgZGF0YTogZWl0aGVyIFR5cGVkQXJyYXksIFwiICsgXCJzdHJpbmcsIG9yIGFycmF5LWxpa2Ugb2JqZWN0IGlzIGV4cGVjdGVkIGluIHRoZSBkYXRhIHByb3BlcnR5LlwiKTtcbn1cbmZ1bmN0aW9uIGdldEZhY3RvcnlVcmxQcm9wKHZhbCkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICh2YWwuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmFjdG9yeSB1cmw6IFwiJHt2YWx9XCIgbXVzdCBpbmNsdWRlIHRyYWlsaW5nIHNsYXNoLmApO1xufVxuY29uc3QgaXNSZWZQcm94eSA9IHYgPT4gdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgTnVtYmVyLmlzSW50ZWdlcih2Py5udW0pICYmIHYubnVtID49IDAgJiYgTnVtYmVyLmlzSW50ZWdlcih2Py5nZW4pICYmIHYuZ2VuID49IDA7XG5jb25zdCBpc05hbWVQcm94eSA9IHYgPT4gdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHY/Lm5hbWUgPT09IFwic3RyaW5nXCI7XG5jb25zdCBpc1ZhbGlkRXhwbGljaXREZXN0ID0gX2lzVmFsaWRFeHBsaWNpdERlc3QuYmluZChudWxsLCBpc1JlZlByb3h5LCBpc05hbWVQcm94eSk7XG5jbGFzcyBQREZEb2N1bWVudExvYWRpbmdUYXNrIHtcbiAgc3RhdGljICNkb2NJZCA9IDA7XG4gIF9jYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gIF90cmFuc3BvcnQgPSBudWxsO1xuICBfd29ya2VyID0gbnVsbDtcbiAgZG9jSWQgPSBgZCR7UERGRG9jdW1lbnRMb2FkaW5nVGFzay4jZG9jSWQrK31gO1xuICBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgb25QYXNzd29yZCA9IG51bGw7XG4gIG9uUHJvZ3Jlc3MgPSBudWxsO1xuICBnZXQgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGFzeW5jIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5fd29ya2VyPy5wb3J0KSB7XG4gICAgICAgIHRoaXMuX3dvcmtlci5fcGVuZGluZ0Rlc3Ryb3kgPSB0cnVlO1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy5fdHJhbnNwb3J0Py5kZXN0cm95KCk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmICh0aGlzLl93b3JrZXI/LnBvcnQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3dvcmtlci5fcGVuZGluZ0Rlc3Ryb3k7XG4gICAgICB9XG4gICAgICB0aHJvdyBleDtcbiAgICB9XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICB0aGlzLl93b3JrZXI/LmRlc3Ryb3koKTtcbiAgICB0aGlzLl93b3JrZXIgPSBudWxsO1xuICB9XG4gIGFzeW5jIGdldERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREYXRhKCk7XG4gIH1cbn1cbmNsYXNzIFBERkRhdGFSYW5nZVRyYW5zcG9ydCB7XG4gIGNvbnN0cnVjdG9yKGxlbmd0aCwgaW5pdGlhbERhdGEsIHByb2dyZXNzaXZlRG9uZSA9IGZhbHNlLCBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA9IG51bGwpIHtcbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB0aGlzLmluaXRpYWxEYXRhID0gaW5pdGlhbERhdGE7XG4gICAgdGhpcy5wcm9ncmVzc2l2ZURvbmUgPSBwcm9ncmVzc2l2ZURvbmU7XG4gICAgdGhpcy5jb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA9IGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lO1xuICAgIHRoaXMuX3JhbmdlTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fcHJvZ3Jlc3NMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgfVxuICBhZGRSYW5nZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fcmFuZ2VMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cbiAgYWRkUHJvZ3Jlc3NMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuX3Byb2dyZXNzTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIGFkZFByb2dyZXNzaXZlUmVhZExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIGFkZFByb2dyZXNzaXZlRG9uZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIG9uRGF0YVJhbmdlKGJlZ2luLCBjaHVuaykge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5fcmFuZ2VMaXN0ZW5lcnMpIHtcbiAgICAgIGxpc3RlbmVyKGJlZ2luLCBjaHVuayk7XG4gICAgfVxuICB9XG4gIG9uRGF0YVByb2dyZXNzKGxvYWRlZCwgdG90YWwpIHtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5fcHJvZ3Jlc3NMaXN0ZW5lcnMpIHtcbiAgICAgICAgbGlzdGVuZXIobG9hZGVkLCB0b3RhbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgb25EYXRhUHJvZ3Jlc3NpdmVSZWFkKGNodW5rKSB7XG4gICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuX3Byb2dyZXNzaXZlUmVhZExpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lcihjaHVuayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgb25EYXRhUHJvZ3Jlc3NpdmVEb25lKCkge1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLl9wcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcnMpIHtcbiAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB0cmFuc3BvcnRSZWFkeSgpIHtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIHJlcXVlc3REYXRhUmFuZ2UoYmVnaW4sIGVuZCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIFBERkRhdGFSYW5nZVRyYW5zcG9ydC5yZXF1ZXN0RGF0YVJhbmdlXCIpO1xuICB9XG4gIGFib3J0KCkge31cbn1cbmNsYXNzIFBERkRvY3VtZW50UHJveHkge1xuICBjb25zdHJ1Y3RvcihwZGZJbmZvLCB0cmFuc3BvcnQpIHtcbiAgICB0aGlzLl9wZGZJbmZvID0gcGRmSW5mbztcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIH1cbiAgZ2V0IGFubm90YXRpb25TdG9yYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuYW5ub3RhdGlvblN0b3JhZ2U7XG4gIH1cbiAgZ2V0IGNhbnZhc0ZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5jYW52YXNGYWN0b3J5O1xuICB9XG4gIGdldCBmaWx0ZXJGYWN0b3J5KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZmlsdGVyRmFjdG9yeTtcbiAgfVxuICBnZXQgbnVtUGFnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BkZkluZm8ubnVtUGFnZXM7XG4gIH1cbiAgZ2V0IGZpbmdlcnByaW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGRmSW5mby5maW5nZXJwcmludHM7XG4gIH1cbiAgZ2V0IGlzUHVyZVhmYSgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNQdXJlWGZhXCIsICEhdGhpcy5fdHJhbnNwb3J0Ll9odG1sRm9yWGZhKTtcbiAgfVxuICBnZXQgYWxsWGZhSHRtbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0Ll9odG1sRm9yWGZhO1xuICB9XG4gIGdldFBhZ2UocGFnZU51bWJlcikge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZShwYWdlTnVtYmVyKTtcbiAgfVxuICBnZXRQYWdlSW5kZXgocmVmKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlSW5kZXgocmVmKTtcbiAgfVxuICBnZXREZXN0aW5hdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREZXN0aW5hdGlvbnMoKTtcbiAgfVxuICBnZXREZXN0aW5hdGlvbihpZCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RGVzdGluYXRpb24oaWQpO1xuICB9XG4gIGdldFBhZ2VMYWJlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlTGFiZWxzKCk7XG4gIH1cbiAgZ2V0UGFnZUxheW91dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VMYXlvdXQoKTtcbiAgfVxuICBnZXRQYWdlTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VNb2RlKCk7XG4gIH1cbiAgZ2V0Vmlld2VyUHJlZmVyZW5jZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRWaWV3ZXJQcmVmZXJlbmNlcygpO1xuICB9XG4gIGdldE9wZW5BY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRPcGVuQWN0aW9uKCk7XG4gIH1cbiAgZ2V0QXR0YWNobWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRBdHRhY2htZW50cygpO1xuICB9XG4gIGdldEpTQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERvY0pTQWN0aW9ucygpO1xuICB9XG4gIGdldE91dGxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRPdXRsaW5lKCk7XG4gIH1cbiAgZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKHtcbiAgICBpbnRlbnQgPSBcImRpc3BsYXlcIlxuICB9ID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICByZW5kZXJpbmdJbnRlbnRcbiAgICB9ID0gdGhpcy5fdHJhbnNwb3J0LmdldFJlbmRlcmluZ0ludGVudChpbnRlbnQpO1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKHJlbmRlcmluZ0ludGVudCk7XG4gIH1cbiAgZ2V0UGVybWlzc2lvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQZXJtaXNzaW9ucygpO1xuICB9XG4gIGdldE1ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0TWV0YWRhdGEoKTtcbiAgfVxuICBnZXRNYXJrSW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE1hcmtJbmZvKCk7XG4gIH1cbiAgZ2V0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERhdGEoKTtcbiAgfVxuICBzYXZlRG9jdW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5zYXZlRG9jdW1lbnQoKTtcbiAgfVxuICBnZXREb3dubG9hZEluZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5kb3dubG9hZEluZm9DYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2xlYW51cChrZWVwTG9hZGVkRm9udHMgPSBmYWxzZSkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuc3RhcnRDbGVhbnVwKGtlZXBMb2FkZWRGb250cyB8fCB0aGlzLmlzUHVyZVhmYSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2FkaW5nVGFzay5kZXN0cm95KCk7XG4gIH1cbiAgY2FjaGVkUGFnZU51bWJlcihyZWYpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmNhY2hlZFBhZ2VOdW1iZXIocmVmKTtcbiAgfVxuICBnZXQgbG9hZGluZ1BhcmFtcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmxvYWRpbmdQYXJhbXM7XG4gIH1cbiAgZ2V0IGxvYWRpbmdUYXNrKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQubG9hZGluZ1Rhc2s7XG4gIH1cbiAgZ2V0RmllbGRPYmplY3RzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RmllbGRPYmplY3RzKCk7XG4gIH1cbiAgaGFzSlNBY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuaGFzSlNBY3Rpb25zKCk7XG4gIH1cbiAgZ2V0Q2FsY3VsYXRpb25PcmRlcklkcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldENhbGN1bGF0aW9uT3JkZXJJZHMoKTtcbiAgfVxufVxuY2xhc3MgUERGUGFnZVByb3h5IHtcbiAgI3BlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKHBhZ2VJbmRleCwgcGFnZUluZm8sIHRyYW5zcG9ydCwgcGRmQnVnID0gZmFsc2UpIHtcbiAgICB0aGlzLl9wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgdGhpcy5fcGFnZUluZm8gPSBwYWdlSW5mbztcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgdGhpcy5fc3RhdHMgPSBwZGZCdWcgPyBuZXcgU3RhdFRpbWVyKCkgOiBudWxsO1xuICAgIHRoaXMuX3BkZkJ1ZyA9IHBkZkJ1ZztcbiAgICB0aGlzLmNvbW1vbk9ianMgPSB0cmFuc3BvcnQuY29tbW9uT2JqcztcbiAgICB0aGlzLm9ianMgPSBuZXcgUERGT2JqZWN0cygpO1xuICAgIHRoaXMuX2ludGVudFN0YXRlcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICB9XG4gIGdldCBwYWdlTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5kZXggKyAxO1xuICB9XG4gIGdldCByb3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnJvdGF0ZTtcbiAgfVxuICBnZXQgcmVmKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby5yZWY7XG4gIH1cbiAgZ2V0IHVzZXJVbml0KCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby51c2VyVW5pdDtcbiAgfVxuICBnZXQgdmlldygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUluZm8udmlldztcbiAgfVxuICBnZXRWaWV3cG9ydCh7XG4gICAgc2NhbGUsXG4gICAgcm90YXRpb24gPSB0aGlzLnJvdGF0ZSxcbiAgICBvZmZzZXRYID0gMCxcbiAgICBvZmZzZXRZID0gMCxcbiAgICBkb250RmxpcCA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIHJldHVybiBuZXcgUGFnZVZpZXdwb3J0KHtcbiAgICAgIHZpZXdCb3g6IHRoaXMudmlldyxcbiAgICAgIHVzZXJVbml0OiB0aGlzLnVzZXJVbml0LFxuICAgICAgc2NhbGUsXG4gICAgICByb3RhdGlvbixcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZLFxuICAgICAgZG9udEZsaXBcbiAgICB9KTtcbiAgfVxuICBnZXRBbm5vdGF0aW9ucyh7XG4gICAgaW50ZW50ID0gXCJkaXNwbGF5XCJcbiAgfSA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVuZGVyaW5nSW50ZW50XG4gICAgfSA9IHRoaXMuX3RyYW5zcG9ydC5nZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50KTtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldEFubm90YXRpb25zKHRoaXMuX3BhZ2VJbmRleCwgcmVuZGVyaW5nSW50ZW50KTtcbiAgfVxuICBnZXRKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlSlNBY3Rpb25zKHRoaXMuX3BhZ2VJbmRleCk7XG4gIH1cbiAgZ2V0IGZpbHRlckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5maWx0ZXJGYWN0b3J5O1xuICB9XG4gIGdldCBpc1B1cmVYZmEoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzUHVyZVhmYVwiLCAhIXRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYSk7XG4gIH1cbiAgYXN5bmMgZ2V0WGZhKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuX2h0bWxGb3JYZmE/LmNoaWxkcmVuW3RoaXMuX3BhZ2VJbmRleF0gfHwgbnVsbDtcbiAgfVxuICByZW5kZXIoe1xuICAgIGNhbnZhc0NvbnRleHQsXG4gICAgdmlld3BvcnQsXG4gICAgaW50ZW50ID0gXCJkaXNwbGF5XCIsXG4gICAgYW5ub3RhdGlvbk1vZGUgPSBBbm5vdGF0aW9uTW9kZS5FTkFCTEUsXG4gICAgdHJhbnNmb3JtID0gbnVsbCxcbiAgICBiYWNrZ3JvdW5kID0gbnVsbCxcbiAgICBvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlID0gbnVsbCxcbiAgICBhbm5vdGF0aW9uQ2FudmFzTWFwID0gbnVsbCxcbiAgICBwYWdlQ29sb3JzID0gbnVsbCxcbiAgICBwcmludEFubm90YXRpb25TdG9yYWdlID0gbnVsbCxcbiAgICBpc0VkaXRpbmcgPSBmYWxzZVxuICB9KSB7XG4gICAgdGhpcy5fc3RhdHM/LnRpbWUoXCJPdmVyYWxsXCIpO1xuICAgIGNvbnN0IGludGVudEFyZ3MgPSB0aGlzLl90cmFuc3BvcnQuZ2V0UmVuZGVyaW5nSW50ZW50KGludGVudCwgYW5ub3RhdGlvbk1vZGUsIHByaW50QW5ub3RhdGlvblN0b3JhZ2UsIGlzRWRpdGluZyk7XG4gICAgY29uc3Qge1xuICAgICAgcmVuZGVyaW5nSW50ZW50LFxuICAgICAgY2FjaGVLZXlcbiAgICB9ID0gaW50ZW50QXJncztcbiAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UgfHw9IHRoaXMuX3RyYW5zcG9ydC5nZXRPcHRpb25hbENvbnRlbnRDb25maWcocmVuZGVyaW5nSW50ZW50KTtcbiAgICBsZXQgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoIWludGVudFN0YXRlKSB7XG4gICAgICBpbnRlbnRTdGF0ZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuc2V0KGNhY2hlS2V5LCBpbnRlbnRTdGF0ZSk7XG4gICAgfVxuICAgIGlmIChpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCk7XG4gICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgaW50ZW50UHJpbnQgPSAhIShyZW5kZXJpbmdJbnRlbnQgJiBSZW5kZXJpbmdJbnRlbnRGbGFnLlBSSU5UKTtcbiAgICBpZiAoIWludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkpIHtcbiAgICAgIGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCA9IHtcbiAgICAgICAgZm5BcnJheTogW10sXG4gICAgICAgIGFyZ3NBcnJheTogW10sXG4gICAgICAgIGxhc3RDaHVuazogZmFsc2UsXG4gICAgICAgIHNlcGFyYXRlQW5ub3RzOiBudWxsXG4gICAgICB9O1xuICAgICAgdGhpcy5fc3RhdHM/LnRpbWUoXCJQYWdlIFJlcXVlc3RcIik7XG4gICAgICB0aGlzLl9wdW1wT3BlcmF0b3JMaXN0KGludGVudEFyZ3MpO1xuICAgIH1cbiAgICBjb25zdCBjb21wbGV0ZSA9IGVycm9yID0+IHtcbiAgICAgIGludGVudFN0YXRlLnJlbmRlclRhc2tzLmRlbGV0ZShpbnRlcm5hbFJlbmRlclRhc2spO1xuICAgICAgaWYgKGludGVudFByaW50KSB7XG4gICAgICAgIHRoaXMuI3BlbmRpbmdDbGVhbnVwID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3RyeUNsZWFudXAoKTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2suY2FwYWJpbGl0eS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB0aGlzLl9hYm9ydE9wZXJhdG9yTGlzdCh7XG4gICAgICAgICAgaW50ZW50U3RhdGUsXG4gICAgICAgICAgcmVhc29uOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoZXJyb3IpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLmNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3N0YXRzKSB7XG4gICAgICAgIHRoaXMuX3N0YXRzLnRpbWVFbmQoXCJSZW5kZXJpbmdcIik7XG4gICAgICAgIHRoaXMuX3N0YXRzLnRpbWVFbmQoXCJPdmVyYWxsXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5TdGF0cz8uZW5hYmxlZCkge1xuICAgICAgICAgIGdsb2JhbFRoaXMuU3RhdHMuYWRkKHRoaXMucGFnZU51bWJlciwgdGhpcy5fc3RhdHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpbnRlcm5hbFJlbmRlclRhc2sgPSBuZXcgSW50ZXJuYWxSZW5kZXJUYXNrKHtcbiAgICAgIGNhbGxiYWNrOiBjb21wbGV0ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBjYW52YXNDb250ZXh0LFxuICAgICAgICB2aWV3cG9ydCxcbiAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICBiYWNrZ3JvdW5kXG4gICAgICB9LFxuICAgICAgb2JqczogdGhpcy5vYmpzLFxuICAgICAgY29tbW9uT2JqczogdGhpcy5jb21tb25PYmpzLFxuICAgICAgYW5ub3RhdGlvbkNhbnZhc01hcCxcbiAgICAgIG9wZXJhdG9yTGlzdDogaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0LFxuICAgICAgcGFnZUluZGV4OiB0aGlzLl9wYWdlSW5kZXgsXG4gICAgICBjYW52YXNGYWN0b3J5OiB0aGlzLl90cmFuc3BvcnQuY2FudmFzRmFjdG9yeSxcbiAgICAgIGZpbHRlckZhY3Rvcnk6IHRoaXMuX3RyYW5zcG9ydC5maWx0ZXJGYWN0b3J5LFxuICAgICAgdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lOiAhaW50ZW50UHJpbnQsXG4gICAgICBwZGZCdWc6IHRoaXMuX3BkZkJ1ZyxcbiAgICAgIHBhZ2VDb2xvcnNcbiAgICB9KTtcbiAgICAoaW50ZW50U3RhdGUucmVuZGVyVGFza3MgfHw9IG5ldyBTZXQoKSkuYWRkKGludGVybmFsUmVuZGVyVGFzayk7XG4gICAgY29uc3QgcmVuZGVyVGFzayA9IGludGVybmFsUmVuZGVyVGFzay50YXNrO1xuICAgIFByb21pc2UuYWxsKFtpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5LnByb21pc2UsIG9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2VdKS50aGVuKChbdHJhbnNwYXJlbmN5LCBvcHRpb25hbENvbnRlbnRDb25maWddKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3RhdHM/LnRpbWUoXCJSZW5kZXJpbmdcIik7XG4gICAgICBpZiAoIShvcHRpb25hbENvbnRlbnRDb25maWcucmVuZGVyaW5nSW50ZW50ICYgcmVuZGVyaW5nSW50ZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHVzZSB0aGUgc2FtZSBgaW50ZW50YC1hcmd1bWVudCB3aGVuIGNhbGxpbmcgdGhlIGBQREZQYWdlUHJveHkucmVuZGVyYCBcIiArIFwiYW5kIGBQREZEb2N1bWVudFByb3h5LmdldE9wdGlvbmFsQ29udGVudENvbmZpZ2AgbWV0aG9kcy5cIik7XG4gICAgICB9XG4gICAgICBpbnRlcm5hbFJlbmRlclRhc2suaW5pdGlhbGl6ZUdyYXBoaWNzKHtcbiAgICAgICAgdHJhbnNwYXJlbmN5LFxuICAgICAgICBvcHRpb25hbENvbnRlbnRDb25maWdcbiAgICAgIH0pO1xuICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLm9wZXJhdG9yTGlzdENoYW5nZWQoKTtcbiAgICB9KS5jYXRjaChjb21wbGV0ZSk7XG4gICAgcmV0dXJuIHJlbmRlclRhc2s7XG4gIH1cbiAgZ2V0T3BlcmF0b3JMaXN0KHtcbiAgICBpbnRlbnQgPSBcImRpc3BsYXlcIixcbiAgICBhbm5vdGF0aW9uTW9kZSA9IEFubm90YXRpb25Nb2RlLkVOQUJMRSxcbiAgICBwcmludEFubm90YXRpb25TdG9yYWdlID0gbnVsbCxcbiAgICBpc0VkaXRpbmcgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICBmdW5jdGlvbiBvcGVyYXRvckxpc3RDaGFuZ2VkKCkge1xuICAgICAgaWYgKGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5sYXN0Q2h1bmspIHtcbiAgICAgICAgaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkucmVzb2x2ZShpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QpO1xuICAgICAgICBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5kZWxldGUob3BMaXN0VGFzayk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGludGVudEFyZ3MgPSB0aGlzLl90cmFuc3BvcnQuZ2V0UmVuZGVyaW5nSW50ZW50KGludGVudCwgYW5ub3RhdGlvbk1vZGUsIHByaW50QW5ub3RhdGlvblN0b3JhZ2UsIGlzRWRpdGluZywgdHJ1ZSk7XG4gICAgbGV0IGludGVudFN0YXRlID0gdGhpcy5faW50ZW50U3RhdGVzLmdldChpbnRlbnRBcmdzLmNhY2hlS2V5KTtcbiAgICBpZiAoIWludGVudFN0YXRlKSB7XG4gICAgICBpbnRlbnRTdGF0ZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuc2V0KGludGVudEFyZ3MuY2FjaGVLZXksIGludGVudFN0YXRlKTtcbiAgICB9XG4gICAgbGV0IG9wTGlzdFRhc2s7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eSkge1xuICAgICAgb3BMaXN0VGFzayA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBvcExpc3RUYXNrLm9wZXJhdG9yTGlzdENoYW5nZWQgPSBvcGVyYXRvckxpc3RDaGFuZ2VkO1xuICAgICAgaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgIChpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcyB8fD0gbmV3IFNldCgpKS5hZGQob3BMaXN0VGFzayk7XG4gICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QgPSB7XG4gICAgICAgIGZuQXJyYXk6IFtdLFxuICAgICAgICBhcmdzQXJyYXk6IFtdLFxuICAgICAgICBsYXN0Q2h1bms6IGZhbHNlLFxuICAgICAgICBzZXBhcmF0ZUFubm90czogbnVsbFxuICAgICAgfTtcbiAgICAgIHRoaXMuX3N0YXRzPy50aW1lKFwiUGFnZSBSZXF1ZXN0XCIpO1xuICAgICAgdGhpcy5fcHVtcE9wZXJhdG9yTGlzdChpbnRlbnRBcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgc3RyZWFtVGV4dENvbnRlbnQoe1xuICAgIGluY2x1ZGVNYXJrZWRDb250ZW50ID0gZmFsc2UsXG4gICAgZGlzYWJsZU5vcm1hbGl6YXRpb24gPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICBjb25zdCBURVhUX0NPTlRFTlRfQ0hVTktfU0laRSA9IDEwMDtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0Lm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoU3RyZWFtKFwiR2V0VGV4dENvbnRlbnRcIiwge1xuICAgICAgcGFnZUluZGV4OiB0aGlzLl9wYWdlSW5kZXgsXG4gICAgICBpbmNsdWRlTWFya2VkQ29udGVudDogaW5jbHVkZU1hcmtlZENvbnRlbnQgPT09IHRydWUsXG4gICAgICBkaXNhYmxlTm9ybWFsaXphdGlvbjogZGlzYWJsZU5vcm1hbGl6YXRpb24gPT09IHRydWVcbiAgICB9LCB7XG4gICAgICBoaWdoV2F0ZXJNYXJrOiBURVhUX0NPTlRFTlRfQ0hVTktfU0laRSxcbiAgICAgIHNpemUodGV4dENvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRleHRDb250ZW50Lml0ZW1zLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRUZXh0Q29udGVudChwYXJhbXMgPSB7fSkge1xuICAgIGlmICh0aGlzLl90cmFuc3BvcnQuX2h0bWxGb3JYZmEpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFhmYSgpLnRoZW4oeGZhID0+IFhmYVRleHQudGV4dENvbnRlbnQoeGZhKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlYWRhYmxlU3RyZWFtID0gdGhpcy5zdHJlYW1UZXh0Q29udGVudChwYXJhbXMpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBmdW5jdGlvbiBwdW1wKCkge1xuICAgICAgICByZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBkb25lXG4gICAgICAgIH0pIHtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgcmVzb2x2ZSh0ZXh0Q29udGVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRleHRDb250ZW50LmxhbmcgPz89IHZhbHVlLmxhbmc7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbih0ZXh0Q29udGVudC5zdHlsZXMsIHZhbHVlLnN0eWxlcyk7XG4gICAgICAgICAgdGV4dENvbnRlbnQuaXRlbXMucHVzaCguLi52YWx1ZS5pdGVtcyk7XG4gICAgICAgICAgcHVtcCgpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVhZGVyID0gcmVhZGFibGVTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICBjb25zdCB0ZXh0Q29udGVudCA9IHtcbiAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICBzdHlsZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgIGxhbmc6IG51bGxcbiAgICAgIH07XG4gICAgICBwdW1wKCk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0U3RydWN0VHJlZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFN0cnVjdFRyZWUodGhpcy5fcGFnZUluZGV4KTtcbiAgfVxuICBfZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgY29uc3Qgd2FpdE9uID0gW107XG4gICAgZm9yIChjb25zdCBpbnRlbnRTdGF0ZSBvZiB0aGlzLl9pbnRlbnRTdGF0ZXMudmFsdWVzKCkpIHtcbiAgICAgIHRoaXMuX2Fib3J0T3BlcmF0b3JMaXN0KHtcbiAgICAgICAgaW50ZW50U3RhdGUsXG4gICAgICAgIHJlYXNvbjogbmV3IEVycm9yKFwiUGFnZSB3YXMgZGVzdHJveWVkLlwiKSxcbiAgICAgICAgZm9yY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgaWYgKGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBpbnRlcm5hbFJlbmRlclRhc2sgb2YgaW50ZW50U3RhdGUucmVuZGVyVGFza3MpIHtcbiAgICAgICAgd2FpdE9uLnB1c2goaW50ZXJuYWxSZW5kZXJUYXNrLmNvbXBsZXRlZCk7XG4gICAgICAgIGludGVybmFsUmVuZGVyVGFzay5jYW5jZWwoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5vYmpzLmNsZWFyKCk7XG4gICAgdGhpcy4jcGVuZGluZ0NsZWFudXAgPSBmYWxzZTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwod2FpdE9uKTtcbiAgfVxuICBjbGVhbnVwKHJlc2V0U3RhdHMgPSBmYWxzZSkge1xuICAgIHRoaXMuI3BlbmRpbmdDbGVhbnVwID0gdHJ1ZTtcbiAgICBjb25zdCBzdWNjZXNzID0gdGhpcy4jdHJ5Q2xlYW51cCgpO1xuICAgIGlmIChyZXNldFN0YXRzICYmIHN1Y2Nlc3MpIHtcbiAgICAgIHRoaXMuX3N0YXRzICYmPSBuZXcgU3RhdFRpbWVyKCk7XG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzO1xuICB9XG4gICN0cnlDbGVhbnVwKCkge1xuICAgIGlmICghdGhpcy4jcGVuZGluZ0NsZWFudXAgfHwgdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB7XG4gICAgICByZW5kZXJUYXNrcyxcbiAgICAgIG9wZXJhdG9yTGlzdFxuICAgIH0gb2YgdGhpcy5faW50ZW50U3RhdGVzLnZhbHVlcygpKSB7XG4gICAgICBpZiAocmVuZGVyVGFza3Muc2l6ZSA+IDAgfHwgIW9wZXJhdG9yTGlzdC5sYXN0Q2h1bmspIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuY2xlYXIoKTtcbiAgICB0aGlzLm9ianMuY2xlYXIoKTtcbiAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIF9zdGFydFJlbmRlclBhZ2UodHJhbnNwYXJlbmN5LCBjYWNoZUtleSkge1xuICAgIGNvbnN0IGludGVudFN0YXRlID0gdGhpcy5faW50ZW50U3RhdGVzLmdldChjYWNoZUtleSk7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9zdGF0cz8udGltZUVuZChcIlBhZ2UgUmVxdWVzdFwiKTtcbiAgICBpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5Py5yZXNvbHZlKHRyYW5zcGFyZW5jeSk7XG4gIH1cbiAgX3JlbmRlclBhZ2VDaHVuayhvcGVyYXRvckxpc3RDaHVuaywgaW50ZW50U3RhdGUpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBvcGVyYXRvckxpc3RDaHVuay5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QuZm5BcnJheS5wdXNoKG9wZXJhdG9yTGlzdENodW5rLmZuQXJyYXlbaV0pO1xuICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0LmFyZ3NBcnJheS5wdXNoKG9wZXJhdG9yTGlzdENodW5rLmFyZ3NBcnJheVtpXSk7XG4gICAgfVxuICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5sYXN0Q2h1bmsgPSBvcGVyYXRvckxpc3RDaHVuay5sYXN0Q2h1bms7XG4gICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0LnNlcGFyYXRlQW5ub3RzID0gb3BlcmF0b3JMaXN0Q2h1bmsuc2VwYXJhdGVBbm5vdHM7XG4gICAgZm9yIChjb25zdCBpbnRlcm5hbFJlbmRlclRhc2sgb2YgaW50ZW50U3RhdGUucmVuZGVyVGFza3MpIHtcbiAgICAgIGludGVybmFsUmVuZGVyVGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkKCk7XG4gICAgfVxuICAgIGlmIChvcGVyYXRvckxpc3RDaHVuay5sYXN0Q2h1bmspIHtcbiAgICAgIHRoaXMuI3RyeUNsZWFudXAoKTtcbiAgICB9XG4gIH1cbiAgX3B1bXBPcGVyYXRvckxpc3Qoe1xuICAgIHJlbmRlcmluZ0ludGVudCxcbiAgICBjYWNoZUtleSxcbiAgICBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZSxcbiAgICBtb2RpZmllZElkc1xuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgbWFwLFxuICAgICAgdHJhbnNmZXJcbiAgICB9ID0gYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGU7XG4gICAgY29uc3QgcmVhZGFibGVTdHJlYW0gPSB0aGlzLl90cmFuc3BvcnQubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhTdHJlYW0oXCJHZXRPcGVyYXRvckxpc3RcIiwge1xuICAgICAgcGFnZUluZGV4OiB0aGlzLl9wYWdlSW5kZXgsXG4gICAgICBpbnRlbnQ6IHJlbmRlcmluZ0ludGVudCxcbiAgICAgIGNhY2hlS2V5LFxuICAgICAgYW5ub3RhdGlvblN0b3JhZ2U6IG1hcCxcbiAgICAgIG1vZGlmaWVkSWRzXG4gICAgfSwgdHJhbnNmZXIpO1xuICAgIGNvbnN0IHJlYWRlciA9IHJlYWRhYmxlU3RyZWFtLmdldFJlYWRlcigpO1xuICAgIGNvbnN0IGludGVudFN0YXRlID0gdGhpcy5faW50ZW50U3RhdGVzLmdldChjYWNoZUtleSk7XG4gICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyID0gcmVhZGVyO1xuICAgIGNvbnN0IHB1bXAgPSAoKSA9PiB7XG4gICAgICByZWFkZXIucmVhZCgpLnRoZW4oKHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRvbmVcbiAgICAgIH0pID0+IHtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIgPSBudWxsO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdHJhbnNwb3J0LmRlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW5kZXJQYWdlQ2h1bmsodmFsdWUsIGludGVudFN0YXRlKTtcbiAgICAgICAgcHVtcCgpO1xuICAgICAgfSwgcmVhc29uID0+IHtcbiAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zcG9ydC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCkge1xuICAgICAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5sYXN0Q2h1bmsgPSB0cnVlO1xuICAgICAgICAgIGZvciAoY29uc3QgaW50ZXJuYWxSZW5kZXJUYXNrIG9mIGludGVudFN0YXRlLnJlbmRlclRhc2tzKSB7XG4gICAgICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2sub3BlcmF0b3JMaXN0Q2hhbmdlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLiN0cnlDbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkpIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5LnJlamVjdChyZWFzb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5KSB7XG4gICAgICAgICAgaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHB1bXAoKTtcbiAgfVxuICBfYWJvcnRPcGVyYXRvckxpc3Qoe1xuICAgIGludGVudFN0YXRlLFxuICAgIHJlYXNvbixcbiAgICBmb3JjZSA9IGZhbHNlXG4gIH0pIHtcbiAgICBpZiAoIWludGVudFN0YXRlLnN0cmVhbVJlYWRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQpO1xuICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIGlmICghZm9yY2UpIHtcbiAgICAgIGlmIChpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5zaXplID4gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocmVhc29uIGluc3RhbmNlb2YgUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uKSB7XG4gICAgICAgIGxldCBkZWxheSA9IFJFTkRFUklOR19DQU5DRUxMRURfVElNRU9VVDtcbiAgICAgICAgaWYgKHJlYXNvbi5leHRyYURlbGF5ID4gMCAmJiByZWFzb24uZXh0cmFEZWxheSA8IDEwMDApIHtcbiAgICAgICAgICBkZWxheSArPSByZWFzb24uZXh0cmFEZWxheTtcbiAgICAgICAgfVxuICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fYWJvcnRPcGVyYXRvckxpc3Qoe1xuICAgICAgICAgICAgaW50ZW50U3RhdGUsXG4gICAgICAgICAgICByZWFzb24sXG4gICAgICAgICAgICBmb3JjZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyLmNhbmNlbChuZXcgQWJvcnRFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UpKS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyID0gbnVsbDtcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtjdXJDYWNoZUtleSwgY3VySW50ZW50U3RhdGVdIG9mIHRoaXMuX2ludGVudFN0YXRlcykge1xuICAgICAgaWYgKGN1ckludGVudFN0YXRlID09PSBpbnRlbnRTdGF0ZSkge1xuICAgICAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuZGVsZXRlKGN1ckNhY2hlS2V5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2xlYW51cCgpO1xuICB9XG4gIGdldCBzdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHM7XG4gIH1cbn1cbmNsYXNzIExvb3BiYWNrUG9ydCB7XG4gICNsaXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG4gICNkZWZlcnJlZCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICBwb3N0TWVzc2FnZShvYmosIHRyYW5zZmVyKSB7XG4gICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICBkYXRhOiBzdHJ1Y3R1cmVkQ2xvbmUob2JqLCB0cmFuc2ZlciA/IHtcbiAgICAgICAgdHJhbnNmZXJcbiAgICAgIH0gOiBudWxsKVxuICAgIH07XG4gICAgdGhpcy4jZGVmZXJyZWQudGhlbigoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IFtsaXN0ZW5lcl0gb2YgdGhpcy4jbGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIobmFtZSwgbGlzdGVuZXIsIG9wdGlvbnMgPSBudWxsKSB7XG4gICAgbGV0IHJtQWJvcnQgPSBudWxsO1xuICAgIGlmIChvcHRpb25zPy5zaWduYWwgaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHdhcm4oXCJMb29wYmFja1BvcnQgLSBjYW5ub3QgdXNlIGFuIGBhYm9ydGVkYCBzaWduYWwuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvbkFib3J0ID0gKCkgPT4gdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyKTtcbiAgICAgIHJtQWJvcnQgPSAoKSA9PiBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICB9XG4gICAgdGhpcy4jbGlzdGVuZXJzLnNldChsaXN0ZW5lciwgcm1BYm9ydCk7XG4gIH1cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IHJtQWJvcnQgPSB0aGlzLiNsaXN0ZW5lcnMuZ2V0KGxpc3RlbmVyKTtcbiAgICBybUFib3J0Py4oKTtcbiAgICB0aGlzLiNsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgfVxuICB0ZXJtaW5hdGUoKSB7XG4gICAgZm9yIChjb25zdCBbLCBybUFib3J0XSBvZiB0aGlzLiNsaXN0ZW5lcnMpIHtcbiAgICAgIHJtQWJvcnQ/LigpO1xuICAgIH1cbiAgICB0aGlzLiNsaXN0ZW5lcnMuY2xlYXIoKTtcbiAgfVxufVxuY2xhc3MgUERGV29ya2VyIHtcbiAgc3RhdGljICNmYWtlV29ya2VySWQgPSAwO1xuICBzdGF0aWMgI2lzV29ya2VyRGlzYWJsZWQgPSBmYWxzZTtcbiAgc3RhdGljICN3b3JrZXJQb3J0cztcbiAgc3RhdGljIHtcbiAgICBpZiAoaXNOb2RlSlMpIHtcbiAgICAgIHRoaXMuI2lzV29ya2VyRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmMgfHw9IFwiLi9wZGYud29ya2VyLm1qc1wiO1xuICAgIH1cbiAgICB0aGlzLl9pc1NhbWVPcmlnaW4gPSAoYmFzZVVybCwgb3RoZXJVcmwpID0+IHtcbiAgICAgIGNvbnN0IGJhc2UgPSBVUkwucGFyc2UoYmFzZVVybCk7XG4gICAgICBpZiAoIWJhc2U/Lm9yaWdpbiB8fCBiYXNlLm9yaWdpbiA9PT0gXCJudWxsXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3RoZXIgPSBuZXcgVVJMKG90aGVyVXJsLCBiYXNlKTtcbiAgICAgIHJldHVybiBiYXNlLm9yaWdpbiA9PT0gb3RoZXIub3JpZ2luO1xuICAgIH07XG4gICAgdGhpcy5fY3JlYXRlQ0ROV3JhcHBlciA9IHVybCA9PiB7XG4gICAgICBjb25zdCB3cmFwcGVyID0gYGF3YWl0IGltcG9ydChcIiR7dXJsfVwiKTtgO1xuICAgICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW3dyYXBwZXJdLCB7XG4gICAgICAgIHR5cGU6IFwidGV4dC9qYXZhc2NyaXB0XCJcbiAgICAgIH0pKTtcbiAgICB9O1xuICB9XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBuYW1lID0gbnVsbCxcbiAgICBwb3J0ID0gbnVsbCxcbiAgICB2ZXJib3NpdHkgPSBnZXRWZXJib3NpdHlMZXZlbCgpXG4gIH0gPSB7fSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnZlcmJvc2l0eSA9IHZlcmJvc2l0eTtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9wb3J0ID0gbnVsbDtcbiAgICB0aGlzLl93ZWJXb3JrZXIgPSBudWxsO1xuICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbnVsbDtcbiAgICBpZiAocG9ydCkge1xuICAgICAgaWYgKFBERldvcmtlci4jd29ya2VyUG9ydHM/Lmhhcyhwb3J0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIG1vcmUgdGhhbiBvbmUgUERGV29ya2VyIHBlciBwb3J0LlwiKTtcbiAgICAgIH1cbiAgICAgIChQREZXb3JrZXIuI3dvcmtlclBvcnRzIHx8PSBuZXcgV2Vha01hcCgpKS5zZXQocG9ydCwgdGhpcyk7XG4gICAgICB0aGlzLl9pbml0aWFsaXplRnJvbVBvcnQocG9ydCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2luaXRpYWxpemUoKTtcbiAgfVxuICBnZXQgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgI3Jlc29sdmUoKSB7XG4gICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB0aGlzLl9tZXNzYWdlSGFuZGxlci5zZW5kKFwiY29uZmlndXJlXCIsIHtcbiAgICAgIHZlcmJvc2l0eTogdGhpcy52ZXJib3NpdHlcbiAgICB9KTtcbiAgfVxuICBnZXQgcG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9ydDtcbiAgfVxuICBnZXQgbWVzc2FnZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lc3NhZ2VIYW5kbGVyO1xuICB9XG4gIF9pbml0aWFsaXplRnJvbVBvcnQocG9ydCkge1xuICAgIHRoaXMuX3BvcnQgPSBwb3J0O1xuICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbmV3IE1lc3NhZ2VIYW5kbGVyKFwibWFpblwiLCBcIndvcmtlclwiLCBwb3J0KTtcbiAgICB0aGlzLl9tZXNzYWdlSGFuZGxlci5vbihcInJlYWR5XCIsIGZ1bmN0aW9uICgpIHt9KTtcbiAgICB0aGlzLiNyZXNvbHZlKCk7XG4gIH1cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgaWYgKFBERldvcmtlci4jaXNXb3JrZXJEaXNhYmxlZCB8fCBQREZXb3JrZXIuI21haW5UaHJlYWRXb3JrZXJNZXNzYWdlSGFuZGxlcikge1xuICAgICAgdGhpcy5fc2V0dXBGYWtlV29ya2VyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB7XG4gICAgICB3b3JrZXJTcmNcbiAgICB9ID0gUERGV29ya2VyO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIVBERldvcmtlci5faXNTYW1lT3JpZ2luKHdpbmRvdy5sb2NhdGlvbiwgd29ya2VyU3JjKSkge1xuICAgICAgICB3b3JrZXJTcmMgPSBQREZXb3JrZXIuX2NyZWF0ZUNETldyYXBwZXIobmV3IFVSTCh3b3JrZXJTcmMsIHdpbmRvdy5sb2NhdGlvbikuaHJlZik7XG4gICAgICB9XG4gICAgICBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKHdvcmtlclNyYywge1xuICAgICAgICB0eXBlOiBcIm1vZHVsZVwiXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1lc3NhZ2VIYW5kbGVyID0gbmV3IE1lc3NhZ2VIYW5kbGVyKFwibWFpblwiLCBcIndvcmtlclwiLCB3b3JrZXIpO1xuICAgICAgY29uc3QgdGVybWluYXRlRWFybHkgPSAoKSA9PiB7XG4gICAgICAgIGFjLmFib3J0KCk7XG4gICAgICAgIG1lc3NhZ2VIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zZXR1cEZha2VXb3JrZXIoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5fd2ViV29ya2VyKSB7XG4gICAgICAgICAgdGVybWluYXRlRWFybHkoKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBzaWduYWw6IGFjLnNpZ25hbFxuICAgICAgfSk7XG4gICAgICBtZXNzYWdlSGFuZGxlci5vbihcInRlc3RcIiwgZGF0YSA9PiB7XG4gICAgICAgIGFjLmFib3J0KCk7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCB8fCAhZGF0YSkge1xuICAgICAgICAgIHRlcm1pbmF0ZUVhcmx5KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbWVzc2FnZUhhbmRsZXI7XG4gICAgICAgIHRoaXMuX3BvcnQgPSB3b3JrZXI7XG4gICAgICAgIHRoaXMuX3dlYldvcmtlciA9IHdvcmtlcjtcbiAgICAgICAgdGhpcy4jcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgICBtZXNzYWdlSGFuZGxlci5vbihcInJlYWR5XCIsIGRhdGEgPT4ge1xuICAgICAgICBhYy5hYm9ydCgpO1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICB0ZXJtaW5hdGVFYXJseSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHNlbmRUZXN0KCk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHRoaXMuX3NldHVwRmFrZVdvcmtlcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHNlbmRUZXN0ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB0ZXN0T2JqID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZUhhbmRsZXIuc2VuZChcInRlc3RcIiwgdGVzdE9iaiwgW3Rlc3RPYmouYnVmZmVyXSk7XG4gICAgICB9O1xuICAgICAgc2VuZFRlc3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGluZm8oXCJUaGUgd29ya2VyIGhhcyBiZWVuIGRpc2FibGVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5fc2V0dXBGYWtlV29ya2VyKCk7XG4gIH1cbiAgX3NldHVwRmFrZVdvcmtlcigpIHtcbiAgICBpZiAoIVBERldvcmtlci4jaXNXb3JrZXJEaXNhYmxlZCkge1xuICAgICAgd2FybihcIlNldHRpbmcgdXAgZmFrZSB3b3JrZXIuXCIpO1xuICAgICAgUERGV29ya2VyLiNpc1dvcmtlckRpc2FibGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgUERGV29ya2VyLl9zZXR1cEZha2VXb3JrZXJHbG9iYWwudGhlbihXb3JrZXJNZXNzYWdlSGFuZGxlciA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlamVjdChuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZFwiKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvcnQgPSBuZXcgTG9vcGJhY2tQb3J0KCk7XG4gICAgICB0aGlzLl9wb3J0ID0gcG9ydDtcbiAgICAgIGNvbnN0IGlkID0gYGZha2Uke1BERldvcmtlci4jZmFrZVdvcmtlcklkKyt9YDtcbiAgICAgIGNvbnN0IHdvcmtlckhhbmRsZXIgPSBuZXcgTWVzc2FnZUhhbmRsZXIoaWQgKyBcIl93b3JrZXJcIiwgaWQsIHBvcnQpO1xuICAgICAgV29ya2VyTWVzc2FnZUhhbmRsZXIuc2V0dXAod29ya2VySGFuZGxlciwgcG9ydCk7XG4gICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcihpZCwgaWQgKyBcIl93b3JrZXJcIiwgcG9ydCk7XG4gICAgICB0aGlzLiNyZXNvbHZlKCk7XG4gICAgfSkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5yZWplY3QobmV3IEVycm9yKGBTZXR0aW5nIHVwIGZha2Ugd29ya2VyIGZhaWxlZDogXCIke3JlYXNvbi5tZXNzYWdlfVwiLmApKTtcbiAgICB9KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLl93ZWJXb3JrZXI/LnRlcm1pbmF0ZSgpO1xuICAgIHRoaXMuX3dlYldvcmtlciA9IG51bGw7XG4gICAgUERGV29ya2VyLiN3b3JrZXJQb3J0cz8uZGVsZXRlKHRoaXMuX3BvcnQpO1xuICAgIHRoaXMuX3BvcnQgPSBudWxsO1xuICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyPy5kZXN0cm95KCk7XG4gICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIgPSBudWxsO1xuICB9XG4gIHN0YXRpYyBmcm9tUG9ydChwYXJhbXMpIHtcbiAgICBpZiAoIXBhcmFtcz8ucG9ydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUERGV29ya2VyLmZyb21Qb3J0IC0gaW52YWxpZCBtZXRob2Qgc2lnbmF0dXJlLlwiKTtcbiAgICB9XG4gICAgY29uc3QgY2FjaGVkUG9ydCA9IHRoaXMuI3dvcmtlclBvcnRzPy5nZXQocGFyYW1zLnBvcnQpO1xuICAgIGlmIChjYWNoZWRQb3J0KSB7XG4gICAgICBpZiAoY2FjaGVkUG9ydC5fcGVuZGluZ0Rlc3Ryb3kpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUERGV29ya2VyLmZyb21Qb3J0IC0gdGhlIHdvcmtlciBpcyBiZWluZyBkZXN0cm95ZWQuXFxuXCIgKyBcIlBsZWFzZSByZW1lbWJlciB0byBhd2FpdCBgUERGRG9jdW1lbnRMb2FkaW5nVGFzay5kZXN0cm95KClgLWNhbGxzLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWNoZWRQb3J0O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFBERldvcmtlcihwYXJhbXMpO1xuICB9XG4gIHN0YXRpYyBnZXQgd29ya2VyU3JjKCkge1xuICAgIGlmIChHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYykge1xuICAgICAgcmV0dXJuIEdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFwiR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmNcIiBzcGVjaWZpZWQuJyk7XG4gIH1cbiAgc3RhdGljIGdldCAjbWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZ2xvYmFsVGhpcy5wZGZqc1dvcmtlcj8uV29ya2VyTWVzc2FnZUhhbmRsZXIgfHwgbnVsbDtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IF9zZXR1cEZha2VXb3JrZXJHbG9iYWwoKSB7XG4gICAgY29uc3QgbG9hZGVyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuI21haW5UaHJlYWRXb3JrZXJNZXNzYWdlSGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcy4jbWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyO1xuICAgICAgfVxuICAgICAgY29uc3Qgd29ya2VyID0gYXdhaXQgaW1wb3J0KFxuICAgICAgLyp3ZWJwYWNrSWdub3JlOiB0cnVlKi9cbiAgICAgIC8qQHZpdGUtaWdub3JlKi9cbiAgICAgIHRoaXMud29ya2VyU3JjKTtcbiAgICAgIHJldHVybiB3b3JrZXIuV29ya2VyTWVzc2FnZUhhbmRsZXI7XG4gICAgfTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX3NldHVwRmFrZVdvcmtlckdsb2JhbFwiLCBsb2FkZXIoKSk7XG4gIH1cbn1cbmNsYXNzIFdvcmtlclRyYW5zcG9ydCB7XG4gICNtZXRob2RQcm9taXNlcyA9IG5ldyBNYXAoKTtcbiAgI3BhZ2VDYWNoZSA9IG5ldyBNYXAoKTtcbiAgI3BhZ2VQcm9taXNlcyA9IG5ldyBNYXAoKTtcbiAgI3BhZ2VSZWZDYWNoZSA9IG5ldyBNYXAoKTtcbiAgI3Bhc3N3b3JkQ2FwYWJpbGl0eSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2VIYW5kbGVyLCBsb2FkaW5nVGFzaywgbmV0d29ya1N0cmVhbSwgcGFyYW1zLCBmYWN0b3J5KSB7XG4gICAgdGhpcy5tZXNzYWdlSGFuZGxlciA9IG1lc3NhZ2VIYW5kbGVyO1xuICAgIHRoaXMubG9hZGluZ1Rhc2sgPSBsb2FkaW5nVGFzaztcbiAgICB0aGlzLmNvbW1vbk9ianMgPSBuZXcgUERGT2JqZWN0cygpO1xuICAgIHRoaXMuZm9udExvYWRlciA9IG5ldyBGb250TG9hZGVyKHtcbiAgICAgIG93bmVyRG9jdW1lbnQ6IHBhcmFtcy5vd25lckRvY3VtZW50LFxuICAgICAgc3R5bGVFbGVtZW50OiBwYXJhbXMuc3R5bGVFbGVtZW50XG4gICAgfSk7XG4gICAgdGhpcy5sb2FkaW5nUGFyYW1zID0gcGFyYW1zLmxvYWRpbmdQYXJhbXM7XG4gICAgdGhpcy5fcGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGZhY3RvcnkuY2FudmFzRmFjdG9yeTtcbiAgICB0aGlzLmZpbHRlckZhY3RvcnkgPSBmYWN0b3J5LmZpbHRlckZhY3Rvcnk7XG4gICAgdGhpcy5jTWFwUmVhZGVyRmFjdG9yeSA9IGZhY3RvcnkuY01hcFJlYWRlckZhY3Rvcnk7XG4gICAgdGhpcy5zdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IGZhY3Rvcnkuc3RhbmRhcmRGb250RGF0YUZhY3Rvcnk7XG4gICAgdGhpcy53YXNtRmFjdG9yeSA9IGZhY3Rvcnkud2FzbUZhY3Rvcnk7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5ID0gbnVsbDtcbiAgICB0aGlzLl9uZXR3b3JrU3RyZWFtID0gbmV0d29ya1N0cmVhbTtcbiAgICB0aGlzLl9mdWxsUmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9sYXN0UHJvZ3Jlc3MgPSBudWxsO1xuICAgIHRoaXMuZG93bmxvYWRJbmZvQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuc2V0dXBNZXNzYWdlSGFuZGxlcigpO1xuICB9XG4gICNjYWNoZVNpbXBsZU1ldGhvZChuYW1lLCBkYXRhID0gbnVsbCkge1xuICAgIGNvbnN0IGNhY2hlZFByb21pc2UgPSB0aGlzLiNtZXRob2RQcm9taXNlcy5nZXQobmFtZSk7XG4gICAgaWYgKGNhY2hlZFByb21pc2UpIHtcbiAgICAgIHJldHVybiBjYWNoZWRQcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UobmFtZSwgZGF0YSk7XG4gICAgdGhpcy4jbWV0aG9kUHJvbWlzZXMuc2V0KG5hbWUsIHByb21pc2UpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGdldCBhbm5vdGF0aW9uU3RvcmFnZSgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiYW5ub3RhdGlvblN0b3JhZ2VcIiwgbmV3IEFubm90YXRpb25TdG9yYWdlKCkpO1xuICB9XG4gIGdldFJlbmRlcmluZ0ludGVudChpbnRlbnQsIGFubm90YXRpb25Nb2RlID0gQW5ub3RhdGlvbk1vZGUuRU5BQkxFLCBwcmludEFubm90YXRpb25TdG9yYWdlID0gbnVsbCwgaXNFZGl0aW5nID0gZmFsc2UsIGlzT3BMaXN0ID0gZmFsc2UpIHtcbiAgICBsZXQgcmVuZGVyaW5nSW50ZW50ID0gUmVuZGVyaW5nSW50ZW50RmxhZy5ESVNQTEFZO1xuICAgIGxldCBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZSA9IFNlcmlhbGl6YWJsZUVtcHR5O1xuICAgIHN3aXRjaCAoaW50ZW50KSB7XG4gICAgICBjYXNlIFwiYW55XCI6XG4gICAgICAgIHJlbmRlcmluZ0ludGVudCA9IFJlbmRlcmluZ0ludGVudEZsYWcuQU5ZO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkaXNwbGF5XCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInByaW50XCI6XG4gICAgICAgIHJlbmRlcmluZ0ludGVudCA9IFJlbmRlcmluZ0ludGVudEZsYWcuUFJJTlQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgd2FybihgZ2V0UmVuZGVyaW5nSW50ZW50IC0gaW52YWxpZCBpbnRlbnQ6ICR7aW50ZW50fWApO1xuICAgIH1cbiAgICBjb25zdCBhbm5vdGF0aW9uU3RvcmFnZSA9IHJlbmRlcmluZ0ludGVudCAmIFJlbmRlcmluZ0ludGVudEZsYWcuUFJJTlQgJiYgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSBpbnN0YW5jZW9mIFByaW50QW5ub3RhdGlvblN0b3JhZ2UgPyBwcmludEFubm90YXRpb25TdG9yYWdlIDogdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBzd2l0Y2ggKGFubm90YXRpb25Nb2RlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25Nb2RlLkRJU0FCTEU6XG4gICAgICAgIHJlbmRlcmluZ0ludGVudCArPSBSZW5kZXJpbmdJbnRlbnRGbGFnLkFOTk9UQVRJT05TX0RJU0FCTEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uTW9kZS5FTkFCTEU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uTW9kZS5FTkFCTEVfRk9STVM6XG4gICAgICAgIHJlbmRlcmluZ0ludGVudCArPSBSZW5kZXJpbmdJbnRlbnRGbGFnLkFOTk9UQVRJT05TX0ZPUk1TO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbk1vZGUuRU5BQkxFX1NUT1JBR0U6XG4gICAgICAgIHJlbmRlcmluZ0ludGVudCArPSBSZW5kZXJpbmdJbnRlbnRGbGFnLkFOTk9UQVRJT05TX1NUT1JBR0U7XG4gICAgICAgIGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlID0gYW5ub3RhdGlvblN0b3JhZ2Uuc2VyaWFsaXphYmxlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHdhcm4oYGdldFJlbmRlcmluZ0ludGVudCAtIGludmFsaWQgYW5ub3RhdGlvbk1vZGU6ICR7YW5ub3RhdGlvbk1vZGV9YCk7XG4gICAgfVxuICAgIGlmIChpc0VkaXRpbmcpIHtcbiAgICAgIHJlbmRlcmluZ0ludGVudCArPSBSZW5kZXJpbmdJbnRlbnRGbGFnLklTX0VESVRJTkc7XG4gICAgfVxuICAgIGlmIChpc09wTGlzdCkge1xuICAgICAgcmVuZGVyaW5nSW50ZW50ICs9IFJlbmRlcmluZ0ludGVudEZsYWcuT1BMSVNUO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBpZHM6IG1vZGlmaWVkSWRzLFxuICAgICAgaGFzaDogbW9kaWZpZWRJZHNIYXNoXG4gICAgfSA9IGFubm90YXRpb25TdG9yYWdlLm1vZGlmaWVkSWRzO1xuICAgIGNvbnN0IGNhY2hlS2V5QnVmID0gW3JlbmRlcmluZ0ludGVudCwgYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGUuaGFzaCwgbW9kaWZpZWRJZHNIYXNoXTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVuZGVyaW5nSW50ZW50LFxuICAgICAgY2FjaGVLZXk6IGNhY2hlS2V5QnVmLmpvaW4oXCJfXCIpLFxuICAgICAgYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGUsXG4gICAgICBtb2RpZmllZElkc1xuICAgIH07XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95Q2FwYWJpbGl0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB9XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHk/LnJlamVjdChuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZCBkdXJpbmcgb25QYXNzd29yZCBjYWxsYmFja1wiKSk7XG4gICAgY29uc3Qgd2FpdE9uID0gW107XG4gICAgZm9yIChjb25zdCBwYWdlIG9mIHRoaXMuI3BhZ2VDYWNoZS52YWx1ZXMoKSkge1xuICAgICAgd2FpdE9uLnB1c2gocGFnZS5fZGVzdHJveSgpKTtcbiAgICB9XG4gICAgdGhpcy4jcGFnZUNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy4jcGFnZVByb21pc2VzLmNsZWFyKCk7XG4gICAgdGhpcy4jcGFnZVJlZkNhY2hlLmNsZWFyKCk7XG4gICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoXCJhbm5vdGF0aW9uU3RvcmFnZVwiKSkge1xuICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5yZXNldE1vZGlmaWVkKCk7XG4gICAgfVxuICAgIGNvbnN0IHRlcm1pbmF0ZWQgPSB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIlRlcm1pbmF0ZVwiLCBudWxsKTtcbiAgICB3YWl0T24ucHVzaCh0ZXJtaW5hdGVkKTtcbiAgICBQcm9taXNlLmFsbCh3YWl0T24pLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5jb21tb25PYmpzLmNsZWFyKCk7XG4gICAgICB0aGlzLmZvbnRMb2FkZXIuY2xlYXIoKTtcbiAgICAgIHRoaXMuI21ldGhvZFByb21pc2VzLmNsZWFyKCk7XG4gICAgICB0aGlzLmZpbHRlckZhY3RvcnkuZGVzdHJveSgpO1xuICAgICAgVGV4dExheWVyLmNsZWFudXAoKTtcbiAgICAgIHRoaXMuX25ldHdvcmtTdHJlYW0/LmNhbmNlbEFsbFJlcXVlc3RzKG5ldyBBYm9ydEV4Y2VwdGlvbihcIldvcmtlciB3YXMgdGVybWluYXRlZC5cIikpO1xuICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlcj8uZGVzdHJveSgpO1xuICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlciA9IG51bGw7XG4gICAgICB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9LCB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgcmV0dXJuIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBzZXR1cE1lc3NhZ2VIYW5kbGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLFxuICAgICAgbG9hZGluZ1Rhc2tcbiAgICB9ID0gdGhpcztcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkdldFJlYWRlclwiLCAoZGF0YSwgc2luaykgPT4ge1xuICAgICAgYXNzZXJ0KHRoaXMuX25ldHdvcmtTdHJlYW0sIFwiR2V0UmVhZGVyIC0gbm8gYElQREZTdHJlYW1gIGluc3RhbmNlIGF2YWlsYWJsZS5cIik7XG4gICAgICB0aGlzLl9mdWxsUmVhZGVyID0gdGhpcy5fbmV0d29ya1N0cmVhbS5nZXRGdWxsUmVhZGVyKCk7XG4gICAgICB0aGlzLl9mdWxsUmVhZGVyLm9uUHJvZ3Jlc3MgPSBldnQgPT4ge1xuICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3MgPSB7XG4gICAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgICAgIHRvdGFsOiBldnQudG90YWxcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBzaW5rLm9uUHVsbCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5fZnVsbFJlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAoe1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGRvbmVcbiAgICAgICAgfSkge1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBzaW5rLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzc2VydCh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyLCBcIkdldFJlYWRlciAtIGV4cGVjdGVkIGFuIEFycmF5QnVmZmVyLlwiKTtcbiAgICAgICAgICBzaW5rLmVucXVldWUobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCAxLCBbdmFsdWVdKTtcbiAgICAgICAgfSkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgICAgICBzaW5rLmVycm9yKHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHNpbmsub25DYW5jZWwgPSByZWFzb24gPT4ge1xuICAgICAgICB0aGlzLl9mdWxsUmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgICAgICBzaW5rLnJlYWR5LmNhdGNoKHJlYWR5UmVhc29uID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgcmVhZHlSZWFzb247XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIlJlYWRlckhlYWRlcnNSZWFkeVwiLCBhc3luYyBkYXRhID0+IHtcbiAgICAgIGF3YWl0IHRoaXMuX2Z1bGxSZWFkZXIuaGVhZGVyc1JlYWR5O1xuICAgICAgY29uc3Qge1xuICAgICAgICBpc1N0cmVhbWluZ1N1cHBvcnRlZCxcbiAgICAgICAgaXNSYW5nZVN1cHBvcnRlZCxcbiAgICAgICAgY29udGVudExlbmd0aFxuICAgICAgfSA9IHRoaXMuX2Z1bGxSZWFkZXI7XG4gICAgICBpZiAoIWlzU3RyZWFtaW5nU3VwcG9ydGVkIHx8ICFpc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYXN0UHJvZ3Jlc3MpIHtcbiAgICAgICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzPy4odGhpcy5fbGFzdFByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mdWxsUmVhZGVyLm9uUHJvZ3Jlc3MgPSBldnQgPT4ge1xuICAgICAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWQsXG4gICAgICAgICAgICB0b3RhbDogZXZ0LnRvdGFsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1N0cmVhbWluZ1N1cHBvcnRlZCxcbiAgICAgICAgaXNSYW5nZVN1cHBvcnRlZCxcbiAgICAgICAgY29udGVudExlbmd0aFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkdldFJhbmdlUmVhZGVyXCIsIChkYXRhLCBzaW5rKSA9PiB7XG4gICAgICBhc3NlcnQodGhpcy5fbmV0d29ya1N0cmVhbSwgXCJHZXRSYW5nZVJlYWRlciAtIG5vIGBJUERGU3RyZWFtYCBpbnN0YW5jZSBhdmFpbGFibGUuXCIpO1xuICAgICAgY29uc3QgcmFuZ2VSZWFkZXIgPSB0aGlzLl9uZXR3b3JrU3RyZWFtLmdldFJhbmdlUmVhZGVyKGRhdGEuYmVnaW4sIGRhdGEuZW5kKTtcbiAgICAgIGlmICghcmFuZ2VSZWFkZXIpIHtcbiAgICAgICAgc2luay5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzaW5rLm9uUHVsbCA9ICgpID0+IHtcbiAgICAgICAgcmFuZ2VSZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBkb25lXG4gICAgICAgIH0pIHtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgc2luay5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3NlcnQodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciwgXCJHZXRSYW5nZVJlYWRlciAtIGV4cGVjdGVkIGFuIEFycmF5QnVmZmVyLlwiKTtcbiAgICAgICAgICBzaW5rLmVucXVldWUobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCAxLCBbdmFsdWVdKTtcbiAgICAgICAgfSkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgICAgICBzaW5rLmVycm9yKHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHNpbmsub25DYW5jZWwgPSByZWFzb24gPT4ge1xuICAgICAgICByYW5nZVJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICAgICAgc2luay5yZWFkeS5jYXRjaChyZWFkeVJlYXNvbiA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IHJlYWR5UmVhc29uO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJHZXREb2NcIiwgKHtcbiAgICAgIHBkZkluZm9cbiAgICB9KSA9PiB7XG4gICAgICB0aGlzLl9udW1QYWdlcyA9IHBkZkluZm8ubnVtUGFnZXM7XG4gICAgICB0aGlzLl9odG1sRm9yWGZhID0gcGRmSW5mby5odG1sRm9yWGZhO1xuICAgICAgZGVsZXRlIHBkZkluZm8uaHRtbEZvclhmYTtcbiAgICAgIGxvYWRpbmdUYXNrLl9jYXBhYmlsaXR5LnJlc29sdmUobmV3IFBERkRvY3VtZW50UHJveHkocGRmSW5mbywgdGhpcykpO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRG9jRXhjZXB0aW9uXCIsIGV4ID0+IHtcbiAgICAgIGxvYWRpbmdUYXNrLl9jYXBhYmlsaXR5LnJlamVjdCh3cmFwUmVhc29uKGV4KSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJQYXNzd29yZFJlcXVlc3RcIiwgZXggPT4ge1xuICAgICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWxvYWRpbmdUYXNrLm9uUGFzc3dvcmQpIHtcbiAgICAgICAgICB0aHJvdyB3cmFwUmVhc29uKGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGRhdGVQYXNzd29yZCA9IHBhc3N3b3JkID0+IHtcbiAgICAgICAgICBpZiAocGFzc3dvcmQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5LnJlamVjdChwYXNzd29yZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgcGFzc3dvcmRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbG9hZGluZ1Rhc2sub25QYXNzd29yZCh1cGRhdGVQYXNzd29yZCwgZXguY29kZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5LnJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRGF0YUxvYWRlZFwiLCBkYXRhID0+IHtcbiAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZGF0YS5sZW5ndGgsXG4gICAgICAgIHRvdGFsOiBkYXRhLmxlbmd0aFxuICAgICAgfSk7XG4gICAgICB0aGlzLmRvd25sb2FkSW5mb0NhcGFiaWxpdHkucmVzb2x2ZShkYXRhKTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIlN0YXJ0UmVuZGVyUGFnZVwiLCBkYXRhID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwYWdlID0gdGhpcy4jcGFnZUNhY2hlLmdldChkYXRhLnBhZ2VJbmRleCk7XG4gICAgICBwYWdlLl9zdGFydFJlbmRlclBhZ2UoZGF0YS50cmFuc3BhcmVuY3ksIGRhdGEuY2FjaGVLZXkpO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiY29tbW9ub2JqXCIsIChbaWQsIHR5cGUsIGV4cG9ydGVkRGF0YV0pID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbW1vbk9ianMuaGFzKGlkKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiRm9udFwiOlxuICAgICAgICAgIGlmIChcImVycm9yXCIgaW4gZXhwb3J0ZWREYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBleHBvcnRlZEVycm9yID0gZXhwb3J0ZWREYXRhLmVycm9yO1xuICAgICAgICAgICAgd2FybihgRXJyb3IgZHVyaW5nIGZvbnQgbG9hZGluZzogJHtleHBvcnRlZEVycm9yfWApO1xuICAgICAgICAgICAgdGhpcy5jb21tb25PYmpzLnJlc29sdmUoaWQsIGV4cG9ydGVkRXJyb3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGluc3BlY3RGb250ID0gdGhpcy5fcGFyYW1zLnBkZkJ1ZyAmJiBnbG9iYWxUaGlzLkZvbnRJbnNwZWN0b3I/LmVuYWJsZWQgPyAoZm9udCwgdXJsKSA9PiBnbG9iYWxUaGlzLkZvbnRJbnNwZWN0b3IuZm9udEFkZGVkKGZvbnQsIHVybCkgOiBudWxsO1xuICAgICAgICAgIGNvbnN0IGZvbnQgPSBuZXcgRm9udEZhY2VPYmplY3QoZXhwb3J0ZWREYXRhLCBpbnNwZWN0Rm9udCk7XG4gICAgICAgICAgdGhpcy5mb250TG9hZGVyLmJpbmQoZm9udCkuY2F0Y2goKCkgPT4gbWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiRm9udEZhbGxiYWNrXCIsIHtcbiAgICAgICAgICAgIGlkXG4gICAgICAgICAgfSkpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFmb250LmZvbnRFeHRyYVByb3BlcnRpZXMgJiYgZm9udC5kYXRhKSB7XG4gICAgICAgICAgICAgIGZvbnQuZGF0YSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgZm9udCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJDb3B5TG9jYWxJbWFnZVwiOlxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGltYWdlUmVmXG4gICAgICAgICAgfSA9IGV4cG9ydGVkRGF0YTtcbiAgICAgICAgICBhc3NlcnQoaW1hZ2VSZWYsIFwiVGhlIGltYWdlUmVmIG11c3QgYmUgZGVmaW5lZC5cIik7XG4gICAgICAgICAgZm9yIChjb25zdCBwYWdlUHJveHkgb2YgdGhpcy4jcGFnZUNhY2hlLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFssIGRhdGFdIG9mIHBhZ2VQcm94eS5vYmpzKSB7XG4gICAgICAgICAgICAgIGlmIChkYXRhPy5yZWYgIT09IGltYWdlUmVmKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFkYXRhLmRhdGFMZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgc3RydWN0dXJlZENsb25lKGRhdGEpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuZGF0YUxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJGb250UGF0aFwiOlxuICAgICAgICBjYXNlIFwiSW1hZ2VcIjpcbiAgICAgICAgY2FzZSBcIlBhdHRlcm5cIjpcbiAgICAgICAgICB0aGlzLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgZXhwb3J0ZWREYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCB1bmtub3duIGNvbW1vbiBvYmplY3QgdHlwZSAke3R5cGV9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIm9ialwiLCAoW2lkLCBwYWdlSW5kZXgsIHR5cGUsIGltYWdlRGF0YV0pID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwYWdlUHJveHkgPSB0aGlzLiNwYWdlQ2FjaGUuZ2V0KHBhZ2VJbmRleCk7XG4gICAgICBpZiAocGFnZVByb3h5Lm9ianMuaGFzKGlkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocGFnZVByb3h5Ll9pbnRlbnRTdGF0ZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBpbWFnZURhdGE/LmJpdG1hcD8uY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJJbWFnZVwiOlxuICAgICAgICBjYXNlIFwiUGF0dGVyblwiOlxuICAgICAgICAgIHBhZ2VQcm94eS5vYmpzLnJlc29sdmUoaWQsIGltYWdlRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHb3QgdW5rbm93biBvYmplY3QgdHlwZSAke3R5cGV9YCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJEb2NQcm9ncmVzc1wiLCBkYXRhID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzPy4oe1xuICAgICAgICBsb2FkZWQ6IGRhdGEubG9hZGVkLFxuICAgICAgICB0b3RhbDogZGF0YS50b3RhbFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJGZXRjaEJpbmFyeURhdGFcIiwgYXN5bmMgZGF0YSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWQuXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZmFjdG9yeSA9IHRoaXNbZGF0YS50eXBlXTtcbiAgICAgIGlmICghZmFjdG9yeSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZGF0YS50eXBlfSBub3QgaW5pdGlhbGl6ZWQsIHNlZSB0aGUgXFxgdXNlV29ya2VyRmV0Y2hcXGAgcGFyYW1ldGVyLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhY3RvcnkuZmV0Y2goZGF0YSk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREYXRhXCIsIG51bGwpO1xuICB9XG4gIHNhdmVEb2N1bWVudCgpIHtcbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zaXplIDw9IDApIHtcbiAgICAgIHdhcm4oXCJzYXZlRG9jdW1lbnQgY2FsbGVkIHdoaWxlIGBhbm5vdGF0aW9uU3RvcmFnZWAgaXMgZW1wdHksIFwiICsgXCJwbGVhc2UgdXNlIHRoZSBnZXREYXRhLW1ldGhvZCBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbWFwLFxuICAgICAgdHJhbnNmZXJcbiAgICB9ID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXJpYWxpemFibGU7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiU2F2ZURvY3VtZW50XCIsIHtcbiAgICAgIGlzUHVyZVhmYTogISF0aGlzLl9odG1sRm9yWGZhLFxuICAgICAgbnVtUGFnZXM6IHRoaXMuX251bVBhZ2VzLFxuICAgICAgYW5ub3RhdGlvblN0b3JhZ2U6IG1hcCxcbiAgICAgIGZpbGVuYW1lOiB0aGlzLl9mdWxsUmVhZGVyPy5maWxlbmFtZSA/PyBudWxsXG4gICAgfSwgdHJhbnNmZXIpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5yZXNldE1vZGlmaWVkKCk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0UGFnZShwYWdlTnVtYmVyKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHBhZ2VOdW1iZXIpIHx8IHBhZ2VOdW1iZXIgPD0gMCB8fCBwYWdlTnVtYmVyID4gdGhpcy5fbnVtUGFnZXMpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIHBhZ2UgcmVxdWVzdC5cIikpO1xuICAgIH1cbiAgICBjb25zdCBwYWdlSW5kZXggPSBwYWdlTnVtYmVyIC0gMSxcbiAgICAgIGNhY2hlZFByb21pc2UgPSB0aGlzLiNwYWdlUHJvbWlzZXMuZ2V0KHBhZ2VJbmRleCk7XG4gICAgaWYgKGNhY2hlZFByb21pc2UpIHtcbiAgICAgIHJldHVybiBjYWNoZWRQcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlXCIsIHtcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0pLnRoZW4ocGFnZUluZm8gPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zcG9ydCBkZXN0cm95ZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAocGFnZUluZm8ucmVmU3RyKSB7XG4gICAgICAgIHRoaXMuI3BhZ2VSZWZDYWNoZS5zZXQocGFnZUluZm8ucmVmU3RyLCBwYWdlTnVtYmVyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhZ2UgPSBuZXcgUERGUGFnZVByb3h5KHBhZ2VJbmRleCwgcGFnZUluZm8sIHRoaXMsIHRoaXMuX3BhcmFtcy5wZGZCdWcpO1xuICAgICAgdGhpcy4jcGFnZUNhY2hlLnNldChwYWdlSW5kZXgsIHBhZ2UpO1xuICAgICAgcmV0dXJuIHBhZ2U7XG4gICAgfSk7XG4gICAgdGhpcy4jcGFnZVByb21pc2VzLnNldChwYWdlSW5kZXgsIHByb21pc2UpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGdldFBhZ2VJbmRleChyZWYpIHtcbiAgICBpZiAoIWlzUmVmUHJveHkocmVmKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgcGFnZUluZGV4IHJlcXVlc3QuXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUluZGV4XCIsIHtcbiAgICAgIG51bTogcmVmLm51bSxcbiAgICAgIGdlbjogcmVmLmdlblxuICAgIH0pO1xuICB9XG4gIGdldEFubm90YXRpb25zKHBhZ2VJbmRleCwgaW50ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0QW5ub3RhdGlvbnNcIiwge1xuICAgICAgcGFnZUluZGV4LFxuICAgICAgaW50ZW50XG4gICAgfSk7XG4gIH1cbiAgZ2V0RmllbGRPYmplY3RzKCkge1xuICAgIHJldHVybiB0aGlzLiNjYWNoZVNpbXBsZU1ldGhvZChcIkdldEZpZWxkT2JqZWN0c1wiKTtcbiAgfVxuICBoYXNKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlU2ltcGxlTWV0aG9kKFwiSGFzSlNBY3Rpb25zXCIpO1xuICB9XG4gIGdldENhbGN1bGF0aW9uT3JkZXJJZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0Q2FsY3VsYXRpb25PcmRlcklkc1wiLCBudWxsKTtcbiAgfVxuICBnZXREZXN0aW5hdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RGVzdGluYXRpb25zXCIsIG51bGwpO1xuICB9XG4gIGdldERlc3RpbmF0aW9uKGlkKSB7XG4gICAgaWYgKHR5cGVvZiBpZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgZGVzdGluYXRpb24gcmVxdWVzdC5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREZXN0aW5hdGlvblwiLCB7XG4gICAgICBpZFxuICAgIH0pO1xuICB9XG4gIGdldFBhZ2VMYWJlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUxhYmVsc1wiLCBudWxsKTtcbiAgfVxuICBnZXRQYWdlTGF5b3V0KCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VMYXlvdXRcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0UGFnZU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZU1vZGVcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0Vmlld2VyUHJlZmVyZW5jZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0Vmlld2VyUHJlZmVyZW5jZXNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0T3BlbkFjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRPcGVuQWN0aW9uXCIsIG51bGwpO1xuICB9XG4gIGdldEF0dGFjaG1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldEF0dGFjaG1lbnRzXCIsIG51bGwpO1xuICB9XG4gIGdldERvY0pTQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy4jY2FjaGVTaW1wbGVNZXRob2QoXCJHZXREb2NKU0FjdGlvbnNcIik7XG4gIH1cbiAgZ2V0UGFnZUpTQWN0aW9ucyhwYWdlSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlSlNBY3Rpb25zXCIsIHtcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0pO1xuICB9XG4gIGdldFN0cnVjdFRyZWUocGFnZUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0U3RydWN0VHJlZVwiLCB7XG4gICAgICBwYWdlSW5kZXhcbiAgICB9KTtcbiAgfVxuICBnZXRPdXRsaW5lKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldE91dGxpbmVcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKHJlbmRlcmluZ0ludGVudCkge1xuICAgIHJldHVybiB0aGlzLiNjYWNoZVNpbXBsZU1ldGhvZChcIkdldE9wdGlvbmFsQ29udGVudENvbmZpZ1wiKS50aGVuKGRhdGEgPT4gbmV3IE9wdGlvbmFsQ29udGVudENvbmZpZyhkYXRhLCByZW5kZXJpbmdJbnRlbnQpKTtcbiAgfVxuICBnZXRQZXJtaXNzaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQZXJtaXNzaW9uc1wiLCBudWxsKTtcbiAgfVxuICBnZXRNZXRhZGF0YSgpIHtcbiAgICBjb25zdCBuYW1lID0gXCJHZXRNZXRhZGF0YVwiLFxuICAgICAgY2FjaGVkUHJvbWlzZSA9IHRoaXMuI21ldGhvZFByb21pc2VzLmdldChuYW1lKTtcbiAgICBpZiAoY2FjaGVkUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIGNhY2hlZFByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShuYW1lLCBudWxsKS50aGVuKHJlc3VsdHMgPT4gKHtcbiAgICAgIGluZm86IHJlc3VsdHNbMF0sXG4gICAgICBtZXRhZGF0YTogcmVzdWx0c1sxXSA/IG5ldyBNZXRhZGF0YShyZXN1bHRzWzFdKSA6IG51bGwsXG4gICAgICBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZTogdGhpcy5fZnVsbFJlYWRlcj8uZmlsZW5hbWUgPz8gbnVsbCxcbiAgICAgIGNvbnRlbnRMZW5ndGg6IHRoaXMuX2Z1bGxSZWFkZXI/LmNvbnRlbnRMZW5ndGggPz8gbnVsbFxuICAgIH0pKTtcbiAgICB0aGlzLiNtZXRob2RQcm9taXNlcy5zZXQobmFtZSwgcHJvbWlzZSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgZ2V0TWFya0luZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0TWFya0luZm9cIiwgbnVsbCk7XG4gIH1cbiAgYXN5bmMgc3RhcnRDbGVhbnVwKGtlZXBMb2FkZWRGb250cyA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiQ2xlYW51cFwiLCBudWxsKTtcbiAgICBmb3IgKGNvbnN0IHBhZ2Ugb2YgdGhpcy4jcGFnZUNhY2hlLnZhbHVlcygpKSB7XG4gICAgICBjb25zdCBjbGVhbnVwU3VjY2Vzc2Z1bCA9IHBhZ2UuY2xlYW51cCgpO1xuICAgICAgaWYgKCFjbGVhbnVwU3VjY2Vzc2Z1bCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN0YXJ0Q2xlYW51cDogUGFnZSAke3BhZ2UucGFnZU51bWJlcn0gaXMgY3VycmVudGx5IHJlbmRlcmluZy5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb21tb25PYmpzLmNsZWFyKCk7XG4gICAgaWYgKCFrZWVwTG9hZGVkRm9udHMpIHtcbiAgICAgIHRoaXMuZm9udExvYWRlci5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLiNtZXRob2RQcm9taXNlcy5jbGVhcigpO1xuICAgIHRoaXMuZmlsdGVyRmFjdG9yeS5kZXN0cm95KHRydWUpO1xuICAgIFRleHRMYXllci5jbGVhbnVwKCk7XG4gIH1cbiAgY2FjaGVkUGFnZU51bWJlcihyZWYpIHtcbiAgICBpZiAoIWlzUmVmUHJveHkocmVmKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlZlN0ciA9IHJlZi5nZW4gPT09IDAgPyBgJHtyZWYubnVtfVJgIDogYCR7cmVmLm51bX1SJHtyZWYuZ2VufWA7XG4gICAgcmV0dXJuIHRoaXMuI3BhZ2VSZWZDYWNoZS5nZXQocmVmU3RyKSA/PyBudWxsO1xuICB9XG59XG5jb25zdCBJTklUSUFMX0RBVEEgPSBTeW1ib2woXCJJTklUSUFMX0RBVEFcIik7XG5jbGFzcyBQREZPYmplY3RzIHtcbiAgI29ianMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAjZW5zdXJlT2JqKG9iaklkKSB7XG4gICAgcmV0dXJuIHRoaXMuI29ianNbb2JqSWRdIHx8PSB7XG4gICAgICAuLi5Qcm9taXNlLndpdGhSZXNvbHZlcnMoKSxcbiAgICAgIGRhdGE6IElOSVRJQUxfREFUQVxuICAgIH07XG4gIH1cbiAgZ2V0KG9iaklkLCBjYWxsYmFjayA9IG51bGwpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IG9iaiA9IHRoaXMuI2Vuc3VyZU9iaihvYmpJZCk7XG4gICAgICBvYmoucHJvbWlzZS50aGVuKCgpID0+IGNhbGxiYWNrKG9iai5kYXRhKSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgb2JqID0gdGhpcy4jb2Jqc1tvYmpJZF07XG4gICAgaWYgKCFvYmogfHwgb2JqLmRhdGEgPT09IElOSVRJQUxfREFUQSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXF1ZXN0aW5nIG9iamVjdCB0aGF0IGlzbid0IHJlc29sdmVkIHlldCAke29iaklkfS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iai5kYXRhO1xuICB9XG4gIGhhcyhvYmpJZCkge1xuICAgIGNvbnN0IG9iaiA9IHRoaXMuI29ianNbb2JqSWRdO1xuICAgIHJldHVybiAhIW9iaiAmJiBvYmouZGF0YSAhPT0gSU5JVElBTF9EQVRBO1xuICB9XG4gIGRlbGV0ZShvYmpJZCkge1xuICAgIGNvbnN0IG9iaiA9IHRoaXMuI29ianNbb2JqSWRdO1xuICAgIGlmICghb2JqIHx8IG9iai5kYXRhID09PSBJTklUSUFMX0RBVEEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuI29ianNbb2JqSWRdO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJlc29sdmUob2JqSWQsIGRhdGEgPSBudWxsKSB7XG4gICAgY29uc3Qgb2JqID0gdGhpcy4jZW5zdXJlT2JqKG9iaklkKTtcbiAgICBvYmouZGF0YSA9IGRhdGE7XG4gICAgb2JqLnJlc29sdmUoKTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBmb3IgKGNvbnN0IG9iaklkIGluIHRoaXMuI29ianMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YVxuICAgICAgfSA9IHRoaXMuI29ianNbb2JqSWRdO1xuICAgICAgZGF0YT8uYml0bWFwPy5jbG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLiNvYmpzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgZm9yIChjb25zdCBvYmpJZCBpbiB0aGlzLiNvYmpzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGFcbiAgICAgIH0gPSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICAgIGlmIChkYXRhID09PSBJTklUSUFMX0RBVEEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB5aWVsZCBbb2JqSWQsIGRhdGFdO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgUmVuZGVyVGFzayB7XG4gICNpbnRlcm5hbFJlbmRlclRhc2sgPSBudWxsO1xuICBvbkNvbnRpbnVlID0gbnVsbDtcbiAgb25FcnJvciA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGludGVybmFsUmVuZGVyVGFzaykge1xuICAgIHRoaXMuI2ludGVybmFsUmVuZGVyVGFzayA9IGludGVybmFsUmVuZGVyVGFzaztcbiAgfVxuICBnZXQgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrLmNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwoZXh0cmFEZWxheSA9IDApIHtcbiAgICB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2suY2FuY2VsKG51bGwsIGV4dHJhRGVsYXkpO1xuICB9XG4gIGdldCBzZXBhcmF0ZUFubm90cygpIHtcbiAgICBjb25zdCB7XG4gICAgICBzZXBhcmF0ZUFubm90c1xuICAgIH0gPSB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2sub3BlcmF0b3JMaXN0O1xuICAgIGlmICghc2VwYXJhdGVBbm5vdHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYW5ub3RhdGlvbkNhbnZhc01hcFxuICAgIH0gPSB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2s7XG4gICAgcmV0dXJuIHNlcGFyYXRlQW5ub3RzLmZvcm0gfHwgc2VwYXJhdGVBbm5vdHMuY2FudmFzICYmIGFubm90YXRpb25DYW52YXNNYXA/LnNpemUgPiAwO1xuICB9XG59XG5jbGFzcyBJbnRlcm5hbFJlbmRlclRhc2sge1xuICAjckFGID0gbnVsbDtcbiAgc3RhdGljICNjYW52YXNJblVzZSA9IG5ldyBXZWFrU2V0KCk7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjYWxsYmFjayxcbiAgICBwYXJhbXMsXG4gICAgb2JqcyxcbiAgICBjb21tb25PYmpzLFxuICAgIGFubm90YXRpb25DYW52YXNNYXAsXG4gICAgb3BlcmF0b3JMaXN0LFxuICAgIHBhZ2VJbmRleCxcbiAgICBjYW52YXNGYWN0b3J5LFxuICAgIGZpbHRlckZhY3RvcnksXG4gICAgdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZmFsc2UsXG4gICAgcGRmQnVnID0gZmFsc2UsXG4gICAgcGFnZUNvbG9ycyA9IG51bGxcbiAgfSkge1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLm9ianMgPSBvYmpzO1xuICAgIHRoaXMuY29tbW9uT2JqcyA9IGNvbW1vbk9ianM7XG4gICAgdGhpcy5hbm5vdGF0aW9uQ2FudmFzTWFwID0gYW5ub3RhdGlvbkNhbnZhc01hcDtcbiAgICB0aGlzLm9wZXJhdG9yTGlzdElkeCA9IG51bGw7XG4gICAgdGhpcy5vcGVyYXRvckxpc3QgPSBvcGVyYXRvckxpc3Q7XG4gICAgdGhpcy5fcGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGNhbnZhc0ZhY3Rvcnk7XG4gICAgdGhpcy5maWx0ZXJGYWN0b3J5ID0gZmlsdGVyRmFjdG9yeTtcbiAgICB0aGlzLl9wZGZCdWcgPSBwZGZCdWc7XG4gICAgdGhpcy5wYWdlQ29sb3JzID0gcGFnZUNvbG9ycztcbiAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLmdyYXBoaWNzUmVhZHlDYWxsYmFjayA9IG51bGw7XG4gICAgdGhpcy5ncmFwaGljc1JlYWR5ID0gZmFsc2U7XG4gICAgdGhpcy5fdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSB0cnVlICYmIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLnRhc2sgPSBuZXcgUmVuZGVyVGFzayh0aGlzKTtcbiAgICB0aGlzLl9jYW5jZWxCb3VuZCA9IHRoaXMuY2FuY2VsLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fY29udGludWVCb3VuZCA9IHRoaXMuX2NvbnRpbnVlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fc2NoZWR1bGVOZXh0Qm91bmQgPSB0aGlzLl9zY2hlZHVsZU5leHQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9uZXh0Qm91bmQgPSB0aGlzLl9uZXh0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fY2FudmFzID0gcGFyYW1zLmNhbnZhc0NvbnRleHQuY2FudmFzO1xuICB9XG4gIGdldCBjb21wbGV0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FwYWJpbGl0eS5wcm9taXNlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgfVxuICBpbml0aWFsaXplR3JhcGhpY3Moe1xuICAgIHRyYW5zcGFyZW5jeSA9IGZhbHNlLFxuICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1xuICB9KSB7XG4gICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9jYW52YXMpIHtcbiAgICAgIGlmIChJbnRlcm5hbFJlbmRlclRhc2suI2NhbnZhc0luVXNlLmhhcyh0aGlzLl9jYW52YXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgdGhlIHNhbWUgY2FudmFzIGR1cmluZyBtdWx0aXBsZSByZW5kZXIoKSBvcGVyYXRpb25zLiBcIiArIFwiVXNlIGRpZmZlcmVudCBjYW52YXMgb3IgZW5zdXJlIHByZXZpb3VzIG9wZXJhdGlvbnMgd2VyZSBcIiArIFwiY2FuY2VsbGVkIG9yIGNvbXBsZXRlZC5cIik7XG4gICAgICB9XG4gICAgICBJbnRlcm5hbFJlbmRlclRhc2suI2NhbnZhc0luVXNlLmFkZCh0aGlzLl9jYW52YXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcGRmQnVnICYmIGdsb2JhbFRoaXMuU3RlcHBlck1hbmFnZXI/LmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuc3RlcHBlciA9IGdsb2JhbFRoaXMuU3RlcHBlck1hbmFnZXIuY3JlYXRlKHRoaXMuX3BhZ2VJbmRleCk7XG4gICAgICB0aGlzLnN0ZXBwZXIuaW5pdCh0aGlzLm9wZXJhdG9yTGlzdCk7XG4gICAgICB0aGlzLnN0ZXBwZXIubmV4dEJyZWFrUG9pbnQgPSB0aGlzLnN0ZXBwZXIuZ2V0TmV4dEJyZWFrUG9pbnQoKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY2FudmFzQ29udGV4dCxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgYmFja2dyb3VuZFxuICAgIH0gPSB0aGlzLnBhcmFtcztcbiAgICB0aGlzLmdmeCA9IG5ldyBDYW52YXNHcmFwaGljcyhjYW52YXNDb250ZXh0LCB0aGlzLmNvbW1vbk9ianMsIHRoaXMub2JqcywgdGhpcy5jYW52YXNGYWN0b3J5LCB0aGlzLmZpbHRlckZhY3RvcnksIHtcbiAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1xuICAgIH0sIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcCwgdGhpcy5wYWdlQ29sb3JzKTtcbiAgICB0aGlzLmdmeC5iZWdpbkRyYXdpbmcoe1xuICAgICAgdHJhbnNmb3JtLFxuICAgICAgdmlld3BvcnQsXG4gICAgICB0cmFuc3BhcmVuY3ksXG4gICAgICBiYWNrZ3JvdW5kXG4gICAgfSk7XG4gICAgdGhpcy5vcGVyYXRvckxpc3RJZHggPSAwO1xuICAgIHRoaXMuZ3JhcGhpY3NSZWFkeSA9IHRydWU7XG4gICAgdGhpcy5ncmFwaGljc1JlYWR5Q2FsbGJhY2s/LigpO1xuICB9XG4gIGNhbmNlbChlcnJvciA9IG51bGwsIGV4dHJhRGVsYXkgPSAwKSB7XG4gICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIHRoaXMuZ2Z4Py5lbmREcmF3aW5nKCk7XG4gICAgaWYgKHRoaXMuI3JBRikge1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuI3JBRik7XG4gICAgICB0aGlzLiNyQUYgPSBudWxsO1xuICAgIH1cbiAgICBJbnRlcm5hbFJlbmRlclRhc2suI2NhbnZhc0luVXNlLmRlbGV0ZSh0aGlzLl9jYW52YXMpO1xuICAgIGVycm9yIHx8PSBuZXcgUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uKGBSZW5kZXJpbmcgY2FuY2VsbGVkLCBwYWdlICR7dGhpcy5fcGFnZUluZGV4ICsgMX1gLCBleHRyYURlbGF5KTtcbiAgICB0aGlzLmNhbGxiYWNrKGVycm9yKTtcbiAgICB0aGlzLnRhc2sub25FcnJvcj8uKGVycm9yKTtcbiAgfVxuICBvcGVyYXRvckxpc3RDaGFuZ2VkKCkge1xuICAgIGlmICghdGhpcy5ncmFwaGljc1JlYWR5KSB7XG4gICAgICB0aGlzLmdyYXBoaWNzUmVhZHlDYWxsYmFjayB8fD0gdGhpcy5fY29udGludWVCb3VuZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGVwcGVyPy51cGRhdGVPcGVyYXRvckxpc3QodGhpcy5vcGVyYXRvckxpc3QpO1xuICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY29udGludWUoKTtcbiAgfVxuICBfY29udGludWUoKSB7XG4gICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMudGFzay5vbkNvbnRpbnVlKSB7XG4gICAgICB0aGlzLnRhc2sub25Db250aW51ZSh0aGlzLl9zY2hlZHVsZU5leHRCb3VuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NjaGVkdWxlTmV4dCgpO1xuICAgIH1cbiAgfVxuICBfc2NoZWR1bGVOZXh0KCkge1xuICAgIGlmICh0aGlzLl91c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHRoaXMuI3JBRiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB0aGlzLiNyQUYgPSBudWxsO1xuICAgICAgICB0aGlzLl9uZXh0Qm91bmQoKS5jYXRjaCh0aGlzLl9jYW5jZWxCb3VuZCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbih0aGlzLl9uZXh0Qm91bmQpLmNhdGNoKHRoaXMuX2NhbmNlbEJvdW5kKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgX25leHQoKSB7XG4gICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMub3BlcmF0b3JMaXN0SWR4ID0gdGhpcy5nZnguZXhlY3V0ZU9wZXJhdG9yTGlzdCh0aGlzLm9wZXJhdG9yTGlzdCwgdGhpcy5vcGVyYXRvckxpc3RJZHgsIHRoaXMuX2NvbnRpbnVlQm91bmQsIHRoaXMuc3RlcHBlcik7XG4gICAgaWYgKHRoaXMub3BlcmF0b3JMaXN0SWR4ID09PSB0aGlzLm9wZXJhdG9yTGlzdC5hcmdzQXJyYXkubGVuZ3RoKSB7XG4gICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLm9wZXJhdG9yTGlzdC5sYXN0Q2h1bmspIHtcbiAgICAgICAgdGhpcy5nZnguZW5kRHJhd2luZygpO1xuICAgICAgICBJbnRlcm5hbFJlbmRlclRhc2suI2NhbnZhc0luVXNlLmRlbGV0ZSh0aGlzLl9jYW52YXMpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jb25zdCB2ZXJzaW9uID0gXCI1LjIuMTMzXCI7XG5jb25zdCBidWlsZCA9IFwiNGY3NzYxMzUzXCI7XG5cbjsvLyAuL3NyYy9zaGFyZWQvc2NyaXB0aW5nX3V0aWxzLmpzXG5mdW5jdGlvbiBtYWtlQ29sb3JDb21wKG4pIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgbikpICogMjU1KS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpO1xufVxuZnVuY3Rpb24gc2NhbGVBbmRDbGFtcCh4KSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIDI1NSAqIHgpKTtcbn1cbmNsYXNzIENvbG9yQ29udmVydGVycyB7XG4gIHN0YXRpYyBDTVlLX0coW2MsIHksIG0sIGtdKSB7XG4gICAgcmV0dXJuIFtcIkdcIiwgMSAtIE1hdGgubWluKDEsIDAuMyAqIGMgKyAwLjU5ICogbSArIDAuMTEgKiB5ICsgayldO1xuICB9XG4gIHN0YXRpYyBHX0NNWUsoW2ddKSB7XG4gICAgcmV0dXJuIFtcIkNNWUtcIiwgMCwgMCwgMCwgMSAtIGddO1xuICB9XG4gIHN0YXRpYyBHX1JHQihbZ10pIHtcbiAgICByZXR1cm4gW1wiUkdCXCIsIGcsIGcsIGddO1xuICB9XG4gIHN0YXRpYyBHX3JnYihbZ10pIHtcbiAgICBnID0gc2NhbGVBbmRDbGFtcChnKTtcbiAgICByZXR1cm4gW2csIGcsIGddO1xuICB9XG4gIHN0YXRpYyBHX0hUTUwoW2ddKSB7XG4gICAgY29uc3QgRyA9IG1ha2VDb2xvckNvbXAoZyk7XG4gICAgcmV0dXJuIGAjJHtHfSR7R30ke0d9YDtcbiAgfVxuICBzdGF0aWMgUkdCX0coW3IsIGcsIGJdKSB7XG4gICAgcmV0dXJuIFtcIkdcIiwgMC4zICogciArIDAuNTkgKiBnICsgMC4xMSAqIGJdO1xuICB9XG4gIHN0YXRpYyBSR0JfcmdiKGNvbG9yKSB7XG4gICAgcmV0dXJuIGNvbG9yLm1hcChzY2FsZUFuZENsYW1wKTtcbiAgfVxuICBzdGF0aWMgUkdCX0hUTUwoY29sb3IpIHtcbiAgICByZXR1cm4gYCMke2NvbG9yLm1hcChtYWtlQ29sb3JDb21wKS5qb2luKFwiXCIpfWA7XG4gIH1cbiAgc3RhdGljIFRfSFRNTCgpIHtcbiAgICByZXR1cm4gXCIjMDAwMDAwMDBcIjtcbiAgfVxuICBzdGF0aWMgVF9yZ2IoKSB7XG4gICAgcmV0dXJuIFtudWxsXTtcbiAgfVxuICBzdGF0aWMgQ01ZS19SR0IoW2MsIHksIG0sIGtdKSB7XG4gICAgcmV0dXJuIFtcIlJHQlwiLCAxIC0gTWF0aC5taW4oMSwgYyArIGspLCAxIC0gTWF0aC5taW4oMSwgbSArIGspLCAxIC0gTWF0aC5taW4oMSwgeSArIGspXTtcbiAgfVxuICBzdGF0aWMgQ01ZS19yZ2IoW2MsIHksIG0sIGtdKSB7XG4gICAgcmV0dXJuIFtzY2FsZUFuZENsYW1wKDEgLSBNYXRoLm1pbigxLCBjICsgaykpLCBzY2FsZUFuZENsYW1wKDEgLSBNYXRoLm1pbigxLCBtICsgaykpLCBzY2FsZUFuZENsYW1wKDEgLSBNYXRoLm1pbigxLCB5ICsgaykpXTtcbiAgfVxuICBzdGF0aWMgQ01ZS19IVE1MKGNvbXBvbmVudHMpIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLkNNWUtfUkdCKGNvbXBvbmVudHMpLnNsaWNlKDEpO1xuICAgIHJldHVybiB0aGlzLlJHQl9IVE1MKHJnYik7XG4gIH1cbiAgc3RhdGljIFJHQl9DTVlLKFtyLCBnLCBiXSkge1xuICAgIGNvbnN0IGMgPSAxIC0gcjtcbiAgICBjb25zdCBtID0gMSAtIGc7XG4gICAgY29uc3QgeSA9IDEgLSBiO1xuICAgIGNvbnN0IGsgPSBNYXRoLm1pbihjLCBtLCB5KTtcbiAgICByZXR1cm4gW1wiQ01ZS1wiLCBjLCBtLCB5LCBrXTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9zdmdfZmFjdG9yeS5qc1xuXG5cbmNsYXNzIEJhc2VTVkdGYWN0b3J5IHtcbiAgY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHNraXBEaW1lbnNpb25zID0gZmFsc2UpIHtcbiAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBTVkcgZGltZW5zaW9uc1wiKTtcbiAgICB9XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5fY3JlYXRlU1ZHKFwic3ZnOnN2Z1wiKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwidmVyc2lvblwiLCBcIjEuMVwiKTtcbiAgICBpZiAoIXNraXBEaW1lbnNpb25zKSB7XG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgYCR7d2lkdGh9cHhgKTtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgYCR7aGVpZ2h0fXB4YCk7XG4gICAgfVxuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCIsIFwibm9uZVwiKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBgMCAwICR7d2lkdGh9ICR7aGVpZ2h0fWApO1xuICAgIHJldHVybiBzdmc7XG4gIH1cbiAgY3JlYXRlRWxlbWVudCh0eXBlKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFNWRyBlbGVtZW50IHR5cGVcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVTVkcodHlwZSk7XG4gIH1cbiAgX2NyZWF0ZVNWRyh0eXBlKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYF9jcmVhdGVTVkdgIGNhbGxlZC5cIik7XG4gIH1cbn1cbmNsYXNzIERPTVNWR0ZhY3RvcnkgZXh0ZW5kcyBCYXNlU1ZHRmFjdG9yeSB7XG4gIF9jcmVhdGVTVkcodHlwZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCB0eXBlKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS94ZmFfbGF5ZXIuanNcblxuY2xhc3MgWGZhTGF5ZXIge1xuICBzdGF0aWMgc2V0dXBTdG9yYWdlKGh0bWwsIGlkLCBlbGVtZW50LCBzdG9yYWdlLCBpbnRlbnQpIHtcbiAgICBjb25zdCBzdG9yZWREYXRhID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcbiAgICBzd2l0Y2ggKGVsZW1lbnQubmFtZSkge1xuICAgICAgY2FzZSBcInRleHRhcmVhXCI6XG4gICAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgaHRtbC50ZXh0Q29udGVudCA9IHN0b3JlZERhdGEudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVudCA9PT0gXCJwcmludFwiKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImlucHV0XCI6XG4gICAgICAgIGlmIChlbGVtZW50LmF0dHJpYnV0ZXMudHlwZSA9PT0gXCJyYWRpb1wiIHx8IGVsZW1lbnQuYXR0cmlidXRlcy50eXBlID09PSBcImNoZWNrYm94XCIpIHtcbiAgICAgICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZSA9PT0gZWxlbWVudC5hdHRyaWJ1dGVzLnhmYU9uKSB7XG4gICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdG9yZWREYXRhLnZhbHVlID09PSBlbGVtZW50LmF0dHJpYnV0ZXMueGZhT2ZmKSB7XG4gICAgICAgICAgICBodG1sLnJlbW92ZUF0dHJpYnV0ZShcImNoZWNrZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnRlbnQgPT09IFwicHJpbnRcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBldmVudCA9PiB7XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQuY2hlY2tlZCA/IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ4ZmFPblwiKSA6IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ4ZmFPZmZcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIHN0b3JlZERhdGEudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW50ZW50ID09PSBcInByaW50XCIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgc3RvcmVkRGF0YS52YWx1ZSk7XG4gICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgZWxlbWVudC5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbi5hdHRyaWJ1dGVzLnZhbHVlID09PSBzdG9yZWREYXRhLnZhbHVlKSB7XG4gICAgICAgICAgICAgIG9wdGlvbi5hdHRyaWJ1dGVzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9uLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoXCJzZWxlY3RlZFwiKSkge1xuICAgICAgICAgICAgICBkZWxldGUgb3B0aW9uLmF0dHJpYnV0ZXMuc2VsZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICBjb25zdCBvcHRpb25zID0gZXZlbnQudGFyZ2V0Lm9wdGlvbnM7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBvcHRpb25zLnNlbGVjdGVkSW5kZXggPT09IC0xID8gXCJcIiA6IG9wdGlvbnNbb3B0aW9ucy5zZWxlY3RlZEluZGV4XS52YWx1ZTtcbiAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBzZXRBdHRyaWJ1dGVzKHtcbiAgICBodG1sLFxuICAgIGVsZW1lbnQsXG4gICAgc3RvcmFnZSA9IG51bGwsXG4gICAgaW50ZW50LFxuICAgIGxpbmtTZXJ2aWNlXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBhdHRyaWJ1dGVzXG4gICAgfSA9IGVsZW1lbnQ7XG4gICAgY29uc3QgaXNIVE1MQW5jaG9yRWxlbWVudCA9IGh0bWwgaW5zdGFuY2VvZiBIVE1MQW5jaG9yRWxlbWVudDtcbiAgICBpZiAoYXR0cmlidXRlcy50eXBlID09PSBcInJhZGlvXCIpIHtcbiAgICAgIGF0dHJpYnV0ZXMubmFtZSA9IGAke2F0dHJpYnV0ZXMubmFtZX0tJHtpbnRlbnR9YDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZS5qb2luKFwiIFwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGF0YUlkXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpZFwiOlxuICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihodG1sLnN0eWxlLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0ZXh0Q29udGVudFwiOlxuICAgICAgICAgIGh0bWwudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWlzSFRNTEFuY2hvckVsZW1lbnQgfHwga2V5ICE9PSBcImhyZWZcIiAmJiBrZXkgIT09IFwibmV3V2luZG93XCIpIHtcbiAgICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzSFRNTEFuY2hvckVsZW1lbnQpIHtcbiAgICAgIGxpbmtTZXJ2aWNlLmFkZExpbmtBdHRyaWJ1dGVzKGh0bWwsIGF0dHJpYnV0ZXMuaHJlZiwgYXR0cmlidXRlcy5uZXdXaW5kb3cpO1xuICAgIH1cbiAgICBpZiAoc3RvcmFnZSAmJiBhdHRyaWJ1dGVzLmRhdGFJZCkge1xuICAgICAgdGhpcy5zZXR1cFN0b3JhZ2UoaHRtbCwgYXR0cmlidXRlcy5kYXRhSWQsIGVsZW1lbnQsIHN0b3JhZ2UpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgcmVuZGVyKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gcGFyYW1ldGVycy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBsaW5rU2VydmljZSA9IHBhcmFtZXRlcnMubGlua1NlcnZpY2U7XG4gICAgY29uc3Qgcm9vdCA9IHBhcmFtZXRlcnMueGZhSHRtbDtcbiAgICBjb25zdCBpbnRlbnQgPSBwYXJhbWV0ZXJzLmludGVudCB8fCBcImRpc3BsYXlcIjtcbiAgICBjb25zdCByb290SHRtbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocm9vdC5uYW1lKTtcbiAgICBpZiAocm9vdC5hdHRyaWJ1dGVzKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICBodG1sOiByb290SHRtbCxcbiAgICAgICAgZWxlbWVudDogcm9vdCxcbiAgICAgICAgaW50ZW50LFxuICAgICAgICBsaW5rU2VydmljZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGlzTm90Rm9yUmljaFRleHQgPSBpbnRlbnQgIT09IFwicmljaFRleHRcIjtcbiAgICBjb25zdCByb290RGl2ID0gcGFyYW1ldGVycy5kaXY7XG4gICAgcm9vdERpdi5hcHBlbmQocm9vdEh0bWwpO1xuICAgIGlmIChwYXJhbWV0ZXJzLnZpZXdwb3J0KSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBgbWF0cml4KCR7cGFyYW1ldGVycy52aWV3cG9ydC50cmFuc2Zvcm0uam9pbihcIixcIil9KWA7XG4gICAgICByb290RGl2LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICB9XG4gICAgaWYgKGlzTm90Rm9yUmljaFRleHQpIHtcbiAgICAgIHJvb3REaXYuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJ4ZmFMYXllciB4ZmFGb250XCIpO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0RGl2cyA9IFtdO1xuICAgIGlmIChyb290LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKHJvb3QudmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJvb3QudmFsdWUpO1xuICAgICAgICByb290SHRtbC5hcHBlbmQobm9kZSk7XG4gICAgICAgIGlmIChpc05vdEZvclJpY2hUZXh0ICYmIFhmYVRleHQuc2hvdWxkQnVpbGRUZXh0KHJvb3QubmFtZSkpIHtcbiAgICAgICAgICB0ZXh0RGl2cy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0RGl2c1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc3RhY2sgPSBbW3Jvb3QsIC0xLCByb290SHRtbF1dO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBbcGFyZW50LCBpLCBodG1sXSA9IHN0YWNrLmF0KC0xKTtcbiAgICAgIGlmIChpICsgMSA9PT0gcGFyZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZCA9IHBhcmVudC5jaGlsZHJlblsrK3N0YWNrLmF0KC0xKVsxXV07XG4gICAgICBpZiAoY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWVcbiAgICAgIH0gPSBjaGlsZDtcbiAgICAgIGlmIChuYW1lID09PSBcIiN0ZXh0XCIpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNoaWxkLnZhbHVlKTtcbiAgICAgICAgdGV4dERpdnMucHVzaChub2RlKTtcbiAgICAgICAgaHRtbC5hcHBlbmQobm9kZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hpbGRIdG1sID0gY2hpbGQ/LmF0dHJpYnV0ZXM/LnhtbG5zID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGNoaWxkLmF0dHJpYnV0ZXMueG1sbnMsIG5hbWUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcbiAgICAgIGh0bWwuYXBwZW5kKGNoaWxkSHRtbCk7XG4gICAgICBpZiAoY2hpbGQuYXR0cmlidXRlcykge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgIGh0bWw6IGNoaWxkSHRtbCxcbiAgICAgICAgICBlbGVtZW50OiBjaGlsZCxcbiAgICAgICAgICBzdG9yYWdlLFxuICAgICAgICAgIGludGVudCxcbiAgICAgICAgICBsaW5rU2VydmljZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5jaGlsZHJlbj8ubGVuZ3RoID4gMCkge1xuICAgICAgICBzdGFjay5wdXNoKFtjaGlsZCwgLTEsIGNoaWxkSHRtbF0pO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZC52YWx1ZSkge1xuICAgICAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY2hpbGQudmFsdWUpO1xuICAgICAgICBpZiAoaXNOb3RGb3JSaWNoVGV4dCAmJiBYZmFUZXh0LnNob3VsZEJ1aWxkVGV4dChuYW1lKSkge1xuICAgICAgICAgIHRleHREaXZzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRIdG1sLmFwcGVuZChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBlbCBvZiByb290RGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCIueGZhTm9uSW50ZXJhY3RpdmUgaW5wdXQsIC54ZmFOb25JbnRlcmFjdGl2ZSB0ZXh0YXJlYVwiKSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFwicmVhZE9ubHlcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0ZXh0RGl2c1xuICAgIH07XG4gIH1cbiAgc3RhdGljIHVwZGF0ZShwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gYG1hdHJpeCgke3BhcmFtZXRlcnMudmlld3BvcnQudHJhbnNmb3JtLmpvaW4oXCIsXCIpfSlgO1xuICAgIHBhcmFtZXRlcnMuZGl2LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBwYXJhbWV0ZXJzLmRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9hbm5vdGF0aW9uX2xheWVyLmpzXG5cblxuXG5cblxuXG5jb25zdCBERUZBVUxUX1RBQl9JTkRFWCA9IDEwMDA7XG5jb25zdCBhbm5vdGF0aW9uX2xheWVyX0RFRkFVTFRfRk9OVF9TSVpFID0gOTtcbmNvbnN0IEdldEVsZW1lbnRzQnlOYW1lU2V0ID0gbmV3IFdlYWtTZXQoKTtcbmNsYXNzIEFubm90YXRpb25FbGVtZW50RmFjdG9yeSB7XG4gIHN0YXRpYyBjcmVhdGUocGFyYW1ldGVycykge1xuICAgIGNvbnN0IHN1YnR5cGUgPSBwYXJhbWV0ZXJzLmRhdGEuYW5ub3RhdGlvblR5cGU7XG4gICAgc3dpdGNoIChzdWJ0eXBlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLkxJTks6XG4gICAgICAgIHJldHVybiBuZXcgTGlua0Fubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5URVhUOlxuICAgICAgICByZXR1cm4gbmV3IFRleHRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuV0lER0VUOlxuICAgICAgICBjb25zdCBmaWVsZFR5cGUgPSBwYXJhbWV0ZXJzLmRhdGEuZmllbGRUeXBlO1xuICAgICAgICBzd2l0Y2ggKGZpZWxkVHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJUeFwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgICAgY2FzZSBcIkJ0blwiOlxuICAgICAgICAgICAgaWYgKHBhcmFtZXRlcnMuZGF0YS5yYWRpb0J1dHRvbikge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFJhZGlvQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtZXRlcnMuZGF0YS5jaGVja0JveCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IENoZWNrYm94V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFB1c2hCdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICBjYXNlIFwiQ2hcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hvaWNlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgICAgY2FzZSBcIlNpZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmVXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5QT1BVUDpcbiAgICAgICAgcmV0dXJuIG5ldyBQb3B1cEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5GUkVFVEVYVDpcbiAgICAgICAgcmV0dXJuIG5ldyBGcmVlVGV4dEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5MSU5FOlxuICAgICAgICByZXR1cm4gbmV3IExpbmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuU1FVQVJFOlxuICAgICAgICByZXR1cm4gbmV3IFNxdWFyZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5DSVJDTEU6XG4gICAgICAgIHJldHVybiBuZXcgQ2lyY2xlQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlBPTFlMSU5FOlxuICAgICAgICByZXR1cm4gbmV3IFBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLkNBUkVUOlxuICAgICAgICByZXR1cm4gbmV3IENhcmV0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLklOSzpcbiAgICAgICAgcmV0dXJuIG5ldyBJbmtBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuUE9MWUdPTjpcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5Z29uQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLkhJR0hMSUdIVDpcbiAgICAgICAgcmV0dXJuIG5ldyBIaWdobGlnaHRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuVU5ERVJMSU5FOlxuICAgICAgICByZXR1cm4gbmV3IFVuZGVybGluZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5TUVVJR0dMWTpcbiAgICAgICAgcmV0dXJuIG5ldyBTcXVpZ2dseUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5TVFJJS0VPVVQ6XG4gICAgICAgIHJldHVybiBuZXcgU3RyaWtlT3V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlNUQU1QOlxuICAgICAgICByZXR1cm4gbmV3IFN0YW1wQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLkZJTEVBVFRBQ0hNRU5UOlxuICAgICAgICByZXR1cm4gbmV3IEZpbGVBdHRhY2htZW50QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbmV3IEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjdXBkYXRlcyA9IG51bGw7XG4gICNoYXNCb3JkZXIgPSBmYWxzZTtcbiAgI3BvcHVwRWxlbWVudCA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMsIHtcbiAgICBpc1JlbmRlcmFibGUgPSBmYWxzZSxcbiAgICBpZ25vcmVCb3JkZXIgPSBmYWxzZSxcbiAgICBjcmVhdGVRdWFkcmlsYXRlcmFscyA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIHRoaXMuaXNSZW5kZXJhYmxlID0gaXNSZW5kZXJhYmxlO1xuICAgIHRoaXMuZGF0YSA9IHBhcmFtZXRlcnMuZGF0YTtcbiAgICB0aGlzLmxheWVyID0gcGFyYW1ldGVycy5sYXllcjtcbiAgICB0aGlzLmxpbmtTZXJ2aWNlID0gcGFyYW1ldGVycy5saW5rU2VydmljZTtcbiAgICB0aGlzLmRvd25sb2FkTWFuYWdlciA9IHBhcmFtZXRlcnMuZG93bmxvYWRNYW5hZ2VyO1xuICAgIHRoaXMuaW1hZ2VSZXNvdXJjZXNQYXRoID0gcGFyYW1ldGVycy5pbWFnZVJlc291cmNlc1BhdGg7XG4gICAgdGhpcy5yZW5kZXJGb3JtcyA9IHBhcmFtZXRlcnMucmVuZGVyRm9ybXM7XG4gICAgdGhpcy5zdmdGYWN0b3J5ID0gcGFyYW1ldGVycy5zdmdGYWN0b3J5O1xuICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UgPSBwYXJhbWV0ZXJzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIHRoaXMuZW5hYmxlU2NyaXB0aW5nID0gcGFyYW1ldGVycy5lbmFibGVTY3JpcHRpbmc7XG4gICAgdGhpcy5oYXNKU0FjdGlvbnMgPSBwYXJhbWV0ZXJzLmhhc0pTQWN0aW9ucztcbiAgICB0aGlzLl9maWVsZE9iamVjdHMgPSBwYXJhbWV0ZXJzLmZpZWxkT2JqZWN0cztcbiAgICB0aGlzLnBhcmVudCA9IHBhcmFtZXRlcnMucGFyZW50O1xuICAgIGlmIChpc1JlbmRlcmFibGUpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5fY3JlYXRlQ29udGFpbmVyKGlnbm9yZUJvcmRlcik7XG4gICAgfVxuICAgIGlmIChjcmVhdGVRdWFkcmlsYXRlcmFscykge1xuICAgICAgdGhpcy5fY3JlYXRlUXVhZHJpbGF0ZXJhbHMoKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIF9oYXNQb3B1cERhdGEoe1xuICAgIHRpdGxlT2JqLFxuICAgIGNvbnRlbnRzT2JqLFxuICAgIHJpY2hUZXh0XG4gIH0pIHtcbiAgICByZXR1cm4gISEodGl0bGVPYmo/LnN0ciB8fCBjb250ZW50c09iaj8uc3RyIHx8IHJpY2hUZXh0Py5zdHIpO1xuICB9XG4gIGdldCBfaXNFZGl0YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmlzRWRpdGFibGU7XG4gIH1cbiAgZ2V0IGhhc1BvcHVwRGF0YSgpIHtcbiAgICByZXR1cm4gQW5ub3RhdGlvbkVsZW1lbnQuX2hhc1BvcHVwRGF0YSh0aGlzLmRhdGEpO1xuICB9XG4gIHVwZGF0ZUVkaXRlZChwYXJhbXMpIHtcbiAgICBpZiAoIXRoaXMuY29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3VwZGF0ZXMgfHw9IHtcbiAgICAgIHJlY3Q6IHRoaXMuZGF0YS5yZWN0LnNsaWNlKDApXG4gICAgfTtcbiAgICBjb25zdCB7XG4gICAgICByZWN0XG4gICAgfSA9IHBhcmFtcztcbiAgICBpZiAocmVjdCkge1xuICAgICAgdGhpcy4jc2V0UmVjdEVkaXRlZChyZWN0KTtcbiAgICB9XG4gICAgdGhpcy4jcG9wdXBFbGVtZW50Py5wb3B1cC51cGRhdGVFZGl0ZWQocGFyYW1zKTtcbiAgfVxuICByZXNldEVkaXRlZCgpIHtcbiAgICBpZiAoIXRoaXMuI3VwZGF0ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jc2V0UmVjdEVkaXRlZCh0aGlzLiN1cGRhdGVzLnJlY3QpO1xuICAgIHRoaXMuI3BvcHVwRWxlbWVudD8ucG9wdXAucmVzZXRFZGl0ZWQoKTtcbiAgICB0aGlzLiN1cGRhdGVzID0gbnVsbDtcbiAgfVxuICAjc2V0UmVjdEVkaXRlZChyZWN0KSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGFpbmVyOiB7XG4gICAgICAgIHN0eWxlXG4gICAgICB9LFxuICAgICAgZGF0YToge1xuICAgICAgICByZWN0OiBjdXJyZW50UmVjdCxcbiAgICAgICAgcm90YXRpb25cbiAgICAgIH0sXG4gICAgICBwYXJlbnQ6IHtcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICByYXdEaW1zOiB7XG4gICAgICAgICAgICBwYWdlV2lkdGgsXG4gICAgICAgICAgICBwYWdlSGVpZ2h0LFxuICAgICAgICAgICAgcGFnZVgsXG4gICAgICAgICAgICBwYWdlWVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGN1cnJlbnRSZWN0Py5zcGxpY2UoMCwgNCwgLi4ucmVjdCk7XG4gICAgc3R5bGUubGVmdCA9IGAkezEwMCAqIChyZWN0WzBdIC0gcGFnZVgpIC8gcGFnZVdpZHRofSVgO1xuICAgIHN0eWxlLnRvcCA9IGAkezEwMCAqIChwYWdlSGVpZ2h0IC0gcmVjdFszXSArIHBhZ2VZKSAvIHBhZ2VIZWlnaHR9JWA7XG4gICAgaWYgKHJvdGF0aW9uID09PSAwKSB7XG4gICAgICBzdHlsZS53aWR0aCA9IGAkezEwMCAqIChyZWN0WzJdIC0gcmVjdFswXSkgLyBwYWdlV2lkdGh9JWA7XG4gICAgICBzdHlsZS5oZWlnaHQgPSBgJHsxMDAgKiAocmVjdFszXSAtIHJlY3RbMV0pIC8gcGFnZUhlaWdodH0lYDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRSb3RhdGlvbihyb3RhdGlvbik7XG4gICAgfVxuICB9XG4gIF9jcmVhdGVDb250YWluZXIoaWdub3JlQm9yZGVyKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YSxcbiAgICAgIHBhcmVudDoge1xuICAgICAgICBwYWdlLFxuICAgICAgICB2aWV3cG9ydFxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIpO1xuICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJkYXRhLWFubm90YXRpb24taWRcIiwgZGF0YS5pZCk7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdpZGdldEFubm90YXRpb25FbGVtZW50KSkge1xuICAgICAgY29udGFpbmVyLnRhYkluZGV4ID0gREVGQVVMVF9UQUJfSU5ERVg7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IGNvbnRhaW5lcjtcbiAgICBzdHlsZS56SW5kZXggPSB0aGlzLnBhcmVudC56SW5kZXgrKztcbiAgICBpZiAoZGF0YS5hbHRlcm5hdGl2ZVRleHQpIHtcbiAgICAgIGNvbnRhaW5lci50aXRsZSA9IGRhdGEuYWx0ZXJuYXRpdmVUZXh0O1xuICAgIH1cbiAgICBpZiAoZGF0YS5ub1JvdGF0ZSkge1xuICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJub3JvdGF0ZVwiKTtcbiAgICB9XG4gICAgaWYgKCFkYXRhLnJlY3QgfHwgdGhpcyBpbnN0YW5jZW9mIFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcm90YXRpb25cbiAgICAgIH0gPSBkYXRhO1xuICAgICAgaWYgKCFkYXRhLmhhc093bkNhbnZhcyAmJiByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICB0aGlzLnNldFJvdGF0aW9uKHJvdGF0aW9uLCBjb250YWluZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWlnbm9yZUJvcmRlciAmJiBkYXRhLmJvcmRlclN0eWxlLndpZHRoID4gMCkge1xuICAgICAgc3R5bGUuYm9yZGVyV2lkdGggPSBgJHtkYXRhLmJvcmRlclN0eWxlLndpZHRofXB4YDtcbiAgICAgIGNvbnN0IGhvcml6b250YWxSYWRpdXMgPSBkYXRhLmJvcmRlclN0eWxlLmhvcml6b250YWxDb3JuZXJSYWRpdXM7XG4gICAgICBjb25zdCB2ZXJ0aWNhbFJhZGl1cyA9IGRhdGEuYm9yZGVyU3R5bGUudmVydGljYWxDb3JuZXJSYWRpdXM7XG4gICAgICBpZiAoaG9yaXpvbnRhbFJhZGl1cyA+IDAgfHwgdmVydGljYWxSYWRpdXMgPiAwKSB7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IGBjYWxjKCR7aG9yaXpvbnRhbFJhZGl1c31weCAqIHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikpIC8gY2FsYygke3ZlcnRpY2FsUmFkaXVzfXB4ICogdmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSlgO1xuICAgICAgICBzdHlsZS5ib3JkZXJSYWRpdXMgPSByYWRpdXM7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMgaW5zdGFuY2VvZiBSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IGBjYWxjKCR7d2lkdGh9cHggKiB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpKSAvIGNhbGMoJHtoZWlnaHR9cHggKiB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpKWA7XG4gICAgICAgIHN0eWxlLmJvcmRlclJhZGl1cyA9IHJhZGl1cztcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZGF0YS5ib3JkZXJTdHlsZS5zdHlsZSkge1xuICAgICAgICBjYXNlIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuU09MSUQ6XG4gICAgICAgICAgc3R5bGUuYm9yZGVyU3R5bGUgPSBcInNvbGlkXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5EQVNIRUQ6XG4gICAgICAgICAgc3R5bGUuYm9yZGVyU3R5bGUgPSBcImRhc2hlZFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuQkVWRUxFRDpcbiAgICAgICAgICB3YXJuKFwiVW5pbXBsZW1lbnRlZCBib3JkZXIgc3R5bGU6IGJldmVsZWRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5JTlNFVDpcbiAgICAgICAgICB3YXJuKFwiVW5pbXBsZW1lbnRlZCBib3JkZXIgc3R5bGU6IGluc2V0XCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuVU5ERVJMSU5FOlxuICAgICAgICAgIHN0eWxlLmJvcmRlckJvdHRvbVN0eWxlID0gXCJzb2xpZFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3QgYm9yZGVyQ29sb3IgPSBkYXRhLmJvcmRlckNvbG9yIHx8IG51bGw7XG4gICAgICBpZiAoYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgdGhpcy4jaGFzQm9yZGVyID0gdHJ1ZTtcbiAgICAgICAgc3R5bGUuYm9yZGVyQ29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvcihib3JkZXJDb2xvclswXSB8IDAsIGJvcmRlckNvbG9yWzFdIHwgMCwgYm9yZGVyQ29sb3JbMl0gfCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlLmJvcmRlcldpZHRoID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVjdCA9IFV0aWwubm9ybWFsaXplUmVjdChbZGF0YS5yZWN0WzBdLCBwYWdlLnZpZXdbM10gLSBkYXRhLnJlY3RbMV0gKyBwYWdlLnZpZXdbMV0sIGRhdGEucmVjdFsyXSwgcGFnZS52aWV3WzNdIC0gZGF0YS5yZWN0WzNdICsgcGFnZS52aWV3WzFdXSk7XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodCxcbiAgICAgIHBhZ2VYLFxuICAgICAgcGFnZVlcbiAgICB9ID0gdmlld3BvcnQucmF3RGltcztcbiAgICBzdHlsZS5sZWZ0ID0gYCR7MTAwICogKHJlY3RbMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGh9JWA7XG4gICAgc3R5bGUudG9wID0gYCR7MTAwICogKHJlY3RbMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0fSVgO1xuICAgIGNvbnN0IHtcbiAgICAgIHJvdGF0aW9uXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKGRhdGEuaGFzT3duQ2FudmFzIHx8IHJvdGF0aW9uID09PSAwKSB7XG4gICAgICBzdHlsZS53aWR0aCA9IGAkezEwMCAqIHdpZHRoIC8gcGFnZVdpZHRofSVgO1xuICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7MTAwICogaGVpZ2h0IC8gcGFnZUhlaWdodH0lYDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRSb3RhdGlvbihyb3RhdGlvbiwgY29udGFpbmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuICBzZXRSb3RhdGlvbihhbmdsZSwgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5yZWN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHRcbiAgICB9ID0gdGhpcy5wYXJlbnQudmlld3BvcnQucmF3RGltcztcbiAgICBsZXQge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoYW5nbGUgJSAxODAgIT09IDApIHtcbiAgICAgIFt3aWR0aCwgaGVpZ2h0XSA9IFtoZWlnaHQsIHdpZHRoXTtcbiAgICB9XG4gICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gYCR7MTAwICogd2lkdGggLyBwYWdlV2lkdGh9JWA7XG4gICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGAkezEwMCAqIGhlaWdodCAvIHBhZ2VIZWlnaHR9JWA7XG4gICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtbWFpbi1yb3RhdGlvblwiLCAoMzYwIC0gYW5nbGUpICUgMzYwKTtcbiAgfVxuICBnZXQgX2NvbW1vbkFjdGlvbnMoKSB7XG4gICAgY29uc3Qgc2V0Q29sb3IgPSAoanNOYW1lLCBzdHlsZU5hbWUsIGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBjb2xvciA9IGV2ZW50LmRldGFpbFtqc05hbWVdO1xuICAgICAgY29uc3QgY29sb3JUeXBlID0gY29sb3JbMF07XG4gICAgICBjb25zdCBjb2xvckFycmF5ID0gY29sb3Iuc2xpY2UoMSk7XG4gICAgICBldmVudC50YXJnZXQuc3R5bGVbc3R5bGVOYW1lXSA9IENvbG9yQ29udmVydGVyc1tgJHtjb2xvclR5cGV9X0hUTUxgXShjb2xvckFycmF5KTtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgIFtzdHlsZU5hbWVdOiBDb2xvckNvbnZlcnRlcnNbYCR7Y29sb3JUeXBlfV9yZ2JgXShjb2xvckFycmF5KVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2NvbW1vbkFjdGlvbnNcIiwge1xuICAgICAgZGlzcGxheTogZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZGlzcGxheVxuICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICBjb25zdCBoaWRkZW4gPSBkaXNwbGF5ICUgMiA9PT0gMTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9IGhpZGRlbiA/IFwiaGlkZGVuXCIgOiBcInZpc2libGVcIjtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXRWYWx1ZSh0aGlzLmRhdGEuaWQsIHtcbiAgICAgICAgICBub1ZpZXc6IGhpZGRlbixcbiAgICAgICAgICBub1ByaW50OiBkaXNwbGF5ID09PSAxIHx8IGRpc3BsYXkgPT09IDJcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgcHJpbnQ6IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXRWYWx1ZSh0aGlzLmRhdGEuaWQsIHtcbiAgICAgICAgICBub1ByaW50OiAhZXZlbnQuZGV0YWlsLnByaW50XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGhpZGRlbjogZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaGlkZGVuXG4gICAgICAgIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSBoaWRkZW4gPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCI7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgbm9QcmludDogaGlkZGVuLFxuICAgICAgICAgIG5vVmlldzogaGlkZGVuXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZvY3VzOiBldmVudCA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gZXZlbnQudGFyZ2V0LmZvY3VzKHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiBmYWxzZVxuICAgICAgICB9KSwgMCk7XG4gICAgICB9LFxuICAgICAgdXNlck5hbWU6IGV2ZW50ID0+IHtcbiAgICAgICAgZXZlbnQudGFyZ2V0LnRpdGxlID0gZXZlbnQuZGV0YWlsLnVzZXJOYW1lO1xuICAgICAgfSxcbiAgICAgIHJlYWRvbmx5OiBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LnRhcmdldC5kaXNhYmxlZCA9IGV2ZW50LmRldGFpbC5yZWFkb25seTtcbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLl9zZXRSZXF1aXJlZChldmVudC50YXJnZXQsIGV2ZW50LmRldGFpbC5yZXF1aXJlZCk7XG4gICAgICB9LFxuICAgICAgYmdDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImJnQ29sb3JcIiwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIGZpbGxDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImZpbGxDb2xvclwiLCBcImJhY2tncm91bmRDb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgZmdDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImZnQ29sb3JcIiwgXCJjb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgdGV4dENvbG9yOiBldmVudCA9PiB7XG4gICAgICAgIHNldENvbG9yKFwidGV4dENvbG9yXCIsIFwiY29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIGJvcmRlckNvbG9yOiBldmVudCA9PiB7XG4gICAgICAgIHNldENvbG9yKFwiYm9yZGVyQ29sb3JcIiwgXCJib3JkZXJDb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgc3Ryb2tlQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJzdHJva2VDb2xvclwiLCBcImJvcmRlckNvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICByb3RhdGlvbjogZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBhbmdsZSA9IGV2ZW50LmRldGFpbC5yb3RhdGlvbjtcbiAgICAgICAgdGhpcy5zZXRSb3RhdGlvbihhbmdsZSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgcm90YXRpb246IGFuZ2xlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCkge1xuICAgIGNvbnN0IGNvbW1vbkFjdGlvbnMgPSB0aGlzLl9jb21tb25BY3Rpb25zO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhqc0V2ZW50LmRldGFpbCkpIHtcbiAgICAgIGNvbnN0IGFjdGlvbiA9IGFjdGlvbnNbbmFtZV0gfHwgY29tbW9uQWN0aW9uc1tuYW1lXTtcbiAgICAgIGFjdGlvbj8uKGpzRXZlbnQpO1xuICAgIH1cbiAgfVxuICBfc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCkge1xuICAgIGlmICghdGhpcy5lbmFibGVTY3JpcHRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RvcmVkRGF0YSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UuZ2V0UmF3VmFsdWUodGhpcy5kYXRhLmlkKTtcbiAgICBpZiAoIXN0b3JlZERhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29tbW9uQWN0aW9ucyA9IHRoaXMuX2NvbW1vbkFjdGlvbnM7XG4gICAgZm9yIChjb25zdCBbYWN0aW9uTmFtZSwgZGV0YWlsXSBvZiBPYmplY3QuZW50cmllcyhzdG9yZWREYXRhKSkge1xuICAgICAgY29uc3QgYWN0aW9uID0gY29tbW9uQWN0aW9uc1thY3Rpb25OYW1lXTtcbiAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgZXZlbnRQcm94eSA9IHtcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIFthY3Rpb25OYW1lXTogZGV0YWlsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0YXJnZXQ6IGVsZW1lbnRcbiAgICAgICAgfTtcbiAgICAgICAgYWN0aW9uKGV2ZW50UHJveHkpO1xuICAgICAgICBkZWxldGUgc3RvcmVkRGF0YVthY3Rpb25OYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2NyZWF0ZVF1YWRyaWxhdGVyYWxzKCkge1xuICAgIGlmICghdGhpcy5jb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcXVhZFBvaW50c1xuICAgIH0gPSB0aGlzLmRhdGE7XG4gICAgaWYgKCFxdWFkUG9pbnRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtyZWN0QmxYLCByZWN0QmxZLCByZWN0VHJYLCByZWN0VHJZXSA9IHRoaXMuZGF0YS5yZWN0Lm1hcCh4ID0+IE1hdGguZnJvdW5kKHgpKTtcbiAgICBpZiAocXVhZFBvaW50cy5sZW5ndGggPT09IDgpIHtcbiAgICAgIGNvbnN0IFt0clgsIHRyWSwgYmxYLCBibFldID0gcXVhZFBvaW50cy5zdWJhcnJheSgyLCA2KTtcbiAgICAgIGlmIChyZWN0VHJYID09PSB0clggJiYgcmVjdFRyWSA9PT0gdHJZICYmIHJlY3RCbFggPT09IGJsWCAmJiByZWN0QmxZID09PSBibFkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLmNvbnRhaW5lcjtcbiAgICBsZXQgc3ZnQnVmZmVyO1xuICAgIGlmICh0aGlzLiNoYXNCb3JkZXIpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYm9yZGVyQ29sb3IsXG4gICAgICAgIGJvcmRlcldpZHRoXG4gICAgICB9ID0gc3R5bGU7XG4gICAgICBzdHlsZS5ib3JkZXJXaWR0aCA9IDA7XG4gICAgICBzdmdCdWZmZXIgPSBbXCJ1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LFwiLCBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJgLCBgIHByZXNlcnZlQXNwZWN0UmF0aW89XCJub25lXCIgdmlld0JveD1cIjAgMCAxIDFcIj5gLCBgPGcgZmlsbD1cInRyYW5zcGFyZW50XCIgc3Ryb2tlPVwiJHtib3JkZXJDb2xvcn1cIiBzdHJva2Utd2lkdGg9XCIke2JvcmRlcldpZHRofVwiPmBdO1xuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhhc0JvcmRlclwiKTtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGggPSByZWN0VHJYIC0gcmVjdEJsWDtcbiAgICBjb25zdCBoZWlnaHQgPSByZWN0VHJZIC0gcmVjdEJsWTtcbiAgICBjb25zdCB7XG4gICAgICBzdmdGYWN0b3J5XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3ZnID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnXCIpO1xuICAgIHN2Zy5jbGFzc0xpc3QuYWRkKFwicXVhZHJpbGF0ZXJhbHNDb250YWluZXJcIik7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIDApO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgMCk7XG4gICAgY29uc3QgZGVmcyA9IHN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcImRlZnNcIik7XG4gICAgc3ZnLmFwcGVuZChkZWZzKTtcbiAgICBjb25zdCBjbGlwUGF0aCA9IHN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcImNsaXBQYXRoXCIpO1xuICAgIGNvbnN0IGlkID0gYGNsaXBwYXRoXyR7dGhpcy5kYXRhLmlkfWA7XG4gICAgY2xpcFBhdGguc2V0QXR0cmlidXRlKFwiaWRcIiwgaWQpO1xuICAgIGNsaXBQYXRoLnNldEF0dHJpYnV0ZShcImNsaXBQYXRoVW5pdHNcIiwgXCJvYmplY3RCb3VuZGluZ0JveFwiKTtcbiAgICBkZWZzLmFwcGVuZChjbGlwUGF0aCk7XG4gICAgZm9yIChsZXQgaSA9IDIsIGlpID0gcXVhZFBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSA4KSB7XG4gICAgICBjb25zdCB0clggPSBxdWFkUG9pbnRzW2ldO1xuICAgICAgY29uc3QgdHJZID0gcXVhZFBvaW50c1tpICsgMV07XG4gICAgICBjb25zdCBibFggPSBxdWFkUG9pbnRzW2kgKyAyXTtcbiAgICAgIGNvbnN0IGJsWSA9IHF1YWRQb2ludHNbaSArIDNdO1xuICAgICAgY29uc3QgcmVjdCA9IHN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInJlY3RcIik7XG4gICAgICBjb25zdCB4ID0gKGJsWCAtIHJlY3RCbFgpIC8gd2lkdGg7XG4gICAgICBjb25zdCB5ID0gKHJlY3RUclkgLSB0clkpIC8gaGVpZ2h0O1xuICAgICAgY29uc3QgcmVjdFdpZHRoID0gKHRyWCAtIGJsWCkgLyB3aWR0aDtcbiAgICAgIGNvbnN0IHJlY3RIZWlnaHQgPSAodHJZIC0gYmxZKSAvIGhlaWdodDtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwieFwiLCB4KTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwieVwiLCB5KTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgcmVjdFdpZHRoKTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIHJlY3RIZWlnaHQpO1xuICAgICAgY2xpcFBhdGguYXBwZW5kKHJlY3QpO1xuICAgICAgc3ZnQnVmZmVyPy5wdXNoKGA8cmVjdCB2ZWN0b3ItZWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCIgeD1cIiR7eH1cIiB5PVwiJHt5fVwiIHdpZHRoPVwiJHtyZWN0V2lkdGh9XCIgaGVpZ2h0PVwiJHtyZWN0SGVpZ2h0fVwiLz5gKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2hhc0JvcmRlcikge1xuICAgICAgc3ZnQnVmZmVyLnB1c2goYDwvZz48L3N2Zz4nKWApO1xuICAgICAgc3R5bGUuYmFja2dyb3VuZEltYWdlID0gc3ZnQnVmZmVyLmpvaW4oXCJcIik7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmNsaXBQYXRoID0gYHVybCgjJHtpZH0pYDtcbiAgfVxuICBfY3JlYXRlUG9wdXAoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHBvcHVwID0gdGhpcy4jcG9wdXBFbGVtZW50ID0gbmV3IFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQoe1xuICAgICAgZGF0YToge1xuICAgICAgICBjb2xvcjogZGF0YS5jb2xvcixcbiAgICAgICAgdGl0bGVPYmo6IGRhdGEudGl0bGVPYmosXG4gICAgICAgIG1vZGlmaWNhdGlvbkRhdGU6IGRhdGEubW9kaWZpY2F0aW9uRGF0ZSxcbiAgICAgICAgY29udGVudHNPYmo6IGRhdGEuY29udGVudHNPYmosXG4gICAgICAgIHJpY2hUZXh0OiBkYXRhLnJpY2hUZXh0LFxuICAgICAgICBwYXJlbnRSZWN0OiBkYXRhLnJlY3QsXG4gICAgICAgIGJvcmRlclN0eWxlOiAwLFxuICAgICAgICBpZDogYHBvcHVwXyR7ZGF0YS5pZH1gLFxuICAgICAgICByb3RhdGlvbjogZGF0YS5yb3RhdGlvblxuICAgICAgfSxcbiAgICAgIHBhcmVudDogdGhpcy5wYXJlbnQsXG4gICAgICBlbGVtZW50czogW3RoaXNdXG4gICAgfSk7XG4gICAgdGhpcy5wYXJlbnQuZGl2LmFwcGVuZChwb3B1cC5yZW5kZXIoKSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBBbm5vdGF0aW9uRWxlbWVudC5yZW5kZXJgIGNhbGxlZFwiKTtcbiAgfVxuICBfZ2V0RWxlbWVudHNCeU5hbWUobmFtZSwgc2tpcElkID0gbnVsbCkge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtdO1xuICAgIGlmICh0aGlzLl9maWVsZE9iamVjdHMpIHtcbiAgICAgIGNvbnN0IGZpZWxkT2JqID0gdGhpcy5fZmllbGRPYmplY3RzW25hbWVdO1xuICAgICAgaWYgKGZpZWxkT2JqKSB7XG4gICAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICAgIHBhZ2UsXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgZXhwb3J0VmFsdWVzXG4gICAgICAgIH0gb2YgZmllbGRPYmopIHtcbiAgICAgICAgICBpZiAocGFnZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaWQgPT09IHNraXBJZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGV4cG9ydFZhbHVlID0gdHlwZW9mIGV4cG9ydFZhbHVlcyA9PT0gXCJzdHJpbmdcIiA/IGV4cG9ydFZhbHVlcyA6IG51bGw7XG4gICAgICAgICAgY29uc3QgZG9tRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWVsZW1lbnQtaWQ9XCIke2lkfVwiXWApO1xuICAgICAgICAgIGlmIChkb21FbGVtZW50ICYmICFHZXRFbGVtZW50c0J5TmFtZVNldC5oYXMoZG9tRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHdhcm4oYF9nZXRFbGVtZW50c0J5TmFtZSAtIGVsZW1lbnQgbm90IGFsbG93ZWQ6ICR7aWR9YCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmllbGRzLnB1c2goe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBleHBvcnRWYWx1ZSxcbiAgICAgICAgICAgIGRvbUVsZW1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZpZWxkcztcbiAgICB9XG4gICAgZm9yIChjb25zdCBkb21FbGVtZW50IG9mIGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKG5hbWUpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGV4cG9ydFZhbHVlXG4gICAgICB9ID0gZG9tRWxlbWVudDtcbiAgICAgIGNvbnN0IGlkID0gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIik7XG4gICAgICBpZiAoaWQgPT09IHNraXBJZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghR2V0RWxlbWVudHNCeU5hbWVTZXQuaGFzKGRvbUVsZW1lbnQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZmllbGRzLnB1c2goe1xuICAgICAgICBpZCxcbiAgICAgICAgZXhwb3J0VmFsdWUsXG4gICAgICAgIGRvbUVsZW1lbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGRzO1xuICB9XG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5oaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5wb3B1cD8ubWF5YmVTaG93KCk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmhpZGRlbiA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMucG9wdXA/LmZvcmNlSGlkZSgpO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgY29uc3QgdHJpZ2dlcnMgPSB0aGlzLmdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmlnZ2VycykpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0cmlnZ2Vycykge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cmlnZ2Vycy5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgICB9XG4gIH1cbiAgX2VkaXRPbkRvdWJsZUNsaWNrKCkge1xuICAgIGlmICghdGhpcy5faXNFZGl0YWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhbm5vdGF0aW9uRWRpdG9yVHlwZTogbW9kZSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgaWQ6IGVkaXRJZFxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJkYmxjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcInN3aXRjaGFubm90YXRpb25lZGl0b3Jtb2RlXCIsIHtcbiAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICBtb2RlLFxuICAgICAgICBlZGl0SWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnJlY3RbMl0gLSB0aGlzLmRhdGEucmVjdFswXTtcbiAgfVxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEucmVjdFszXSAtIHRoaXMuZGF0YS5yZWN0WzFdO1xuICB9XG59XG5jbGFzcyBMaW5rQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMsIG9wdGlvbnMgPSBudWxsKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiAhIW9wdGlvbnM/Lmlnbm9yZUJvcmRlcixcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5pc1Rvb2x0aXBPbmx5ID0gcGFyYW1ldGVycy5kYXRhLmlzVG9vbHRpcE9ubHk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBsaW5rU2VydmljZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICBsaW5rLnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBkYXRhLmlkKTtcbiAgICBsZXQgaXNCb3VuZCA9IGZhbHNlO1xuICAgIGlmIChkYXRhLnVybCkge1xuICAgICAgbGlua1NlcnZpY2UuYWRkTGlua0F0dHJpYnV0ZXMobGluaywgZGF0YS51cmwsIGRhdGEubmV3V2luZG93KTtcbiAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5hY3Rpb24pIHtcbiAgICAgIHRoaXMuX2JpbmROYW1lZEFjdGlvbihsaW5rLCBkYXRhLmFjdGlvbik7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuYXR0YWNobWVudCkge1xuICAgICAgdGhpcy4jYmluZEF0dGFjaG1lbnQobGluaywgZGF0YS5hdHRhY2htZW50LCBkYXRhLmF0dGFjaG1lbnREZXN0KTtcbiAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5zZXRPQ0dTdGF0ZSkge1xuICAgICAgdGhpcy4jYmluZFNldE9DR1N0YXRlKGxpbmssIGRhdGEuc2V0T0NHU3RhdGUpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChkYXRhLmRlc3QpIHtcbiAgICAgIHRoaXMuX2JpbmRMaW5rKGxpbmssIGRhdGEuZGVzdCk7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRhdGEuYWN0aW9ucyAmJiAoZGF0YS5hY3Rpb25zLkFjdGlvbiB8fCBkYXRhLmFjdGlvbnNbXCJNb3VzZSBVcFwiXSB8fCBkYXRhLmFjdGlvbnNbXCJNb3VzZSBEb3duXCJdKSAmJiB0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgICB0aGlzLl9iaW5kSlNBY3Rpb24obGluaywgZGF0YSk7XG4gICAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEucmVzZXRGb3JtKSB7XG4gICAgICAgIHRoaXMuX2JpbmRSZXNldEZvcm1BY3Rpb24obGluaywgZGF0YS5yZXNldEZvcm0pO1xuICAgICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1Rvb2x0aXBPbmx5ICYmICFpc0JvdW5kKSB7XG4gICAgICAgIHRoaXMuX2JpbmRMaW5rKGxpbmssIFwiXCIpO1xuICAgICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImxpbmtBbm5vdGF0aW9uXCIpO1xuICAgIGlmIChpc0JvdW5kKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQobGluayk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICAjc2V0SW50ZXJuYWxMaW5rKCkge1xuICAgIHRoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtaW50ZXJuYWwtbGlua1wiLCBcIlwiKTtcbiAgfVxuICBfYmluZExpbmsobGluaywgZGVzdGluYXRpb24pIHtcbiAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldERlc3RpbmF0aW9uSGFzaChkZXN0aW5hdGlvbik7XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgaWYgKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZ29Ub0Rlc3RpbmF0aW9uKGRlc3RpbmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGlmIChkZXN0aW5hdGlvbiB8fCBkZXN0aW5hdGlvbiA9PT0gXCJcIikge1xuICAgICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gICAgfVxuICB9XG4gIF9iaW5kTmFtZWRBY3Rpb24obGluaywgYWN0aW9uKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5saW5rU2VydmljZS5leGVjdXRlTmFtZWRBY3Rpb24oYWN0aW9uKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICB9XG4gICNiaW5kQXR0YWNobWVudChsaW5rLCBhdHRhY2htZW50LCBkZXN0ID0gbnVsbCkge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIGlmIChhdHRhY2htZW50LmRlc2NyaXB0aW9uKSB7XG4gICAgICBsaW5rLnRpdGxlID0gYXR0YWNobWVudC5kZXNjcmlwdGlvbjtcbiAgICB9XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5kb3dubG9hZE1hbmFnZXI/Lm9wZW5PckRvd25sb2FkRGF0YShhdHRhY2htZW50LmNvbnRlbnQsIGF0dGFjaG1lbnQuZmlsZW5hbWUsIGRlc3QpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gIH1cbiAgI2JpbmRTZXRPQ0dTdGF0ZShsaW5rLCBhY3Rpb24pIHtcbiAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldEFuY2hvclVybChcIlwiKTtcbiAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV4ZWN1dGVTZXRPQ0dTdGF0ZShhY3Rpb24pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gIH1cbiAgX2JpbmRKU0FjdGlvbihsaW5rLCBkYXRhKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgY29uc3QgbWFwID0gbmV3IE1hcChbW1wiQWN0aW9uXCIsIFwib25jbGlja1wiXSwgW1wiTW91c2UgVXBcIiwgXCJvbm1vdXNldXBcIl0sIFtcIk1vdXNlIERvd25cIiwgXCJvbm1vdXNlZG93blwiXV0pO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhkYXRhLmFjdGlvbnMpKSB7XG4gICAgICBjb25zdCBqc05hbWUgPSBtYXAuZ2V0KG5hbWUpO1xuICAgICAgaWYgKCFqc05hbWUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsaW5rW2pzTmFtZV0gPSAoKSA9PiB7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQ6IGRhdGEuaWQsXG4gICAgICAgICAgICBuYW1lXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFsaW5rLm9uY2xpY2spIHtcbiAgICAgIGxpbmsub25jbGljayA9ICgpID0+IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLiNzZXRJbnRlcm5hbExpbmsoKTtcbiAgfVxuICBfYmluZFJlc2V0Rm9ybUFjdGlvbihsaW5rLCByZXNldEZvcm0pIHtcbiAgICBjb25zdCBvdGhlckNsaWNrQWN0aW9uID0gbGluay5vbmNsaWNrO1xuICAgIGlmICghb3RoZXJDbGlja0FjdGlvbikge1xuICAgICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgfVxuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICAgIGlmICghdGhpcy5fZmllbGRPYmplY3RzKSB7XG4gICAgICB3YXJuKGBfYmluZFJlc2V0Rm9ybUFjdGlvbiAtIFwicmVzZXRGb3JtXCIgYWN0aW9uIG5vdCBzdXBwb3J0ZWQsIGAgKyBcImVuc3VyZSB0aGF0IHRoZSBgZmllbGRPYmplY3RzYCBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQuXCIpO1xuICAgICAgaWYgKCFvdGhlckNsaWNrQWN0aW9uKSB7XG4gICAgICAgIGxpbmsub25jbGljayA9ICgpID0+IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICBvdGhlckNsaWNrQWN0aW9uPy4oKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmllbGRzOiByZXNldEZvcm1GaWVsZHMsXG4gICAgICAgIHJlZnM6IHJlc2V0Rm9ybVJlZnMsXG4gICAgICAgIGluY2x1ZGVcbiAgICAgIH0gPSByZXNldEZvcm07XG4gICAgICBjb25zdCBhbGxGaWVsZHMgPSBbXTtcbiAgICAgIGlmIChyZXNldEZvcm1GaWVsZHMubGVuZ3RoICE9PSAwIHx8IHJlc2V0Rm9ybVJlZnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkSWRzID0gbmV3IFNldChyZXNldEZvcm1SZWZzKTtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgb2YgcmVzZXRGb3JtRmllbGRzKSB7XG4gICAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy5fZmllbGRPYmplY3RzW2ZpZWxkTmFtZV0gfHwgW107XG4gICAgICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgICAgICBpZFxuICAgICAgICAgIH0gb2YgZmllbGRzKSB7XG4gICAgICAgICAgICBmaWVsZElkcy5hZGQoaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkcyBvZiBPYmplY3QudmFsdWVzKHRoaXMuX2ZpZWxkT2JqZWN0cykpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICAgICAgaWYgKGZpZWxkSWRzLmhhcyhmaWVsZC5pZCkgPT09IGluY2x1ZGUpIHtcbiAgICAgICAgICAgICAgYWxsRmllbGRzLnB1c2goZmllbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZHMgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLl9maWVsZE9iamVjdHMpKSB7XG4gICAgICAgICAgYWxsRmllbGRzLnB1c2goLi4uZmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgICBjb25zdCBhbGxJZHMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgYWxsRmllbGRzKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gZmllbGQ7XG4gICAgICAgIGFsbElkcy5wdXNoKGlkKTtcbiAgICAgICAgc3dpdGNoIChmaWVsZC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5kZWZhdWx0VmFsdWUgfHwgXCJcIjtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiY2hlY2tib3hcIjpcbiAgICAgICAgICBjYXNlIFwicmFkaW9idXR0b25cIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5kZWZhdWx0VmFsdWUgPT09IGZpZWxkLmV4cG9ydFZhbHVlcztcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiY29tYm9ib3hcIjpcbiAgICAgICAgICBjYXNlIFwibGlzdGJveFwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGZpZWxkLmRlZmF1bHRWYWx1ZSB8fCBcIlwiO1xuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb21FbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtZWxlbWVudC1pZD1cIiR7aWR9XCJdYCk7XG4gICAgICAgIGlmICghZG9tRWxlbWVudCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCFHZXRFbGVtZW50c0J5TmFtZVNldC5oYXMoZG9tRWxlbWVudCkpIHtcbiAgICAgICAgICB3YXJuKGBfYmluZFJlc2V0Rm9ybUFjdGlvbiAtIGVsZW1lbnQgbm90IGFsbG93ZWQ6ICR7aWR9YCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZG9tRWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInJlc2V0Zm9ybVwiKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcpIHtcbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZDogXCJhcHBcIixcbiAgICAgICAgICAgIGlkczogYWxsSWRzLFxuICAgICAgICAgICAgbmFtZTogXCJSZXNldEZvcm1cIlxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgfVxufVxuY2xhc3MgVGV4dEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ0ZXh0QW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgaW1hZ2Uuc3JjID0gdGhpcy5pbWFnZVJlc291cmNlc1BhdGggKyBcImFubm90YXRpb24tXCIgKyB0aGlzLmRhdGEubmFtZS50b0xvd2VyQ2FzZSgpICsgXCIuc3ZnXCI7XG4gICAgaW1hZ2Uuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtdGV4dC1hbm5vdGF0aW9uLXR5cGVcIik7XG4gICAgaW1hZ2Uuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWFyZ3NcIiwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgdHlwZTogdGhpcy5kYXRhLm5hbWVcbiAgICB9KSk7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChpbWFnZSk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBzaG93RWxlbWVudEFuZEhpZGVDYW52YXMoZWxlbWVudCkge1xuICAgIGlmICh0aGlzLmRhdGEuaGFzT3duQ2FudmFzKSB7XG4gICAgICBpZiAoZWxlbWVudC5wcmV2aW91c1NpYmxpbmc/Lm5vZGVOYW1lID09PSBcIkNBTlZBU1wiKSB7XG4gICAgICAgIGVsZW1lbnQucHJldmlvdXNTaWJsaW5nLmhpZGRlbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBlbGVtZW50LmhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBfZ2V0S2V5TW9kaWZpZXIoZXZlbnQpIHtcbiAgICByZXR1cm4gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybS5pc01hYyA/IGV2ZW50Lm1ldGFLZXkgOiBldmVudC5jdHJsS2V5O1xuICB9XG4gIF9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBiYXNlTmFtZSwgZXZlbnROYW1lLCB2YWx1ZUdldHRlcikge1xuICAgIGlmIChiYXNlTmFtZS5pbmNsdWRlcyhcIm1vdXNlXCIpKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoYmFzZU5hbWUsIGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZDogdGhpcy5kYXRhLmlkLFxuICAgICAgICAgICAgbmFtZTogZXZlbnROYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlR2V0dGVyKGV2ZW50KSxcbiAgICAgICAgICAgIHNoaWZ0OiBldmVudC5zaGlmdEtleSxcbiAgICAgICAgICAgIG1vZGlmaWVyOiB0aGlzLl9nZXRLZXlNb2RpZmllcihldmVudClcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihiYXNlTmFtZSwgZXZlbnQgPT4ge1xuICAgICAgICBpZiAoYmFzZU5hbWUgPT09IFwiYmx1clwiKSB7XG4gICAgICAgICAgaWYgKCFlbGVtZW50RGF0YS5mb2N1c2VkIHx8ICFldmVudC5yZWxhdGVkVGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChiYXNlTmFtZSA9PT0gXCJmb2N1c1wiKSB7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLmZvY3VzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEuZm9jdXNlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWx1ZUdldHRlcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmRhdGEuaWQsXG4gICAgICAgICAgICBuYW1lOiBldmVudE5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVHZXR0ZXIoZXZlbnQpXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfc2V0RXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgZWxlbWVudERhdGEsIG5hbWVzLCBnZXR0ZXIpIHtcbiAgICBmb3IgKGNvbnN0IFtiYXNlTmFtZSwgZXZlbnROYW1lXSBvZiBuYW1lcykge1xuICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJBY3Rpb25cIiB8fCB0aGlzLmRhdGEuYWN0aW9ucz8uW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJGb2N1c1wiIHx8IGV2ZW50TmFtZSA9PT0gXCJCbHVyXCIpIHtcbiAgICAgICAgICBlbGVtZW50RGF0YSB8fD0ge1xuICAgICAgICAgICAgZm9jdXNlZDogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZWxlbWVudERhdGEsIGJhc2VOYW1lLCBldmVudE5hbWUsIGdldHRlcik7XG4gICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiRm9jdXNcIiAmJiAhdGhpcy5kYXRhLmFjdGlvbnM/LkJsdXIpIHtcbiAgICAgICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBcImJsdXJcIiwgXCJCbHVyXCIsIG51bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gXCJCbHVyXCIgJiYgIXRoaXMuZGF0YS5hY3Rpb25zPy5Gb2N1cykge1xuICAgICAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZWxlbWVudERhdGEsIFwiZm9jdXNcIiwgXCJGb2N1c1wiLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBfc2V0QmFja2dyb3VuZENvbG9yKGVsZW1lbnQpIHtcbiAgICBjb25zdCBjb2xvciA9IHRoaXMuZGF0YS5iYWNrZ3JvdW5kQ29sb3IgfHwgbnVsbDtcbiAgICBlbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yID09PSBudWxsID8gXCJ0cmFuc3BhcmVudFwiIDogVXRpbC5tYWtlSGV4Q29sb3IoY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSk7XG4gIH1cbiAgX3NldFRleHRTdHlsZShlbGVtZW50KSB7XG4gICAgY29uc3QgVEVYVF9BTElHTk1FTlQgPSBbXCJsZWZ0XCIsIFwiY2VudGVyXCIsIFwicmlnaHRcIl07XG4gICAgY29uc3Qge1xuICAgICAgZm9udENvbG9yXG4gICAgfSA9IHRoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGE7XG4gICAgY29uc3QgZm9udFNpemUgPSB0aGlzLmRhdGEuZGVmYXVsdEFwcGVhcmFuY2VEYXRhLmZvbnRTaXplIHx8IGFubm90YXRpb25fbGF5ZXJfREVGQVVMVF9GT05UX1NJWkU7XG4gICAgY29uc3Qgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuICAgIGxldCBjb21wdXRlZEZvbnRTaXplO1xuICAgIGNvbnN0IEJPUkRFUl9TSVpFID0gMjtcbiAgICBjb25zdCByb3VuZFRvT25lRGVjaW1hbCA9IHggPT4gTWF0aC5yb3VuZCgxMCAqIHgpIC8gMTA7XG4gICAgaWYgKHRoaXMuZGF0YS5tdWx0aUxpbmUpIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguYWJzKHRoaXMuZGF0YS5yZWN0WzNdIC0gdGhpcy5kYXRhLnJlY3RbMV0gLSBCT1JERVJfU0laRSk7XG4gICAgICBjb25zdCBudW1iZXJPZkxpbmVzID0gTWF0aC5yb3VuZChoZWlnaHQgLyAoTElORV9GQUNUT1IgKiBmb250U2l6ZSkpIHx8IDE7XG4gICAgICBjb25zdCBsaW5lSGVpZ2h0ID0gaGVpZ2h0IC8gbnVtYmVyT2ZMaW5lcztcbiAgICAgIGNvbXB1dGVkRm9udFNpemUgPSBNYXRoLm1pbihmb250U2l6ZSwgcm91bmRUb09uZURlY2ltYWwobGluZUhlaWdodCAvIExJTkVfRkFDVE9SKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguYWJzKHRoaXMuZGF0YS5yZWN0WzNdIC0gdGhpcy5kYXRhLnJlY3RbMV0gLSBCT1JERVJfU0laRSk7XG4gICAgICBjb21wdXRlZEZvbnRTaXplID0gTWF0aC5taW4oZm9udFNpemUsIHJvdW5kVG9PbmVEZWNpbWFsKGhlaWdodCAvIExJTkVfRkFDVE9SKSk7XG4gICAgfVxuICAgIHN0eWxlLmZvbnRTaXplID0gYGNhbGMoJHtjb21wdXRlZEZvbnRTaXplfXB4ICogdmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSlgO1xuICAgIHN0eWxlLmNvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoZm9udENvbG9yWzBdLCBmb250Q29sb3JbMV0sIGZvbnRDb2xvclsyXSk7XG4gICAgaWYgKHRoaXMuZGF0YS50ZXh0QWxpZ25tZW50ICE9PSBudWxsKSB7XG4gICAgICBzdHlsZS50ZXh0QWxpZ24gPSBURVhUX0FMSUdOTUVOVFt0aGlzLmRhdGEudGV4dEFsaWdubWVudF07XG4gICAgfVxuICB9XG4gIF9zZXRSZXF1aXJlZChlbGVtZW50LCBpc1JlcXVpcmVkKSB7XG4gICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwicmVxdWlyZWRcIiwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwicmVxdWlyZWRcIik7XG4gICAgfVxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1yZXF1aXJlZFwiLCBpc1JlcXVpcmVkKTtcbiAgfVxufVxuY2xhc3MgVGV4dFdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgaXNSZW5kZXJhYmxlID0gcGFyYW1ldGVycy5yZW5kZXJGb3JtcyB8fCBwYXJhbWV0ZXJzLmRhdGEuaGFzT3duQ2FudmFzIHx8ICFwYXJhbWV0ZXJzLmRhdGEuaGFzQXBwZWFyYW5jZSAmJiAhIXBhcmFtZXRlcnMuZGF0YS5maWVsZFZhbHVlO1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZVxuICAgIH0pO1xuICB9XG4gIHNldFByb3BlcnR5T25TaWJsaW5ncyhiYXNlLCBrZXksIHZhbHVlLCBrZXlJblN0b3JhZ2UpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUoYmFzZS5uYW1lLCBiYXNlLmlkKSkge1xuICAgICAgaWYgKGVsZW1lbnQuZG9tRWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LmRvbUVsZW1lbnRba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShlbGVtZW50LmlkLCB7XG4gICAgICAgIFtrZXlJblN0b3JhZ2VdOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBpZCA9IHRoaXMuZGF0YS5pZDtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidGV4dFdpZGdldEFubm90YXRpb25cIik7XG4gICAgbGV0IGVsZW1lbnQgPSBudWxsO1xuICAgIGlmICh0aGlzLnJlbmRlckZvcm1zKSB7XG4gICAgICBjb25zdCBzdG9yZWREYXRhID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZTogdGhpcy5kYXRhLmZpZWxkVmFsdWVcbiAgICAgIH0pO1xuICAgICAgbGV0IHRleHRDb250ZW50ID0gc3RvcmVkRGF0YS52YWx1ZSB8fCBcIlwiO1xuICAgICAgY29uc3QgbWF4TGVuID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgICBjaGFyTGltaXQ6IHRoaXMuZGF0YS5tYXhMZW5cbiAgICAgIH0pLmNoYXJMaW1pdDtcbiAgICAgIGlmIChtYXhMZW4gJiYgdGV4dENvbnRlbnQubGVuZ3RoID4gbWF4TGVuKSB7XG4gICAgICAgIHRleHRDb250ZW50ID0gdGV4dENvbnRlbnQuc2xpY2UoMCwgbWF4TGVuKTtcbiAgICAgIH1cbiAgICAgIGxldCBmaWVsZEZvcm1hdHRlZFZhbHVlcyA9IHN0b3JlZERhdGEuZm9ybWF0dGVkVmFsdWUgfHwgdGhpcy5kYXRhLnRleHRDb250ZW50Py5qb2luKFwiXFxuXCIpIHx8IG51bGw7XG4gICAgICBpZiAoZmllbGRGb3JtYXR0ZWRWYWx1ZXMgJiYgdGhpcy5kYXRhLmNvbWIpIHtcbiAgICAgICAgZmllbGRGb3JtYXR0ZWRWYWx1ZXMgPSBmaWVsZEZvcm1hdHRlZFZhbHVlcy5yZXBsYWNlQWxsKC9cXHMrL2csIFwiXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZWxlbWVudERhdGEgPSB7XG4gICAgICAgIHVzZXJWYWx1ZTogdGV4dENvbnRlbnQsXG4gICAgICAgIGZvcm1hdHRlZFZhbHVlOiBmaWVsZEZvcm1hdHRlZFZhbHVlcyxcbiAgICAgICAgbGFzdENvbW1pdHRlZFZhbHVlOiBudWxsLFxuICAgICAgICBjb21taXRLZXk6IDEsXG4gICAgICAgIGZvY3VzZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuZGF0YS5tdWx0aUxpbmUpIHtcbiAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKTtcbiAgICAgICAgZWxlbWVudC50ZXh0Q29udGVudCA9IGZpZWxkRm9ybWF0dGVkVmFsdWVzID8/IHRleHRDb250ZW50O1xuICAgICAgICBpZiAodGhpcy5kYXRhLmRvTm90U2Nyb2xsKSB7XG4gICAgICAgICAgZWxlbWVudC5zdHlsZS5vdmVyZmxvd1kgPSBcImhpZGRlblwiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICBlbGVtZW50LnR5cGUgPSB0aGlzLmRhdGEucGFzc3dvcmQgPyBcInBhc3N3b3JkXCIgOiBcInRleHRcIjtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBmaWVsZEZvcm1hdHRlZFZhbHVlcyA/PyB0ZXh0Q29udGVudCk7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuZG9Ob3RTY3JvbGwpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlLm92ZXJmbG93WCA9IFwiaGlkZGVuXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRhdGEuaGFzT3duQ2FudmFzKSB7XG4gICAgICAgIGVsZW1lbnQuaGlkZGVuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIEdldEVsZW1lbnRzQnlOYW1lU2V0LmFkZChlbGVtZW50KTtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIGlkKTtcbiAgICAgIGVsZW1lbnQuZGlzYWJsZWQgPSB0aGlzLmRhdGEucmVhZE9ubHk7XG4gICAgICBlbGVtZW50Lm5hbWUgPSB0aGlzLmRhdGEuZmllbGROYW1lO1xuICAgICAgZWxlbWVudC50YWJJbmRleCA9IERFRkFVTFRfVEFCX0lOREVYO1xuICAgICAgdGhpcy5fc2V0UmVxdWlyZWQoZWxlbWVudCwgdGhpcy5kYXRhLnJlcXVpcmVkKTtcbiAgICAgIGlmIChtYXhMZW4pIHtcbiAgICAgICAgZWxlbWVudC5tYXhMZW5ndGggPSBtYXhMZW47XG4gICAgICB9XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFByb3BlcnR5T25TaWJsaW5ncyhlbGVtZW50LCBcInZhbHVlXCIsIGV2ZW50LnRhcmdldC52YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgZWxlbWVudERhdGEuZm9ybWF0dGVkVmFsdWUgPSBudWxsO1xuICAgICAgfSk7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldGZvcm1cIiwgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSB0aGlzLmRhdGEuZGVmYXVsdEZpZWxkVmFsdWUgPz8gXCJcIjtcbiAgICAgICAgZWxlbWVudC52YWx1ZSA9IGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgZWxlbWVudERhdGEuZm9ybWF0dGVkVmFsdWUgPSBudWxsO1xuICAgICAgfSk7XG4gICAgICBsZXQgYmx1ckxpc3RlbmVyID0gZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZm9ybWF0dGVkVmFsdWVcbiAgICAgICAgfSA9IGVsZW1lbnREYXRhO1xuICAgICAgICBpZiAoZm9ybWF0dGVkVmFsdWUgIT09IG51bGwgJiYgZm9ybWF0dGVkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnRhcmdldC5zY3JvbGxMZWZ0ID0gMDtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5mb2N1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHRhcmdldFxuICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICBpZiAoZWxlbWVudERhdGEudXNlclZhbHVlKSB7XG4gICAgICAgICAgICB0YXJnZXQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSA9IHRhcmdldC52YWx1ZTtcbiAgICAgICAgICBlbGVtZW50RGF0YS5jb21taXRLZXkgPSAxO1xuICAgICAgICAgIGlmICghdGhpcy5kYXRhLmFjdGlvbnM/LkZvY3VzKSB7XG4gICAgICAgICAgICBlbGVtZW50RGF0YS5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgICB0aGlzLnNob3dFbGVtZW50QW5kSGlkZUNhbnZhcyhqc0V2ZW50LnRhcmdldCk7XG4gICAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICAgIHZhbHVlKGV2ZW50KSB7XG4gICAgICAgICAgICAgIGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IGV2ZW50LmRldGFpbC52YWx1ZSA/PyBcIlwiO1xuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGVsZW1lbnREYXRhLnVzZXJWYWx1ZS50b1N0cmluZygpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWUoZXZlbnQpIHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlXG4gICAgICAgICAgICAgIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgICAgICAgIGVsZW1lbnREYXRhLmZvcm1hdHRlZFZhbHVlID0gZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgICAgICAgIGlmIChmb3JtYXR0ZWRWYWx1ZSAhPT0gbnVsbCAmJiBmb3JtYXR0ZWRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIGV2ZW50LnRhcmdldCAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWxSYW5nZShldmVudCkge1xuICAgICAgICAgICAgICBldmVudC50YXJnZXQuc2V0U2VsZWN0aW9uUmFuZ2UoLi4uZXZlbnQuZGV0YWlsLnNlbFJhbmdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGFyTGltaXQ6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGNoYXJMaW1pdFxuICAgICAgICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICAgICAgaWYgKGNoYXJMaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJtYXhMZW5ndGhcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJtYXhMZW5ndGhcIiwgY2hhckxpbWl0KTtcbiAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlO1xuICAgICAgICAgICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlLmxlbmd0aCA8PSBjaGFyTGltaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBjaGFyTGltaXQpO1xuICAgICAgICAgICAgICB0YXJnZXQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgd2lsbENvbW1pdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdEtleTogMSxcbiAgICAgICAgICAgICAgICAgIHNlbFN0YXJ0OiB0YXJnZXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgICBzZWxFbmQ6IHRhcmdldC5zZWxlY3Rpb25FbmRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KGFjdGlvbnMsIGpzRXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBldmVudCA9PiB7XG4gICAgICAgICAgZWxlbWVudERhdGEuY29tbWl0S2V5ID0gMTtcbiAgICAgICAgICBsZXQgY29tbWl0S2V5ID0gLTE7XG4gICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICAgICAgY29tbWl0S2V5ID0gMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gXCJFbnRlclwiICYmICF0aGlzLmRhdGEubXVsdGlMaW5lKSB7XG4gICAgICAgICAgICBjb21taXRLZXkgPSAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSBcIlRhYlwiKSB7XG4gICAgICAgICAgICBlbGVtZW50RGF0YS5jb21taXRLZXkgPSAzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29tbWl0S2V5ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0gPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEubGFzdENvbW1pdHRlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgZWxlbWVudERhdGEudXNlclZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIHdpbGxDb21taXQ6IHRydWUsXG4gICAgICAgICAgICAgIGNvbW1pdEtleSxcbiAgICAgICAgICAgICAgc2VsU3RhcnQ6IGV2ZW50LnRhcmdldC5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgc2VsRW5kOiBldmVudC50YXJnZXQuc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBfYmx1ckxpc3RlbmVyID0gYmx1ckxpc3RlbmVyO1xuICAgICAgICBibHVyTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAoIWVsZW1lbnREYXRhLmZvY3VzZWQgfHwgIWV2ZW50LnJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLmRhdGEuYWN0aW9ucz8uQmx1cikge1xuICAgICAgICAgICAgZWxlbWVudERhdGEuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0gPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgZWxlbWVudERhdGEudXNlclZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB3aWxsQ29tbWl0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbW1pdEtleTogZWxlbWVudERhdGEuY29tbWl0S2V5LFxuICAgICAgICAgICAgICAgIHNlbFN0YXJ0OiBldmVudC50YXJnZXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgc2VsRW5kOiBldmVudC50YXJnZXQuc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfYmx1ckxpc3RlbmVyKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuYWN0aW9ucz8uS2V5c3Ryb2tlKSB7XG4gICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgICAgZWxlbWVudERhdGEubGFzdENvbW1pdHRlZFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgICB9ID0gZXZlbnQ7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICB9ID0gdGFyZ2V0O1xuICAgICAgICAgICAgbGV0IHNlbFN0YXJ0ID0gc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgIHNlbEVuZCA9IHNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQuaW5wdXRUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVXb3JkQmFja3dhcmRcIjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHZhbHVlLnN1YnN0cmluZygwLCBzZWxlY3Rpb25TdGFydCkubWF0Y2goL1xcdypbXlxcd10qJC8pO1xuICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbFN0YXJ0IC09IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZVdvcmRGb3J3YXJkXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB2YWx1ZS5zdWJzdHJpbmcoc2VsZWN0aW9uU3RhcnQpLm1hdGNoKC9eW15cXHddKlxcdyovKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxFbmQgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlQ29udGVudEJhY2t3YXJkXCI6XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ID09PSBzZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgIHNlbFN0YXJ0IC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlQ29udGVudEZvcndhcmRcIjpcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgICAgc2VsRW5kICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBjaGFuZ2U6IGRhdGEgfHwgXCJcIixcbiAgICAgICAgICAgICAgICB3aWxsQ29tbWl0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzZWxTdGFydCxcbiAgICAgICAgICAgICAgICBzZWxFbmRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgZWxlbWVudERhdGEsIFtbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdXSwgZXZlbnQgPT4gZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChibHVyTGlzdGVuZXIpIHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBibHVyTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGF0YS5jb21iKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkV2lkdGggPSB0aGlzLmRhdGEucmVjdFsyXSAtIHRoaXMuZGF0YS5yZWN0WzBdO1xuICAgICAgICBjb25zdCBjb21iV2lkdGggPSBmaWVsZFdpZHRoIC8gbWF4TGVuO1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJjb21iXCIpO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmxldHRlclNwYWNpbmcgPSBgY2FsYygke2NvbWJXaWR0aH1weCAqIHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikgLSAxY2gpYDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gdGhpcy5kYXRhLmZpZWxkVmFsdWU7XG4gICAgICBlbGVtZW50LnN0eWxlLnZlcnRpY2FsQWxpZ24gPSBcIm1pZGRsZVwiO1xuICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJ0YWJsZS1jZWxsXCI7XG4gICAgICBpZiAodGhpcy5kYXRhLmhhc093bkNhbnZhcykge1xuICAgICAgICBlbGVtZW50LmhpZGRlbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3NldFRleHRTdHlsZShlbGVtZW50KTtcbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgU2lnbmF0dXJlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6ICEhcGFyYW1ldGVycy5kYXRhLmhhc093bkNhbnZhc1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBDaGVja2JveFdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgaWQgPSBkYXRhLmlkO1xuICAgIGxldCB2YWx1ZSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiBkYXRhLmV4cG9ydFZhbHVlID09PSBkYXRhLmZpZWxkVmFsdWVcbiAgICB9KS52YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICE9PSBcIk9mZlwiO1xuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJidXR0b25XaWRnZXRBbm5vdGF0aW9uXCIsIFwiY2hlY2tCb3hcIik7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBHZXRFbGVtZW50c0J5TmFtZVNldC5hZGQoZWxlbWVudCk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgaWQpO1xuICAgIGVsZW1lbnQuZGlzYWJsZWQgPSBkYXRhLnJlYWRPbmx5O1xuICAgIHRoaXMuX3NldFJlcXVpcmVkKGVsZW1lbnQsIHRoaXMuZGF0YS5yZXF1aXJlZCk7XG4gICAgZWxlbWVudC50eXBlID0gXCJjaGVja2JveFwiO1xuICAgIGVsZW1lbnQubmFtZSA9IGRhdGEuZmllbGROYW1lO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsIHRydWUpO1xuICAgIH1cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImV4cG9ydFZhbHVlXCIsIGRhdGEuZXhwb3J0VmFsdWUpO1xuICAgIGVsZW1lbnQudGFiSW5kZXggPSBERUZBVUxUX1RBQl9JTkRFWDtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBuYW1lLFxuICAgICAgICBjaGVja2VkXG4gICAgICB9ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgZm9yIChjb25zdCBjaGVja2JveCBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShuYW1lLCBpZCkpIHtcbiAgICAgICAgY29uc3QgY3VyQ2hlY2tlZCA9IGNoZWNrZWQgJiYgY2hlY2tib3guZXhwb3J0VmFsdWUgPT09IGRhdGEuZXhwb3J0VmFsdWU7XG4gICAgICAgIGlmIChjaGVja2JveC5kb21FbGVtZW50KSB7XG4gICAgICAgICAgY2hlY2tib3guZG9tRWxlbWVudC5jaGVja2VkID0gY3VyQ2hlY2tlZDtcbiAgICAgICAgfVxuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGNoZWNrYm94LmlkLCB7XG4gICAgICAgICAgdmFsdWU6IGN1ckNoZWNrZWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlOiBjaGVja2VkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldGZvcm1cIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gZGF0YS5kZWZhdWx0RmllbGRWYWx1ZSB8fCBcIk9mZlwiO1xuICAgICAgZXZlbnQudGFyZ2V0LmNoZWNrZWQgPSBkZWZhdWx0VmFsdWUgPT09IGRhdGEuZXhwb3J0VmFsdWU7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICB2YWx1ZShldmVudCkge1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmNoZWNrZWQgPSBldmVudC5kZXRhaWwudmFsdWUgIT09IFwiT2ZmXCI7XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQuY2hlY2tlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXJzKGVsZW1lbnQsIG51bGwsIFtbXCJjaGFuZ2VcIiwgXCJWYWxpZGF0ZVwiXSwgW1wiY2hhbmdlXCIsIFwiQWN0aW9uXCJdLCBbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdXSwgZXZlbnQgPT4gZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFdpZGdldEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogcGFyYW1ldGVycy5yZW5kZXJGb3Jtc1xuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiYnV0dG9uV2lkZ2V0QW5ub3RhdGlvblwiLCBcInJhZGlvQnV0dG9uXCIpO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgaWQgPSBkYXRhLmlkO1xuICAgIGxldCB2YWx1ZSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiBkYXRhLmZpZWxkVmFsdWUgPT09IGRhdGEuYnV0dG9uVmFsdWVcbiAgICB9KS52YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICE9PSBkYXRhLmJ1dHRvblZhbHVlO1xuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZm9yIChjb25zdCByYWRpbyBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShkYXRhLmZpZWxkTmFtZSwgaWQpKSB7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUocmFkaW8uaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgR2V0RWxlbWVudHNCeU5hbWVTZXQuYWRkKGVsZW1lbnQpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIGlkKTtcbiAgICBlbGVtZW50LmRpc2FibGVkID0gZGF0YS5yZWFkT25seTtcbiAgICB0aGlzLl9zZXRSZXF1aXJlZChlbGVtZW50LCB0aGlzLmRhdGEucmVxdWlyZWQpO1xuICAgIGVsZW1lbnQudHlwZSA9IFwicmFkaW9cIjtcbiAgICBlbGVtZW50Lm5hbWUgPSBkYXRhLmZpZWxkTmFtZTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCB0cnVlKTtcbiAgICB9XG4gICAgZWxlbWVudC50YWJJbmRleCA9IERFRkFVTFRfVEFCX0lOREVYO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGNoZWNrZWRcbiAgICAgIH0gPSBldmVudC50YXJnZXQ7XG4gICAgICBmb3IgKGNvbnN0IHJhZGlvIG9mIHRoaXMuX2dldEVsZW1lbnRzQnlOYW1lKG5hbWUsIGlkKSkge1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKHJhZGlvLmlkLCB7XG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZTogY2hlY2tlZFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVzZXRmb3JtXCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IGRhdGEuZGVmYXVsdEZpZWxkVmFsdWU7XG4gICAgICBldmVudC50YXJnZXQuY2hlY2tlZCA9IGRlZmF1bHRWYWx1ZSAhPT0gbnVsbCAmJiBkZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0VmFsdWUgPT09IGRhdGEuYnV0dG9uVmFsdWU7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICBjb25zdCBwZGZCdXR0b25WYWx1ZSA9IGRhdGEuYnV0dG9uVmFsdWU7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICB2YWx1ZTogZXZlbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hlY2tlZCA9IHBkZkJ1dHRvblZhbHVlID09PSBldmVudC5kZXRhaWwudmFsdWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJhZGlvIG9mIHRoaXMuX2dldEVsZW1lbnRzQnlOYW1lKGV2ZW50LnRhcmdldC5uYW1lKSkge1xuICAgICAgICAgICAgICBjb25zdCBjdXJDaGVja2VkID0gY2hlY2tlZCAmJiByYWRpby5pZCA9PT0gaWQ7XG4gICAgICAgICAgICAgIGlmIChyYWRpby5kb21FbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmFkaW8uZG9tRWxlbWVudC5jaGVja2VkID0gY3VyQ2hlY2tlZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKHJhZGlvLmlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGN1ckNoZWNrZWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXJzKGVsZW1lbnQsIG51bGwsIFtbXCJjaGFuZ2VcIiwgXCJWYWxpZGF0ZVwiXSwgW1wiY2hhbmdlXCIsIFwiQWN0aW9uXCJdLCBbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdXSwgZXZlbnQgPT4gZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgUHVzaEJ1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgTGlua0Fubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlnbm9yZUJvcmRlcjogcGFyYW1ldGVycy5kYXRhLmhhc0FwcGVhcmFuY2VcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gc3VwZXIucmVuZGVyKCk7XG4gICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJidXR0b25XaWRnZXRBbm5vdGF0aW9uXCIsIFwicHVzaEJ1dHRvblwiKTtcbiAgICBjb25zdCBsaW5rRWxlbWVudCA9IGNvbnRhaW5lci5sYXN0Q2hpbGQ7XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zICYmIGxpbmtFbGVtZW50KSB7XG4gICAgICB0aGlzLl9zZXREZWZhdWx0UHJvcGVydGllc0Zyb21KUyhsaW5rRWxlbWVudCk7XG4gICAgICBsaW5rRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwganNFdmVudCA9PiB7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveCh7fSwganNFdmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgQ2hvaWNlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHBhcmFtZXRlcnMucmVuZGVyRm9ybXNcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImNob2ljZVdpZGdldEFubm90YXRpb25cIik7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgY29uc3QgaWQgPSB0aGlzLmRhdGEuaWQ7XG4gICAgY29uc3Qgc3RvcmVkRGF0YSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiB0aGlzLmRhdGEuZmllbGRWYWx1ZVxuICAgIH0pO1xuICAgIGNvbnN0IHNlbGVjdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpO1xuICAgIEdldEVsZW1lbnRzQnlOYW1lU2V0LmFkZChzZWxlY3RFbGVtZW50KTtcbiAgICBzZWxlY3RFbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBpZCk7XG4gICAgc2VsZWN0RWxlbWVudC5kaXNhYmxlZCA9IHRoaXMuZGF0YS5yZWFkT25seTtcbiAgICB0aGlzLl9zZXRSZXF1aXJlZChzZWxlY3RFbGVtZW50LCB0aGlzLmRhdGEucmVxdWlyZWQpO1xuICAgIHNlbGVjdEVsZW1lbnQubmFtZSA9IHRoaXMuZGF0YS5maWVsZE5hbWU7XG4gICAgc2VsZWN0RWxlbWVudC50YWJJbmRleCA9IERFRkFVTFRfVEFCX0lOREVYO1xuICAgIGxldCBhZGRBbkVtcHR5RW50cnkgPSB0aGlzLmRhdGEuY29tYm8gJiYgdGhpcy5kYXRhLm9wdGlvbnMubGVuZ3RoID4gMDtcbiAgICBpZiAoIXRoaXMuZGF0YS5jb21ibykge1xuICAgICAgc2VsZWN0RWxlbWVudC5zaXplID0gdGhpcy5kYXRhLm9wdGlvbnMubGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuZGF0YS5tdWx0aVNlbGVjdCkge1xuICAgICAgICBzZWxlY3RFbGVtZW50Lm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVzZXRmb3JtXCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHRoaXMuZGF0YS5kZWZhdWx0RmllbGRWYWx1ZTtcbiAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIHNlbGVjdEVsZW1lbnQub3B0aW9ucykge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBvcHRpb24udmFsdWUgPT09IGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiB0aGlzLmRhdGEub3B0aW9ucykge1xuICAgICAgY29uc3Qgb3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICBvcHRpb25FbGVtZW50LnRleHRDb250ZW50ID0gb3B0aW9uLmRpc3BsYXlWYWx1ZTtcbiAgICAgIG9wdGlvbkVsZW1lbnQudmFsdWUgPSBvcHRpb24uZXhwb3J0VmFsdWU7XG4gICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZS5pbmNsdWRlcyhvcHRpb24uZXhwb3J0VmFsdWUpKSB7XG4gICAgICAgIG9wdGlvbkVsZW1lbnQuc2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIiwgdHJ1ZSk7XG4gICAgICAgIGFkZEFuRW1wdHlFbnRyeSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgc2VsZWN0RWxlbWVudC5hcHBlbmQob3B0aW9uRWxlbWVudCk7XG4gICAgfVxuICAgIGxldCByZW1vdmVFbXB0eUVudHJ5ID0gbnVsbDtcbiAgICBpZiAoYWRkQW5FbXB0eUVudHJ5KSB7XG4gICAgICBjb25zdCBub25lT3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICBub25lT3B0aW9uRWxlbWVudC52YWx1ZSA9IFwiIFwiO1xuICAgICAgbm9uZU9wdGlvbkVsZW1lbnQuc2V0QXR0cmlidXRlKFwiaGlkZGVuXCIsIHRydWUpO1xuICAgICAgbm9uZU9wdGlvbkVsZW1lbnQuc2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIiwgdHJ1ZSk7XG4gICAgICBzZWxlY3RFbGVtZW50LnByZXBlbmQobm9uZU9wdGlvbkVsZW1lbnQpO1xuICAgICAgcmVtb3ZlRW1wdHlFbnRyeSA9ICgpID0+IHtcbiAgICAgICAgbm9uZU9wdGlvbkVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgIHNlbGVjdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHJlbW92ZUVtcHR5RW50cnkpO1xuICAgICAgICByZW1vdmVFbXB0eUVudHJ5ID0gbnVsbDtcbiAgICAgIH07XG4gICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCByZW1vdmVFbXB0eUVudHJ5KTtcbiAgICB9XG4gICAgY29uc3QgZ2V0VmFsdWUgPSBpc0V4cG9ydCA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gaXNFeHBvcnQgPyBcInZhbHVlXCIgOiBcInRleHRDb250ZW50XCI7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIG11bHRpcGxlXG4gICAgICB9ID0gc2VsZWN0RWxlbWVudDtcbiAgICAgIGlmICghbXVsdGlwbGUpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuc2VsZWN0ZWRJbmRleCA9PT0gLTEgPyBudWxsIDogb3B0aW9uc1tvcHRpb25zLnNlbGVjdGVkSW5kZXhdW25hbWVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChvcHRpb25zLCBvcHRpb24gPT4gb3B0aW9uLnNlbGVjdGVkKS5tYXAob3B0aW9uID0+IG9wdGlvbltuYW1lXSk7XG4gICAgfTtcbiAgICBsZXQgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgY29uc3QgZ2V0SXRlbXMgPSBldmVudCA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zID0gZXZlbnQudGFyZ2V0Lm9wdGlvbnM7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKG9wdGlvbnMsIG9wdGlvbiA9PiAoe1xuICAgICAgICBkaXNwbGF5VmFsdWU6IG9wdGlvbi50ZXh0Q29udGVudCxcbiAgICAgICAgZXhwb3J0VmFsdWU6IG9wdGlvbi52YWx1ZVxuICAgICAgfSkpO1xuICAgIH07XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICB2YWx1ZShldmVudCkge1xuICAgICAgICAgICAgcmVtb3ZlRW1wdHlFbnRyeT8uKCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGV2ZW50LmRldGFpbC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBTZXQoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2Ygc2VsZWN0RWxlbWVudC5vcHRpb25zKSB7XG4gICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlcy5oYXMob3B0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbXVsdGlwbGVTZWxlY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQubXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVtb3ZlKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gc2VsZWN0RWxlbWVudC5vcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBldmVudC5kZXRhaWwucmVtb3ZlO1xuICAgICAgICAgICAgb3B0aW9uc1tpbmRleF0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQucmVtb3ZlKGluZGV4KTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgaSA9IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXguY2FsbChvcHRpb25zLCBvcHRpb24gPT4gb3B0aW9uLnNlbGVjdGVkKTtcbiAgICAgICAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1swXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpLFxuICAgICAgICAgICAgICBpdGVtczogZ2V0SXRlbXMoZXZlbnQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2xlYXIoZXZlbnQpIHtcbiAgICAgICAgICAgIHdoaWxlIChzZWxlY3RFbGVtZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgIGl0ZW1zOiBbXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGluc2VydChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgZGlzcGxheVZhbHVlLFxuICAgICAgICAgICAgICBleHBvcnRWYWx1ZVxuICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbC5pbnNlcnQ7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RDaGlsZCA9IHNlbGVjdEVsZW1lbnQuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgICAgICBvcHRpb25FbGVtZW50LnRleHRDb250ZW50ID0gZGlzcGxheVZhbHVlO1xuICAgICAgICAgICAgb3B0aW9uRWxlbWVudC52YWx1ZSA9IGV4cG9ydFZhbHVlO1xuICAgICAgICAgICAgaWYgKHNlbGVjdENoaWxkKSB7XG4gICAgICAgICAgICAgIHNlbGVjdENoaWxkLmJlZm9yZShvcHRpb25FbGVtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQuYXBwZW5kKG9wdGlvbkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSksXG4gICAgICAgICAgICAgIGl0ZW1zOiBnZXRJdGVtcyhldmVudClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpdGVtcyhldmVudCkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBpdGVtc1xuICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgICAgIHdoaWxlIChzZWxlY3RFbGVtZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgZGlzcGxheVZhbHVlLFxuICAgICAgICAgICAgICAgIGV4cG9ydFZhbHVlXG4gICAgICAgICAgICAgIH0gPSBpdGVtO1xuICAgICAgICAgICAgICBjb25zdCBvcHRpb25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgICAgICAgb3B0aW9uRWxlbWVudC50ZXh0Q29udGVudCA9IGRpc3BsYXlWYWx1ZTtcbiAgICAgICAgICAgICAgb3B0aW9uRWxlbWVudC52YWx1ZSA9IGV4cG9ydFZhbHVlO1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LmFwcGVuZChvcHRpb25FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RFbGVtZW50Lm9wdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50Lm9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSksXG4gICAgICAgICAgICAgIGl0ZW1zOiBnZXRJdGVtcyhldmVudClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbmRpY2VzKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gbmV3IFNldChldmVudC5kZXRhaWwuaW5kaWNlcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBldmVudC50YXJnZXQub3B0aW9ucykge1xuICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBpbmRpY2VzLmhhcyhvcHRpb24uaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlZGl0YWJsZShldmVudCkge1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmRpc2FibGVkID0gIWV2ZW50LmRldGFpbC5lZGl0YWJsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveChhY3Rpb25zLCBqc0V2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBleHBvcnRWYWx1ZSA9IGdldFZhbHVlKHRydWUpO1xuICAgICAgICBjb25zdCBjaGFuZ2UgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZXhwb3J0VmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBuYW1lOiBcIktleXN0cm9rZVwiLFxuICAgICAgICAgICAgdmFsdWU6IHNlbGVjdGVkVmFsdWVzLFxuICAgICAgICAgICAgY2hhbmdlLFxuICAgICAgICAgICAgY2hhbmdlRXg6IGV4cG9ydFZhbHVlLFxuICAgICAgICAgICAgd2lsbENvbW1pdDogZmFsc2UsXG4gICAgICAgICAgICBjb21taXRLZXk6IDEsXG4gICAgICAgICAgICBrZXlEb3duOiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXJzKHNlbGVjdEVsZW1lbnQsIG51bGwsIFtbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdLCBbXCJpbnB1dFwiLCBcIkFjdGlvblwiXSwgW1wiaW5wdXRcIiwgXCJWYWxpZGF0ZVwiXV0sIGV2ZW50ID0+IGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRhdGEuY29tYm8pIHtcbiAgICAgIHRoaXMuX3NldFRleHRTdHlsZShzZWxlY3RFbGVtZW50KTtcbiAgICB9IGVsc2Uge31cbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3Ioc2VsZWN0RWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoc2VsZWN0RWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHNlbGVjdEVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgUG9wdXBBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBlbGVtZW50c1xuICAgIH0gPSBwYXJhbWV0ZXJzO1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogQW5ub3RhdGlvbkVsZW1lbnQuX2hhc1BvcHVwRGF0YShkYXRhKVxuICAgIH0pO1xuICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICB0aGlzLnBvcHVwID0gbnVsbDtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInBvcHVwQW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCBwb3B1cCA9IHRoaXMucG9wdXAgPSBuZXcgUG9wdXBFbGVtZW50KHtcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jb250YWluZXIsXG4gICAgICBjb2xvcjogdGhpcy5kYXRhLmNvbG9yLFxuICAgICAgdGl0bGVPYmo6IHRoaXMuZGF0YS50aXRsZU9iaixcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGU6IHRoaXMuZGF0YS5tb2RpZmljYXRpb25EYXRlLFxuICAgICAgY29udGVudHNPYmo6IHRoaXMuZGF0YS5jb250ZW50c09iaixcbiAgICAgIHJpY2hUZXh0OiB0aGlzLmRhdGEucmljaFRleHQsXG4gICAgICByZWN0OiB0aGlzLmRhdGEucmVjdCxcbiAgICAgIHBhcmVudFJlY3Q6IHRoaXMuZGF0YS5wYXJlbnRSZWN0IHx8IG51bGwsXG4gICAgICBwYXJlbnQ6IHRoaXMucGFyZW50LFxuICAgICAgZWxlbWVudHM6IHRoaXMuZWxlbWVudHMsXG4gICAgICBvcGVuOiB0aGlzLmRhdGEub3BlblxuICAgIH0pO1xuICAgIGNvbnN0IGVsZW1lbnRJZHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5lbGVtZW50cykge1xuICAgICAgZWxlbWVudC5wb3B1cCA9IHBvcHVwO1xuICAgICAgZWxlbWVudC5jb250YWluZXIuYXJpYUhhc1BvcHVwID0gXCJkaWFsb2dcIjtcbiAgICAgIGVsZW1lbnRJZHMucHVzaChlbGVtZW50LmRhdGEuaWQpO1xuICAgICAgZWxlbWVudC5hZGRIaWdobGlnaHRBcmVhKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImFyaWEtY29udHJvbHNcIiwgZWxlbWVudElkcy5tYXAoaWQgPT4gYCR7QW5ub3RhdGlvblByZWZpeH0ke2lkfWApLmpvaW4oXCIsXCIpKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFBvcHVwRWxlbWVudCB7XG4gICNib3VuZEtleURvd24gPSB0aGlzLiNrZXlEb3duLmJpbmQodGhpcyk7XG4gICNib3VuZEhpZGUgPSB0aGlzLiNoaWRlLmJpbmQodGhpcyk7XG4gICNib3VuZFNob3cgPSB0aGlzLiNzaG93LmJpbmQodGhpcyk7XG4gICNib3VuZFRvZ2dsZSA9IHRoaXMuI3RvZ2dsZS5iaW5kKHRoaXMpO1xuICAjY29sb3IgPSBudWxsO1xuICAjY29udGFpbmVyID0gbnVsbDtcbiAgI2NvbnRlbnRzT2JqID0gbnVsbDtcbiAgI2RhdGVPYmogPSBudWxsO1xuICAjZWxlbWVudHMgPSBudWxsO1xuICAjcGFyZW50ID0gbnVsbDtcbiAgI3BhcmVudFJlY3QgPSBudWxsO1xuICAjcGlubmVkID0gZmFsc2U7XG4gICNwb3B1cCA9IG51bGw7XG4gICNwb3NpdGlvbiA9IG51bGw7XG4gICNyZWN0ID0gbnVsbDtcbiAgI3JpY2hUZXh0ID0gbnVsbDtcbiAgI3RpdGxlT2JqID0gbnVsbDtcbiAgI3VwZGF0ZXMgPSBudWxsO1xuICAjd2FzVmlzaWJsZSA9IGZhbHNlO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY29udGFpbmVyLFxuICAgIGNvbG9yLFxuICAgIGVsZW1lbnRzLFxuICAgIHRpdGxlT2JqLFxuICAgIG1vZGlmaWNhdGlvbkRhdGUsXG4gICAgY29udGVudHNPYmosXG4gICAgcmljaFRleHQsXG4gICAgcGFyZW50LFxuICAgIHJlY3QsXG4gICAgcGFyZW50UmVjdCxcbiAgICBvcGVuXG4gIH0pIHtcbiAgICB0aGlzLiNjb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy4jdGl0bGVPYmogPSB0aXRsZU9iajtcbiAgICB0aGlzLiNjb250ZW50c09iaiA9IGNvbnRlbnRzT2JqO1xuICAgIHRoaXMuI3JpY2hUZXh0ID0gcmljaFRleHQ7XG4gICAgdGhpcy4jcGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuI2NvbG9yID0gY29sb3I7XG4gICAgdGhpcy4jcmVjdCA9IHJlY3Q7XG4gICAgdGhpcy4jcGFyZW50UmVjdCA9IHBhcmVudFJlY3Q7XG4gICAgdGhpcy4jZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICB0aGlzLiNkYXRlT2JqID0gUERGRGF0ZVN0cmluZy50b0RhdGVPYmplY3QobW9kaWZpY2F0aW9uRGF0ZSk7XG4gICAgdGhpcy50cmlnZ2VyID0gZWxlbWVudHMuZmxhdE1hcChlID0+IGUuZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpKTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy50cmlnZ2VyKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNib3VuZFRvZ2dsZSk7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIHRoaXMuI2JvdW5kU2hvdyk7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMuI2JvdW5kSGlkZSk7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJwb3B1cFRyaWdnZXJBcmVhXCIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgIGVsZW1lbnQuY29udGFpbmVyPy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEtleURvd24pO1xuICAgIH1cbiAgICB0aGlzLiNjb250YWluZXIuaGlkZGVuID0gdHJ1ZTtcbiAgICBpZiAob3Blbikge1xuICAgICAgdGhpcy4jdG9nZ2xlKCk7XG4gICAgfVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy4jcG9wdXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcG9wdXAgPSB0aGlzLiNwb3B1cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgcG9wdXAuY2xhc3NOYW1lID0gXCJwb3B1cFwiO1xuICAgIGlmICh0aGlzLiNjb2xvcikge1xuICAgICAgY29uc3QgYmFzZUNvbG9yID0gcG9wdXAuc3R5bGUub3V0bGluZUNvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoLi4udGhpcy4jY29sb3IpO1xuICAgICAgcG9wdXAuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYGNvbG9yLW1peChpbiBzcmdiLCAke2Jhc2VDb2xvcn0gMzAlLCB3aGl0ZSlgO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBoZWFkZXIuY2xhc3NOYW1lID0gXCJoZWFkZXJcIjtcbiAgICBjb25zdCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoMVwiKTtcbiAgICBoZWFkZXIuYXBwZW5kKHRpdGxlKTtcbiAgICAoe1xuICAgICAgZGlyOiB0aXRsZS5kaXIsXG4gICAgICBzdHI6IHRpdGxlLnRleHRDb250ZW50XG4gICAgfSA9IHRoaXMuI3RpdGxlT2JqKTtcbiAgICBwb3B1cC5hcHBlbmQoaGVhZGVyKTtcbiAgICBpZiAodGhpcy4jZGF0ZU9iaikge1xuICAgICAgY29uc3QgbW9kaWZpY2F0aW9uRGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgbW9kaWZpY2F0aW9uRGF0ZS5jbGFzc0xpc3QuYWRkKFwicG9wdXBEYXRlXCIpO1xuICAgICAgbW9kaWZpY2F0aW9uRGF0ZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1hbm5vdGF0aW9uLWRhdGUtdGltZS1zdHJpbmdcIik7XG4gICAgICBtb2RpZmljYXRpb25EYXRlLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1hcmdzXCIsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgZGF0ZU9iajogdGhpcy4jZGF0ZU9iai52YWx1ZU9mKClcbiAgICAgIH0pKTtcbiAgICAgIGhlYWRlci5hcHBlbmQobW9kaWZpY2F0aW9uRGF0ZSk7XG4gICAgfVxuICAgIGNvbnN0IGh0bWwgPSB0aGlzLiNodG1sO1xuICAgIGlmIChodG1sKSB7XG4gICAgICBYZmFMYXllci5yZW5kZXIoe1xuICAgICAgICB4ZmFIdG1sOiBodG1sLFxuICAgICAgICBpbnRlbnQ6IFwicmljaFRleHRcIixcbiAgICAgICAgZGl2OiBwb3B1cFxuICAgICAgfSk7XG4gICAgICBwb3B1cC5sYXN0Q2hpbGQuY2xhc3NMaXN0LmFkZChcInJpY2hUZXh0XCIsIFwicG9wdXBDb250ZW50XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb250ZW50cyA9IHRoaXMuX2Zvcm1hdENvbnRlbnRzKHRoaXMuI2NvbnRlbnRzT2JqKTtcbiAgICAgIHBvcHVwLmFwcGVuZChjb250ZW50cyk7XG4gICAgfVxuICAgIHRoaXMuI2NvbnRhaW5lci5hcHBlbmQocG9wdXApO1xuICB9XG4gIGdldCAjaHRtbCgpIHtcbiAgICBjb25zdCByaWNoVGV4dCA9IHRoaXMuI3JpY2hUZXh0O1xuICAgIGNvbnN0IGNvbnRlbnRzT2JqID0gdGhpcy4jY29udGVudHNPYmo7XG4gICAgaWYgKHJpY2hUZXh0Py5zdHIgJiYgKCFjb250ZW50c09iaj8uc3RyIHx8IGNvbnRlbnRzT2JqLnN0ciA9PT0gcmljaFRleHQuc3RyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuI3JpY2hUZXh0Lmh0bWwgfHwgbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0ICNmb250U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaHRtbD8uYXR0cmlidXRlcz8uc3R5bGU/LmZvbnRTaXplIHx8IDA7XG4gIH1cbiAgZ2V0ICNmb250Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2h0bWw/LmF0dHJpYnV0ZXM/LnN0eWxlPy5jb2xvciB8fCBudWxsO1xuICB9XG4gICNtYWtlUG9wdXBDb250ZW50KHRleHQpIHtcbiAgICBjb25zdCBwb3B1cExpbmVzID0gW107XG4gICAgY29uc3QgcG9wdXBDb250ZW50ID0ge1xuICAgICAgc3RyOiB0ZXh0LFxuICAgICAgaHRtbDoge1xuICAgICAgICBuYW1lOiBcImRpdlwiLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgZGlyOiBcImF1dG9cIlxuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICBuYW1lOiBcInBcIixcbiAgICAgICAgICBjaGlsZHJlbjogcG9wdXBMaW5lc1xuICAgICAgICB9XVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbGluZUF0dHJpYnV0ZXMgPSB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBjb2xvcjogdGhpcy4jZm9udENvbG9yLFxuICAgICAgICBmb250U2l6ZTogdGhpcy4jZm9udFNpemUgPyBgY2FsYygke3RoaXMuI2ZvbnRTaXplfXB4ICogdmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSlgIDogXCJcIlxuICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIHRleHQuc3BsaXQoXCJcXG5cIikpIHtcbiAgICAgIHBvcHVwTGluZXMucHVzaCh7XG4gICAgICAgIG5hbWU6IFwic3BhblwiLFxuICAgICAgICB2YWx1ZTogbGluZSxcbiAgICAgICAgYXR0cmlidXRlczogbGluZUF0dHJpYnV0ZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcG9wdXBDb250ZW50O1xuICB9XG4gIF9mb3JtYXRDb250ZW50cyh7XG4gICAgc3RyLFxuICAgIGRpclxuICB9KSB7XG4gICAgY29uc3QgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpO1xuICAgIHAuY2xhc3NMaXN0LmFkZChcInBvcHVwQ29udGVudFwiKTtcbiAgICBwLmRpciA9IGRpcjtcbiAgICBjb25zdCBsaW5lcyA9IHN0ci5zcGxpdCgvKD86XFxyXFxuP3xcXG4pLyk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGluZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgcC5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGluZSkpO1xuICAgICAgaWYgKGkgPCBpaSAtIDEpIHtcbiAgICAgICAgcC5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgI2tleURvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYWx0S2V5IHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQua2V5ID09PSBcIkVudGVyXCIgfHwgZXZlbnQua2V5ID09PSBcIkVzY2FwZVwiICYmIHRoaXMuI3Bpbm5lZCkge1xuICAgICAgdGhpcy4jdG9nZ2xlKCk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZUVkaXRlZCh7XG4gICAgcmVjdCxcbiAgICBwb3B1cENvbnRlbnRcbiAgfSkge1xuICAgIHRoaXMuI3VwZGF0ZXMgfHw9IHtcbiAgICAgIGNvbnRlbnRzT2JqOiB0aGlzLiNjb250ZW50c09iaixcbiAgICAgIHJpY2hUZXh0OiB0aGlzLiNyaWNoVGV4dFxuICAgIH07XG4gICAgaWYgKHJlY3QpIHtcbiAgICAgIHRoaXMuI3Bvc2l0aW9uID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHBvcHVwQ29udGVudCkge1xuICAgICAgdGhpcy4jcmljaFRleHQgPSB0aGlzLiNtYWtlUG9wdXBDb250ZW50KHBvcHVwQ29udGVudCk7XG4gICAgICB0aGlzLiNjb250ZW50c09iaiA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuI3BvcHVwPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNwb3B1cCA9IG51bGw7XG4gIH1cbiAgcmVzZXRFZGl0ZWQoKSB7XG4gICAgaWYgKCF0aGlzLiN1cGRhdGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICh7XG4gICAgICBjb250ZW50c09iajogdGhpcy4jY29udGVudHNPYmosXG4gICAgICByaWNoVGV4dDogdGhpcy4jcmljaFRleHRcbiAgICB9ID0gdGhpcy4jdXBkYXRlcyk7XG4gICAgdGhpcy4jdXBkYXRlcyA9IG51bGw7XG4gICAgdGhpcy4jcG9wdXA/LnJlbW92ZSgpO1xuICAgIHRoaXMuI3BvcHVwID0gbnVsbDtcbiAgICB0aGlzLiNwb3NpdGlvbiA9IG51bGw7XG4gIH1cbiAgI3NldFBvc2l0aW9uKCkge1xuICAgIGlmICh0aGlzLiNwb3NpdGlvbiAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwYWdlOiB7XG4gICAgICAgIHZpZXdcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICByYXdEaW1zOiB7XG4gICAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICAgICAgcGFnZVgsXG4gICAgICAgICAgcGFnZVlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gPSB0aGlzLiNwYXJlbnQ7XG4gICAgbGV0IHVzZVBhcmVudFJlY3QgPSAhIXRoaXMuI3BhcmVudFJlY3Q7XG4gICAgbGV0IHJlY3QgPSB1c2VQYXJlbnRSZWN0ID8gdGhpcy4jcGFyZW50UmVjdCA6IHRoaXMuI3JlY3Q7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMuI2VsZW1lbnRzKSB7XG4gICAgICBpZiAoIXJlY3QgfHwgVXRpbC5pbnRlcnNlY3QoZWxlbWVudC5kYXRhLnJlY3QsIHJlY3QpICE9PSBudWxsKSB7XG4gICAgICAgIHJlY3QgPSBlbGVtZW50LmRhdGEucmVjdDtcbiAgICAgICAgdXNlUGFyZW50UmVjdCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBub3JtYWxpemVkUmVjdCA9IFV0aWwubm9ybWFsaXplUmVjdChbcmVjdFswXSwgdmlld1szXSAtIHJlY3RbMV0gKyB2aWV3WzFdLCByZWN0WzJdLCB2aWV3WzNdIC0gcmVjdFszXSArIHZpZXdbMV1dKTtcbiAgICBjb25zdCBIT1JJWk9OVEFMX1NQQUNFX0FGVEVSX0FOTk9UQVRJT04gPSA1O1xuICAgIGNvbnN0IHBhcmVudFdpZHRoID0gdXNlUGFyZW50UmVjdCA/IHJlY3RbMl0gLSByZWN0WzBdICsgSE9SSVpPTlRBTF9TUEFDRV9BRlRFUl9BTk5PVEFUSU9OIDogMDtcbiAgICBjb25zdCBwb3B1cExlZnQgPSBub3JtYWxpemVkUmVjdFswXSArIHBhcmVudFdpZHRoO1xuICAgIGNvbnN0IHBvcHVwVG9wID0gbm9ybWFsaXplZFJlY3RbMV07XG4gICAgdGhpcy4jcG9zaXRpb24gPSBbMTAwICogKHBvcHVwTGVmdCAtIHBhZ2VYKSAvIHBhZ2VXaWR0aCwgMTAwICogKHBvcHVwVG9wIC0gcGFnZVkpIC8gcGFnZUhlaWdodF07XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy4jY29udGFpbmVyO1xuICAgIHN0eWxlLmxlZnQgPSBgJHt0aGlzLiNwb3NpdGlvblswXX0lYDtcbiAgICBzdHlsZS50b3AgPSBgJHt0aGlzLiNwb3NpdGlvblsxXX0lYDtcbiAgfVxuICAjdG9nZ2xlKCkge1xuICAgIHRoaXMuI3Bpbm5lZCA9ICF0aGlzLiNwaW5uZWQ7XG4gICAgaWYgKHRoaXMuI3Bpbm5lZCkge1xuICAgICAgdGhpcy4jc2hvdygpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNib3VuZFRvZ2dsZSk7XG4gICAgICB0aGlzLiNjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRLZXlEb3duKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jaGlkZSgpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNib3VuZFRvZ2dsZSk7XG4gICAgICB0aGlzLiNjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRLZXlEb3duKTtcbiAgICB9XG4gIH1cbiAgI3Nob3coKSB7XG4gICAgaWYgKCF0aGlzLiNwb3B1cCkge1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgdGhpcy4jc2V0UG9zaXRpb24oKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5zdHlsZS56SW5kZXggPSBwYXJzZUludCh0aGlzLiNjb250YWluZXIuc3R5bGUuekluZGV4KSArIDEwMDA7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNwaW5uZWQpIHtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiZm9jdXNlZFwiKTtcbiAgICB9XG4gIH1cbiAgI2hpZGUoKSB7XG4gICAgdGhpcy4jY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoXCJmb2N1c2VkXCIpO1xuICAgIGlmICh0aGlzLiNwaW5uZWQgfHwgIXRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSB0cnVlO1xuICAgIHRoaXMuI2NvbnRhaW5lci5zdHlsZS56SW5kZXggPSBwYXJzZUludCh0aGlzLiNjb250YWluZXIuc3R5bGUuekluZGV4KSAtIDEwMDA7XG4gIH1cbiAgZm9yY2VIaWRlKCkge1xuICAgIHRoaXMuI3dhc1Zpc2libGUgPSB0aGlzLmlzVmlzaWJsZTtcbiAgICBpZiAoIXRoaXMuI3dhc1Zpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IHRydWU7XG4gIH1cbiAgbWF5YmVTaG93KCkge1xuICAgIGlmICghdGhpcy4jd2FzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI3BvcHVwKSB7XG4gICAgICB0aGlzLiNzaG93KCk7XG4gICAgfVxuICAgIHRoaXMuI3dhc1Zpc2libGUgPSBmYWxzZTtcbiAgICB0aGlzLiNjb250YWluZXIuaGlkZGVuID0gZmFsc2U7XG4gIH1cbiAgZ2V0IGlzVmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9PT0gZmFsc2U7XG4gIH1cbn1cbmNsYXNzIEZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gcGFyYW1ldGVycy5kYXRhLnRleHRDb250ZW50O1xuICAgIHRoaXMudGV4dFBvc2l0aW9uID0gcGFyYW1ldGVycy5kYXRhLnRleHRQb3NpdGlvbjtcbiAgICB0aGlzLmFubm90YXRpb25FZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQ7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJmcmVlVGV4dEFubm90YXRpb25cIik7XG4gICAgaWYgKHRoaXMudGV4dENvbnRlbnQpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKFwiYW5ub3RhdGlvblRleHRDb250ZW50XCIpO1xuICAgICAgY29udGVudC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiY29tbWVudFwiKTtcbiAgICAgIGZvciAoY29uc3QgbGluZSBvZiB0aGlzLnRleHRDb250ZW50KSB7XG4gICAgICAgIGNvbnN0IGxpbmVTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIGxpbmVTcGFuLnRleHRDb250ZW50ID0gbGluZTtcbiAgICAgICAgY29udGVudC5hcHBlbmQobGluZVNwYW4pO1xuICAgICAgfVxuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGNvbnRlbnQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5fZWRpdE9uRG91YmxlQ2xpY2soKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIExpbmVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI2xpbmUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJsaW5lQW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGNvbnN0IGxpbmUgPSB0aGlzLiNsaW5lID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6bGluZVwiKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcIngxXCIsIGRhdGEucmVjdFsyXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzBdKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcInkxXCIsIGRhdGEucmVjdFszXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzFdKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcIngyXCIsIGRhdGEucmVjdFsyXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzJdKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcInkyXCIsIGRhdGEucmVjdFszXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzNdKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBkYXRhLmJvcmRlclN0eWxlLndpZHRoIHx8IDEpO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3ZnLmFwcGVuZChsaW5lKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNsaW5lO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmNsYXNzIFNxdWFyZUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjc3F1YXJlID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwic3F1YXJlQW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGNvbnN0IGJvcmRlcldpZHRoID0gZGF0YS5ib3JkZXJTdHlsZS53aWR0aDtcbiAgICBjb25zdCBzcXVhcmUgPSB0aGlzLiNzcXVhcmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpyZWN0XCIpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJ4XCIsIGJvcmRlcldpZHRoIC8gMik7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInlcIiwgYm9yZGVyV2lkdGggLyAyKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgd2lkdGggLSBib3JkZXJXaWR0aCk7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBoZWlnaHQgLSBib3JkZXJXaWR0aCk7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBib3JkZXJXaWR0aCB8fCAxKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzdmcuYXBwZW5kKHNxdWFyZSk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgaWYgKCFkYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jc3F1YXJlO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmNsYXNzIENpcmNsZUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjY2lyY2xlID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiY2lyY2xlQW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGNvbnN0IGJvcmRlcldpZHRoID0gZGF0YS5ib3JkZXJTdHlsZS53aWR0aDtcbiAgICBjb25zdCBjaXJjbGUgPSB0aGlzLiNjaXJjbGUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzplbGxpcHNlXCIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJjeFwiLCB3aWR0aCAvIDIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJjeVwiLCBoZWlnaHQgLyAyKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwicnhcIiwgd2lkdGggLyAyIC0gYm9yZGVyV2lkdGggLyAyKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwicnlcIiwgaGVpZ2h0IC8gMiAtIGJvcmRlcldpZHRoIC8gMik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBib3JkZXJXaWR0aCB8fCAxKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzdmcuYXBwZW5kKGNpcmNsZSk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgaWYgKCFkYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY2lyY2xlO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmNsYXNzIFBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNwb2x5bGluZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSA9IFwicG9seWxpbmVBbm5vdGF0aW9uXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50TmFtZSA9IFwic3ZnOnBvbHlsaW5lXCI7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQodGhpcy5jb250YWluZXJDbGFzc05hbWUpO1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcmVjdCxcbiAgICAgICAgdmVydGljZXMsXG4gICAgICAgIGJvcmRlclN0eWxlLFxuICAgICAgICBwb3B1cFJlZlxuICAgICAgfSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCF2ZXJ0aWNlcykge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH1cbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGxldCBwb2ludHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBjb25zdCB4ID0gdmVydGljZXNbaV0gLSByZWN0WzBdO1xuICAgICAgY29uc3QgeSA9IHJlY3RbM10gLSB2ZXJ0aWNlc1tpICsgMV07XG4gICAgICBwb2ludHMucHVzaChgJHt4fSwke3l9YCk7XG4gICAgfVxuICAgIHBvaW50cyA9IHBvaW50cy5qb2luKFwiIFwiKTtcbiAgICBjb25zdCBwb2x5bGluZSA9IHRoaXMuI3BvbHlsaW5lID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQodGhpcy5zdmdFbGVtZW50TmFtZSk7XG4gICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwicG9pbnRzXCIsIHBvaW50cyk7XG4gICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGJvcmRlclN0eWxlLndpZHRoIHx8IDEpO1xuICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzdmcuYXBwZW5kKHBvbHlsaW5lKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICBpZiAoIXBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9seWxpbmU7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuY2xhc3MgUG9seWdvbkFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgUG9seWxpbmVBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzKTtcbiAgICB0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSA9IFwicG9seWdvbkFubm90YXRpb25cIjtcbiAgICB0aGlzLnN2Z0VsZW1lbnROYW1lID0gXCJzdmc6cG9seWdvblwiO1xuICB9XG59XG5jbGFzcyBDYXJldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJjYXJldEFubm90YXRpb25cIik7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgSW5rQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNwb2x5bGluZXNHcm91cEVsZW1lbnQgPSBudWxsO1xuICAjcG9seWxpbmVzID0gW107XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSA9IFwiaW5rQW5ub3RhdGlvblwiO1xuICAgIHRoaXMuc3ZnRWxlbWVudE5hbWUgPSBcInN2Zzpwb2x5bGluZVwiO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVkaXRvclR5cGUgPSB0aGlzLmRhdGEuaXQgPT09IFwiSW5rSGlnaGxpZ2h0XCIgPyBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQgOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5JTks7XG4gIH1cbiAgI2dldFRyYW5zZm9ybShyb3RhdGlvbiwgcmVjdCkge1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlKDkwKSB0cmFuc2xhdGUoJHstcmVjdFswXX0sJHtyZWN0WzFdfSkgc2NhbGUoMSwtMSlgLFxuICAgICAgICAgIHdpZHRoOiByZWN0WzNdIC0gcmVjdFsxXSxcbiAgICAgICAgICBoZWlnaHQ6IHJlY3RbMl0gLSByZWN0WzBdXG4gICAgICAgIH07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGUoMTgwKSB0cmFuc2xhdGUoJHstcmVjdFsyXX0sJHtyZWN0WzFdfSkgc2NhbGUoMSwtMSlgLFxuICAgICAgICAgIHdpZHRoOiByZWN0WzJdIC0gcmVjdFswXSxcbiAgICAgICAgICBoZWlnaHQ6IHJlY3RbM10gLSByZWN0WzFdXG4gICAgICAgIH07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGUoMjcwKSB0cmFuc2xhdGUoJHstcmVjdFsyXX0sJHtyZWN0WzNdfSkgc2NhbGUoMSwtMSlgLFxuICAgICAgICAgIHdpZHRoOiByZWN0WzNdIC0gcmVjdFsxXSxcbiAgICAgICAgICBoZWlnaHQ6IHJlY3RbMl0gLSByZWN0WzBdXG4gICAgICAgIH07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgkey1yZWN0WzBdfSwke3JlY3RbM119KSBzY2FsZSgxLC0xKWAsXG4gICAgICAgICAgd2lkdGg6IHJlY3RbMl0gLSByZWN0WzBdLFxuICAgICAgICAgIGhlaWdodDogcmVjdFszXSAtIHJlY3RbMV1cbiAgICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQodGhpcy5jb250YWluZXJDbGFzc05hbWUpO1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcmVjdCxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGlua0xpc3RzLFxuICAgICAgICBib3JkZXJTdHlsZSxcbiAgICAgICAgcG9wdXBSZWZcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzLiNnZXRUcmFuc2Zvcm0ocm90YXRpb24sIHJlY3QpO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgY29uc3QgZyA9IHRoaXMuI3BvbHlsaW5lc0dyb3VwRWxlbWVudCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmdcIik7XG4gICAgc3ZnLmFwcGVuZChnKTtcbiAgICBnLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBib3JkZXJTdHlsZS53aWR0aCB8fCAxKTtcbiAgICBnLnNldEF0dHJpYnV0ZShcInN0cm9rZS1saW5lY2FwXCIsIFwicm91bmRcIik7XG4gICAgZy5zZXRBdHRyaWJ1dGUoXCJzdHJva2UtbGluZWpvaW5cIiwgXCJyb3VuZFwiKTtcbiAgICBnLnNldEF0dHJpYnV0ZShcInN0cm9rZS1taXRlcmxpbWl0XCIsIDEwKTtcbiAgICBnLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIGcuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIGcuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gaW5rTGlzdHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgY29uc3QgcG9seWxpbmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudCh0aGlzLnN2Z0VsZW1lbnROYW1lKTtcbiAgICAgIHRoaXMuI3BvbHlsaW5lcy5wdXNoKHBvbHlsaW5lKTtcbiAgICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInBvaW50c1wiLCBpbmtMaXN0c1tpXS5qb2luKFwiLFwiKSk7XG4gICAgICBnLmFwcGVuZChwb2x5bGluZSk7XG4gICAgfVxuICAgIGlmICghcG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIHRoaXMuX2VkaXRPbkRvdWJsZUNsaWNrKCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIHVwZGF0ZUVkaXRlZChwYXJhbXMpIHtcbiAgICBzdXBlci51cGRhdGVFZGl0ZWQocGFyYW1zKTtcbiAgICBjb25zdCB7XG4gICAgICB0aGlja25lc3MsXG4gICAgICBwb2ludHMsXG4gICAgICByZWN0XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCBnID0gdGhpcy4jcG9seWxpbmVzR3JvdXBFbGVtZW50O1xuICAgIGlmICh0aGlja25lc3MgPj0gMCkge1xuICAgICAgZy5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgdGhpY2tuZXNzIHx8IDEpO1xuICAgIH1cbiAgICBpZiAocG9pbnRzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB0aGlzLiNwb2x5bGluZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICB0aGlzLiNwb2x5bGluZXNbaV0uc2V0QXR0cmlidXRlKFwicG9pbnRzXCIsIHBvaW50c1tpXS5qb2luKFwiLFwiKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZWN0KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IHRoaXMuI2dldFRyYW5zZm9ybSh0aGlzLmRhdGEucm90YXRpb24sIHJlY3QpO1xuICAgICAgY29uc3Qgcm9vdCA9IGcucGFyZW50RWxlbWVudDtcbiAgICAgIHJvb3Quc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBgMCAwICR7d2lkdGh9ICR7aGVpZ2h0fWApO1xuICAgICAgZy5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKTtcbiAgICB9XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9seWxpbmVzO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmNsYXNzIEhpZ2hsaWdodEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmFubm90YXRpb25FZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFubm90YXRpb25cIik7XG4gICAgdGhpcy5fZWRpdE9uRG91YmxlQ2xpY2soKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFVuZGVybGluZUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ1bmRlcmxpbmVBbm5vdGF0aW9uXCIpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgU3F1aWdnbHlBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZSxcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwic3F1aWdnbHlBbm5vdGF0aW9uXCIpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgU3RyaWtlT3V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWUsXG4gICAgICBjcmVhdGVRdWFkcmlsYXRlcmFsczogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInN0cmlrZW91dEFubm90YXRpb25cIik7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBTdGFtcEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5hbm5vdGF0aW9uRWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwic3RhbXBBbm5vdGF0aW9uXCIpO1xuICAgIHRoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJpbWdcIik7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuX2VkaXRPbkRvdWJsZUNsaWNrKCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBGaWxlQXR0YWNobWVudEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjdHJpZ2dlciA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBmaWxlXG4gICAgfSA9IHRoaXMuZGF0YTtcbiAgICB0aGlzLmZpbGVuYW1lID0gZmlsZS5maWxlbmFtZTtcbiAgICB0aGlzLmNvbnRlbnQgPSBmaWxlLmNvbnRlbnQ7XG4gICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJmaWxlYXR0YWNobWVudGFubm90YXRpb25cIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgLi4uZmlsZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiZmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGRhdGFcbiAgICB9ID0gdGhpcztcbiAgICBsZXQgdHJpZ2dlcjtcbiAgICBpZiAoZGF0YS5oYXNBcHBlYXJhbmNlIHx8IGRhdGEuZmlsbEFscGhhID09PSAwKSB7XG4gICAgICB0cmlnZ2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJpZ2dlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICB0cmlnZ2VyLnNyYyA9IGAke3RoaXMuaW1hZ2VSZXNvdXJjZXNQYXRofWFubm90YXRpb24tJHsvcGFwZXJjbGlwL2kudGVzdChkYXRhLm5hbWUpID8gXCJwYXBlcmNsaXBcIiA6IFwicHVzaHBpblwifS5zdmdgO1xuICAgICAgaWYgKGRhdGEuZmlsbEFscGhhICYmIGRhdGEuZmlsbEFscGhhIDwgMSkge1xuICAgICAgICB0cmlnZ2VyLnN0eWxlID0gYGZpbHRlcjogb3BhY2l0eSgke01hdGgucm91bmQoZGF0YS5maWxsQWxwaGEgKiAxMDApfSUpO2A7XG4gICAgICB9XG4gICAgfVxuICAgIHRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcihcImRibGNsaWNrXCIsIHRoaXMuI2Rvd25sb2FkLmJpbmQodGhpcykpO1xuICAgIHRoaXMuI3RyaWdnZXIgPSB0cmlnZ2VyO1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGV2dCA9PiB7XG4gICAgICBpZiAoZXZ0LmtleSA9PT0gXCJFbnRlclwiICYmIChpc01hYyA/IGV2dC5tZXRhS2V5IDogZXZ0LmN0cmxLZXkpKSB7XG4gICAgICAgIHRoaXMuI2Rvd25sb2FkKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFkYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmlnZ2VyLmNsYXNzTGlzdC5hZGQoXCJwb3B1cFRyaWdnZXJBcmVhXCIpO1xuICAgIH1cbiAgICBjb250YWluZXIuYXBwZW5kKHRyaWdnZXIpO1xuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jdHJpZ2dlcjtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG4gICNkb3dubG9hZCgpIHtcbiAgICB0aGlzLmRvd25sb2FkTWFuYWdlcj8ub3Blbk9yRG93bmxvYWREYXRhKHRoaXMuY29udGVudCwgdGhpcy5maWxlbmFtZSk7XG4gIH1cbn1cbmNsYXNzIEFubm90YXRpb25MYXllciB7XG4gICNhY2Nlc3NpYmlsaXR5TWFuYWdlciA9IG51bGw7XG4gICNhbm5vdGF0aW9uQ2FudmFzTWFwID0gbnVsbDtcbiAgI2VkaXRhYmxlQW5ub3RhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICNzdHJ1Y3RUcmVlTGF5ZXIgPSBudWxsO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZGl2LFxuICAgIGFjY2Vzc2liaWxpdHlNYW5hZ2VyLFxuICAgIGFubm90YXRpb25DYW52YXNNYXAsXG4gICAgYW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlcixcbiAgICBwYWdlLFxuICAgIHZpZXdwb3J0LFxuICAgIHN0cnVjdFRyZWVMYXllclxuICB9KSB7XG4gICAgdGhpcy5kaXYgPSBkaXY7XG4gICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXIgPSBhY2Nlc3NpYmlsaXR5TWFuYWdlcjtcbiAgICB0aGlzLiNhbm5vdGF0aW9uQ2FudmFzTWFwID0gYW5ub3RhdGlvbkNhbnZhc01hcDtcbiAgICB0aGlzLiNzdHJ1Y3RUcmVlTGF5ZXIgPSBzdHJ1Y3RUcmVlTGF5ZXIgfHwgbnVsbDtcbiAgICB0aGlzLnBhZ2UgPSBwYWdlO1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICB0aGlzLnpJbmRleCA9IDA7XG4gICAgdGhpcy5fYW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlciA9IGFubm90YXRpb25FZGl0b3JVSU1hbmFnZXI7XG4gIH1cbiAgaGFzRWRpdGFibGVBbm5vdGF0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy4jZWRpdGFibGVBbm5vdGF0aW9ucy5zaXplID4gMDtcbiAgfVxuICBhc3luYyAjYXBwZW5kRWxlbWVudChlbGVtZW50LCBpZCkge1xuICAgIGNvbnN0IGNvbnRlbnRFbGVtZW50ID0gZWxlbWVudC5maXJzdENoaWxkIHx8IGVsZW1lbnQ7XG4gICAgY29uc3QgYW5ub3RhdGlvbklkID0gY29udGVudEVsZW1lbnQuaWQgPSBgJHtBbm5vdGF0aW9uUHJlZml4fSR7aWR9YDtcbiAgICBjb25zdCBhcmlhQXR0cmlidXRlcyA9IGF3YWl0IHRoaXMuI3N0cnVjdFRyZWVMYXllcj8uZ2V0QXJpYUF0dHJpYnV0ZXMoYW5ub3RhdGlvbklkKTtcbiAgICBpZiAoYXJpYUF0dHJpYnV0ZXMpIHtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGFyaWFBdHRyaWJ1dGVzKSB7XG4gICAgICAgIGNvbnRlbnRFbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kaXYuYXBwZW5kKGVsZW1lbnQpO1xuICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyPy5tb3ZlRWxlbWVudEluRE9NKHRoaXMuZGl2LCBlbGVtZW50LCBjb250ZW50RWxlbWVudCwgZmFsc2UpO1xuICB9XG4gIGFzeW5jIHJlbmRlcihwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBhbm5vdGF0aW9uc1xuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmRpdjtcbiAgICBzZXRMYXllckRpbWVuc2lvbnMobGF5ZXIsIHRoaXMudmlld3BvcnQpO1xuICAgIGNvbnN0IHBvcHVwVG9FbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBlbGVtZW50UGFyYW1zID0ge1xuICAgICAgZGF0YTogbnVsbCxcbiAgICAgIGxheWVyLFxuICAgICAgbGlua1NlcnZpY2U6IHBhcmFtcy5saW5rU2VydmljZSxcbiAgICAgIGRvd25sb2FkTWFuYWdlcjogcGFyYW1zLmRvd25sb2FkTWFuYWdlcixcbiAgICAgIGltYWdlUmVzb3VyY2VzUGF0aDogcGFyYW1zLmltYWdlUmVzb3VyY2VzUGF0aCB8fCBcIlwiLFxuICAgICAgcmVuZGVyRm9ybXM6IHBhcmFtcy5yZW5kZXJGb3JtcyAhPT0gZmFsc2UsXG4gICAgICBzdmdGYWN0b3J5OiBuZXcgRE9NU1ZHRmFjdG9yeSgpLFxuICAgICAgYW5ub3RhdGlvblN0b3JhZ2U6IHBhcmFtcy5hbm5vdGF0aW9uU3RvcmFnZSB8fCBuZXcgQW5ub3RhdGlvblN0b3JhZ2UoKSxcbiAgICAgIGVuYWJsZVNjcmlwdGluZzogcGFyYW1zLmVuYWJsZVNjcmlwdGluZyA9PT0gdHJ1ZSxcbiAgICAgIGhhc0pTQWN0aW9uczogcGFyYW1zLmhhc0pTQWN0aW9ucyxcbiAgICAgIGZpZWxkT2JqZWN0czogcGFyYW1zLmZpZWxkT2JqZWN0cyxcbiAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgIGVsZW1lbnRzOiBudWxsXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGRhdGEgb2YgYW5ub3RhdGlvbnMpIHtcbiAgICAgIGlmIChkYXRhLm5vSFRNTCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzUG9wdXBBbm5vdGF0aW9uID0gZGF0YS5hbm5vdGF0aW9uVHlwZSA9PT0gQW5ub3RhdGlvblR5cGUuUE9QVVA7XG4gICAgICBpZiAoIWlzUG9wdXBBbm5vdGF0aW9uKSB7XG4gICAgICAgIGlmIChkYXRhLnJlY3RbMl0gPT09IGRhdGEucmVjdFswXSB8fCBkYXRhLnJlY3RbM10gPT09IGRhdGEucmVjdFsxXSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHBvcHVwVG9FbGVtZW50cy5nZXQoZGF0YS5pZCk7XG4gICAgICAgIGlmICghZWxlbWVudHMpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50UGFyYW1zLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgICB9XG4gICAgICBlbGVtZW50UGFyYW1zLmRhdGEgPSBkYXRhO1xuICAgICAgY29uc3QgZWxlbWVudCA9IEFubm90YXRpb25FbGVtZW50RmFjdG9yeS5jcmVhdGUoZWxlbWVudFBhcmFtcyk7XG4gICAgICBpZiAoIWVsZW1lbnQuaXNSZW5kZXJhYmxlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFpc1BvcHVwQW5ub3RhdGlvbiAmJiBkYXRhLnBvcHVwUmVmKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gcG9wdXBUb0VsZW1lbnRzLmdldChkYXRhLnBvcHVwUmVmKTtcbiAgICAgICAgaWYgKCFlbGVtZW50cykge1xuICAgICAgICAgIHBvcHVwVG9FbGVtZW50cy5zZXQoZGF0YS5wb3B1cFJlZiwgW2VsZW1lbnRdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCByZW5kZXJlZCA9IGVsZW1lbnQucmVuZGVyKCk7XG4gICAgICBpZiAoZGF0YS5oaWRkZW4pIHtcbiAgICAgICAgcmVuZGVyZWQuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLiNhcHBlbmRFbGVtZW50KHJlbmRlcmVkLCBkYXRhLmlkKTtcbiAgICAgIGlmIChlbGVtZW50Ll9pc0VkaXRhYmxlKSB7XG4gICAgICAgIHRoaXMuI2VkaXRhYmxlQW5ub3RhdGlvbnMuc2V0KGVsZW1lbnQuZGF0YS5pZCwgZWxlbWVudCk7XG4gICAgICAgIHRoaXMuX2Fubm90YXRpb25FZGl0b3JVSU1hbmFnZXI/LnJlbmRlckFubm90YXRpb25FbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNzZXRBbm5vdGF0aW9uQ2FudmFzTWFwKCk7XG4gIH1cbiAgYXN5bmMgYWRkTGlua0Fubm90YXRpb25zKGFubm90YXRpb25zLCBsaW5rU2VydmljZSkge1xuICAgIGNvbnN0IGVsZW1lbnRQYXJhbXMgPSB7XG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgbGF5ZXI6IHRoaXMuZGl2LFxuICAgICAgbGlua1NlcnZpY2UsXG4gICAgICBzdmdGYWN0b3J5OiBuZXcgRE9NU1ZHRmFjdG9yeSgpLFxuICAgICAgcGFyZW50OiB0aGlzXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGRhdGEgb2YgYW5ub3RhdGlvbnMpIHtcbiAgICAgIGRhdGEuYm9yZGVyU3R5bGUgfHw9IEFubm90YXRpb25MYXllci5fZGVmYXVsdEJvcmRlclN0eWxlO1xuICAgICAgZWxlbWVudFBhcmFtcy5kYXRhID0gZGF0YTtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBBbm5vdGF0aW9uRWxlbWVudEZhY3RvcnkuY3JlYXRlKGVsZW1lbnRQYXJhbXMpO1xuICAgICAgaWYgKCFlbGVtZW50LmlzUmVuZGVyYWJsZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbmRlcmVkID0gZWxlbWVudC5yZW5kZXIoKTtcbiAgICAgIGF3YWl0IHRoaXMuI2FwcGVuZEVsZW1lbnQocmVuZGVyZWQsIGRhdGEuaWQpO1xuICAgIH1cbiAgfVxuICB1cGRhdGUoe1xuICAgIHZpZXdwb3J0XG4gIH0pIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuZGl2O1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICBzZXRMYXllckRpbWVuc2lvbnMobGF5ZXIsIHtcbiAgICAgIHJvdGF0aW9uOiB2aWV3cG9ydC5yb3RhdGlvblxuICAgIH0pO1xuICAgIHRoaXMuI3NldEFubm90YXRpb25DYW52YXNNYXAoKTtcbiAgICBsYXllci5oaWRkZW4gPSBmYWxzZTtcbiAgfVxuICAjc2V0QW5ub3RhdGlvbkNhbnZhc01hcCgpIHtcbiAgICBpZiAoIXRoaXMuI2Fubm90YXRpb25DYW52YXNNYXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmRpdjtcbiAgICBmb3IgKGNvbnN0IFtpZCwgY2FudmFzXSBvZiB0aGlzLiNhbm5vdGF0aW9uQ2FudmFzTWFwKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gbGF5ZXIucXVlcnlTZWxlY3RvcihgW2RhdGEtYW5ub3RhdGlvbi1pZD1cIiR7aWR9XCJdYCk7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjYW52YXMuY2xhc3NOYW1lID0gXCJhbm5vdGF0aW9uQ29udGVudFwiO1xuICAgICAgY29uc3Qge1xuICAgICAgICBmaXJzdENoaWxkXG4gICAgICB9ID0gZWxlbWVudDtcbiAgICAgIGlmICghZmlyc3RDaGlsZCkge1xuICAgICAgICBlbGVtZW50LmFwcGVuZChjYW52YXMpO1xuICAgICAgfSBlbHNlIGlmIChmaXJzdENoaWxkLm5vZGVOYW1lID09PSBcIkNBTlZBU1wiKSB7XG4gICAgICAgIGZpcnN0Q2hpbGQucmVwbGFjZVdpdGgoY2FudmFzKTtcbiAgICAgIH0gZWxzZSBpZiAoIWZpcnN0Q2hpbGQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYW5ub3RhdGlvbkNvbnRlbnRcIikpIHtcbiAgICAgICAgZmlyc3RDaGlsZC5iZWZvcmUoY2FudmFzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0Q2hpbGQuYWZ0ZXIoY2FudmFzKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVkaXRhYmxlQW5ub3RhdGlvbiA9IHRoaXMuI2VkaXRhYmxlQW5ub3RhdGlvbnMuZ2V0KGlkKTtcbiAgICAgIGlmICghZWRpdGFibGVBbm5vdGF0aW9uKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGVkaXRhYmxlQW5ub3RhdGlvbi5faGFzTm9DYW52YXMpIHtcbiAgICAgICAgdGhpcy5fYW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlcj8uc2V0TWlzc2luZ0NhbnZhcyhpZCwgZWxlbWVudC5pZCwgY2FudmFzKTtcbiAgICAgICAgZWRpdGFibGVBbm5vdGF0aW9uLl9oYXNOb0NhbnZhcyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdGFibGVBbm5vdGF0aW9uLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jYW5ub3RhdGlvbkNhbnZhc01hcC5jbGVhcigpO1xuICB9XG4gIGdldEVkaXRhYmxlQW5ub3RhdGlvbnMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4jZWRpdGFibGVBbm5vdGF0aW9ucy52YWx1ZXMoKSk7XG4gIH1cbiAgZ2V0RWRpdGFibGVBbm5vdGF0aW9uKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2VkaXRhYmxlQW5ub3RhdGlvbnMuZ2V0KGlkKTtcbiAgfVxuICBzdGF0aWMgZ2V0IF9kZWZhdWx0Qm9yZGVyU3R5bGUoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9kZWZhdWx0Qm9yZGVyU3R5bGVcIiwgT2JqZWN0LmZyZWV6ZSh7XG4gICAgICB3aWR0aDogMSxcbiAgICAgIHJhd1dpZHRoOiAxLFxuICAgICAgc3R5bGU6IEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuU09MSUQsXG4gICAgICBkYXNoQXJyYXk6IFszXSxcbiAgICAgIGhvcml6b250YWxDb3JuZXJSYWRpdXM6IDAsXG4gICAgICB2ZXJ0aWNhbENvcm5lclJhZGl1czogMFxuICAgIH0pKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvZnJlZXRleHQuanNcblxuXG5cblxuY29uc3QgRU9MX1BBVFRFUk4gPSAvXFxyXFxuP3xcXG4vZztcbmNsYXNzIEZyZWVUZXh0RWRpdG9yIGV4dGVuZHMgQW5ub3RhdGlvbkVkaXRvciB7XG4gICNjb2xvcjtcbiAgI2NvbnRlbnQgPSBcIlwiO1xuICAjZWRpdG9yRGl2SWQgPSBgJHt0aGlzLmlkfS1lZGl0b3JgO1xuICAjZWRpdE1vZGVBQyA9IG51bGw7XG4gICNmb250U2l6ZTtcbiAgc3RhdGljIF9mcmVlVGV4dERlZmF1bHRDb250ZW50ID0gXCJcIjtcbiAgc3RhdGljIF9pbnRlcm5hbFBhZGRpbmcgPSAwO1xuICBzdGF0aWMgX2RlZmF1bHRDb2xvciA9IG51bGw7XG4gIHN0YXRpYyBfZGVmYXVsdEZvbnRTaXplID0gMTA7XG4gIHN0YXRpYyBnZXQgX2tleWJvYXJkTWFuYWdlcigpIHtcbiAgICBjb25zdCBwcm90byA9IEZyZWVUZXh0RWRpdG9yLnByb3RvdHlwZTtcbiAgICBjb25zdCBhcnJvd0NoZWNrZXIgPSBzZWxmID0+IHNlbGYuaXNFbXB0eSgpO1xuICAgIGNvbnN0IHNtYWxsID0gQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5UUkFOU0xBVEVfU01BTEw7XG4gICAgY29uc3QgYmlnID0gQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5UUkFOU0xBVEVfQklHO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfa2V5Ym9hcmRNYW5hZ2VyXCIsIG5ldyBLZXlib2FyZE1hbmFnZXIoW1tbXCJjdHJsK3NcIiwgXCJtYWMrbWV0YStzXCIsIFwiY3RybCtwXCIsIFwibWFjK21ldGErcFwiXSwgcHJvdG8uY29tbWl0T3JSZW1vdmUsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICB9XSwgW1tcImN0cmwrRW50ZXJcIiwgXCJtYWMrbWV0YStFbnRlclwiLCBcIkVzY2FwZVwiLCBcIm1hYytFc2NhcGVcIl0sIHByb3RvLmNvbW1pdE9yUmVtb3ZlXSwgW1tcIkFycm93TGVmdFwiLCBcIm1hYytBcnJvd0xlZnRcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWy1zbWFsbCwgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dMZWZ0XCIsIFwibWFjK3NoaWZ0K0Fycm93TGVmdFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbLWJpZywgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93UmlnaHRcIiwgXCJtYWMrQXJyb3dSaWdodFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbc21hbGwsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93UmlnaHRcIiwgXCJtYWMrc2hpZnQrQXJyb3dSaWdodFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbYmlnLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dVcFwiLCBcIm1hYytBcnJvd1VwXCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFswLCAtc21hbGxdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93VXBcIiwgXCJtYWMrc2hpZnQrQXJyb3dVcFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbMCwgLWJpZ10sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93RG93blwiLCBcIm1hYytBcnJvd0Rvd25cIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWzAsIHNtYWxsXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0Rvd25cIiwgXCJtYWMrc2hpZnQrQXJyb3dEb3duXCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFswLCBiaWddLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV1dKSk7XG4gIH1cbiAgc3RhdGljIF90eXBlID0gXCJmcmVldGV4dFwiO1xuICBzdGF0aWMgX2VkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVDtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgbmFtZTogXCJmcmVlVGV4dEVkaXRvclwiXG4gICAgfSk7XG4gICAgdGhpcy4jY29sb3IgPSBwYXJhbXMuY29sb3IgfHwgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRDb2xvciB8fCBBbm5vdGF0aW9uRWRpdG9yLl9kZWZhdWx0TGluZUNvbG9yO1xuICAgIHRoaXMuI2ZvbnRTaXplID0gcGFyYW1zLmZvbnRTaXplIHx8IEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Rm9udFNpemU7XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKSB7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5pbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcik7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG4gICAgdGhpcy5faW50ZXJuYWxQYWRkaW5nID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1mcmVldGV4dC1wYWRkaW5nXCIpKTtcbiAgfVxuICBzdGF0aWMgdXBkYXRlRGVmYXVsdFBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9TSVpFOlxuICAgICAgICBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdEZvbnRTaXplID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUjpcbiAgICAgICAgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRDb2xvciA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkU6XG4gICAgICAgIHRoaXMuI3VwZGF0ZUZvbnRTaXplKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SOlxuICAgICAgICB0aGlzLiN1cGRhdGVDb2xvcih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRSwgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRGb250U2l6ZV0sIFtBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUiwgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRDb2xvciB8fCBBbm5vdGF0aW9uRWRpdG9yLl9kZWZhdWx0TGluZUNvbG9yXV07XG4gIH1cbiAgZ2V0IHByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW1tBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9TSVpFLCB0aGlzLiNmb250U2l6ZV0sIFtBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUiwgdGhpcy4jY29sb3JdXTtcbiAgfVxuICAjdXBkYXRlRm9udFNpemUoZm9udFNpemUpIHtcbiAgICBjb25zdCBzZXRGb250c2l6ZSA9IHNpemUgPT4ge1xuICAgICAgdGhpcy5lZGl0b3JEaXYuc3R5bGUuZm9udFNpemUgPSBgY2FsYygke3NpemV9cHggKiB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpKWA7XG4gICAgICB0aGlzLnRyYW5zbGF0ZSgwLCAtKHNpemUgLSB0aGlzLiNmb250U2l6ZSkgKiB0aGlzLnBhcmVudFNjYWxlKTtcbiAgICAgIHRoaXMuI2ZvbnRTaXplID0gc2l6ZTtcbiAgICAgIHRoaXMuI3NldEVkaXRvckRpbWVuc2lvbnMoKTtcbiAgICB9O1xuICAgIGNvbnN0IHNhdmVkRm9udHNpemUgPSB0aGlzLiNmb250U2l6ZTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogc2V0Rm9udHNpemUuYmluZCh0aGlzLCBmb250U2l6ZSksXG4gICAgICB1bmRvOiBzZXRGb250c2l6ZS5iaW5kKHRoaXMsIHNhdmVkRm9udHNpemUpLFxuICAgICAgcG9zdDogdGhpcy5fdWlNYW5hZ2VyLnVwZGF0ZVVJLmJpbmQodGhpcy5fdWlNYW5hZ2VyLCB0aGlzKSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRSxcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gICN1cGRhdGVDb2xvcihjb2xvcikge1xuICAgIGNvbnN0IHNldENvbG9yID0gY29sID0+IHtcbiAgICAgIHRoaXMuI2NvbG9yID0gdGhpcy5lZGl0b3JEaXYuc3R5bGUuY29sb3IgPSBjb2w7XG4gICAgfTtcbiAgICBjb25zdCBzYXZlZENvbG9yID0gdGhpcy4jY29sb3I7XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6IHNldENvbG9yLmJpbmQodGhpcywgY29sb3IpLFxuICAgICAgdW5kbzogc2V0Q29sb3IuYmluZCh0aGlzLCBzYXZlZENvbG9yKSxcbiAgICAgIHBvc3Q6IHRoaXMuX3VpTWFuYWdlci51cGRhdGVVSS5iaW5kKHRoaXMuX3VpTWFuYWdlciwgdGhpcyksXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgX3RyYW5zbGF0ZUVtcHR5KHgsIHkpIHtcbiAgICB0aGlzLl91aU1hbmFnZXIudHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzKHgsIHksIHRydWUpO1xuICB9XG4gIGdldEluaXRpYWxUcmFuc2xhdGlvbigpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMucGFyZW50U2NhbGU7XG4gICAgcmV0dXJuIFstRnJlZVRleHRFZGl0b3IuX2ludGVybmFsUGFkZGluZyAqIHNjYWxlLCAtKEZyZWVUZXh0RWRpdG9yLl9pbnRlcm5hbFBhZGRpbmcgKyB0aGlzLiNmb250U2l6ZSkgKiBzY2FsZV07XG4gIH1cbiAgcmVidWlsZCgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnJlYnVpbGQoKTtcbiAgICBpZiAodGhpcy5kaXYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkKHRoaXMpO1xuICAgIH1cbiAgfVxuICBlbmFibGVFZGl0TW9kZSgpIHtcbiAgICBpZiAodGhpcy5pc0luRWRpdE1vZGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudC5zZXRFZGl0aW5nU3RhdGUoZmFsc2UpO1xuICAgIHRoaXMucGFyZW50LnVwZGF0ZVRvb2xiYXIoQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQpO1xuICAgIHN1cGVyLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5vdmVybGF5RGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJlbmFibGVkXCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICB0aGlzLmRpdi5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIik7XG4gICAgdGhpcy4jZWRpdE1vZGVBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl91aU1hbmFnZXIuY29tYmluZWRTaWduYWwodGhpcy4jZWRpdE1vZGVBQyk7XG4gICAgdGhpcy5lZGl0b3JEaXYuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5lZGl0b3JEaXZLZXlkb3duLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuZWRpdG9yRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLmVkaXRvckRpdkZvY3VzLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuZWRpdG9yRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuZWRpdG9yRGl2Qmx1ci5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvckRpdi5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhpcy5lZGl0b3JEaXZJbnB1dC5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvckRpdi5hZGRFdmVudExpc3RlbmVyKFwicGFzdGVcIiwgdGhpcy5lZGl0b3JEaXZQYXN0ZS5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICBkaXNhYmxlRWRpdE1vZGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzSW5FZGl0TW9kZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFyZW50LnNldEVkaXRpbmdTdGF0ZSh0cnVlKTtcbiAgICBzdXBlci5kaXNhYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLm92ZXJsYXlEaXYuY2xhc3NMaXN0LmFkZChcImVuYWJsZWRcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIsIHRoaXMuI2VkaXRvckRpdklkKTtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IHRydWU7XG4gICAgdGhpcy4jZWRpdE1vZGVBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNlZGl0TW9kZUFDID0gbnVsbDtcbiAgICB0aGlzLmRpdi5mb2N1cyh7XG4gICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnBhcmVudC5kaXYuY2xhc3NMaXN0LmFkZChcImZyZWV0ZXh0RWRpdGluZ1wiKTtcbiAgfVxuICBmb2N1c2luKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9mb2N1c0V2ZW50c0FsbG93ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuZm9jdXNpbihldmVudCk7XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gdGhpcy5lZGl0b3JEaXYpIHtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LmZvY3VzKCk7XG4gICAgfVxuICB9XG4gIG9uY2VBZGRlZChmb2N1cykge1xuICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICBpZiAoZm9jdXMpIHtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LmZvY3VzKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9pbml0aWFsT3B0aW9ucz8uaXNDZW50ZXJlZCkge1xuICAgICAgdGhpcy5jZW50ZXIoKTtcbiAgICB9XG4gICAgdGhpcy5faW5pdGlhbE9wdGlvbnMgPSBudWxsO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuICF0aGlzLmVkaXRvckRpdiB8fCB0aGlzLmVkaXRvckRpdi5pbm5lclRleHQudHJpbSgpID09PSBcIlwiO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQuc2V0RWRpdGluZ1N0YXRlKHRydWUpO1xuICAgICAgdGhpcy5wYXJlbnQuZGl2LmNsYXNzTGlzdC5hZGQoXCJmcmVldGV4dEVkaXRpbmdcIik7XG4gICAgfVxuICAgIHN1cGVyLnJlbW92ZSgpO1xuICB9XG4gICNleHRyYWN0VGV4dCgpIHtcbiAgICBjb25zdCBidWZmZXIgPSBbXTtcbiAgICB0aGlzLmVkaXRvckRpdi5ub3JtYWxpemUoKTtcbiAgICBsZXQgcHJldkNoaWxkID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuZWRpdG9yRGl2LmNoaWxkTm9kZXMpIHtcbiAgICAgIGlmIChwcmV2Q2hpbGQ/Lm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSAmJiBjaGlsZC5ub2RlTmFtZSA9PT0gXCJCUlwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnVmZmVyLnB1c2goRnJlZVRleHRFZGl0b3IuI2dldE5vZGVDb250ZW50KGNoaWxkKSk7XG4gICAgICBwcmV2Q2hpbGQgPSBjaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlci5qb2luKFwiXFxuXCIpO1xuICB9XG4gICNzZXRFZGl0b3JEaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBsZXQgcmVjdDtcbiAgICBpZiAodGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHJlY3QgPSB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjdXJyZW50TGF5ZXIsXG4gICAgICAgIGRpdlxuICAgICAgfSA9IHRoaXM7XG4gICAgICBjb25zdCBzYXZlZERpc3BsYXkgPSBkaXYuc3R5bGUuZGlzcGxheTtcbiAgICAgIGNvbnN0IHNhdmVkVmlzaWJpbGl0eSA9IGRpdi5jbGFzc0xpc3QuY29udGFpbnMoXCJoaWRkZW5cIik7XG4gICAgICBkaXYuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcbiAgICAgIGRpdi5zdHlsZS5kaXNwbGF5ID0gXCJoaWRkZW5cIjtcbiAgICAgIGN1cnJlbnRMYXllci5kaXYuYXBwZW5kKHRoaXMuZGl2KTtcbiAgICAgIHJlY3QgPSBkaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBkaXYucmVtb3ZlKCk7XG4gICAgICBkaXYuc3R5bGUuZGlzcGxheSA9IHNhdmVkRGlzcGxheTtcbiAgICAgIGRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiaGlkZGVuXCIsIHNhdmVkVmlzaWJpbGl0eSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJvdGF0aW9uICUgMTgwID09PSB0aGlzLnBhcmVudFJvdGF0aW9uICUgMTgwKSB7XG4gICAgICB0aGlzLndpZHRoID0gcmVjdC53aWR0aCAvIHBhcmVudFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSByZWN0LmhlaWdodCAvIHBhcmVudEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IHJlY3QuaGVpZ2h0IC8gcGFyZW50V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHJlY3Qud2lkdGggLyBwYXJlbnRIZWlnaHQ7XG4gICAgfVxuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICBjb21taXQoKSB7XG4gICAgaWYgKCF0aGlzLmlzSW5FZGl0TW9kZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmNvbW1pdCgpO1xuICAgIHRoaXMuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgY29uc3Qgc2F2ZWRUZXh0ID0gdGhpcy4jY29udGVudDtcbiAgICBjb25zdCBuZXdUZXh0ID0gdGhpcy4jY29udGVudCA9IHRoaXMuI2V4dHJhY3RUZXh0KCkudHJpbUVuZCgpO1xuICAgIGlmIChzYXZlZFRleHQgPT09IG5ld1RleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2V0VGV4dCA9IHRleHQgPT4ge1xuICAgICAgdGhpcy4jY29udGVudCA9IHRleHQ7XG4gICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy4jc2V0Q29udGVudCgpO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLnJlYnVpbGQodGhpcyk7XG4gICAgICB0aGlzLiNzZXRFZGl0b3JEaW1lbnNpb25zKCk7XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICBzZXRUZXh0KG5ld1RleHQpO1xuICAgICAgfSxcbiAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgc2V0VGV4dChzYXZlZFRleHQpO1xuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiBmYWxzZVxuICAgIH0pO1xuICAgIHRoaXMuI3NldEVkaXRvckRpbWVuc2lvbnMoKTtcbiAgfVxuICBzaG91bGRHZXRLZXlib2FyZEV2ZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5pc0luRWRpdE1vZGUoKTtcbiAgfVxuICBlbnRlckluRWRpdE1vZGUoKSB7XG4gICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmZvY3VzKCk7XG4gIH1cbiAgZGJsY2xpY2soZXZlbnQpIHtcbiAgICB0aGlzLmVudGVySW5FZGl0TW9kZSgpO1xuICB9XG4gIGtleWRvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLmRpdiAmJiBldmVudC5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgdGhpcy5lbnRlckluRWRpdE1vZGUoKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG4gIGVkaXRvckRpdktleWRvd24oZXZlbnQpIHtcbiAgICBGcmVlVGV4dEVkaXRvci5fa2V5Ym9hcmRNYW5hZ2VyLmV4ZWModGhpcywgZXZlbnQpO1xuICB9XG4gIGVkaXRvckRpdkZvY3VzKGV2ZW50KSB7XG4gICAgdGhpcy5pc0VkaXRpbmcgPSB0cnVlO1xuICB9XG4gIGVkaXRvckRpdkJsdXIoZXZlbnQpIHtcbiAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuICB9XG4gIGVkaXRvckRpdklucHV0KGV2ZW50KSB7XG4gICAgdGhpcy5wYXJlbnQuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJmcmVldGV4dEVkaXRpbmdcIiwgdGhpcy5pc0VtcHR5KCkpO1xuICB9XG4gIGRpc2FibGVFZGl0aW5nKCkge1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJjb21tZW50XCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtbXVsdGlsaW5lXCIpO1xuICB9XG4gIGVuYWJsZUVkaXRpbmcoKSB7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRleHRib3hcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1tdWx0aWxpbmVcIiwgdHJ1ZSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2O1xuICAgIH1cbiAgICBsZXQgYmFzZVgsIGJhc2VZO1xuICAgIGlmICh0aGlzLl9pc0NvcHkgfHwgdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICBiYXNlWCA9IHRoaXMueDtcbiAgICAgIGJhc2VZID0gdGhpcy55O1xuICAgIH1cbiAgICBzdXBlci5yZW5kZXIoKTtcbiAgICB0aGlzLmVkaXRvckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuY2xhc3NOYW1lID0gXCJpbnRlcm5hbFwiO1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcImlkXCIsIHRoaXMuI2VkaXRvckRpdklkKTtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1mcmVlLXRleHQyXCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1hdHRyc1wiLCBcImRlZmF1bHQtY29udGVudFwiKTtcbiAgICB0aGlzLmVuYWJsZUVkaXRpbmcoKTtcbiAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSB0cnVlO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuZWRpdG9yRGl2O1xuICAgIHN0eWxlLmZvbnRTaXplID0gYGNhbGMoJHt0aGlzLiNmb250U2l6ZX1weCAqIHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikpYDtcbiAgICBzdHlsZS5jb2xvciA9IHRoaXMuI2NvbG9yO1xuICAgIHRoaXMuZGl2LmFwcGVuZCh0aGlzLmVkaXRvckRpdik7XG4gICAgdGhpcy5vdmVybGF5RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLm92ZXJsYXlEaXYuY2xhc3NMaXN0LmFkZChcIm92ZXJsYXlcIiwgXCJlbmFibGVkXCIpO1xuICAgIHRoaXMuZGl2LmFwcGVuZCh0aGlzLm92ZXJsYXlEaXYpO1xuICAgIGJpbmRFdmVudHModGhpcywgdGhpcy5kaXYsIFtcImRibGNsaWNrXCIsIFwia2V5ZG93blwiXSk7XG4gICAgaWYgKHRoaXMuX2lzQ29weSB8fCB0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICAgIGlmICh0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgIH0gPSB0aGlzLl9pbml0aWFsRGF0YTtcbiAgICAgICAgbGV0IFt0eCwgdHldID0gdGhpcy5nZXRJbml0aWFsVHJhbnNsYXRpb24oKTtcbiAgICAgICAgW3R4LCB0eV0gPSB0aGlzLnBhZ2VUcmFuc2xhdGlvblRvU2NyZWVuKHR4LCB0eSk7XG4gICAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICAgICAgY29uc3QgW3BhZ2VYLCBwYWdlWV0gPSB0aGlzLnBhZ2VUcmFuc2xhdGlvbjtcbiAgICAgICAgbGV0IHBvc1gsIHBvc1k7XG4gICAgICAgIHN3aXRjaCAodGhpcy5yb3RhdGlvbikge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHBvc1ggPSBiYXNlWCArIChwb3NpdGlvblswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICAgIHBvc1kgPSBiYXNlWSArIHRoaXMuaGVpZ2h0IC0gKHBvc2l0aW9uWzFdIC0gcGFnZVkpIC8gcGFnZUhlaWdodDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgOTA6XG4gICAgICAgICAgICBwb3NYID0gYmFzZVggKyAocG9zaXRpb25bMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgICBwb3NZID0gYmFzZVkgLSAocG9zaXRpb25bMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgICAgW3R4LCB0eV0gPSBbdHksIC10eF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE4MDpcbiAgICAgICAgICAgIHBvc1ggPSBiYXNlWCAtIHRoaXMud2lkdGggKyAocG9zaXRpb25bMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgICBwb3NZID0gYmFzZVkgLSAocG9zaXRpb25bMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgICAgW3R4LCB0eV0gPSBbLXR4LCAtdHldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyNzA6XG4gICAgICAgICAgICBwb3NYID0gYmFzZVggKyAocG9zaXRpb25bMF0gLSBwYWdlWCAtIHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodCkgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgICBwb3NZID0gYmFzZVkgKyAocG9zaXRpb25bMV0gLSBwYWdlWSAtIHRoaXMud2lkdGggKiBwYWdlV2lkdGgpIC8gcGFnZUhlaWdodDtcbiAgICAgICAgICAgIFt0eCwgdHldID0gWy10eSwgdHhdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRBdChwb3NYICogcGFyZW50V2lkdGgsIHBvc1kgKiBwYXJlbnRIZWlnaHQsIHR4LCB0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9tb3ZlQWZ0ZXJQYXN0ZShiYXNlWCwgYmFzZVkpO1xuICAgICAgfVxuICAgICAgdGhpcy4jc2V0Q29udGVudCgpO1xuICAgICAgdGhpcy5faXNEcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgc3RhdGljICNnZXROb2RlQ29udGVudChub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSA/IG5vZGUubm9kZVZhbHVlIDogbm9kZS5pbm5lclRleHQpLnJlcGxhY2VBbGwoRU9MX1BBVFRFUk4sIFwiXCIpO1xuICB9XG4gIGVkaXRvckRpdlBhc3RlKGV2ZW50KSB7XG4gICAgY29uc3QgY2xpcGJvYXJkRGF0YSA9IGV2ZW50LmNsaXBib2FyZERhdGEgfHwgd2luZG93LmNsaXBib2FyZERhdGE7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZXNcbiAgICB9ID0gY2xpcGJvYXJkRGF0YTtcbiAgICBpZiAodHlwZXMubGVuZ3RoID09PSAxICYmIHR5cGVzWzBdID09PSBcInRleHQvcGxhaW5cIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHBhc3RlID0gRnJlZVRleHRFZGl0b3IuI2Rlc2VyaWFsaXplQ29udGVudChjbGlwYm9hcmREYXRhLmdldERhdGEoXCJ0ZXh0XCIpIHx8IFwiXCIpLnJlcGxhY2VBbGwoRU9MX1BBVFRFUk4sIFwiXFxuXCIpO1xuICAgIGlmICghcGFzdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghc2VsZWN0aW9uLnJhbmdlQ291bnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lZGl0b3JEaXYubm9ybWFsaXplKCk7XG4gICAgc2VsZWN0aW9uLmRlbGV0ZUZyb21Eb2N1bWVudCgpO1xuICAgIGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgaWYgKCFwYXN0ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShwYXN0ZSkpO1xuICAgICAgdGhpcy5lZGl0b3JEaXYubm9ybWFsaXplKCk7XG4gICAgICBzZWxlY3Rpb24uY29sbGFwc2VUb1N0YXJ0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0Q29udGFpbmVyLFxuICAgICAgc3RhcnRPZmZzZXRcbiAgICB9ID0gcmFuZ2U7XG4gICAgY29uc3QgYnVmZmVyQmVmb3JlID0gW107XG4gICAgY29uc3QgYnVmZmVyQWZ0ZXIgPSBbXTtcbiAgICBpZiAoc3RhcnRDb250YWluZXIubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBzdGFydENvbnRhaW5lci5wYXJlbnRFbGVtZW50O1xuICAgICAgYnVmZmVyQWZ0ZXIucHVzaChzdGFydENvbnRhaW5lci5ub2RlVmFsdWUuc2xpY2Uoc3RhcnRPZmZzZXQpLnJlcGxhY2VBbGwoRU9MX1BBVFRFUk4sIFwiXCIpKTtcbiAgICAgIGlmIChwYXJlbnQgIT09IHRoaXMuZWRpdG9yRGl2KSB7XG4gICAgICAgIGxldCBidWZmZXIgPSBidWZmZXJCZWZvcmU7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5lZGl0b3JEaXYuY2hpbGROb2Rlcykge1xuICAgICAgICAgIGlmIChjaGlsZCA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgICBidWZmZXIgPSBidWZmZXJBZnRlcjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWZmZXIucHVzaChGcmVlVGV4dEVkaXRvci4jZ2V0Tm9kZUNvbnRlbnQoY2hpbGQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnVmZmVyQmVmb3JlLnB1c2goc3RhcnRDb250YWluZXIubm9kZVZhbHVlLnNsaWNlKDAsIHN0YXJ0T2Zmc2V0KS5yZXBsYWNlQWxsKEVPTF9QQVRURVJOLCBcIlwiKSk7XG4gICAgfSBlbHNlIGlmIChzdGFydENvbnRhaW5lciA9PT0gdGhpcy5lZGl0b3JEaXYpIHtcbiAgICAgIGxldCBidWZmZXIgPSBidWZmZXJCZWZvcmU7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuZWRpdG9yRGl2LmNoaWxkTm9kZXMpIHtcbiAgICAgICAgaWYgKGkrKyA9PT0gc3RhcnRPZmZzZXQpIHtcbiAgICAgICAgICBidWZmZXIgPSBidWZmZXJBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXIucHVzaChGcmVlVGV4dEVkaXRvci4jZ2V0Tm9kZUNvbnRlbnQoY2hpbGQpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jY29udGVudCA9IGAke2J1ZmZlckJlZm9yZS5qb2luKFwiXFxuXCIpfSR7cGFzdGV9JHtidWZmZXJBZnRlci5qb2luKFwiXFxuXCIpfWA7XG4gICAgdGhpcy4jc2V0Q29udGVudCgpO1xuICAgIGNvbnN0IG5ld1JhbmdlID0gbmV3IFJhbmdlKCk7XG4gICAgbGV0IGJlZm9yZUxlbmd0aCA9IE1hdGguc3VtUHJlY2lzZShidWZmZXJCZWZvcmUubWFwKGxpbmUgPT4gbGluZS5sZW5ndGgpKTtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIGZpcnN0Q2hpbGRcbiAgICB9IG9mIHRoaXMuZWRpdG9yRGl2LmNoaWxkTm9kZXMpIHtcbiAgICAgIGlmIChmaXJzdENoaWxkLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBmaXJzdENoaWxkLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgIGlmIChiZWZvcmVMZW5ndGggPD0gbGVuZ3RoKSB7XG4gICAgICAgICAgbmV3UmFuZ2Uuc2V0U3RhcnQoZmlyc3RDaGlsZCwgYmVmb3JlTGVuZ3RoKTtcbiAgICAgICAgICBuZXdSYW5nZS5zZXRFbmQoZmlyc3RDaGlsZCwgYmVmb3JlTGVuZ3RoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBiZWZvcmVMZW5ndGggLT0gbGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgc2VsZWN0aW9uLmFkZFJhbmdlKG5ld1JhbmdlKTtcbiAgfVxuICAjc2V0Q29udGVudCgpIHtcbiAgICB0aGlzLmVkaXRvckRpdi5yZXBsYWNlQ2hpbGRyZW4oKTtcbiAgICBpZiAoIXRoaXMuI2NvbnRlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIHRoaXMuI2NvbnRlbnQuc3BsaXQoXCJcXG5cIikpIHtcbiAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBkaXYuYXBwZW5kKGxpbmUgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgICB0aGlzLmVkaXRvckRpdi5hcHBlbmQoZGl2KTtcbiAgICB9XG4gIH1cbiAgI3NlcmlhbGl6ZUNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NvbnRlbnQucmVwbGFjZUFsbChcIlxceGEwXCIsIFwiIFwiKTtcbiAgfVxuICBzdGF0aWMgI2Rlc2VyaWFsaXplQ29udGVudChjb250ZW50KSB7XG4gICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZUFsbChcIiBcIiwgXCJcXHhhMFwiKTtcbiAgfVxuICBnZXQgY29udGVudERpdigpIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0b3JEaXY7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgbGV0IGluaXRpYWxEYXRhID0gbnVsbDtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGRlZmF1bHRBcHBlYXJhbmNlRGF0YToge1xuICAgICAgICAgICAgZm9udFNpemUsXG4gICAgICAgICAgICBmb250Q29sb3JcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcG9wdXBSZWZcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dENvbnRlbnQsXG4gICAgICAgIHRleHRQb3NpdGlvbixcbiAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgcGFnZU51bWJlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSA9IGRhdGE7XG4gICAgICBpZiAoIXRleHRDb250ZW50IHx8IHRleHRDb250ZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGluaXRpYWxEYXRhID0gZGF0YSA9IHtcbiAgICAgICAgYW5ub3RhdGlvblR5cGU6IEFubm90YXRpb25FZGl0b3JUeXBlLkZSRUVURVhULFxuICAgICAgICBjb2xvcjogQXJyYXkuZnJvbShmb250Q29sb3IpLFxuICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgdmFsdWU6IHRleHRDb250ZW50LmpvaW4oXCJcXG5cIiksXG4gICAgICAgIHBvc2l0aW9uOiB0ZXh0UG9zaXRpb24sXG4gICAgICAgIHBhZ2VJbmRleDogcGFnZU51bWJlciAtIDEsXG4gICAgICAgIHJlY3Q6IHJlY3Quc2xpY2UoMCksXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBpZCxcbiAgICAgICAgZGVsZXRlZDogZmFsc2UsXG4gICAgICAgIHBvcHVwUmVmXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgZWRpdG9yLiNmb250U2l6ZSA9IGRhdGEuZm9udFNpemU7XG4gICAgZWRpdG9yLiNjb2xvciA9IFV0aWwubWFrZUhleENvbG9yKC4uLmRhdGEuY29sb3IpO1xuICAgIGVkaXRvci4jY29udGVudCA9IEZyZWVUZXh0RWRpdG9yLiNkZXNlcmlhbGl6ZUNvbnRlbnQoZGF0YS52YWx1ZSk7XG4gICAgZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgPSBkYXRhLmlkIHx8IG51bGw7XG4gICAgZWRpdG9yLl9pbml0aWFsRGF0YSA9IGluaXRpYWxEYXRhO1xuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZyA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVsZXRlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplRGVsZXRlZCgpO1xuICAgIH1cbiAgICBjb25zdCBwYWRkaW5nID0gRnJlZVRleHRFZGl0b3IuX2ludGVybmFsUGFkZGluZyAqIHRoaXMucGFyZW50U2NhbGU7XG4gICAgY29uc3QgcmVjdCA9IHRoaXMuZ2V0UmVjdChwYWRkaW5nLCBwYWRkaW5nKTtcbiAgICBjb25zdCBjb2xvciA9IEFubm90YXRpb25FZGl0b3IuX2NvbG9yTWFuYWdlci5jb252ZXJ0KHRoaXMuaXNBdHRhY2hlZFRvRE9NID8gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVkaXRvckRpdikuY29sb3IgOiB0aGlzLiNjb2xvcik7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHtcbiAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVCxcbiAgICAgIGNvbG9yLFxuICAgICAgZm9udFNpemU6IHRoaXMuI2ZvbnRTaXplLFxuICAgICAgdmFsdWU6IHRoaXMuI3NlcmlhbGl6ZUNvbnRlbnQoKSxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5wYWdlSW5kZXgsXG4gICAgICByZWN0LFxuICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24sXG4gICAgICBzdHJ1Y3RUcmVlUGFyZW50SWQ6IHRoaXMuX3N0cnVjdFRyZWVQYXJlbnRJZFxuICAgIH07XG4gICAgaWYgKGlzRm9yQ29weWluZykge1xuICAgICAgc2VyaWFsaXplZC5pc0NvcHkgPSB0cnVlO1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmFubm90YXRpb25FbGVtZW50SWQgJiYgIXRoaXMuI2hhc0VsZW1lbnRDaGFuZ2VkKHNlcmlhbGl6ZWQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc2VyaWFsaXplZC5pZCA9IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZDtcbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgfVxuICAjaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHZhbHVlLFxuICAgICAgZm9udFNpemUsXG4gICAgICBjb2xvcixcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0gPSB0aGlzLl9pbml0aWFsRGF0YTtcbiAgICByZXR1cm4gdGhpcy5faGFzQmVlbk1vdmVkIHx8IHNlcmlhbGl6ZWQudmFsdWUgIT09IHZhbHVlIHx8IHNlcmlhbGl6ZWQuZm9udFNpemUgIT09IGZvbnRTaXplIHx8IHNlcmlhbGl6ZWQuY29sb3Iuc29tZSgoYywgaSkgPT4gYyAhPT0gY29sb3JbaV0pIHx8IHNlcmlhbGl6ZWQucGFnZUluZGV4ICE9PSBwYWdlSW5kZXg7XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBzdXBlci5yZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKTtcbiAgICBpZiAodGhpcy5kZWxldGVkKSB7XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gY29udGVudDtcbiAgICBzdHlsZS5mb250U2l6ZSA9IGBjYWxjKCR7dGhpcy4jZm9udFNpemV9cHggKiB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpKWA7XG4gICAgc3R5bGUuY29sb3IgPSB0aGlzLiNjb2xvcjtcbiAgICBjb250ZW50LnJlcGxhY2VDaGlsZHJlbigpO1xuICAgIGZvciAoY29uc3QgbGluZSBvZiB0aGlzLiNjb250ZW50LnNwbGl0KFwiXFxuXCIpKSB7XG4gICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZGl2LmFwcGVuZChsaW5lID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGluZSkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xuICAgICAgY29udGVudC5hcHBlbmQoZGl2KTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGluZyA9IEZyZWVUZXh0RWRpdG9yLl9pbnRlcm5hbFBhZGRpbmcgKiB0aGlzLnBhcmVudFNjYWxlO1xuICAgIGFubm90YXRpb24udXBkYXRlRWRpdGVkKHtcbiAgICAgIHJlY3Q6IHRoaXMuZ2V0UmVjdChwYWRkaW5nLCBwYWRkaW5nKSxcbiAgICAgIHBvcHVwQ29udGVudDogdGhpcy4jY29udGVudFxuICAgIH0pO1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIHJlc2V0QW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIHN1cGVyLnJlc2V0QW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbik7XG4gICAgYW5ub3RhdGlvbi5yZXNldEVkaXRlZCgpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9kcmF3ZXJzL291dGxpbmUuanNcblxuY2xhc3MgT3V0bGluZSB7XG4gIHN0YXRpYyBQUkVDSVNJT04gPSAxZS00O1xuICB0b1NWR1BhdGgoKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYHRvU1ZHUGF0aGAgbXVzdCBiZSBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgZ2V0IGJveCgpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IGdldHRlciBgYm94YCBtdXN0IGJlIGltcGxlbWVudGVkLlwiKTtcbiAgfVxuICBzZXJpYWxpemUoX2Jib3gsIF9yb3RhdGlvbikge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBzZXJpYWxpemVgIG11c3QgYmUgaW1wbGVtZW50ZWQuXCIpO1xuICB9XG4gIHN0YXRpYyBfcmVzY2FsZShzcmMsIHR4LCB0eSwgc3gsIHN5LCBkZXN0KSB7XG4gICAgZGVzdCB8fD0gbmV3IEZsb2F0MzJBcnJheShzcmMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzcmMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgZGVzdFtpXSA9IHR4ICsgc3JjW2ldICogc3g7XG4gICAgICBkZXN0W2kgKyAxXSA9IHR5ICsgc3JjW2kgKyAxXSAqIHN5O1xuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbiAgfVxuICBzdGF0aWMgX3Jlc2NhbGVBbmRTd2FwKHNyYywgdHgsIHR5LCBzeCwgc3ksIGRlc3QpIHtcbiAgICBkZXN0IHx8PSBuZXcgRmxvYXQzMkFycmF5KHNyYy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNyYy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBkZXN0W2ldID0gdHggKyBzcmNbaSArIDFdICogc3g7XG4gICAgICBkZXN0W2kgKyAxXSA9IHR5ICsgc3JjW2ldICogc3k7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9XG4gIHN0YXRpYyBfdHJhbnNsYXRlKHNyYywgdHgsIHR5LCBkZXN0KSB7XG4gICAgZGVzdCB8fD0gbmV3IEZsb2F0MzJBcnJheShzcmMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzcmMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgZGVzdFtpXSA9IHR4ICsgc3JjW2ldO1xuICAgICAgZGVzdFtpICsgMV0gPSB0eSArIHNyY1tpICsgMV07XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9XG4gIHN0YXRpYyBzdmdSb3VuZCh4KSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoeCAqIDEwMDAwKTtcbiAgfVxuICBzdGF0aWMgX25vcm1hbGl6ZVBvaW50KHgsIHksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHJvdGF0aW9uKSB7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geSAvIHBhcmVudFdpZHRoLCB4IC8gcGFyZW50SGVpZ2h0XTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gWzEgLSB4IC8gcGFyZW50V2lkdGgsIDEgLSB5IC8gcGFyZW50SGVpZ2h0XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3kgLyBwYXJlbnRXaWR0aCwgMSAtIHggLyBwYXJlbnRIZWlnaHRdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt4IC8gcGFyZW50V2lkdGgsIHkgLyBwYXJlbnRIZWlnaHRdO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgX25vcm1hbGl6ZVBhZ2VQb2ludCh4LCB5LCByb3RhdGlvbikge1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbMSAtIHksIHhdO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbMSAtIHgsIDEgLSB5XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3ksIDEgLSB4XTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuICB9XG4gIHN0YXRpYyBjcmVhdGVCZXppZXJQb2ludHMoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIHJldHVybiBbKHgxICsgNSAqIHgyKSAvIDYsICh5MSArIDUgKiB5MikgLyA2LCAoNSAqIHgyICsgeDMpIC8gNiwgKDUgKiB5MiArIHkzKSAvIDYsICh4MiArIHgzKSAvIDIsICh5MiArIHkzKSAvIDJdO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9kcmF3ZXJzL2ZyZWVkcmF3LmpzXG5cblxuY2xhc3MgRnJlZURyYXdPdXRsaW5lciB7XG4gICNib3g7XG4gICNib3R0b20gPSBbXTtcbiAgI2lubmVyTWFyZ2luO1xuICAjaXNMVFI7XG4gICN0b3AgPSBbXTtcbiAgI2xhc3QgPSBuZXcgRmxvYXQzMkFycmF5KDE4KTtcbiAgI2xhc3RYO1xuICAjbGFzdFk7XG4gICNtaW47XG4gICNtaW5fZGlzdDtcbiAgI3NjYWxlRmFjdG9yO1xuICAjdGhpY2tuZXNzO1xuICAjcG9pbnRzID0gW107XG4gIHN0YXRpYyAjTUlOX0RJU1QgPSA4O1xuICBzdGF0aWMgI01JTl9ESUZGID0gMjtcbiAgc3RhdGljICNNSU4gPSBGcmVlRHJhd091dGxpbmVyLiNNSU5fRElTVCArIEZyZWVEcmF3T3V0bGluZXIuI01JTl9ESUZGO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgeCxcbiAgICB5XG4gIH0sIGJveCwgc2NhbGVGYWN0b3IsIHRoaWNrbmVzcywgaXNMVFIsIGlubmVyTWFyZ2luID0gMCkge1xuICAgIHRoaXMuI2JveCA9IGJveDtcbiAgICB0aGlzLiN0aGlja25lc3MgPSB0aGlja25lc3MgKiBzY2FsZUZhY3RvcjtcbiAgICB0aGlzLiNpc0xUUiA9IGlzTFRSO1xuICAgIHRoaXMuI2xhc3Quc2V0KFtOYU4sIE5hTiwgTmFOLCBOYU4sIHgsIHldLCA2KTtcbiAgICB0aGlzLiNpbm5lck1hcmdpbiA9IGlubmVyTWFyZ2luO1xuICAgIHRoaXMuI21pbl9kaXN0ID0gRnJlZURyYXdPdXRsaW5lci4jTUlOX0RJU1QgKiBzY2FsZUZhY3RvcjtcbiAgICB0aGlzLiNtaW4gPSBGcmVlRHJhd091dGxpbmVyLiNNSU4gKiBzY2FsZUZhY3RvcjtcbiAgICB0aGlzLiNzY2FsZUZhY3RvciA9IHNjYWxlRmFjdG9yO1xuICAgIHRoaXMuI3BvaW50cy5wdXNoKHgsIHkpO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIGlzTmFOKHRoaXMuI2xhc3RbOF0pO1xuICB9XG4gICNnZXRMYXN0Q29vcmRzKCkge1xuICAgIGNvbnN0IGxhc3RUb3AgPSB0aGlzLiNsYXN0LnN1YmFycmF5KDQsIDYpO1xuICAgIGNvbnN0IGxhc3RCb3R0b20gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDE2LCAxOCk7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIHJldHVybiBbKHRoaXMuI2xhc3RYICsgKGxhc3RUb3BbMF0gLSBsYXN0Qm90dG9tWzBdKSAvIDIgLSB4KSAvIHdpZHRoLCAodGhpcy4jbGFzdFkgKyAobGFzdFRvcFsxXSAtIGxhc3RCb3R0b21bMV0pIC8gMiAtIHkpIC8gaGVpZ2h0LCAodGhpcy4jbGFzdFggKyAobGFzdEJvdHRvbVswXSAtIGxhc3RUb3BbMF0pIC8gMiAtIHgpIC8gd2lkdGgsICh0aGlzLiNsYXN0WSArIChsYXN0Qm90dG9tWzFdIC0gbGFzdFRvcFsxXSkgLyAyIC0geSkgLyBoZWlnaHRdO1xuICB9XG4gIGFkZCh7XG4gICAgeCxcbiAgICB5XG4gIH0pIHtcbiAgICB0aGlzLiNsYXN0WCA9IHg7XG4gICAgdGhpcy4jbGFzdFkgPSB5O1xuICAgIGNvbnN0IFtsYXllclgsIGxheWVyWSwgbGF5ZXJXaWR0aCwgbGF5ZXJIZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGxldCBbeDEsIHkxLCB4MiwgeTJdID0gdGhpcy4jbGFzdC5zdWJhcnJheSg4LCAxMik7XG4gICAgY29uc3QgZGlmZlggPSB4IC0geDI7XG4gICAgY29uc3QgZGlmZlkgPSB5IC0geTI7XG4gICAgY29uc3QgZCA9IE1hdGguaHlwb3QoZGlmZlgsIGRpZmZZKTtcbiAgICBpZiAoZCA8IHRoaXMuI21pbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBkaWZmRCA9IGQgLSB0aGlzLiNtaW5fZGlzdDtcbiAgICBjb25zdCBLID0gZGlmZkQgLyBkO1xuICAgIGNvbnN0IHNoaWZ0WCA9IEsgKiBkaWZmWDtcbiAgICBjb25zdCBzaGlmdFkgPSBLICogZGlmZlk7XG4gICAgbGV0IHgwID0geDE7XG4gICAgbGV0IHkwID0geTE7XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICAgIHgyICs9IHNoaWZ0WDtcbiAgICB5MiArPSBzaGlmdFk7XG4gICAgdGhpcy4jcG9pbnRzPy5wdXNoKHgsIHkpO1xuICAgIGNvbnN0IG5YID0gLXNoaWZ0WSAvIGRpZmZEO1xuICAgIGNvbnN0IG5ZID0gc2hpZnRYIC8gZGlmZkQ7XG4gICAgY29uc3QgdGhYID0gblggKiB0aGlzLiN0aGlja25lc3M7XG4gICAgY29uc3QgdGhZID0gblkgKiB0aGlzLiN0aGlja25lc3M7XG4gICAgdGhpcy4jbGFzdC5zZXQodGhpcy4jbGFzdC5zdWJhcnJheSgyLCA4KSwgMCk7XG4gICAgdGhpcy4jbGFzdC5zZXQoW3gyICsgdGhYLCB5MiArIHRoWV0sIDQpO1xuICAgIHRoaXMuI2xhc3Quc2V0KHRoaXMuI2xhc3Quc3ViYXJyYXkoMTQsIDE4KSwgMTIpO1xuICAgIHRoaXMuI2xhc3Quc2V0KFt4MiAtIHRoWCwgeTIgLSB0aFldLCAxNik7XG4gICAgaWYgKGlzTmFOKHRoaXMuI2xhc3RbNl0pKSB7XG4gICAgICBpZiAodGhpcy4jdG9wLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLiNsYXN0LnNldChbeDEgKyB0aFgsIHkxICsgdGhZXSwgMik7XG4gICAgICAgIHRoaXMuI3RvcC5wdXNoKE5hTiwgTmFOLCBOYU4sIE5hTiwgKHgxICsgdGhYIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICh5MSArIHRoWSAtIGxheWVyWSkgLyBsYXllckhlaWdodCk7XG4gICAgICAgIHRoaXMuI2xhc3Quc2V0KFt4MSAtIHRoWCwgeTEgLSB0aFldLCAxNCk7XG4gICAgICAgIHRoaXMuI2JvdHRvbS5wdXNoKE5hTiwgTmFOLCBOYU4sIE5hTiwgKHgxIC0gdGhYIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICh5MSAtIHRoWSAtIGxheWVyWSkgLyBsYXllckhlaWdodCk7XG4gICAgICB9XG4gICAgICB0aGlzLiNsYXN0LnNldChbeDAsIHkwLCB4MSwgeTEsIHgyLCB5Ml0sIDYpO1xuICAgICAgcmV0dXJuICF0aGlzLmlzRW1wdHkoKTtcbiAgICB9XG4gICAgdGhpcy4jbGFzdC5zZXQoW3gwLCB5MCwgeDEsIHkxLCB4MiwgeTJdLCA2KTtcbiAgICBjb25zdCBhbmdsZSA9IE1hdGguYWJzKE1hdGguYXRhbjIoeTAgLSB5MSwgeDAgLSB4MSkgLSBNYXRoLmF0YW4yKHNoaWZ0WSwgc2hpZnRYKSk7XG4gICAgaWYgKGFuZ2xlIDwgTWF0aC5QSSAvIDIpIHtcbiAgICAgIFt4MSwgeTEsIHgyLCB5Ml0gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDIsIDYpO1xuICAgICAgdGhpcy4jdG9wLnB1c2goTmFOLCBOYU4sIE5hTiwgTmFOLCAoKHgxICsgeDIpIC8gMiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKHkxICsgeTIpIC8gMiAtIGxheWVyWSkgLyBsYXllckhlaWdodCk7XG4gICAgICBbeDEsIHkxLCB4MCwgeTBdID0gdGhpcy4jbGFzdC5zdWJhcnJheSgxNCwgMTgpO1xuICAgICAgdGhpcy4jYm90dG9tLnB1c2goTmFOLCBOYU4sIE5hTiwgTmFOLCAoKHgwICsgeDEpIC8gMiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKHkwICsgeTEpIC8gMiAtIGxheWVyWSkgLyBsYXllckhlaWdodCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgW3gwLCB5MCwgeDEsIHkxLCB4MiwgeTJdID0gdGhpcy4jbGFzdC5zdWJhcnJheSgwLCA2KTtcbiAgICB0aGlzLiN0b3AucHVzaCgoKHgwICsgNSAqIHgxKSAvIDYgLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKCh5MCArIDUgKiB5MSkgLyA2IC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0LCAoKDUgKiB4MSArIHgyKSAvIDYgLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKCg1ICogeTEgKyB5MikgLyA2IC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0LCAoKHgxICsgeDIpIC8gMiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKHkxICsgeTIpIC8gMiAtIGxheWVyWSkgLyBsYXllckhlaWdodCk7XG4gICAgW3gyLCB5MiwgeDEsIHkxLCB4MCwgeTBdID0gdGhpcy4jbGFzdC5zdWJhcnJheSgxMiwgMTgpO1xuICAgIHRoaXMuI2JvdHRvbS5wdXNoKCgoeDAgKyA1ICogeDEpIC8gNiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKHkwICsgNSAqIHkxKSAvIDYgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsICgoNSAqIHgxICsgeDIpIC8gNiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKDUgKiB5MSArIHkyKSAvIDYgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsICgoeDEgKyB4MikgLyAyIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoeTEgKyB5MikgLyAyIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0b1NWR1BhdGgoKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgY29uc3QgdG9wID0gdGhpcy4jdG9wO1xuICAgIGNvbnN0IGJvdHRvbSA9IHRoaXMuI2JvdHRvbTtcbiAgICBpZiAoaXNOYU4odGhpcy4jbGFzdFs2XSkgJiYgIXRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy4jdG9TVkdQYXRoVHdvUG9pbnRzKCk7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgIGJ1ZmZlci5wdXNoKGBNJHt0b3BbNF19ICR7dG9wWzVdfWApO1xuICAgIGZvciAobGV0IGkgPSA2OyBpIDwgdG9wLmxlbmd0aDsgaSArPSA2KSB7XG4gICAgICBpZiAoaXNOYU4odG9wW2ldKSkge1xuICAgICAgICBidWZmZXIucHVzaChgTCR7dG9wW2kgKyA0XX0gJHt0b3BbaSArIDVdfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyLnB1c2goYEMke3RvcFtpXX0gJHt0b3BbaSArIDFdfSAke3RvcFtpICsgMl19ICR7dG9wW2kgKyAzXX0gJHt0b3BbaSArIDRdfSAke3RvcFtpICsgNV19YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI3RvU1ZHUGF0aEVuZChidWZmZXIpO1xuICAgIGZvciAobGV0IGkgPSBib3R0b20ubGVuZ3RoIC0gNjsgaSA+PSA2OyBpIC09IDYpIHtcbiAgICAgIGlmIChpc05hTihib3R0b21baV0pKSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGBMJHtib3R0b21baSArIDRdfSAke2JvdHRvbVtpICsgNV19YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXIucHVzaChgQyR7Ym90dG9tW2ldfSAke2JvdHRvbVtpICsgMV19ICR7Ym90dG9tW2kgKyAyXX0gJHtib3R0b21baSArIDNdfSAke2JvdHRvbVtpICsgNF19ICR7Ym90dG9tW2kgKyA1XX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jdG9TVkdQYXRoU3RhcnQoYnVmZmVyKTtcbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oXCIgXCIpO1xuICB9XG4gICN0b1NWR1BhdGhUd29Qb2ludHMoKSB7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGNvbnN0IFtsYXN0VG9wWCwgbGFzdFRvcFksIGxhc3RCb3R0b21YLCBsYXN0Qm90dG9tWV0gPSB0aGlzLiNnZXRMYXN0Q29vcmRzKCk7XG4gICAgcmV0dXJuIGBNJHsodGhpcy4jbGFzdFsyXSAtIHgpIC8gd2lkdGh9ICR7KHRoaXMuI2xhc3RbM10gLSB5KSAvIGhlaWdodH0gTCR7KHRoaXMuI2xhc3RbNF0gLSB4KSAvIHdpZHRofSAkeyh0aGlzLiNsYXN0WzVdIC0geSkgLyBoZWlnaHR9IEwke2xhc3RUb3BYfSAke2xhc3RUb3BZfSBMJHtsYXN0Qm90dG9tWH0gJHtsYXN0Qm90dG9tWX0gTCR7KHRoaXMuI2xhc3RbMTZdIC0geCkgLyB3aWR0aH0gJHsodGhpcy4jbGFzdFsxN10gLSB5KSAvIGhlaWdodH0gTCR7KHRoaXMuI2xhc3RbMTRdIC0geCkgLyB3aWR0aH0gJHsodGhpcy4jbGFzdFsxNV0gLSB5KSAvIGhlaWdodH0gWmA7XG4gIH1cbiAgI3RvU1ZHUGF0aFN0YXJ0KGJ1ZmZlcikge1xuICAgIGNvbnN0IGJvdHRvbSA9IHRoaXMuI2JvdHRvbTtcbiAgICBidWZmZXIucHVzaChgTCR7Ym90dG9tWzRdfSAke2JvdHRvbVs1XX0gWmApO1xuICB9XG4gICN0b1NWR1BhdGhFbmQoYnVmZmVyKSB7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGNvbnN0IGxhc3RUb3AgPSB0aGlzLiNsYXN0LnN1YmFycmF5KDQsIDYpO1xuICAgIGNvbnN0IGxhc3RCb3R0b20gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDE2LCAxOCk7XG4gICAgY29uc3QgW2xhc3RUb3BYLCBsYXN0VG9wWSwgbGFzdEJvdHRvbVgsIGxhc3RCb3R0b21ZXSA9IHRoaXMuI2dldExhc3RDb29yZHMoKTtcbiAgICBidWZmZXIucHVzaChgTCR7KGxhc3RUb3BbMF0gLSB4KSAvIHdpZHRofSAkeyhsYXN0VG9wWzFdIC0geSkgLyBoZWlnaHR9IEwke2xhc3RUb3BYfSAke2xhc3RUb3BZfSBMJHtsYXN0Qm90dG9tWH0gJHtsYXN0Qm90dG9tWX0gTCR7KGxhc3RCb3R0b21bMF0gLSB4KSAvIHdpZHRofSAkeyhsYXN0Qm90dG9tWzFdIC0geSkgLyBoZWlnaHR9YCk7XG4gIH1cbiAgbmV3RnJlZURyYXdPdXRsaW5lKG91dGxpbmUsIHBvaW50cywgYm94LCBzY2FsZUZhY3RvciwgaW5uZXJNYXJnaW4sIGlzTFRSKSB7XG4gICAgcmV0dXJuIG5ldyBGcmVlRHJhd091dGxpbmUob3V0bGluZSwgcG9pbnRzLCBib3gsIHNjYWxlRmFjdG9yLCBpbm5lck1hcmdpbiwgaXNMVFIpO1xuICB9XG4gIGdldE91dGxpbmVzKCkge1xuICAgIGNvbnN0IHRvcCA9IHRoaXMuI3RvcDtcbiAgICBjb25zdCBib3R0b20gPSB0aGlzLiNib3R0b207XG4gICAgY29uc3QgbGFzdCA9IHRoaXMuI2xhc3Q7XG4gICAgY29uc3QgW2xheWVyWCwgbGF5ZXJZLCBsYXllcldpZHRoLCBsYXllckhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgY29uc3QgcG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheSgodGhpcy4jcG9pbnRzPy5sZW5ndGggPz8gMCkgKyAyKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoIC0gMjsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIHBvaW50c1tpXSA9ICh0aGlzLiNwb2ludHNbaV0gLSBsYXllclgpIC8gbGF5ZXJXaWR0aDtcbiAgICAgIHBvaW50c1tpICsgMV0gPSAodGhpcy4jcG9pbnRzW2kgKyAxXSAtIGxheWVyWSkgLyBsYXllckhlaWdodDtcbiAgICB9XG4gICAgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSA9ICh0aGlzLiNsYXN0WCAtIGxheWVyWCkgLyBsYXllcldpZHRoO1xuICAgIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0gPSAodGhpcy4jbGFzdFkgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQ7XG4gICAgaWYgKGlzTmFOKGxhc3RbNl0pICYmICF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuI2dldE91dGxpbmVUd29Qb2ludHMocG9pbnRzKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0bGluZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy4jdG9wLmxlbmd0aCArIDI0ICsgdGhpcy4jYm90dG9tLmxlbmd0aCk7XG4gICAgbGV0IE4gPSB0b3AubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgaSArPSAyKSB7XG4gICAgICBpZiAoaXNOYU4odG9wW2ldKSkge1xuICAgICAgICBvdXRsaW5lW2ldID0gb3V0bGluZVtpICsgMV0gPSBOYU47XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgb3V0bGluZVtpXSA9IHRvcFtpXTtcbiAgICAgIG91dGxpbmVbaSArIDFdID0gdG9wW2kgKyAxXTtcbiAgICB9XG4gICAgTiA9IHRoaXMuI2dldE91dGxpbmVFbmQob3V0bGluZSwgTik7XG4gICAgZm9yIChsZXQgaSA9IGJvdHRvbS5sZW5ndGggLSA2OyBpID49IDY7IGkgLT0gNikge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA2OyBqICs9IDIpIHtcbiAgICAgICAgaWYgKGlzTmFOKGJvdHRvbVtpICsgal0pKSB7XG4gICAgICAgICAgb3V0bGluZVtOXSA9IG91dGxpbmVbTiArIDFdID0gTmFOO1xuICAgICAgICAgIE4gKz0gMjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBvdXRsaW5lW05dID0gYm90dG9tW2kgKyBqXTtcbiAgICAgICAgb3V0bGluZVtOICsgMV0gPSBib3R0b21baSArIGogKyAxXTtcbiAgICAgICAgTiArPSAyO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNnZXRPdXRsaW5lU3RhcnQob3V0bGluZSwgTik7XG4gICAgcmV0dXJuIHRoaXMubmV3RnJlZURyYXdPdXRsaW5lKG91dGxpbmUsIHBvaW50cywgdGhpcy4jYm94LCB0aGlzLiNzY2FsZUZhY3RvciwgdGhpcy4jaW5uZXJNYXJnaW4sIHRoaXMuI2lzTFRSKTtcbiAgfVxuICAjZ2V0T3V0bGluZVR3b1BvaW50cyhwb2ludHMpIHtcbiAgICBjb25zdCBsYXN0ID0gdGhpcy4jbGFzdDtcbiAgICBjb25zdCBbbGF5ZXJYLCBsYXllclksIGxheWVyV2lkdGgsIGxheWVySGVpZ2h0XSA9IHRoaXMuI2JveDtcbiAgICBjb25zdCBbbGFzdFRvcFgsIGxhc3RUb3BZLCBsYXN0Qm90dG9tWCwgbGFzdEJvdHRvbVldID0gdGhpcy4jZ2V0TGFzdENvb3JkcygpO1xuICAgIGNvbnN0IG91dGxpbmUgPSBuZXcgRmxvYXQzMkFycmF5KDM2KTtcbiAgICBvdXRsaW5lLnNldChbTmFOLCBOYU4sIE5hTiwgTmFOLCAobGFzdFsyXSAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAobGFzdFszXSAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgTmFOLCBOYU4sIE5hTiwgTmFOLCAobGFzdFs0XSAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAobGFzdFs1XSAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgTmFOLCBOYU4sIE5hTiwgTmFOLCBsYXN0VG9wWCwgbGFzdFRvcFksIE5hTiwgTmFOLCBOYU4sIE5hTiwgbGFzdEJvdHRvbVgsIGxhc3RCb3R0b21ZLCBOYU4sIE5hTiwgTmFOLCBOYU4sIChsYXN0WzE2XSAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAobGFzdFsxN10gLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsIE5hTiwgTmFOLCBOYU4sIE5hTiwgKGxhc3RbMTRdIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsIChsYXN0WzE1XSAtIGxheWVyWSkgLyBsYXllckhlaWdodF0sIDApO1xuICAgIHJldHVybiB0aGlzLm5ld0ZyZWVEcmF3T3V0bGluZShvdXRsaW5lLCBwb2ludHMsIHRoaXMuI2JveCwgdGhpcy4jc2NhbGVGYWN0b3IsIHRoaXMuI2lubmVyTWFyZ2luLCB0aGlzLiNpc0xUUik7XG4gIH1cbiAgI2dldE91dGxpbmVTdGFydChvdXRsaW5lLCBwb3MpIHtcbiAgICBjb25zdCBib3R0b20gPSB0aGlzLiNib3R0b207XG4gICAgb3V0bGluZS5zZXQoW05hTiwgTmFOLCBOYU4sIE5hTiwgYm90dG9tWzRdLCBib3R0b21bNV1dLCBwb3MpO1xuICAgIHJldHVybiBwb3MgKz0gNjtcbiAgfVxuICAjZ2V0T3V0bGluZUVuZChvdXRsaW5lLCBwb3MpIHtcbiAgICBjb25zdCBsYXN0VG9wID0gdGhpcy4jbGFzdC5zdWJhcnJheSg0LCA2KTtcbiAgICBjb25zdCBsYXN0Qm90dG9tID0gdGhpcy4jbGFzdC5zdWJhcnJheSgxNiwgMTgpO1xuICAgIGNvbnN0IFtsYXllclgsIGxheWVyWSwgbGF5ZXJXaWR0aCwgbGF5ZXJIZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGNvbnN0IFtsYXN0VG9wWCwgbGFzdFRvcFksIGxhc3RCb3R0b21YLCBsYXN0Qm90dG9tWV0gPSB0aGlzLiNnZXRMYXN0Q29vcmRzKCk7XG4gICAgb3V0bGluZS5zZXQoW05hTiwgTmFOLCBOYU4sIE5hTiwgKGxhc3RUb3BbMF0gLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKGxhc3RUb3BbMV0gLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsIE5hTiwgTmFOLCBOYU4sIE5hTiwgbGFzdFRvcFgsIGxhc3RUb3BZLCBOYU4sIE5hTiwgTmFOLCBOYU4sIGxhc3RCb3R0b21YLCBsYXN0Qm90dG9tWSwgTmFOLCBOYU4sIE5hTiwgTmFOLCAobGFzdEJvdHRvbVswXSAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAobGFzdEJvdHRvbVsxXSAtIGxheWVyWSkgLyBsYXllckhlaWdodF0sIHBvcyk7XG4gICAgcmV0dXJuIHBvcyArPSAyNDtcbiAgfVxufVxuY2xhc3MgRnJlZURyYXdPdXRsaW5lIGV4dGVuZHMgT3V0bGluZSB7XG4gICNib3g7XG4gICNiYm94ID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbiAgI2lubmVyTWFyZ2luO1xuICAjaXNMVFI7XG4gICNwb2ludHM7XG4gICNzY2FsZUZhY3RvcjtcbiAgI291dGxpbmU7XG4gIGNvbnN0cnVjdG9yKG91dGxpbmUsIHBvaW50cywgYm94LCBzY2FsZUZhY3RvciwgaW5uZXJNYXJnaW4sIGlzTFRSKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNvdXRsaW5lID0gb3V0bGluZTtcbiAgICB0aGlzLiNwb2ludHMgPSBwb2ludHM7XG4gICAgdGhpcy4jYm94ID0gYm94O1xuICAgIHRoaXMuI3NjYWxlRmFjdG9yID0gc2NhbGVGYWN0b3I7XG4gICAgdGhpcy4jaW5uZXJNYXJnaW4gPSBpbm5lck1hcmdpbjtcbiAgICB0aGlzLiNpc0xUUiA9IGlzTFRSO1xuICAgIHRoaXMubGFzdFBvaW50ID0gW05hTiwgTmFOXTtcbiAgICB0aGlzLiNjb21wdXRlTWluTWF4KGlzTFRSKTtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNiYm94O1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IG91dGxpbmUubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgb3V0bGluZVtpXSA9IChvdXRsaW5lW2ldIC0geCkgLyB3aWR0aDtcbiAgICAgIG91dGxpbmVbaSArIDFdID0gKG91dGxpbmVbaSArIDFdIC0geSkgLyBoZWlnaHQ7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBwb2ludHNbaV0gPSAocG9pbnRzW2ldIC0geCkgLyB3aWR0aDtcbiAgICAgIHBvaW50c1tpICsgMV0gPSAocG9pbnRzW2kgKyAxXSAtIHkpIC8gaGVpZ2h0O1xuICAgIH1cbiAgfVxuICB0b1NWR1BhdGgoKSB7XG4gICAgY29uc3QgYnVmZmVyID0gW2BNJHt0aGlzLiNvdXRsaW5lWzRdfSAke3RoaXMuI291dGxpbmVbNV19YF07XG4gICAgZm9yIChsZXQgaSA9IDYsIGlpID0gdGhpcy4jb3V0bGluZS5sZW5ndGg7IGkgPCBpaTsgaSArPSA2KSB7XG4gICAgICBpZiAoaXNOYU4odGhpcy4jb3V0bGluZVtpXSkpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goYEwke3RoaXMuI291dGxpbmVbaSArIDRdfSAke3RoaXMuI291dGxpbmVbaSArIDVdfWApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJ1ZmZlci5wdXNoKGBDJHt0aGlzLiNvdXRsaW5lW2ldfSAke3RoaXMuI291dGxpbmVbaSArIDFdfSAke3RoaXMuI291dGxpbmVbaSArIDJdfSAke3RoaXMuI291dGxpbmVbaSArIDNdfSAke3RoaXMuI291dGxpbmVbaSArIDRdfSAke3RoaXMuI291dGxpbmVbaSArIDVdfWApO1xuICAgIH1cbiAgICBidWZmZXIucHVzaChcIlpcIik7XG4gICAgcmV0dXJuIGJ1ZmZlci5qb2luKFwiIFwiKTtcbiAgfVxuICBzZXJpYWxpemUoW2JsWCwgYmxZLCB0clgsIHRyWV0sIHJvdGF0aW9uKSB7XG4gICAgY29uc3Qgd2lkdGggPSB0clggLSBibFg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdHJZIC0gYmxZO1xuICAgIGxldCBvdXRsaW5lO1xuICAgIGxldCBwb2ludHM7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBvdXRsaW5lID0gT3V0bGluZS5fcmVzY2FsZSh0aGlzLiNvdXRsaW5lLCBibFgsIHRyWSwgd2lkdGgsIC1oZWlnaHQpO1xuICAgICAgICBwb2ludHMgPSBPdXRsaW5lLl9yZXNjYWxlKHRoaXMuI3BvaW50cywgYmxYLCB0clksIHdpZHRoLCAtaGVpZ2h0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICBvdXRsaW5lID0gT3V0bGluZS5fcmVzY2FsZUFuZFN3YXAodGhpcy4jb3V0bGluZSwgYmxYLCBibFksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBwb2ludHMgPSBPdXRsaW5lLl9yZXNjYWxlQW5kU3dhcCh0aGlzLiNwb2ludHMsIGJsWCwgYmxZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgb3V0bGluZSA9IE91dGxpbmUuX3Jlc2NhbGUodGhpcy4jb3V0bGluZSwgdHJYLCBibFksIC13aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgcG9pbnRzID0gT3V0bGluZS5fcmVzY2FsZSh0aGlzLiNwb2ludHMsIHRyWCwgYmxZLCAtd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIG91dGxpbmUgPSBPdXRsaW5lLl9yZXNjYWxlQW5kU3dhcCh0aGlzLiNvdXRsaW5lLCB0clgsIHRyWSwgLXdpZHRoLCAtaGVpZ2h0KTtcbiAgICAgICAgcG9pbnRzID0gT3V0bGluZS5fcmVzY2FsZUFuZFN3YXAodGhpcy4jcG9pbnRzLCB0clgsIHRyWSwgLXdpZHRoLCAtaGVpZ2h0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBvdXRsaW5lOiBBcnJheS5mcm9tKG91dGxpbmUpLFxuICAgICAgcG9pbnRzOiBbQXJyYXkuZnJvbShwb2ludHMpXVxuICAgIH07XG4gIH1cbiAgI2NvbXB1dGVNaW5NYXgoaXNMVFIpIHtcbiAgICBjb25zdCBvdXRsaW5lID0gdGhpcy4jb3V0bGluZTtcbiAgICBsZXQgbGFzdFggPSBvdXRsaW5lWzRdO1xuICAgIGxldCBsYXN0WSA9IG91dGxpbmVbNV07XG4gICAgY29uc3QgbWluTWF4ID0gW2xhc3RYLCBsYXN0WSwgbGFzdFgsIGxhc3RZXTtcbiAgICBsZXQgbGFzdFBvaW50WCA9IGxhc3RYO1xuICAgIGxldCBsYXN0UG9pbnRZID0gbGFzdFk7XG4gICAgY29uc3QgbHRyQ2FsbGJhY2sgPSBpc0xUUiA/IE1hdGgubWF4IDogTWF0aC5taW47XG4gICAgZm9yIChsZXQgaSA9IDYsIGlpID0gb3V0bGluZS5sZW5ndGg7IGkgPCBpaTsgaSArPSA2KSB7XG4gICAgICBjb25zdCB4ID0gb3V0bGluZVtpICsgNF0sXG4gICAgICAgIHkgPSBvdXRsaW5lW2kgKyA1XTtcbiAgICAgIGlmIChpc05hTihvdXRsaW5lW2ldKSkge1xuICAgICAgICBVdGlsLnBvaW50Qm91bmRpbmdCb3goeCwgeSwgbWluTWF4KTtcbiAgICAgICAgaWYgKGxhc3RQb2ludFkgPCB5KSB7XG4gICAgICAgICAgbGFzdFBvaW50WCA9IHg7XG4gICAgICAgICAgbGFzdFBvaW50WSA9IHk7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdFBvaW50WSA9PT0geSkge1xuICAgICAgICAgIGxhc3RQb2ludFggPSBsdHJDYWxsYmFjayhsYXN0UG9pbnRYLCB4KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYmJveCA9IFtJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XTtcbiAgICAgICAgVXRpbC5iZXppZXJCb3VuZGluZ0JveChsYXN0WCwgbGFzdFksIC4uLm91dGxpbmUuc2xpY2UoaSwgaSArIDYpLCBiYm94KTtcbiAgICAgICAgVXRpbC5yZWN0Qm91bmRpbmdCb3goLi4uYmJveCwgbWluTWF4KTtcbiAgICAgICAgaWYgKGxhc3RQb2ludFkgPCBiYm94WzNdKSB7XG4gICAgICAgICAgbGFzdFBvaW50WCA9IGJib3hbMl07XG4gICAgICAgICAgbGFzdFBvaW50WSA9IGJib3hbM107XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdFBvaW50WSA9PT0gYmJveFszXSkge1xuICAgICAgICAgIGxhc3RQb2ludFggPSBsdHJDYWxsYmFjayhsYXN0UG9pbnRYLCBiYm94WzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdFggPSB4O1xuICAgICAgbGFzdFkgPSB5O1xuICAgIH1cbiAgICBjb25zdCBiYm94ID0gdGhpcy4jYmJveDtcbiAgICBiYm94WzBdID0gbWluTWF4WzBdIC0gdGhpcy4jaW5uZXJNYXJnaW47XG4gICAgYmJveFsxXSA9IG1pbk1heFsxXSAtIHRoaXMuI2lubmVyTWFyZ2luO1xuICAgIGJib3hbMl0gPSBtaW5NYXhbMl0gLSBtaW5NYXhbMF0gKyAyICogdGhpcy4jaW5uZXJNYXJnaW47XG4gICAgYmJveFszXSA9IG1pbk1heFszXSAtIG1pbk1heFsxXSArIDIgKiB0aGlzLiNpbm5lck1hcmdpbjtcbiAgICB0aGlzLmxhc3RQb2ludCA9IFtsYXN0UG9pbnRYLCBsYXN0UG9pbnRZXTtcbiAgfVxuICBnZXQgYm94KCkge1xuICAgIHJldHVybiB0aGlzLiNiYm94O1xuICB9XG4gIG5ld091dGxpbmVyKHBvaW50LCBib3gsIHNjYWxlRmFjdG9yLCB0aGlja25lc3MsIGlzTFRSLCBpbm5lck1hcmdpbiA9IDApIHtcbiAgICByZXR1cm4gbmV3IEZyZWVEcmF3T3V0bGluZXIocG9pbnQsIGJveCwgc2NhbGVGYWN0b3IsIHRoaWNrbmVzcywgaXNMVFIsIGlubmVyTWFyZ2luKTtcbiAgfVxuICBnZXROZXdPdXRsaW5lKHRoaWNrbmVzcywgaW5uZXJNYXJnaW4pIHtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNiYm94O1xuICAgIGNvbnN0IFtsYXllclgsIGxheWVyWSwgbGF5ZXJXaWR0aCwgbGF5ZXJIZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGNvbnN0IHN4ID0gd2lkdGggKiBsYXllcldpZHRoO1xuICAgIGNvbnN0IHN5ID0gaGVpZ2h0ICogbGF5ZXJIZWlnaHQ7XG4gICAgY29uc3QgdHggPSB4ICogbGF5ZXJXaWR0aCArIGxheWVyWDtcbiAgICBjb25zdCB0eSA9IHkgKiBsYXllckhlaWdodCArIGxheWVyWTtcbiAgICBjb25zdCBvdXRsaW5lciA9IHRoaXMubmV3T3V0bGluZXIoe1xuICAgICAgeDogdGhpcy4jcG9pbnRzWzBdICogc3ggKyB0eCxcbiAgICAgIHk6IHRoaXMuI3BvaW50c1sxXSAqIHN5ICsgdHlcbiAgICB9LCB0aGlzLiNib3gsIHRoaXMuI3NjYWxlRmFjdG9yLCB0aGlja25lc3MsIHRoaXMuI2lzTFRSLCBpbm5lck1hcmdpbiA/PyB0aGlzLiNpbm5lck1hcmdpbik7XG4gICAgZm9yIChsZXQgaSA9IDI7IGkgPCB0aGlzLiNwb2ludHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIG91dGxpbmVyLmFkZCh7XG4gICAgICAgIHg6IHRoaXMuI3BvaW50c1tpXSAqIHN4ICsgdHgsXG4gICAgICAgIHk6IHRoaXMuI3BvaW50c1tpICsgMV0gKiBzeSArIHR5XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dGxpbmVyLmdldE91dGxpbmVzKCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2RyYXdlcnMvaGlnaGxpZ2h0LmpzXG5cblxuXG5jbGFzcyBIaWdobGlnaHRPdXRsaW5lciB7XG4gICNib3g7XG4gICNsYXN0UG9pbnQ7XG4gICN2ZXJ0aWNhbEVkZ2VzID0gW107XG4gICNpbnRlcnZhbHMgPSBbXTtcbiAgY29uc3RydWN0b3IoYm94ZXMsIGJvcmRlcldpZHRoID0gMCwgaW5uZXJNYXJnaW4gPSAwLCBpc0xUUiA9IHRydWUpIHtcbiAgICBjb25zdCBtaW5NYXggPSBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgY29uc3QgTlVNQkVSX09GX0RJR0lUUyA9IDQ7XG4gICAgY29uc3QgRVBTSUxPTiA9IDEwICoqIC1OVU1CRVJfT0ZfRElHSVRTO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gb2YgYm94ZXMpIHtcbiAgICAgIGNvbnN0IHgxID0gTWF0aC5mbG9vcigoeCAtIGJvcmRlcldpZHRoKSAvIEVQU0lMT04pICogRVBTSUxPTjtcbiAgICAgIGNvbnN0IHgyID0gTWF0aC5jZWlsKCh4ICsgd2lkdGggKyBib3JkZXJXaWR0aCkgLyBFUFNJTE9OKSAqIEVQU0lMT047XG4gICAgICBjb25zdCB5MSA9IE1hdGguZmxvb3IoKHkgLSBib3JkZXJXaWR0aCkgLyBFUFNJTE9OKSAqIEVQU0lMT047XG4gICAgICBjb25zdCB5MiA9IE1hdGguY2VpbCgoeSArIGhlaWdodCArIGJvcmRlcldpZHRoKSAvIEVQU0lMT04pICogRVBTSUxPTjtcbiAgICAgIGNvbnN0IGxlZnQgPSBbeDEsIHkxLCB5MiwgdHJ1ZV07XG4gICAgICBjb25zdCByaWdodCA9IFt4MiwgeTEsIHkyLCBmYWxzZV07XG4gICAgICB0aGlzLiN2ZXJ0aWNhbEVkZ2VzLnB1c2gobGVmdCwgcmlnaHQpO1xuICAgICAgVXRpbC5yZWN0Qm91bmRpbmdCb3goeDEsIHkxLCB4MiwgeTIsIG1pbk1heCk7XG4gICAgfVxuICAgIGNvbnN0IGJib3hXaWR0aCA9IG1pbk1heFsyXSAtIG1pbk1heFswXSArIDIgKiBpbm5lck1hcmdpbjtcbiAgICBjb25zdCBiYm94SGVpZ2h0ID0gbWluTWF4WzNdIC0gbWluTWF4WzFdICsgMiAqIGlubmVyTWFyZ2luO1xuICAgIGNvbnN0IHNoaWZ0ZWRNaW5YID0gbWluTWF4WzBdIC0gaW5uZXJNYXJnaW47XG4gICAgY29uc3Qgc2hpZnRlZE1pblkgPSBtaW5NYXhbMV0gLSBpbm5lck1hcmdpbjtcbiAgICBjb25zdCBsYXN0RWRnZSA9IHRoaXMuI3ZlcnRpY2FsRWRnZXMuYXQoaXNMVFIgPyAtMSA6IC0yKTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBbbGFzdEVkZ2VbMF0sIGxhc3RFZGdlWzJdXTtcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgdGhpcy4jdmVydGljYWxFZGdlcykge1xuICAgICAgY29uc3QgW3gsIHkxLCB5Ml0gPSBlZGdlO1xuICAgICAgZWRnZVswXSA9ICh4IC0gc2hpZnRlZE1pblgpIC8gYmJveFdpZHRoO1xuICAgICAgZWRnZVsxXSA9ICh5MSAtIHNoaWZ0ZWRNaW5ZKSAvIGJib3hIZWlnaHQ7XG4gICAgICBlZGdlWzJdID0gKHkyIC0gc2hpZnRlZE1pblkpIC8gYmJveEhlaWdodDtcbiAgICB9XG4gICAgdGhpcy4jYm94ID0gbmV3IEZsb2F0MzJBcnJheShbc2hpZnRlZE1pblgsIHNoaWZ0ZWRNaW5ZLCBiYm94V2lkdGgsIGJib3hIZWlnaHRdKTtcbiAgICB0aGlzLiNsYXN0UG9pbnQgPSBsYXN0UG9pbnQ7XG4gIH1cbiAgZ2V0T3V0bGluZXMoKSB7XG4gICAgdGhpcy4jdmVydGljYWxFZGdlcy5zb3J0KChhLCBiKSA9PiBhWzBdIC0gYlswXSB8fCBhWzFdIC0gYlsxXSB8fCBhWzJdIC0gYlsyXSk7XG4gICAgY29uc3Qgb3V0bGluZVZlcnRpY2FsRWRnZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgdGhpcy4jdmVydGljYWxFZGdlcykge1xuICAgICAgaWYgKGVkZ2VbM10pIHtcbiAgICAgICAgb3V0bGluZVZlcnRpY2FsRWRnZXMucHVzaCguLi50aGlzLiNicmVha0VkZ2UoZWRnZSkpO1xuICAgICAgICB0aGlzLiNpbnNlcnQoZWRnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiNyZW1vdmUoZWRnZSk7XG4gICAgICAgIG91dGxpbmVWZXJ0aWNhbEVkZ2VzLnB1c2goLi4udGhpcy4jYnJlYWtFZGdlKGVkZ2UpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI2dldE91dGxpbmVzKG91dGxpbmVWZXJ0aWNhbEVkZ2VzKTtcbiAgfVxuICAjZ2V0T3V0bGluZXMob3V0bGluZVZlcnRpY2FsRWRnZXMpIHtcbiAgICBjb25zdCBlZGdlcyA9IFtdO1xuICAgIGNvbnN0IGFsbEVkZ2VzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgZWRnZSBvZiBvdXRsaW5lVmVydGljYWxFZGdlcykge1xuICAgICAgY29uc3QgW3gsIHkxLCB5Ml0gPSBlZGdlO1xuICAgICAgZWRnZXMucHVzaChbeCwgeTEsIGVkZ2VdLCBbeCwgeTIsIGVkZ2VdKTtcbiAgICB9XG4gICAgZWRnZXMuc29ydCgoYSwgYikgPT4gYVsxXSAtIGJbMV0gfHwgYVswXSAtIGJbMF0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGVkZ2VzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IGVkZ2UxID0gZWRnZXNbaV1bMl07XG4gICAgICBjb25zdCBlZGdlMiA9IGVkZ2VzW2kgKyAxXVsyXTtcbiAgICAgIGVkZ2UxLnB1c2goZWRnZTIpO1xuICAgICAgZWRnZTIucHVzaChlZGdlMSk7XG4gICAgICBhbGxFZGdlcy5hZGQoZWRnZTEpO1xuICAgICAgYWxsRWRnZXMuYWRkKGVkZ2UyKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0bGluZXMgPSBbXTtcbiAgICBsZXQgb3V0bGluZTtcbiAgICB3aGlsZSAoYWxsRWRnZXMuc2l6ZSA+IDApIHtcbiAgICAgIGNvbnN0IGVkZ2UgPSBhbGxFZGdlcy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG4gICAgICBsZXQgW3gsIHkxLCB5MiwgZWRnZTEsIGVkZ2UyXSA9IGVkZ2U7XG4gICAgICBhbGxFZGdlcy5kZWxldGUoZWRnZSk7XG4gICAgICBsZXQgbGFzdFBvaW50WCA9IHg7XG4gICAgICBsZXQgbGFzdFBvaW50WSA9IHkxO1xuICAgICAgb3V0bGluZSA9IFt4LCB5Ml07XG4gICAgICBvdXRsaW5lcy5wdXNoKG91dGxpbmUpO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IGU7XG4gICAgICAgIGlmIChhbGxFZGdlcy5oYXMoZWRnZTEpKSB7XG4gICAgICAgICAgZSA9IGVkZ2UxO1xuICAgICAgICB9IGVsc2UgaWYgKGFsbEVkZ2VzLmhhcyhlZGdlMikpIHtcbiAgICAgICAgICBlID0gZWRnZTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYWxsRWRnZXMuZGVsZXRlKGUpO1xuICAgICAgICBbeCwgeTEsIHkyLCBlZGdlMSwgZWRnZTJdID0gZTtcbiAgICAgICAgaWYgKGxhc3RQb2ludFggIT09IHgpIHtcbiAgICAgICAgICBvdXRsaW5lLnB1c2gobGFzdFBvaW50WCwgbGFzdFBvaW50WSwgeCwgbGFzdFBvaW50WSA9PT0geTEgPyB5MSA6IHkyKTtcbiAgICAgICAgICBsYXN0UG9pbnRYID0geDtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UG9pbnRZID0gbGFzdFBvaW50WSA9PT0geTEgPyB5MiA6IHkxO1xuICAgICAgfVxuICAgICAgb3V0bGluZS5wdXNoKGxhc3RQb2ludFgsIGxhc3RQb2ludFkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEhpZ2hsaWdodE91dGxpbmUob3V0bGluZXMsIHRoaXMuI2JveCwgdGhpcy4jbGFzdFBvaW50KTtcbiAgfVxuICAjYmluYXJ5U2VhcmNoKHkpIHtcbiAgICBjb25zdCBhcnJheSA9IHRoaXMuI2ludGVydmFscztcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBlbmQgPSBhcnJheS5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcbiAgICAgIGNvbnN0IG1pZGRsZSA9IHN0YXJ0ICsgZW5kID4+IDE7XG4gICAgICBjb25zdCB5MSA9IGFycmF5W21pZGRsZV1bMF07XG4gICAgICBpZiAoeTEgPT09IHkpIHtcbiAgICAgICAgcmV0dXJuIG1pZGRsZTtcbiAgICAgIH1cbiAgICAgIGlmICh5MSA8IHkpIHtcbiAgICAgICAgc3RhcnQgPSBtaWRkbGUgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gbWlkZGxlIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVuZCArIDE7XG4gIH1cbiAgI2luc2VydChbLCB5MSwgeTJdKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLiNiaW5hcnlTZWFyY2goeTEpO1xuICAgIHRoaXMuI2ludGVydmFscy5zcGxpY2UoaW5kZXgsIDAsIFt5MSwgeTJdKTtcbiAgfVxuICAjcmVtb3ZlKFssIHkxLCB5Ml0pIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuI2JpbmFyeVNlYXJjaCh5MSk7XG4gICAgZm9yIChsZXQgaSA9IGluZGV4OyBpIDwgdGhpcy4jaW50ZXJ2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSB0aGlzLiNpbnRlcnZhbHNbaV07XG4gICAgICBpZiAoc3RhcnQgIT09IHkxKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ID09PSB5MSAmJiBlbmQgPT09IHkyKSB7XG4gICAgICAgIHRoaXMuI2ludGVydmFscy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IGluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IHRoaXMuI2ludGVydmFsc1tpXTtcbiAgICAgIGlmIChzdGFydCAhPT0geTEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPT09IHkxICYmIGVuZCA9PT0geTIpIHtcbiAgICAgICAgdGhpcy4jaW50ZXJ2YWxzLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAjYnJlYWtFZGdlKGVkZ2UpIHtcbiAgICBjb25zdCBbeCwgeTEsIHkyXSA9IGVkZ2U7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtbeCwgeTEsIHkyXV07XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLiNiaW5hcnlTZWFyY2goeTIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gdGhpcy4jaW50ZXJ2YWxzW2ldO1xuICAgICAgZm9yIChsZXQgaiA9IDAsIGpqID0gcmVzdWx0cy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgIGNvbnN0IFssIHkzLCB5NF0gPSByZXN1bHRzW2pdO1xuICAgICAgICBpZiAoZW5kIDw9IHkzIHx8IHk0IDw9IHN0YXJ0KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkzID49IHN0YXJ0KSB7XG4gICAgICAgICAgaWYgKHk0ID4gZW5kKSB7XG4gICAgICAgICAgICByZXN1bHRzW2pdWzFdID0gZW5kO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoamogPT09IDEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0cy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgICAgICBqai0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRzW2pdWzJdID0gc3RhcnQ7XG4gICAgICAgIGlmICh5NCA+IGVuZCkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChbeCwgZW5kLCB5NF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG59XG5jbGFzcyBIaWdobGlnaHRPdXRsaW5lIGV4dGVuZHMgT3V0bGluZSB7XG4gICNib3g7XG4gICNvdXRsaW5lcztcbiAgY29uc3RydWN0b3Iob3V0bGluZXMsIGJveCwgbGFzdFBvaW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNvdXRsaW5lcyA9IG91dGxpbmVzO1xuICAgIHRoaXMuI2JveCA9IGJveDtcbiAgICB0aGlzLmxhc3RQb2ludCA9IGxhc3RQb2ludDtcbiAgfVxuICB0b1NWR1BhdGgoKSB7XG4gICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgZm9yIChjb25zdCBwb2x5Z29uIG9mIHRoaXMuI291dGxpbmVzKSB7XG4gICAgICBsZXQgW3ByZXZYLCBwcmV2WV0gPSBwb2x5Z29uO1xuICAgICAgYnVmZmVyLnB1c2goYE0ke3ByZXZYfSAke3ByZXZZfWApO1xuICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCBwb2x5Z29uLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IHggPSBwb2x5Z29uW2ldO1xuICAgICAgICBjb25zdCB5ID0gcG9seWdvbltpICsgMV07XG4gICAgICAgIGlmICh4ID09PSBwcmV2WCkge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKGBWJHt5fWApO1xuICAgICAgICAgIHByZXZZID0geTtcbiAgICAgICAgfSBlbHNlIGlmICh5ID09PSBwcmV2WSkge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKGBIJHt4fWApO1xuICAgICAgICAgIHByZXZYID0geDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnVmZmVyLnB1c2goXCJaXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oXCIgXCIpO1xuICB9XG4gIHNlcmlhbGl6ZShbYmxYLCBibFksIHRyWCwgdHJZXSwgX3JvdGF0aW9uKSB7XG4gICAgY29uc3Qgb3V0bGluZXMgPSBbXTtcbiAgICBjb25zdCB3aWR0aCA9IHRyWCAtIGJsWDtcbiAgICBjb25zdCBoZWlnaHQgPSB0clkgLSBibFk7XG4gICAgZm9yIChjb25zdCBvdXRsaW5lIG9mIHRoaXMuI291dGxpbmVzKSB7XG4gICAgICBjb25zdCBwb2ludHMgPSBuZXcgQXJyYXkob3V0bGluZS5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRsaW5lLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHBvaW50c1tpXSA9IGJsWCArIG91dGxpbmVbaV0gKiB3aWR0aDtcbiAgICAgICAgcG9pbnRzW2kgKyAxXSA9IHRyWSAtIG91dGxpbmVbaSArIDFdICogaGVpZ2h0O1xuICAgICAgfVxuICAgICAgb3V0bGluZXMucHVzaChwb2ludHMpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0bGluZXM7XG4gIH1cbiAgZ2V0IGJveCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYm94O1xuICB9XG4gIGdldCBjbGFzc05hbWVzRm9yT3V0bGluaW5nKCkge1xuICAgIHJldHVybiBbXCJoaWdobGlnaHRPdXRsaW5lXCJdO1xuICB9XG59XG5jbGFzcyBGcmVlSGlnaGxpZ2h0T3V0bGluZXIgZXh0ZW5kcyBGcmVlRHJhd091dGxpbmVyIHtcbiAgbmV3RnJlZURyYXdPdXRsaW5lKG91dGxpbmUsIHBvaW50cywgYm94LCBzY2FsZUZhY3RvciwgaW5uZXJNYXJnaW4sIGlzTFRSKSB7XG4gICAgcmV0dXJuIG5ldyBGcmVlSGlnaGxpZ2h0T3V0bGluZShvdXRsaW5lLCBwb2ludHMsIGJveCwgc2NhbGVGYWN0b3IsIGlubmVyTWFyZ2luLCBpc0xUUik7XG4gIH1cbn1cbmNsYXNzIEZyZWVIaWdobGlnaHRPdXRsaW5lIGV4dGVuZHMgRnJlZURyYXdPdXRsaW5lIHtcbiAgbmV3T3V0bGluZXIocG9pbnQsIGJveCwgc2NhbGVGYWN0b3IsIHRoaWNrbmVzcywgaXNMVFIsIGlubmVyTWFyZ2luID0gMCkge1xuICAgIHJldHVybiBuZXcgRnJlZUhpZ2hsaWdodE91dGxpbmVyKHBvaW50LCBib3gsIHNjYWxlRmFjdG9yLCB0aGlja25lc3MsIGlzTFRSLCBpbm5lck1hcmdpbik7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2NvbG9yX3BpY2tlci5qc1xuXG5cblxuY2xhc3MgQ29sb3JQaWNrZXIge1xuICAjYnV0dG9uID0gbnVsbDtcbiAgI2J1dHRvblN3YXRjaCA9IG51bGw7XG4gICNkZWZhdWx0Q29sb3I7XG4gICNkcm9wZG93biA9IG51bGw7XG4gICNkcm9wZG93bldhc0Zyb21LZXlib2FyZCA9IGZhbHNlO1xuICAjaXNNYWluQ29sb3JQaWNrZXIgPSBmYWxzZTtcbiAgI2VkaXRvciA9IG51bGw7XG4gICNldmVudEJ1cztcbiAgI29wZW5Ecm9wZG93bkFDID0gbnVsbDtcbiAgI3VpTWFuYWdlciA9IG51bGw7XG4gICN0eXBlO1xuICBzdGF0aWMgI2wxMG5Db2xvciA9IG51bGw7XG4gIHN0YXRpYyBnZXQgX2tleWJvYXJkTWFuYWdlcigpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2tleWJvYXJkTWFuYWdlclwiLCBuZXcgS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiRXNjYXBlXCIsIFwibWFjK0VzY2FwZVwiXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLl9oaWRlRHJvcGRvd25Gcm9tS2V5Ym9hcmRdLCBbW1wiIFwiLCBcIm1hYysgXCJdLCBDb2xvclBpY2tlci5wcm90b3R5cGUuX2NvbG9yU2VsZWN0RnJvbUtleWJvYXJkXSwgW1tcIkFycm93RG93blwiLCBcIkFycm93UmlnaHRcIiwgXCJtYWMrQXJyb3dEb3duXCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIENvbG9yUGlja2VyLnByb3RvdHlwZS5fbW92ZVRvTmV4dF0sIFtbXCJBcnJvd1VwXCIsIFwiQXJyb3dMZWZ0XCIsIFwibWFjK0Fycm93VXBcIiwgXCJtYWMrQXJyb3dMZWZ0XCJdLCBDb2xvclBpY2tlci5wcm90b3R5cGUuX21vdmVUb1ByZXZpb3VzXSwgW1tcIkhvbWVcIiwgXCJtYWMrSG9tZVwiXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLl9tb3ZlVG9CZWdpbm5pbmddLCBbW1wiRW5kXCIsIFwibWFjK0VuZFwiXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLl9tb3ZlVG9FbmRdXSkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBlZGl0b3IgPSBudWxsLFxuICAgIHVpTWFuYWdlciA9IG51bGxcbiAgfSkge1xuICAgIGlmIChlZGl0b3IpIHtcbiAgICAgIHRoaXMuI2lzTWFpbkNvbG9yUGlja2VyID0gZmFsc2U7XG4gICAgICB0aGlzLiN0eXBlID0gQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0NPTE9SO1xuICAgICAgdGhpcy4jZWRpdG9yID0gZWRpdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNpc01haW5Db2xvclBpY2tlciA9IHRydWU7XG4gICAgICB0aGlzLiN0eXBlID0gQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0RFRkFVTFRfQ09MT1I7XG4gICAgfVxuICAgIHRoaXMuI3VpTWFuYWdlciA9IGVkaXRvcj8uX3VpTWFuYWdlciB8fCB1aU1hbmFnZXI7XG4gICAgdGhpcy4jZXZlbnRCdXMgPSB0aGlzLiN1aU1hbmFnZXIuX2V2ZW50QnVzO1xuICAgIHRoaXMuI2RlZmF1bHRDb2xvciA9IGVkaXRvcj8uY29sb3IgfHwgdGhpcy4jdWlNYW5hZ2VyPy5oaWdobGlnaHRDb2xvcnMudmFsdWVzKCkubmV4dCgpLnZhbHVlIHx8IFwiI0ZGRkY5OFwiO1xuICAgIENvbG9yUGlja2VyLiNsMTBuQ29sb3IgfHw9IE9iamVjdC5mcmVlemUoe1xuICAgICAgYmx1ZTogXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXItYmx1ZVwiLFxuICAgICAgZ3JlZW46IFwicGRmanMtZWRpdG9yLWNvbG9ycGlja2VyLWdyZWVuXCIsXG4gICAgICBwaW5rOiBcInBkZmpzLWVkaXRvci1jb2xvcnBpY2tlci1waW5rXCIsXG4gICAgICByZWQ6IFwicGRmanMtZWRpdG9yLWNvbG9ycGlja2VyLXJlZFwiLFxuICAgICAgeWVsbG93OiBcInBkZmpzLWVkaXRvci1jb2xvcnBpY2tlci15ZWxsb3dcIlxuICAgIH0pO1xuICB9XG4gIHJlbmRlckJ1dHRvbigpIHtcbiAgICBjb25zdCBidXR0b24gPSB0aGlzLiNidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGJ1dHRvbi5jbGFzc05hbWUgPSBcImNvbG9yUGlja2VyXCI7XG4gICAgYnV0dG9uLnRhYkluZGV4ID0gXCIwXCI7XG4gICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWVkaXRvci1jb2xvcnBpY2tlci1idXR0b25cIik7XG4gICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtaGFzcG9wdXBcIiwgdHJ1ZSk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNvcGVuRHJvcGRvd24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2tleURvd24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3Qgc3dhdGNoID0gdGhpcy4jYnV0dG9uU3dhdGNoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgc3dhdGNoLmNsYXNzTmFtZSA9IFwic3dhdGNoXCI7XG4gICAgc3dhdGNoLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIHRydWUpO1xuICAgIHN3YXRjaC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLiNkZWZhdWx0Q29sb3I7XG4gICAgYnV0dG9uLmFwcGVuZChzd2F0Y2gpO1xuICAgIHJldHVybiBidXR0b247XG4gIH1cbiAgcmVuZGVyTWFpbkRyb3Bkb3duKCkge1xuICAgIGNvbnN0IGRyb3Bkb3duID0gdGhpcy4jZHJvcGRvd24gPSB0aGlzLiNnZXREcm9wZG93blJvb3QoKTtcbiAgICBkcm9wZG93bi5zZXRBdHRyaWJ1dGUoXCJhcmlhLW9yaWVudGF0aW9uXCIsIFwiaG9yaXpvbnRhbFwiKTtcbiAgICBkcm9wZG93bi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsbGVkYnlcIiwgXCJoaWdobGlnaHRDb2xvclBpY2tlckxhYmVsXCIpO1xuICAgIHJldHVybiBkcm9wZG93bjtcbiAgfVxuICAjZ2V0RHJvcGRvd25Sb290KCkge1xuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBkaXYuY2xhc3NOYW1lID0gXCJkcm9wZG93blwiO1xuICAgIGRpdi5yb2xlID0gXCJsaXN0Ym94XCI7XG4gICAgZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbXVsdGlzZWxlY3RhYmxlXCIsIGZhbHNlKTtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1vcmllbnRhdGlvblwiLCBcInZlcnRpY2FsXCIpO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXItZHJvcGRvd25cIik7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgY29sb3JdIG9mIHRoaXMuI3VpTWFuYWdlci5oaWdobGlnaHRDb2xvcnMpIHtcbiAgICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICBidXR0b24udGFiSW5kZXggPSBcIjBcIjtcbiAgICAgIGJ1dHRvbi5yb2xlID0gXCJvcHRpb25cIjtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbG9yXCIsIGNvbG9yKTtcbiAgICAgIGJ1dHRvbi50aXRsZSA9IG5hbWU7XG4gICAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIENvbG9yUGlja2VyLiNsMTBuQ29sb3JbbmFtZV0pO1xuICAgICAgY29uc3Qgc3dhdGNoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBidXR0b24uYXBwZW5kKHN3YXRjaCk7XG4gICAgICBzd2F0Y2guY2xhc3NOYW1lID0gXCJzd2F0Y2hcIjtcbiAgICAgIHN3YXRjaC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsIGNvbG9yID09PSB0aGlzLiNkZWZhdWx0Q29sb3IpO1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNjb2xvclNlbGVjdC5iaW5kKHRoaXMsIGNvbG9yKSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgZGl2LmFwcGVuZChidXR0b24pO1xuICAgIH1cbiAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4ja2V5RG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICByZXR1cm4gZGl2O1xuICB9XG4gICNjb2xvclNlbGVjdChjb2xvciwgZXZlbnQpIHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB0aGlzLiNldmVudEJ1cy5kaXNwYXRjaChcInN3aXRjaGFubm90YXRpb25lZGl0b3JwYXJhbXNcIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgdHlwZTogdGhpcy4jdHlwZSxcbiAgICAgIHZhbHVlOiBjb2xvclxuICAgIH0pO1xuICB9XG4gIF9jb2xvclNlbGVjdEZyb21LZXlib2FyZChldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuI2J1dHRvbikge1xuICAgICAgdGhpcy4jb3BlbkRyb3Bkb3duKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29sb3IgPSBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jb2xvclwiKTtcbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbG9yU2VsZWN0KGNvbG9yLCBldmVudCk7XG4gIH1cbiAgX21vdmVUb05leHQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLiNidXR0b24pIHtcbiAgICAgIHRoaXMuI2Ryb3Bkb3duLmZpcnN0Q2hpbGQ/LmZvY3VzKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnRhcmdldC5uZXh0U2libGluZz8uZm9jdXMoKTtcbiAgfVxuICBfbW92ZVRvUHJldmlvdXMoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLiNkcm9wZG93bj8uZmlyc3RDaGlsZCB8fCBldmVudC50YXJnZXQgPT09IHRoaXMuI2J1dHRvbikge1xuICAgICAgaWYgKHRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuX2hpZGVEcm9wZG93bkZyb21LZXlib2FyZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd24oZXZlbnQpO1xuICAgIH1cbiAgICBldmVudC50YXJnZXQucHJldmlvdXNTaWJsaW5nPy5mb2N1cygpO1xuICB9XG4gIF9tb3ZlVG9CZWdpbm5pbmcoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNkcm9wZG93bi5maXJzdENoaWxkPy5mb2N1cygpO1xuICB9XG4gIF9tb3ZlVG9FbmQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNkcm9wZG93bi5sYXN0Q2hpbGQ/LmZvY3VzKCk7XG4gIH1cbiAgI2tleURvd24oZXZlbnQpIHtcbiAgICBDb2xvclBpY2tlci5fa2V5Ym9hcmRNYW5hZ2VyLmV4ZWModGhpcywgZXZlbnQpO1xuICB9XG4gICNvcGVuRHJvcGRvd24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy4jaXNEcm9wZG93blZpc2libGUpIHtcbiAgICAgIHRoaXMuaGlkZURyb3Bkb3duKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2Ryb3Bkb3duV2FzRnJvbUtleWJvYXJkID0gZXZlbnQuZGV0YWlsID09PSAwO1xuICAgIGlmICghdGhpcy4jb3BlbkRyb3Bkb3duQUMpIHtcbiAgICAgIHRoaXMuI29wZW5Ecm9wZG93bkFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiNwb2ludGVyRG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICAgIHNpZ25hbDogdGhpcy4jdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI29wZW5Ecm9wZG93bkFDKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNkcm9wZG93bikge1xuICAgICAgdGhpcy4jZHJvcGRvd24uY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuI2Ryb3Bkb3duID0gdGhpcy4jZ2V0RHJvcGRvd25Sb290KCk7XG4gICAgdGhpcy4jYnV0dG9uLmFwcGVuZChyb290KTtcbiAgfVxuICAjcG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy4jZHJvcGRvd24/LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5oaWRlRHJvcGRvd24oKTtcbiAgfVxuICBoaWRlRHJvcGRvd24oKSB7XG4gICAgdGhpcy4jZHJvcGRvd24/LmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XG4gICAgdGhpcy4jb3BlbkRyb3Bkb3duQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jb3BlbkRyb3Bkb3duQUMgPSBudWxsO1xuICB9XG4gIGdldCAjaXNEcm9wZG93blZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Ryb3Bkb3duICYmICF0aGlzLiNkcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoXCJoaWRkZW5cIik7XG4gIH1cbiAgX2hpZGVEcm9wZG93bkZyb21LZXlib2FyZCgpIHtcbiAgICBpZiAodGhpcy4jaXNNYWluQ29sb3JQaWNrZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNpc0Ryb3Bkb3duVmlzaWJsZSkge1xuICAgICAgdGhpcy4jZWRpdG9yPy51bnNlbGVjdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmhpZGVEcm9wZG93bigpO1xuICAgIHRoaXMuI2J1dHRvbi5mb2N1cyh7XG4gICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlLFxuICAgICAgZm9jdXNWaXNpYmxlOiB0aGlzLiNkcm9wZG93bldhc0Zyb21LZXlib2FyZFxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZUNvbG9yKGNvbG9yKSB7XG4gICAgaWYgKHRoaXMuI2J1dHRvblN3YXRjaCkge1xuICAgICAgdGhpcy4jYnV0dG9uU3dhdGNoLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2Ryb3Bkb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGkgPSB0aGlzLiN1aU1hbmFnZXIuaGlnaGxpZ2h0Q29sb3JzLnZhbHVlcygpO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy4jZHJvcGRvd24uY2hpbGRyZW4pIHtcbiAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgaS5uZXh0KCkudmFsdWUgPT09IGNvbG9yKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNidXR0b24/LnJlbW92ZSgpO1xuICAgIHRoaXMuI2J1dHRvbiA9IG51bGw7XG4gICAgdGhpcy4jYnV0dG9uU3dhdGNoID0gbnVsbDtcbiAgICB0aGlzLiNkcm9wZG93bj8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jZHJvcGRvd24gPSBudWxsO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9oaWdobGlnaHQuanNcblxuXG5cblxuXG5cblxuY2xhc3MgSGlnaGxpZ2h0RWRpdG9yIGV4dGVuZHMgQW5ub3RhdGlvbkVkaXRvciB7XG4gICNhbmNob3JOb2RlID0gbnVsbDtcbiAgI2FuY2hvck9mZnNldCA9IDA7XG4gICNib3hlcztcbiAgI2NsaXBQYXRoSWQgPSBudWxsO1xuICAjY29sb3JQaWNrZXIgPSBudWxsO1xuICAjZm9jdXNPdXRsaW5lcyA9IG51bGw7XG4gICNmb2N1c05vZGUgPSBudWxsO1xuICAjZm9jdXNPZmZzZXQgPSAwO1xuICAjaGlnaGxpZ2h0RGl2ID0gbnVsbDtcbiAgI2hpZ2hsaWdodE91dGxpbmVzID0gbnVsbDtcbiAgI2lkID0gbnVsbDtcbiAgI2lzRnJlZUhpZ2hsaWdodCA9IGZhbHNlO1xuICAjbGFzdFBvaW50ID0gbnVsbDtcbiAgI29wYWNpdHk7XG4gICNvdXRsaW5lSWQgPSBudWxsO1xuICAjdGV4dCA9IFwiXCI7XG4gICN0aGlja25lc3M7XG4gICNtZXRob2RPZkNyZWF0aW9uID0gXCJcIjtcbiAgc3RhdGljIF9kZWZhdWx0Q29sb3IgPSBudWxsO1xuICBzdGF0aWMgX2RlZmF1bHRPcGFjaXR5ID0gMTtcbiAgc3RhdGljIF9kZWZhdWx0VGhpY2tuZXNzID0gMTI7XG4gIHN0YXRpYyBfdHlwZSA9IFwiaGlnaGxpZ2h0XCI7XG4gIHN0YXRpYyBfZWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVDtcbiAgc3RhdGljIF9mcmVlSGlnaGxpZ2h0SWQgPSAtMTtcbiAgc3RhdGljIF9mcmVlSGlnaGxpZ2h0ID0gbnVsbDtcbiAgc3RhdGljIF9mcmVlSGlnaGxpZ2h0Q2xpcElkID0gXCJcIjtcbiAgc3RhdGljIGdldCBfa2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGNvbnN0IHByb3RvID0gSGlnaGxpZ2h0RWRpdG9yLnByb3RvdHlwZTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2tleWJvYXJkTWFuYWdlclwiLCBuZXcgS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiQXJyb3dMZWZ0XCIsIFwibWFjK0Fycm93TGVmdFwiXSwgcHJvdG8uX21vdmVDYXJldCwge1xuICAgICAgYXJnczogWzBdXG4gICAgfV0sIFtbXCJBcnJvd1JpZ2h0XCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIHByb3RvLl9tb3ZlQ2FyZXQsIHtcbiAgICAgIGFyZ3M6IFsxXVxuICAgIH1dLCBbW1wiQXJyb3dVcFwiLCBcIm1hYytBcnJvd1VwXCJdLCBwcm90by5fbW92ZUNhcmV0LCB7XG4gICAgICBhcmdzOiBbMl1cbiAgICB9XSwgW1tcIkFycm93RG93blwiLCBcIm1hYytBcnJvd0Rvd25cIl0sIHByb3RvLl9tb3ZlQ2FyZXQsIHtcbiAgICAgIGFyZ3M6IFszXVxuICAgIH1dXSkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIG5hbWU6IFwiaGlnaGxpZ2h0RWRpdG9yXCJcbiAgICB9KTtcbiAgICB0aGlzLmNvbG9yID0gcGFyYW1zLmNvbG9yIHx8IEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdENvbG9yO1xuICAgIHRoaXMuI3RoaWNrbmVzcyA9IHBhcmFtcy50aGlja25lc3MgfHwgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzO1xuICAgIHRoaXMuI29wYWNpdHkgPSBwYXJhbXMub3BhY2l0eSB8fCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRPcGFjaXR5O1xuICAgIHRoaXMuI2JveGVzID0gcGFyYW1zLmJveGVzIHx8IG51bGw7XG4gICAgdGhpcy4jbWV0aG9kT2ZDcmVhdGlvbiA9IHBhcmFtcy5tZXRob2RPZkNyZWF0aW9uIHx8IFwiXCI7XG4gICAgdGhpcy4jdGV4dCA9IHBhcmFtcy50ZXh0IHx8IFwiXCI7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICB0aGlzLmRlZmF1bHRMMTBuSWQgPSBcInBkZmpzLWVkaXRvci1oaWdobGlnaHQtZWRpdG9yXCI7XG4gICAgaWYgKHBhcmFtcy5oaWdobGlnaHRJZCA+IC0xKSB7XG4gICAgICB0aGlzLiNpc0ZyZWVIaWdobGlnaHQgPSB0cnVlO1xuICAgICAgdGhpcy4jY3JlYXRlRnJlZU91dGxpbmVzKHBhcmFtcyk7XG4gICAgICB0aGlzLiNhZGRUb0RyYXdMYXllcigpO1xuICAgIH0gZWxzZSBpZiAodGhpcy4jYm94ZXMpIHtcbiAgICAgIHRoaXMuI2FuY2hvck5vZGUgPSBwYXJhbXMuYW5jaG9yTm9kZTtcbiAgICAgIHRoaXMuI2FuY2hvck9mZnNldCA9IHBhcmFtcy5hbmNob3JPZmZzZXQ7XG4gICAgICB0aGlzLiNmb2N1c05vZGUgPSBwYXJhbXMuZm9jdXNOb2RlO1xuICAgICAgdGhpcy4jZm9jdXNPZmZzZXQgPSBwYXJhbXMuZm9jdXNPZmZzZXQ7XG4gICAgICB0aGlzLiNjcmVhdGVPdXRsaW5lcygpO1xuICAgICAgdGhpcy4jYWRkVG9EcmF3TGF5ZXIoKTtcbiAgICAgIHRoaXMucm90YXRlKHRoaXMucm90YXRpb24pO1xuICAgIH1cbiAgfVxuICBnZXQgdGVsZW1ldHJ5SW5pdGlhbERhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGlvbjogXCJhZGRlZFwiLFxuICAgICAgdHlwZTogdGhpcy4jaXNGcmVlSGlnaGxpZ2h0ID8gXCJmcmVlX2hpZ2hsaWdodFwiIDogXCJoaWdobGlnaHRcIixcbiAgICAgIGNvbG9yOiB0aGlzLl91aU1hbmFnZXIuaGlnaGxpZ2h0Q29sb3JOYW1lcy5nZXQodGhpcy5jb2xvciksXG4gICAgICB0aGlja25lc3M6IHRoaXMuI3RoaWNrbmVzcyxcbiAgICAgIG1ldGhvZE9mQ3JlYXRpb246IHRoaXMuI21ldGhvZE9mQ3JlYXRpb25cbiAgICB9O1xuICB9XG4gIGdldCB0ZWxlbWV0cnlGaW5hbERhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaGlnaGxpZ2h0XCIsXG4gICAgICBjb2xvcjogdGhpcy5fdWlNYW5hZ2VyLmhpZ2hsaWdodENvbG9yTmFtZXMuZ2V0KHRoaXMuY29sb3IpXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgY29tcHV0ZVRlbGVtZXRyeUZpbmFsRGF0YShkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG51bWJlck9mQ29sb3JzOiBkYXRhLmdldChcImNvbG9yXCIpLnNpemVcbiAgICB9O1xuICB9XG4gICNjcmVhdGVPdXRsaW5lcygpIHtcbiAgICBjb25zdCBvdXRsaW5lciA9IG5ldyBIaWdobGlnaHRPdXRsaW5lcih0aGlzLiNib3hlcywgMC4wMDEpO1xuICAgIHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzID0gb3V0bGluZXIuZ2V0T3V0bGluZXMoKTtcbiAgICBbdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XSA9IHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLmJveDtcbiAgICBjb25zdCBvdXRsaW5lckZvck91dGxpbmUgPSBuZXcgSGlnaGxpZ2h0T3V0bGluZXIodGhpcy4jYm94ZXMsIDAuMDAyNSwgMC4wMDEsIHRoaXMuX3VpTWFuYWdlci5kaXJlY3Rpb24gPT09IFwibHRyXCIpO1xuICAgIHRoaXMuI2ZvY3VzT3V0bGluZXMgPSBvdXRsaW5lckZvck91dGxpbmUuZ2V0T3V0bGluZXMoKTtcbiAgICBjb25zdCB7XG4gICAgICBsYXN0UG9pbnRcbiAgICB9ID0gdGhpcy4jZm9jdXNPdXRsaW5lcztcbiAgICB0aGlzLiNsYXN0UG9pbnQgPSBbKGxhc3RQb2ludFswXSAtIHRoaXMueCkgLyB0aGlzLndpZHRoLCAobGFzdFBvaW50WzFdIC0gdGhpcy55KSAvIHRoaXMuaGVpZ2h0XTtcbiAgfVxuICAjY3JlYXRlRnJlZU91dGxpbmVzKHtcbiAgICBoaWdobGlnaHRPdXRsaW5lcyxcbiAgICBoaWdobGlnaHRJZCxcbiAgICBjbGlwUGF0aElkXG4gIH0pIHtcbiAgICB0aGlzLiNoaWdobGlnaHRPdXRsaW5lcyA9IGhpZ2hsaWdodE91dGxpbmVzO1xuICAgIGNvbnN0IGV4dHJhVGhpY2tuZXNzID0gMS41O1xuICAgIHRoaXMuI2ZvY3VzT3V0bGluZXMgPSBoaWdobGlnaHRPdXRsaW5lcy5nZXROZXdPdXRsaW5lKHRoaXMuI3RoaWNrbmVzcyAvIDIgKyBleHRyYVRoaWNrbmVzcywgMC4wMDI1KTtcbiAgICBpZiAoaGlnaGxpZ2h0SWQgPj0gMCkge1xuICAgICAgdGhpcy4jaWQgPSBoaWdobGlnaHRJZDtcbiAgICAgIHRoaXMuI2NsaXBQYXRoSWQgPSBjbGlwUGF0aElkO1xuICAgICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLmZpbmFsaXplRHJhdyhoaWdobGlnaHRJZCwge1xuICAgICAgICBiYm94OiBoaWdobGlnaHRPdXRsaW5lcy5ib3gsXG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICBkOiBoaWdobGlnaHRPdXRsaW5lcy50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuI291dGxpbmVJZCA9IHRoaXMucGFyZW50LmRyYXdMYXllci5kcmF3T3V0bGluZSh7XG4gICAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICAgIGhpZ2hsaWdodE91dGxpbmU6IHRydWUsXG4gICAgICAgICAgZnJlZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBiYm94OiB0aGlzLiNmb2N1c091dGxpbmVzLmJveCxcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IHRoaXMuI2ZvY3VzT3V0bGluZXMudG9TVkdQYXRoKClcbiAgICAgICAgfVxuICAgICAgfSwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgY29uc3QgYW5nbGUgPSB0aGlzLnBhcmVudC52aWV3cG9ydC5yb3RhdGlvbjtcbiAgICAgIHRoaXMucGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI2lkLCB7XG4gICAgICAgIGJib3g6IEhpZ2hsaWdodEVkaXRvci4jcm90YXRlQmJveCh0aGlzLiNoaWdobGlnaHRPdXRsaW5lcy5ib3gsIChhbmdsZSAtIHRoaXMucm90YXRpb24gKyAzNjApICUgMzYwKSxcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IGhpZ2hsaWdodE91dGxpbmVzLnRvU1ZHUGF0aCgpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jb3V0bGluZUlkLCB7XG4gICAgICAgIGJib3g6IEhpZ2hsaWdodEVkaXRvci4jcm90YXRlQmJveCh0aGlzLiNmb2N1c091dGxpbmVzLmJveCwgYW5nbGUpLFxuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgZDogdGhpcy4jZm9jdXNPdXRsaW5lcy50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gaGlnaGxpZ2h0T3V0bGluZXMuYm94O1xuICAgIHN3aXRjaCAodGhpcy5yb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICAgICAgICB0aGlzLnggPSB5O1xuICAgICAgICAgIHRoaXMueSA9IDEgLSB4O1xuICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHBhZ2VIZWlnaHQgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKiBwYWdlV2lkdGggLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgdGhpcy54ID0gMSAtIHg7XG4gICAgICAgIHRoaXMueSA9IDEgLSB5O1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgICAgICAgdGhpcy54ID0gMSAtIHk7XG4gICAgICAgICAgdGhpcy55ID0geDtcbiAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGggKiBwYWdlSGVpZ2h0IC8gcGFnZVdpZHRoO1xuICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogcGFnZVdpZHRoIC8gcGFnZUhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBsYXN0UG9pbnRcbiAgICB9ID0gdGhpcy4jZm9jdXNPdXRsaW5lcztcbiAgICB0aGlzLiNsYXN0UG9pbnQgPSBbKGxhc3RQb2ludFswXSAtIHgpIC8gd2lkdGgsIChsYXN0UG9pbnRbMV0gLSB5KSAvIGhlaWdodF07XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKSB7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5pbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcik7XG4gICAgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0Q29sb3IgfHw9IHVpTWFuYWdlci5oaWdobGlnaHRDb2xvcnM/LnZhbHVlcygpLm5leHQoKS52YWx1ZSB8fCBcIiNmZmYwNjZcIjtcbiAgfVxuICBzdGF0aWMgdXBkYXRlRGVmYXVsdFBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfREVGQVVMVF9DT0xPUjpcbiAgICAgICAgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0Q29sb3IgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9USElDS05FU1M6XG4gICAgICAgIEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdFRoaWNrbmVzcyA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdHJhbnNsYXRlSW5QYWdlKHgsIHkpIHt9XG4gIGdldCB0b29sYmFyUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuI2xhc3RQb2ludDtcbiAgfVxuICB1cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0NPTE9SOlxuICAgICAgICB0aGlzLiN1cGRhdGVDb2xvcih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfVEhJQ0tORVNTOlxuICAgICAgICB0aGlzLiN1cGRhdGVUaGlja25lc3ModmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBkZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9ERUZBVUxUX0NPTE9SLCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRDb2xvcl0sIFtBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfVEhJQ0tORVNTLCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRUaGlja25lc3NdXTtcbiAgfVxuICBnZXQgcHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9DT0xPUiwgdGhpcy5jb2xvciB8fCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRDb2xvcl0sIFtBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfVEhJQ0tORVNTLCB0aGlzLiN0aGlja25lc3MgfHwgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzXSwgW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9GUkVFLCB0aGlzLiNpc0ZyZWVIaWdobGlnaHRdXTtcbiAgfVxuICAjdXBkYXRlQ29sb3IoY29sb3IpIHtcbiAgICBjb25zdCBzZXRDb2xvckFuZE9wYWNpdHkgPSAoY29sLCBvcGEpID0+IHtcbiAgICAgIHRoaXMuY29sb3IgPSBjb2w7XG4gICAgICB0aGlzLiNvcGFjaXR5ID0gb3BhO1xuICAgICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI2lkLCB7XG4gICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICBmaWxsOiBjb2wsXG4gICAgICAgICAgXCJmaWxsLW9wYWNpdHlcIjogb3BhXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy4jY29sb3JQaWNrZXI/LnVwZGF0ZUNvbG9yKGNvbCk7XG4gICAgfTtcbiAgICBjb25zdCBzYXZlZENvbG9yID0gdGhpcy5jb2xvcjtcbiAgICBjb25zdCBzYXZlZE9wYWNpdHkgPSB0aGlzLiNvcGFjaXR5O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiBzZXRDb2xvckFuZE9wYWNpdHkuYmluZCh0aGlzLCBjb2xvciwgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0T3BhY2l0eSksXG4gICAgICB1bmRvOiBzZXRDb2xvckFuZE9wYWNpdHkuYmluZCh0aGlzLCBzYXZlZENvbG9yLCBzYXZlZE9wYWNpdHkpLFxuICAgICAgcG9zdDogdGhpcy5fdWlNYW5hZ2VyLnVwZGF0ZVVJLmJpbmQodGhpcy5fdWlNYW5hZ2VyLCB0aGlzKSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0NPTE9SLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgIGFjdGlvbjogXCJjb2xvcl9jaGFuZ2VkXCIsXG4gICAgICBjb2xvcjogdGhpcy5fdWlNYW5hZ2VyLmhpZ2hsaWdodENvbG9yTmFtZXMuZ2V0KGNvbG9yKVxuICAgIH0sIHRydWUpO1xuICB9XG4gICN1cGRhdGVUaGlja25lc3ModGhpY2tuZXNzKSB7XG4gICAgY29uc3Qgc2F2ZWRUaGlja25lc3MgPSB0aGlzLiN0aGlja25lc3M7XG4gICAgY29uc3Qgc2V0VGhpY2tuZXNzID0gdGggPT4ge1xuICAgICAgdGhpcy4jdGhpY2tuZXNzID0gdGg7XG4gICAgICB0aGlzLiNjaGFuZ2VUaGlja25lc3ModGgpO1xuICAgIH07XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6IHNldFRoaWNrbmVzcy5iaW5kKHRoaXMsIHRoaWNrbmVzcyksXG4gICAgICB1bmRvOiBzZXRUaGlja25lc3MuYmluZCh0aGlzLCBzYXZlZFRoaWNrbmVzcyksXG4gICAgICBwb3N0OiB0aGlzLl91aU1hbmFnZXIudXBkYXRlVUkuYmluZCh0aGlzLl91aU1hbmFnZXIsIHRoaXMpLFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlOiBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfVEhJQ0tORVNTLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgIGFjdGlvbjogXCJ0aGlja25lc3NfY2hhbmdlZFwiLFxuICAgICAgdGhpY2tuZXNzXG4gICAgfSwgdHJ1ZSk7XG4gIH1cbiAgYXN5bmMgYWRkRWRpdFRvb2xiYXIoKSB7XG4gICAgY29uc3QgdG9vbGJhciA9IGF3YWl0IHN1cGVyLmFkZEVkaXRUb29sYmFyKCk7XG4gICAgaWYgKCF0b29sYmFyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3VpTWFuYWdlci5oaWdobGlnaHRDb2xvcnMpIHtcbiAgICAgIHRoaXMuI2NvbG9yUGlja2VyID0gbmV3IENvbG9yUGlja2VyKHtcbiAgICAgICAgZWRpdG9yOiB0aGlzXG4gICAgICB9KTtcbiAgICAgIHRvb2xiYXIuYWRkQ29sb3JQaWNrZXIodGhpcy4jY29sb3JQaWNrZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdG9vbGJhcjtcbiAgfVxuICBkaXNhYmxlRWRpdGluZygpIHtcbiAgICBzdXBlci5kaXNhYmxlRWRpdGluZygpO1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJkaXNhYmxlZFwiLCB0cnVlKTtcbiAgfVxuICBlbmFibGVFZGl0aW5nKCkge1xuICAgIHN1cGVyLmVuYWJsZUVkaXRpbmcoKTtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZGlzYWJsZWRcIiwgZmFsc2UpO1xuICB9XG4gIGZpeEFuZFNldFBvc2l0aW9uKCkge1xuICAgIHJldHVybiBzdXBlci5maXhBbmRTZXRQb3NpdGlvbih0aGlzLiNnZXRSb3RhdGlvbigpKTtcbiAgfVxuICBnZXRCYXNlVHJhbnNsYXRpb24oKSB7XG4gICAgcmV0dXJuIFswLCAwXTtcbiAgfVxuICBnZXRSZWN0KHR4LCB0eSkge1xuICAgIHJldHVybiBzdXBlci5nZXRSZWN0KHR4LCB0eSwgdGhpcy4jZ2V0Um90YXRpb24oKSk7XG4gIH1cbiAgb25jZUFkZGVkKGZvY3VzKSB7XG4gICAgaWYgKCF0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZFVuZG9hYmxlRWRpdG9yKHRoaXMpO1xuICAgIH1cbiAgICBpZiAoZm9jdXMpIHtcbiAgICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gICAgfVxuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLiNjbGVhbkRyYXdMYXllcigpO1xuICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICBhY3Rpb246IFwiZGVsZXRlZFwiXG4gICAgfSk7XG4gICAgc3VwZXIucmVtb3ZlKCk7XG4gIH1cbiAgcmVidWlsZCgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnJlYnVpbGQoKTtcbiAgICBpZiAodGhpcy5kaXYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWRkVG9EcmF3TGF5ZXIoKTtcbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGQodGhpcyk7XG4gICAgfVxuICB9XG4gIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICBsZXQgbXVzdEJlU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5wYXJlbnQgJiYgIXBhcmVudCkge1xuICAgICAgdGhpcy4jY2xlYW5EcmF3TGF5ZXIoKTtcbiAgICB9IGVsc2UgaWYgKHBhcmVudCkge1xuICAgICAgdGhpcy4jYWRkVG9EcmF3TGF5ZXIocGFyZW50KTtcbiAgICAgIG11c3RCZVNlbGVjdGVkID0gIXRoaXMucGFyZW50ICYmIHRoaXMuZGl2Py5jbGFzc0xpc3QuY29udGFpbnMoXCJzZWxlY3RlZEVkaXRvclwiKTtcbiAgICB9XG4gICAgc3VwZXIuc2V0UGFyZW50KHBhcmVudCk7XG4gICAgdGhpcy5zaG93KHRoaXMuX2lzVmlzaWJsZSk7XG4gICAgaWYgKG11c3RCZVNlbGVjdGVkKSB7XG4gICAgICB0aGlzLnNlbGVjdCgpO1xuICAgIH1cbiAgfVxuICAjY2hhbmdlVGhpY2tuZXNzKHRoaWNrbmVzcykge1xuICAgIGlmICghdGhpcy4jaXNGcmVlSGlnaGxpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NyZWF0ZUZyZWVPdXRsaW5lcyh7XG4gICAgICBoaWdobGlnaHRPdXRsaW5lczogdGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMuZ2V0TmV3T3V0bGluZSh0aGlja25lc3MgLyAyKVxuICAgIH0pO1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy5zZXREaW1zKHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICB9XG4gICNjbGVhbkRyYXdMYXllcigpIHtcbiAgICBpZiAodGhpcy4jaWQgPT09IG51bGwgfHwgIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFyZW50LmRyYXdMYXllci5yZW1vdmUodGhpcy4jaWQpO1xuICAgIHRoaXMuI2lkID0gbnVsbDtcbiAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIucmVtb3ZlKHRoaXMuI291dGxpbmVJZCk7XG4gICAgdGhpcy4jb3V0bGluZUlkID0gbnVsbDtcbiAgfVxuICAjYWRkVG9EcmF3TGF5ZXIocGFyZW50ID0gdGhpcy5wYXJlbnQpIHtcbiAgICBpZiAodGhpcy4jaWQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgKHtcbiAgICAgIGlkOiB0aGlzLiNpZCxcbiAgICAgIGNsaXBQYXRoSWQ6IHRoaXMuI2NsaXBQYXRoSWRcbiAgICB9ID0gcGFyZW50LmRyYXdMYXllci5kcmF3KHtcbiAgICAgIGJib3g6IHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLmJveCxcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgdmlld0JveDogXCIwIDAgMSAxXCIsXG4gICAgICAgIGZpbGw6IHRoaXMuY29sb3IsXG4gICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IHRoaXMuI29wYWNpdHlcbiAgICAgIH0sXG4gICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgaGlnaGxpZ2h0OiB0cnVlLFxuICAgICAgICBmcmVlOiB0aGlzLiNpc0ZyZWVIaWdobGlnaHRcbiAgICAgIH0sXG4gICAgICBwYXRoOiB7XG4gICAgICAgIGQ6IHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLnRvU1ZHUGF0aCgpXG4gICAgICB9XG4gICAgfSwgZmFsc2UsIHRydWUpKTtcbiAgICB0aGlzLiNvdXRsaW5lSWQgPSBwYXJlbnQuZHJhd0xheWVyLmRyYXdPdXRsaW5lKHtcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBoaWdobGlnaHRPdXRsaW5lOiB0cnVlLFxuICAgICAgICBmcmVlOiB0aGlzLiNpc0ZyZWVIaWdobGlnaHRcbiAgICAgIH0sXG4gICAgICBiYm94OiB0aGlzLiNmb2N1c091dGxpbmVzLmJveCxcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy4jZm9jdXNPdXRsaW5lcy50b1NWR1BhdGgoKVxuICAgICAgfVxuICAgIH0sIHRoaXMuI2lzRnJlZUhpZ2hsaWdodCk7XG4gICAgaWYgKHRoaXMuI2hpZ2hsaWdodERpdikge1xuICAgICAgdGhpcy4jaGlnaGxpZ2h0RGl2LnN0eWxlLmNsaXBQYXRoID0gdGhpcy4jY2xpcFBhdGhJZDtcbiAgICB9XG4gIH1cbiAgc3RhdGljICNyb3RhdGVCYm94KFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSwgYW5nbGUpIHtcbiAgICBzd2l0Y2ggKGFuZ2xlKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gWzEgLSB5IC0gaGVpZ2h0LCB4LCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gWzEgLSB4IC0gd2lkdGgsIDEgLSB5IC0gaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3ksIDEgLSB4IC0gd2lkdGgsIGhlaWdodCwgd2lkdGhdO1xuICAgIH1cbiAgICByZXR1cm4gW3gsIHksIHdpZHRoLCBoZWlnaHRdO1xuICB9XG4gIHJvdGF0ZShhbmdsZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRyYXdMYXllclxuICAgIH0gPSB0aGlzLnBhcmVudDtcbiAgICBsZXQgYm94O1xuICAgIGlmICh0aGlzLiNpc0ZyZWVIaWdobGlnaHQpIHtcbiAgICAgIGFuZ2xlID0gKGFuZ2xlIC0gdGhpcy5yb3RhdGlvbiArIDM2MCkgJSAzNjA7XG4gICAgICBib3ggPSBIaWdobGlnaHRFZGl0b3IuI3JvdGF0ZUJib3godGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMuYm94LCBhbmdsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJveCA9IEhpZ2hsaWdodEVkaXRvci4jcm90YXRlQmJveChbdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XSwgYW5nbGUpO1xuICAgIH1cbiAgICBkcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLiNpZCwge1xuICAgICAgYmJveDogYm94LFxuICAgICAgcm9vdDoge1xuICAgICAgICBcImRhdGEtbWFpbi1yb3RhdGlvblwiOiBhbmdsZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI291dGxpbmVJZCwge1xuICAgICAgYmJveDogSGlnaGxpZ2h0RWRpdG9yLiNyb3RhdGVCYm94KHRoaXMuI2ZvY3VzT3V0bGluZXMuYm94LCBhbmdsZSksXG4gICAgICByb290OiB7XG4gICAgICAgIFwiZGF0YS1tYWluLXJvdGF0aW9uXCI6IGFuZ2xlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2O1xuICAgIH1cbiAgICBjb25zdCBkaXYgPSBzdXBlci5yZW5kZXIoKTtcbiAgICBpZiAodGhpcy4jdGV4dCkge1xuICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy4jdGV4dCk7XG4gICAgICBkaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcIm1hcmtcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLiNpc0ZyZWVIaWdobGlnaHQpIHtcbiAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKFwiZnJlZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4ja2V5ZG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICAgIHNpZ25hbDogdGhpcy5fdWlNYW5hZ2VyLl9zaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBoaWdobGlnaHREaXYgPSB0aGlzLiNoaWdobGlnaHREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5hcHBlbmQoaGlnaGxpZ2h0RGl2KTtcbiAgICBoaWdobGlnaHREaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgIGhpZ2hsaWdodERpdi5jbGFzc05hbWUgPSBcImludGVybmFsXCI7XG4gICAgaGlnaGxpZ2h0RGl2LnN0eWxlLmNsaXBQYXRoID0gdGhpcy4jY2xpcFBhdGhJZDtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy5zZXREaW1zKHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgIGJpbmRFdmVudHModGhpcywgdGhpcy4jaGlnaGxpZ2h0RGl2LCBbXCJwb2ludGVyb3ZlclwiLCBcInBvaW50ZXJsZWF2ZVwiXSk7XG4gICAgdGhpcy5lbmFibGVFZGl0aW5nKCk7XG4gICAgcmV0dXJuIGRpdjtcbiAgfVxuICBwb2ludGVyb3ZlcigpIHtcbiAgICBpZiAoIXRoaXMuaXNTZWxlY3RlZCkge1xuICAgICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI291dGxpbmVJZCwge1xuICAgICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgICBob3ZlcmVkOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBwb2ludGVybGVhdmUoKSB7XG4gICAgaWYgKCF0aGlzLmlzU2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLiNvdXRsaW5lSWQsIHtcbiAgICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgICAgaG92ZXJlZDogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gICNrZXlkb3duKGV2ZW50KSB7XG4gICAgSGlnaGxpZ2h0RWRpdG9yLl9rZXlib2FyZE1hbmFnZXIuZXhlYyh0aGlzLCBldmVudCk7XG4gIH1cbiAgX21vdmVDYXJldChkaXJlY3Rpb24pIHtcbiAgICB0aGlzLnBhcmVudC51bnNlbGVjdCh0aGlzKTtcbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgY2FzZSAyOlxuICAgICAgICB0aGlzLiNzZXRDYXJldCh0cnVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHRoaXMuI3NldENhcmV0KGZhbHNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gICNzZXRDYXJldChzdGFydCkge1xuICAgIGlmICghdGhpcy4jYW5jaG9yTm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICBzZWxlY3Rpb24uc2V0UG9zaXRpb24odGhpcy4jYW5jaG9yTm9kZSwgdGhpcy4jYW5jaG9yT2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0aW9uLnNldFBvc2l0aW9uKHRoaXMuI2ZvY3VzTm9kZSwgdGhpcy4jZm9jdXNPZmZzZXQpO1xuICAgIH1cbiAgfVxuICBzZWxlY3QoKSB7XG4gICAgc3VwZXIuc2VsZWN0KCk7XG4gICAgaWYgKCF0aGlzLiNvdXRsaW5lSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI291dGxpbmVJZCwge1xuICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgIGhvdmVyZWQ6IGZhbHNlLFxuICAgICAgICBzZWxlY3RlZDogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHVuc2VsZWN0KCkge1xuICAgIHN1cGVyLnVuc2VsZWN0KCk7XG4gICAgaWYgKCF0aGlzLiNvdXRsaW5lSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI291dGxpbmVJZCwge1xuICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgIHNlbGVjdGVkOiBmYWxzZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghdGhpcy4jaXNGcmVlSGlnaGxpZ2h0KSB7XG4gICAgICB0aGlzLiNzZXRDYXJldChmYWxzZSk7XG4gICAgfVxuICB9XG4gIGdldCBfbXVzdEZpeFBvc2l0aW9uKCkge1xuICAgIHJldHVybiAhdGhpcy4jaXNGcmVlSGlnaGxpZ2h0O1xuICB9XG4gIHNob3codmlzaWJsZSA9IHRoaXMuX2lzVmlzaWJsZSkge1xuICAgIHN1cGVyLnNob3codmlzaWJsZSk7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLiNpZCwge1xuICAgICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgICBoaWRkZW46ICF2aXNpYmxlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jb3V0bGluZUlkLCB7XG4gICAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICAgIGhpZGRlbjogIXZpc2libGVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gICNnZXRSb3RhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNGcmVlSGlnaGxpZ2h0ID8gdGhpcy5yb3RhdGlvbiA6IDA7XG4gIH1cbiAgI3NlcmlhbGl6ZUJveGVzKCkge1xuICAgIGlmICh0aGlzLiNpc0ZyZWVIaWdobGlnaHQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3QgW3BhZ2VYLCBwYWdlWV0gPSB0aGlzLnBhZ2VUcmFuc2xhdGlvbjtcbiAgICBjb25zdCBib3hlcyA9IHRoaXMuI2JveGVzO1xuICAgIGNvbnN0IHF1YWRQb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KGJveGVzLmxlbmd0aCAqIDgpO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9IG9mIGJveGVzKSB7XG4gICAgICBjb25zdCBzeCA9IHggKiBwYWdlV2lkdGggKyBwYWdlWDtcbiAgICAgIGNvbnN0IHN5ID0gKDEgLSB5KSAqIHBhZ2VIZWlnaHQgKyBwYWdlWTtcbiAgICAgIHF1YWRQb2ludHNbaV0gPSBxdWFkUG9pbnRzW2kgKyA0XSA9IHN4O1xuICAgICAgcXVhZFBvaW50c1tpICsgMV0gPSBxdWFkUG9pbnRzW2kgKyAzXSA9IHN5O1xuICAgICAgcXVhZFBvaW50c1tpICsgMl0gPSBxdWFkUG9pbnRzW2kgKyA2XSA9IHN4ICsgd2lkdGggKiBwYWdlV2lkdGg7XG4gICAgICBxdWFkUG9pbnRzW2kgKyA1XSA9IHF1YWRQb2ludHNbaSArIDddID0gc3kgLSBoZWlnaHQgKiBwYWdlSGVpZ2h0O1xuICAgICAgaSArPSA4O1xuICAgIH1cbiAgICByZXR1cm4gcXVhZFBvaW50cztcbiAgfVxuICAjc2VyaWFsaXplT3V0bGluZXMocmVjdCkge1xuICAgIHJldHVybiB0aGlzLiNoaWdobGlnaHRPdXRsaW5lcy5zZXJpYWxpemUocmVjdCwgdGhpcy4jZ2V0Um90YXRpb24oKSk7XG4gIH1cbiAgc3RhdGljIHN0YXJ0SGlnaGxpZ2h0aW5nKHBhcmVudCwgaXNMVFIsIHtcbiAgICB0YXJnZXQ6IHRleHRMYXllcixcbiAgICB4LFxuICAgIHlcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHg6IGxheWVyWCxcbiAgICAgIHk6IGxheWVyWSxcbiAgICAgIHdpZHRoOiBwYXJlbnRXaWR0aCxcbiAgICAgIGhlaWdodDogcGFyZW50SGVpZ2h0XG4gICAgfSA9IHRleHRMYXllci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSBwYXJlbnQuY29tYmluZWRTaWduYWwoYWMpO1xuICAgIGNvbnN0IHBvaW50ZXJVcENhbGxiYWNrID0gZSA9PiB7XG4gICAgICBhYy5hYm9ydCgpO1xuICAgICAgdGhpcy4jZW5kSGlnaGxpZ2h0KHBhcmVudCwgZSk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgcG9pbnRlclVwQ2FsbGJhY2ssIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHBvaW50ZXJVcENhbGxiYWNrLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHN0b3BFdmVudCwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0ZXh0TGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHRoaXMuI2hpZ2hsaWdodE1vdmUuYmluZCh0aGlzLCBwYXJlbnQpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLl9mcmVlSGlnaGxpZ2h0ID0gbmV3IEZyZWVIaWdobGlnaHRPdXRsaW5lcih7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0sIFtsYXllclgsIGxheWVyWSwgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0sIHBhcmVudC5zY2FsZSwgdGhpcy5fZGVmYXVsdFRoaWNrbmVzcyAvIDIsIGlzTFRSLCAwLjAwMSk7XG4gICAgKHtcbiAgICAgIGlkOiB0aGlzLl9mcmVlSGlnaGxpZ2h0SWQsXG4gICAgICBjbGlwUGF0aElkOiB0aGlzLl9mcmVlSGlnaGxpZ2h0Q2xpcElkXG4gICAgfSA9IHBhcmVudC5kcmF3TGF5ZXIuZHJhdyh7XG4gICAgICBiYm94OiBbMCwgMCwgMSwgMV0sXG4gICAgICByb290OiB7XG4gICAgICAgIHZpZXdCb3g6IFwiMCAwIDEgMVwiLFxuICAgICAgICBmaWxsOiB0aGlzLl9kZWZhdWx0Q29sb3IsXG4gICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IHRoaXMuX2RlZmF1bHRPcGFjaXR5XG4gICAgICB9LFxuICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgIGhpZ2hsaWdodDogdHJ1ZSxcbiAgICAgICAgZnJlZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy5fZnJlZUhpZ2hsaWdodC50b1NWR1BhdGgoKVxuICAgICAgfVxuICAgIH0sIHRydWUsIHRydWUpKTtcbiAgfVxuICBzdGF0aWMgI2hpZ2hsaWdodE1vdmUocGFyZW50LCBldmVudCkge1xuICAgIGlmICh0aGlzLl9mcmVlSGlnaGxpZ2h0LmFkZChldmVudCkpIHtcbiAgICAgIHBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9mcmVlSGlnaGxpZ2h0SWQsIHtcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IHRoaXMuX2ZyZWVIaWdobGlnaHQudG9TVkdQYXRoKClcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyAjZW5kSGlnaGxpZ2h0KHBhcmVudCwgZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2ZyZWVIaWdobGlnaHQuaXNFbXB0eSgpKSB7XG4gICAgICBwYXJlbnQuY3JlYXRlQW5kQWRkTmV3RWRpdG9yKGV2ZW50LCBmYWxzZSwge1xuICAgICAgICBoaWdobGlnaHRJZDogdGhpcy5fZnJlZUhpZ2hsaWdodElkLFxuICAgICAgICBoaWdobGlnaHRPdXRsaW5lczogdGhpcy5fZnJlZUhpZ2hsaWdodC5nZXRPdXRsaW5lcygpLFxuICAgICAgICBjbGlwUGF0aElkOiB0aGlzLl9mcmVlSGlnaGxpZ2h0Q2xpcElkLFxuICAgICAgICBtZXRob2RPZkNyZWF0aW9uOiBcIm1haW5fdG9vbGJhclwiXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50LmRyYXdMYXllci5yZW1vdmUodGhpcy5fZnJlZUhpZ2hsaWdodElkKTtcbiAgICB9XG4gICAgdGhpcy5fZnJlZUhpZ2hsaWdodElkID0gLTE7XG4gICAgdGhpcy5fZnJlZUhpZ2hsaWdodCA9IG51bGw7XG4gICAgdGhpcy5fZnJlZUhpZ2hsaWdodENsaXBJZCA9IFwiXCI7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgbGV0IGluaXRpYWxEYXRhID0gbnVsbDtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEhpZ2hsaWdodEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBxdWFkUG9pbnRzLFxuICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgY29sb3IsXG4gICAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgICBwb3B1cFJlZlxuICAgICAgICB9LFxuICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgICBwYWdlTnVtYmVyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGluaXRpYWxEYXRhID0gZGF0YSA9IHtcbiAgICAgICAgYW5ub3RhdGlvblR5cGU6IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCxcbiAgICAgICAgY29sb3I6IEFycmF5LmZyb20oY29sb3IpLFxuICAgICAgICBvcGFjaXR5LFxuICAgICAgICBxdWFkUG9pbnRzLFxuICAgICAgICBib3hlczogbnVsbCxcbiAgICAgICAgcGFnZUluZGV4OiBwYWdlTnVtYmVyIC0gMSxcbiAgICAgICAgcmVjdDogcmVjdC5zbGljZSgwKSxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGlkLFxuICAgICAgICBkZWxldGVkOiBmYWxzZSxcbiAgICAgICAgcG9wdXBSZWZcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgSW5rQW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGlua0xpc3RzLFxuICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgY29sb3IsXG4gICAgICAgICAgYm9yZGVyU3R5bGU6IHtcbiAgICAgICAgICAgIHJhd1dpZHRoOiB0aGlja25lc3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBvcHVwUmVmXG4gICAgICAgIH0sXG4gICAgICAgIHBhcmVudDoge1xuICAgICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICAgIHBhZ2VOdW1iZXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gPSBkYXRhO1xuICAgICAgaW5pdGlhbERhdGEgPSBkYXRhID0ge1xuICAgICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hULFxuICAgICAgICBjb2xvcjogQXJyYXkuZnJvbShjb2xvciksXG4gICAgICAgIHRoaWNrbmVzcyxcbiAgICAgICAgaW5rTGlzdHMsXG4gICAgICAgIGJveGVzOiBudWxsLFxuICAgICAgICBwYWdlSW5kZXg6IHBhZ2VOdW1iZXIgLSAxLFxuICAgICAgICByZWN0OiByZWN0LnNsaWNlKDApLFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgaWQsXG4gICAgICAgIGRlbGV0ZWQ6IGZhbHNlLFxuICAgICAgICBwb3B1cFJlZlxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY29sb3IsXG4gICAgICBxdWFkUG9pbnRzLFxuICAgICAgaW5rTGlzdHMsXG4gICAgICBvcGFjaXR5XG4gICAgfSA9IGRhdGE7XG4gICAgY29uc3QgZWRpdG9yID0gYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpO1xuICAgIGVkaXRvci5jb2xvciA9IFV0aWwubWFrZUhleENvbG9yKC4uLmNvbG9yKTtcbiAgICBlZGl0b3IuI29wYWNpdHkgPSBvcGFjaXR5IHx8IDE7XG4gICAgaWYgKGlua0xpc3RzKSB7XG4gICAgICBlZGl0b3IuI3RoaWNrbmVzcyA9IGRhdGEudGhpY2tuZXNzO1xuICAgIH1cbiAgICBlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IGRhdGEuaWQgfHwgbnVsbDtcbiAgICBlZGl0b3IuX2luaXRpYWxEYXRhID0gaW5pdGlhbERhdGE7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSBlZGl0b3IucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3QgW3BhZ2VYLCBwYWdlWV0gPSBlZGl0b3IucGFnZVRyYW5zbGF0aW9uO1xuICAgIGlmIChxdWFkUG9pbnRzKSB7XG4gICAgICBjb25zdCBib3hlcyA9IGVkaXRvci4jYm94ZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVhZFBvaW50cy5sZW5ndGg7IGkgKz0gOCkge1xuICAgICAgICBib3hlcy5wdXNoKHtcbiAgICAgICAgICB4OiAocXVhZFBvaW50c1tpXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aCxcbiAgICAgICAgICB5OiAxIC0gKHF1YWRQb2ludHNbaSArIDFdIC0gcGFnZVkpIC8gcGFnZUhlaWdodCxcbiAgICAgICAgICB3aWR0aDogKHF1YWRQb2ludHNbaSArIDJdIC0gcXVhZFBvaW50c1tpXSkgLyBwYWdlV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiAocXVhZFBvaW50c1tpICsgMV0gLSBxdWFkUG9pbnRzW2kgKyA1XSkgLyBwYWdlSGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWRpdG9yLiNjcmVhdGVPdXRsaW5lcygpO1xuICAgICAgZWRpdG9yLiNhZGRUb0RyYXdMYXllcigpO1xuICAgICAgZWRpdG9yLnJvdGF0ZShlZGl0b3Iucm90YXRpb24pO1xuICAgIH0gZWxzZSBpZiAoaW5rTGlzdHMpIHtcbiAgICAgIGVkaXRvci4jaXNGcmVlSGlnaGxpZ2h0ID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHBvaW50cyA9IGlua0xpc3RzWzBdO1xuICAgICAgY29uc3QgcG9pbnQgPSB7XG4gICAgICAgIHg6IHBvaW50c1swXSAtIHBhZ2VYLFxuICAgICAgICB5OiBwYWdlSGVpZ2h0IC0gKHBvaW50c1sxXSAtIHBhZ2VZKVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG91dGxpbmVyID0gbmV3IEZyZWVIaWdobGlnaHRPdXRsaW5lcihwb2ludCwgWzAsIDAsIHBhZ2VXaWR0aCwgcGFnZUhlaWdodF0sIDEsIGVkaXRvci4jdGhpY2tuZXNzIC8gMiwgdHJ1ZSwgMC4wMDEpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgcG9pbnQueCA9IHBvaW50c1tpXSAtIHBhZ2VYO1xuICAgICAgICBwb2ludC55ID0gcGFnZUhlaWdodCAtIChwb2ludHNbaSArIDFdIC0gcGFnZVkpO1xuICAgICAgICBvdXRsaW5lci5hZGQocG9pbnQpO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBpZCxcbiAgICAgICAgY2xpcFBhdGhJZFxuICAgICAgfSA9IHBhcmVudC5kcmF3TGF5ZXIuZHJhdyh7XG4gICAgICAgIGJib3g6IFswLCAwLCAxLCAxXSxcbiAgICAgICAgcm9vdDoge1xuICAgICAgICAgIHZpZXdCb3g6IFwiMCAwIDEgMVwiLFxuICAgICAgICAgIGZpbGw6IGVkaXRvci5jb2xvcixcbiAgICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiBlZGl0b3IuX2RlZmF1bHRPcGFjaXR5XG4gICAgICAgIH0sXG4gICAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICAgIGhpZ2hsaWdodDogdHJ1ZSxcbiAgICAgICAgICBmcmVlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICBkOiBvdXRsaW5lci50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9LCB0cnVlLCB0cnVlKTtcbiAgICAgIGVkaXRvci4jY3JlYXRlRnJlZU91dGxpbmVzKHtcbiAgICAgICAgaGlnaGxpZ2h0T3V0bGluZXM6IG91dGxpbmVyLmdldE91dGxpbmVzKCksXG4gICAgICAgIGhpZ2hsaWdodElkOiBpZCxcbiAgICAgICAgY2xpcFBhdGhJZFxuICAgICAgfSk7XG4gICAgICBlZGl0b3IuI2FkZFRvRHJhd0xheWVyKCk7XG4gICAgICBlZGl0b3Iucm90YXRlKGVkaXRvci5wYXJlbnRSb3RhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZyA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpIHx8IGlzRm9yQ29weWluZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZURlbGV0ZWQoKTtcbiAgICB9XG4gICAgY29uc3QgcmVjdCA9IHRoaXMuZ2V0UmVjdCgwLCAwKTtcbiAgICBjb25zdCBjb2xvciA9IEFubm90YXRpb25FZGl0b3IuX2NvbG9yTWFuYWdlci5jb252ZXJ0KHRoaXMuY29sb3IpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7XG4gICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hULFxuICAgICAgY29sb3IsXG4gICAgICBvcGFjaXR5OiB0aGlzLiNvcGFjaXR5LFxuICAgICAgdGhpY2tuZXNzOiB0aGlzLiN0aGlja25lc3MsXG4gICAgICBxdWFkUG9pbnRzOiB0aGlzLiNzZXJpYWxpemVCb3hlcygpLFxuICAgICAgb3V0bGluZXM6IHRoaXMuI3NlcmlhbGl6ZU91dGxpbmVzKHJlY3QpLFxuICAgICAgcGFnZUluZGV4OiB0aGlzLnBhZ2VJbmRleCxcbiAgICAgIHJlY3QsXG4gICAgICByb3RhdGlvbjogdGhpcy4jZ2V0Um90YXRpb24oKSxcbiAgICAgIHN0cnVjdFRyZWVQYXJlbnRJZDogdGhpcy5fc3RydWN0VHJlZVBhcmVudElkXG4gICAgfTtcbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uRWxlbWVudElkICYmICF0aGlzLiNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHNlcmlhbGl6ZWQuaWQgPSB0aGlzLmFubm90YXRpb25FbGVtZW50SWQ7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gIH1cbiAgI2hhc0VsZW1lbnRDaGFuZ2VkKHNlcmlhbGl6ZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb2xvclxuICAgIH0gPSB0aGlzLl9pbml0aWFsRGF0YTtcbiAgICByZXR1cm4gc2VyaWFsaXplZC5jb2xvci5zb21lKChjLCBpKSA9PiBjICE9PSBjb2xvcltpXSk7XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGFubm90YXRpb24udXBkYXRlRWRpdGVkKHtcbiAgICAgIHJlY3Q6IHRoaXMuZ2V0UmVjdCgwLCAwKVxuICAgIH0pO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN0YXRpYyBjYW5DcmVhdGVOZXdFbXB0eUVkaXRvcigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2RyYXcuanNcblxuXG5cbmNsYXNzIERyYXdpbmdPcHRpb25zIHtcbiAgI3N2Z1Byb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB1cGRhdGVQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXNbbmFtZV0gPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZVNWR1Byb3BlcnR5KG5hbWUsIHZhbHVlKTtcbiAgfVxuICB1cGRhdGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpIHtcbiAgICBpZiAoIXByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BlcnRpZXMpKSB7XG4gICAgICBpZiAoIW5hbWUuc3RhcnRzV2l0aChcIl9cIikpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHVwZGF0ZVNWR1Byb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy4jc3ZnUHJvcGVydGllc1tuYW1lXSA9IHZhbHVlO1xuICB9XG4gIHRvU1ZHUHJvcGVydGllcygpIHtcbiAgICBjb25zdCByb290ID0gdGhpcy4jc3ZnUHJvcGVydGllcztcbiAgICB0aGlzLiNzdmdQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vdFxuICAgIH07XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy4jc3ZnUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgdXBkYXRlQWxsKG9wdGlvbnMgPSB0aGlzKSB7XG4gICAgdGhpcy51cGRhdGVQcm9wZXJ0aWVzKG9wdGlvbnMpO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHVucmVhY2hhYmxlKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICB9XG59XG5jbGFzcyBEcmF3aW5nRWRpdG9yIGV4dGVuZHMgQW5ub3RhdGlvbkVkaXRvciB7XG4gICNkcmF3T3V0bGluZXMgPSBudWxsO1xuICAjbXVzdEJlQ29tbWl0dGVkO1xuICBfZHJhd0lkID0gbnVsbDtcbiAgc3RhdGljIF9jdXJyZW50RHJhd0lkID0gLTE7XG4gIHN0YXRpYyBfY3VycmVudFBhcmVudCA9IG51bGw7XG4gIHN0YXRpYyAjY3VycmVudERyYXcgPSBudWxsO1xuICBzdGF0aWMgI2N1cnJlbnREcmF3aW5nQUMgPSBudWxsO1xuICBzdGF0aWMgI2N1cnJlbnREcmF3aW5nT3B0aW9ucyA9IG51bGw7XG4gIHN0YXRpYyAjY3VycmVudFBvaW50ZXJJZCA9IE5hTjtcbiAgc3RhdGljICNjdXJyZW50UG9pbnRlclR5cGUgPSBudWxsO1xuICBzdGF0aWMgI2N1cnJlbnRQb2ludGVySWRzID0gbnVsbDtcbiAgc3RhdGljICNjdXJyZW50TW92ZVRpbWVzdGFtcCA9IE5hTjtcbiAgc3RhdGljIF9JTk5FUl9NQVJHSU4gPSAzO1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcihwYXJhbXMpO1xuICAgIHRoaXMuI211c3RCZUNvbW1pdHRlZCA9IHBhcmFtcy5tdXN0QmVDb21taXR0ZWQgfHwgZmFsc2U7XG4gICAgdGhpcy5fYWRkT3V0bGluZXMocGFyYW1zKTtcbiAgfVxuICBfYWRkT3V0bGluZXMocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcy5kcmF3T3V0bGluZXMpIHtcbiAgICAgIHRoaXMuI2NyZWF0ZURyYXdPdXRsaW5lcyhwYXJhbXMpO1xuICAgICAgdGhpcy4jYWRkVG9EcmF3TGF5ZXIoKTtcbiAgICB9XG4gIH1cbiAgI2NyZWF0ZURyYXdPdXRsaW5lcyh7XG4gICAgZHJhd091dGxpbmVzLFxuICAgIGRyYXdJZCxcbiAgICBkcmF3aW5nT3B0aW9uc1xuICB9KSB7XG4gICAgdGhpcy4jZHJhd091dGxpbmVzID0gZHJhd091dGxpbmVzO1xuICAgIHRoaXMuX2RyYXdpbmdPcHRpb25zIHx8PSBkcmF3aW5nT3B0aW9ucztcbiAgICBpZiAoZHJhd0lkID49IDApIHtcbiAgICAgIHRoaXMuX2RyYXdJZCA9IGRyYXdJZDtcbiAgICAgIHRoaXMucGFyZW50LmRyYXdMYXllci5maW5hbGl6ZURyYXcoZHJhd0lkLCBkcmF3T3V0bGluZXMuZGVmYXVsdFByb3BlcnRpZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kcmF3SWQgPSB0aGlzLiNjcmVhdGVEcmF3aW5nKGRyYXdPdXRsaW5lcywgdGhpcy5wYXJlbnQpO1xuICAgIH1cbiAgICB0aGlzLiN1cGRhdGVCYm94KGRyYXdPdXRsaW5lcy5ib3gpO1xuICB9XG4gICNjcmVhdGVEcmF3aW5nKGRyYXdPdXRsaW5lcywgcGFyZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaWRcbiAgICB9ID0gcGFyZW50LmRyYXdMYXllci5kcmF3KERyYXdpbmdFZGl0b3IuX21lcmdlU1ZHUHJvcGVydGllcyh0aGlzLl9kcmF3aW5nT3B0aW9ucy50b1NWR1Byb3BlcnRpZXMoKSwgZHJhd091dGxpbmVzLmRlZmF1bHRTVkdQcm9wZXJ0aWVzKSwgZmFsc2UsIGZhbHNlKTtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgc3RhdGljIF9tZXJnZVNWR1Byb3BlcnRpZXMocDEsIHAyKSB7XG4gICAgY29uc3QgcDFLZXlzID0gbmV3IFNldChPYmplY3Qua2V5cyhwMSkpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHAyKSkge1xuICAgICAgaWYgKHAxS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHAxW2tleV0sIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHAxW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHAxO1xuICB9XG4gIHN0YXRpYyBnZXREZWZhdWx0RHJhd2luZ09wdGlvbnMoX29wdGlvbnMpIHtcbiAgICB1bnJlYWNoYWJsZShcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGVzTWFwKCkge1xuICAgIHVucmVhY2hhYmxlKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNEcmF3ZXIoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3RhdGljIGdldCBzdXBwb3J0TXVsdGlwbGVEcmF3aW5ncygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIHVwZGF0ZURlZmF1bHRQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBjb25zdCBwcm9wZXJ0eU5hbWUgPSB0aGlzLnR5cGVzTWFwLmdldCh0eXBlKTtcbiAgICBpZiAocHJvcGVydHlOYW1lKSB7XG4gICAgICB0aGlzLl9kZWZhdWx0RHJhd2luZ09wdGlvbnMudXBkYXRlUHJvcGVydHkocHJvcGVydHlOYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9jdXJyZW50UGFyZW50KSB7XG4gICAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdy51cGRhdGVQcm9wZXJ0eShwcm9wZXJ0eU5hbWUsIHZhbHVlKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRQYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fY3VycmVudERyYXdJZCwgdGhpcy5fZGVmYXVsdERyYXdpbmdPcHRpb25zLnRvU1ZHUHJvcGVydGllcygpKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgY29uc3QgcHJvcGVydHlOYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci50eXBlc01hcC5nZXQodHlwZSk7XG4gICAgaWYgKHByb3BlcnR5TmFtZSkge1xuICAgICAgdGhpcy5fdXBkYXRlUHJvcGVydHkodHlwZSwgcHJvcGVydHlOYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gW107XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucztcbiAgICBmb3IgKGNvbnN0IFt0eXBlLCBuYW1lXSBvZiB0aGlzLnR5cGVzTWFwKSB7XG4gICAgICBwcm9wZXJ0aWVzLnB1c2goW3R5cGUsIG9wdGlvbnNbbmFtZV1dKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gIH1cbiAgZ2V0IHByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gW107XG4gICAgY29uc3Qge1xuICAgICAgX2RyYXdpbmdPcHRpb25zXG4gICAgfSA9IHRoaXM7XG4gICAgZm9yIChjb25zdCBbdHlwZSwgbmFtZV0gb2YgdGhpcy5jb25zdHJ1Y3Rvci50eXBlc01hcCkge1xuICAgICAgcHJvcGVydGllcy5wdXNoKFt0eXBlLCBfZHJhd2luZ09wdGlvbnNbbmFtZV1dKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gIH1cbiAgX3VwZGF0ZVByb3BlcnR5KHR5cGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2RyYXdpbmdPcHRpb25zO1xuICAgIGNvbnN0IHNhdmVkVmFsdWUgPSBvcHRpb25zW25hbWVdO1xuICAgIGNvbnN0IHNldHRlciA9IHZhbCA9PiB7XG4gICAgICBvcHRpb25zLnVwZGF0ZVByb3BlcnR5KG5hbWUsIHZhbCk7XG4gICAgICBjb25zdCBiYm94ID0gdGhpcy4jZHJhd091dGxpbmVzLnVwZGF0ZVByb3BlcnR5KG5hbWUsIHZhbCk7XG4gICAgICBpZiAoYmJveCkge1xuICAgICAgICB0aGlzLiN1cGRhdGVCYm94KGJib3gpO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2RyYXdJZCwgb3B0aW9ucy50b1NWR1Byb3BlcnRpZXMoKSk7XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogc2V0dGVyLmJpbmQodGhpcywgdmFsdWUpLFxuICAgICAgdW5kbzogc2V0dGVyLmJpbmQodGhpcywgc2F2ZWRWYWx1ZSksXG4gICAgICBwb3N0OiB0aGlzLl91aU1hbmFnZXIudXBkYXRlVUkuYmluZCh0aGlzLl91aU1hbmFnZXIsIHRoaXMpLFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgX29uUmVzaXppbmcoKSB7XG4gICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2RyYXdJZCwgRHJhd2luZ0VkaXRvci5fbWVyZ2VTVkdQcm9wZXJ0aWVzKHRoaXMuI2RyYXdPdXRsaW5lcy5nZXRQYXRoUmVzaXppbmdTVkdQcm9wZXJ0aWVzKHRoaXMuI2NvbnZlcnRUb0RyYXdTcGFjZSgpKSwge1xuICAgICAgYmJveDogdGhpcy4jcm90YXRlQm94KClcbiAgICB9KSk7XG4gIH1cbiAgX29uUmVzaXplZCgpIHtcbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fZHJhd0lkLCBEcmF3aW5nRWRpdG9yLl9tZXJnZVNWR1Byb3BlcnRpZXModGhpcy4jZHJhd091dGxpbmVzLmdldFBhdGhSZXNpemVkU1ZHUHJvcGVydGllcyh0aGlzLiNjb252ZXJ0VG9EcmF3U3BhY2UoKSksIHtcbiAgICAgIGJib3g6IHRoaXMuI3JvdGF0ZUJveCgpXG4gICAgfSkpO1xuICB9XG4gIF9vblRyYW5zbGF0aW5nKF94LCBfeSkge1xuICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIHtcbiAgICAgIGJib3g6IHRoaXMuI3JvdGF0ZUJveCgpXG4gICAgfSk7XG4gIH1cbiAgX29uVHJhbnNsYXRlZCgpIHtcbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fZHJhd0lkLCBEcmF3aW5nRWRpdG9yLl9tZXJnZVNWR1Byb3BlcnRpZXModGhpcy4jZHJhd091dGxpbmVzLmdldFBhdGhUcmFuc2xhdGVkU1ZHUHJvcGVydGllcyh0aGlzLiNjb252ZXJ0VG9EcmF3U3BhY2UoKSwgdGhpcy5wYXJlbnREaW1lbnNpb25zKSwge1xuICAgICAgYmJveDogdGhpcy4jcm90YXRlQm94KClcbiAgICB9KSk7XG4gIH1cbiAgX29uU3RhcnREcmFnZ2luZygpIHtcbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fZHJhd0lkLCB7XG4gICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgbW92aW5nOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX29uU3RvcERyYWdnaW5nKCkge1xuICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIHtcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBtb3Zpbmc6IGZhbHNlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY29tbWl0KCkge1xuICAgIHN1cGVyLmNvbW1pdCgpO1xuICAgIHRoaXMuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5kaXNhYmxlRWRpdGluZygpO1xuICB9XG4gIGRpc2FibGVFZGl0aW5nKCkge1xuICAgIHN1cGVyLmRpc2FibGVFZGl0aW5nKCk7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRpc2FibGVkXCIsIHRydWUpO1xuICB9XG4gIGVuYWJsZUVkaXRpbmcoKSB7XG4gICAgc3VwZXIuZW5hYmxlRWRpdGluZygpO1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJkaXNhYmxlZFwiLCBmYWxzZSk7XG4gIH1cbiAgZ2V0QmFzZVRyYW5zbGF0aW9uKCkge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cbiAgZ2V0IGlzUmVzaXphYmxlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIG9uY2VBZGRlZChmb2N1cykge1xuICAgIGlmICghdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGRVbmRvYWJsZUVkaXRvcih0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSB0cnVlO1xuICAgIGlmICh0aGlzLiNtdXN0QmVDb21taXR0ZWQpIHtcbiAgICAgIHRoaXMuI211c3RCZUNvbW1pdHRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5jb21taXQoKTtcbiAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgICAgaWYgKGZvY3VzICYmIHRoaXMuaXNPblNjcmVlbikge1xuICAgICAgICB0aGlzLmRpdi5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZW1vdmUoKSB7XG4gICAgdGhpcy4jY2xlYW5EcmF3TGF5ZXIoKTtcbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucmVidWlsZCgpO1xuICAgIGlmICh0aGlzLmRpdiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhZGRUb0RyYXdMYXllcigpO1xuICAgIHRoaXMuI3VwZGF0ZUJib3godGhpcy4jZHJhd091dGxpbmVzLmJveCk7XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkKHRoaXMpO1xuICAgIH1cbiAgfVxuICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgbGV0IG11c3RCZVNlbGVjdGVkID0gZmFsc2U7XG4gICAgaWYgKHRoaXMucGFyZW50ICYmICFwYXJlbnQpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5yZW1vdmVTaG91bGRSZXNjYWxlKHRoaXMpO1xuICAgICAgdGhpcy4jY2xlYW5EcmF3TGF5ZXIoKTtcbiAgICB9IGVsc2UgaWYgKHBhcmVudCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmFkZFNob3VsZFJlc2NhbGUodGhpcyk7XG4gICAgICB0aGlzLiNhZGRUb0RyYXdMYXllcihwYXJlbnQpO1xuICAgICAgbXVzdEJlU2VsZWN0ZWQgPSAhdGhpcy5wYXJlbnQgJiYgdGhpcy5kaXY/LmNsYXNzTGlzdC5jb250YWlucyhcInNlbGVjdGVkRWRpdG9yXCIpO1xuICAgIH1cbiAgICBzdXBlci5zZXRQYXJlbnQocGFyZW50KTtcbiAgICBpZiAobXVzdEJlU2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuc2VsZWN0KCk7XG4gICAgfVxuICB9XG4gICNjbGVhbkRyYXdMYXllcigpIHtcbiAgICBpZiAodGhpcy5fZHJhd0lkID09PSBudWxsIHx8ICF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIucmVtb3ZlKHRoaXMuX2RyYXdJZCk7XG4gICAgdGhpcy5fZHJhd0lkID0gbnVsbDtcbiAgICB0aGlzLl9kcmF3aW5nT3B0aW9ucy5yZXNldCgpO1xuICB9XG4gICNhZGRUb0RyYXdMYXllcihwYXJlbnQgPSB0aGlzLnBhcmVudCkge1xuICAgIGlmICh0aGlzLl9kcmF3SWQgIT09IG51bGwgJiYgdGhpcy5wYXJlbnQgPT09IHBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZHJhd0lkICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUGFyZW50KHRoaXMuX2RyYXdJZCwgcGFyZW50LmRyYXdMYXllcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2RyYXdpbmdPcHRpb25zLnVwZGF0ZUFsbCgpO1xuICAgIHRoaXMuX2RyYXdJZCA9IHRoaXMuI2NyZWF0ZURyYXdpbmcodGhpcy4jZHJhd091dGxpbmVzLCBwYXJlbnQpO1xuICB9XG4gICNjb252ZXJ0VG9QYXJlbnRTcGFjZShbeCwgeSwgd2lkdGgsIGhlaWdodF0pIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXJlbnREaW1lbnNpb25zOiBbcFcsIHBIXSxcbiAgICAgIHJvdGF0aW9uXG4gICAgfSA9IHRoaXM7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFt5LCAxIC0geCwgd2lkdGggKiAocEggLyBwVyksIGhlaWdodCAqIChwVyAvIHBIKV07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geCwgMSAtIHksIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbMSAtIHksIHgsIHdpZHRoICogKHBIIC8gcFcpLCBoZWlnaHQgKiAocFcgLyBwSCldO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt4LCB5LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICB9XG4gIH1cbiAgI2NvbnZlcnRUb0RyYXdTcGFjZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcGFyZW50RGltZW5zaW9uczogW3BXLCBwSF0sXG4gICAgICByb3RhdGlvblxuICAgIH0gPSB0aGlzO1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbMSAtIHksIHgsIHdpZHRoICogKHBXIC8gcEgpLCBoZWlnaHQgKiAocEggLyBwVyldO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbMSAtIHgsIDEgLSB5LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3ksIDEgLSB4LCB3aWR0aCAqIChwVyAvIHBIKSwgaGVpZ2h0ICogKHBIIC8gcFcpXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbeCwgeSwgd2lkdGgsIGhlaWdodF07XG4gICAgfVxuICB9XG4gICN1cGRhdGVCYm94KGJib3gpIHtcbiAgICBbdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XSA9IHRoaXMuI2NvbnZlcnRUb1BhcmVudFNwYWNlKGJib3gpO1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgdGhpcy5zZXREaW1zKHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgIH1cbiAgICB0aGlzLl9vblJlc2l6ZWQoKTtcbiAgfVxuICAjcm90YXRlQm94KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICByb3RhdGlvbixcbiAgICAgIHBhcmVudFJvdGF0aW9uLFxuICAgICAgcGFyZW50RGltZW5zaW9uczogW3BXLCBwSF1cbiAgICB9ID0gdGhpcztcbiAgICBzd2l0Y2ggKChyb3RhdGlvbiAqIDQgKyBwYXJlbnRSb3RhdGlvbikgLyA5MCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gWzEgLSB5IC0gaGVpZ2h0LCB4LCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIFsxIC0geCAtIHdpZHRoLCAxIC0geSAtIGhlaWdodCwgd2lkdGgsIGhlaWdodF07XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiBbeSwgMSAtIHggLSB3aWR0aCwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiBbeCwgeSAtIHdpZHRoICogKHBXIC8gcEgpLCBoZWlnaHQgKiAocEggLyBwVyksIHdpZHRoICogKHBXIC8gcEgpXTtcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcmV0dXJuIFsxIC0geSwgeCwgd2lkdGggKiAocFcgLyBwSCksIGhlaWdodCAqIChwSCAvIHBXKV07XG4gICAgICBjYXNlIDY6XG4gICAgICAgIHJldHVybiBbMSAtIHggLSBoZWlnaHQgKiAocEggLyBwVyksIDEgLSB5LCBoZWlnaHQgKiAocEggLyBwVyksIHdpZHRoICogKHBXIC8gcEgpXTtcbiAgICAgIGNhc2UgNzpcbiAgICAgICAgcmV0dXJuIFt5IC0gd2lkdGggKiAocFcgLyBwSCksIDEgLSB4IC0gaGVpZ2h0ICogKHBIIC8gcFcpLCB3aWR0aCAqIChwVyAvIHBIKSwgaGVpZ2h0ICogKHBIIC8gcFcpXTtcbiAgICAgIGNhc2UgODpcbiAgICAgICAgcmV0dXJuIFt4IC0gd2lkdGgsIHkgLSBoZWlnaHQsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSA5OlxuICAgICAgICByZXR1cm4gWzEgLSB5LCB4IC0gd2lkdGgsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgY2FzZSAxMDpcbiAgICAgICAgcmV0dXJuIFsxIC0geCwgMSAtIHksIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSAxMTpcbiAgICAgICAgcmV0dXJuIFt5IC0gaGVpZ2h0LCAxIC0geCwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBjYXNlIDEyOlxuICAgICAgICByZXR1cm4gW3ggLSBoZWlnaHQgKiAocEggLyBwVyksIHksIGhlaWdodCAqIChwSCAvIHBXKSwgd2lkdGggKiAocFcgLyBwSCldO1xuICAgICAgY2FzZSAxMzpcbiAgICAgICAgcmV0dXJuIFsxIC0geSAtIHdpZHRoICogKHBXIC8gcEgpLCB4IC0gaGVpZ2h0ICogKHBIIC8gcFcpLCB3aWR0aCAqIChwVyAvIHBIKSwgaGVpZ2h0ICogKHBIIC8gcFcpXTtcbiAgICAgIGNhc2UgMTQ6XG4gICAgICAgIHJldHVybiBbMSAtIHgsIDEgLSB5IC0gd2lkdGggKiAocFcgLyBwSCksIGhlaWdodCAqIChwSCAvIHBXKSwgd2lkdGggKiAocFcgLyBwSCldO1xuICAgICAgY2FzZSAxNTpcbiAgICAgICAgcmV0dXJuIFt5LCAxIC0geCwgd2lkdGggKiAocFcgLyBwSCksIGhlaWdodCAqIChwSCAvIHBXKV07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW3gsIHksIHdpZHRoLCBoZWlnaHRdO1xuICAgIH1cbiAgfVxuICByb3RhdGUoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIERyYXdpbmdFZGl0b3IuX21lcmdlU1ZHUHJvcGVydGllcyh7XG4gICAgICBiYm94OiB0aGlzLiNyb3RhdGVCb3goKVxuICAgIH0sIHRoaXMuI2RyYXdPdXRsaW5lcy51cGRhdGVSb3RhdGlvbigodGhpcy5wYXJlbnRSb3RhdGlvbiAtIHRoaXMucm90YXRpb24gKyAzNjApICUgMzYwKSkpO1xuICB9XG4gIG9uU2NhbGVDaGFuZ2luZygpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3VwZGF0ZUJib3godGhpcy4jZHJhd091dGxpbmVzLnVwZGF0ZVBhcmVudERpbWVuc2lvbnModGhpcy5wYXJlbnREaW1lbnNpb25zLCB0aGlzLnBhcmVudC5zY2FsZSkpO1xuICB9XG4gIHN0YXRpYyBvblNjYWxlQ2hhbmdpbmdXaGVuRHJhd2luZygpIHt9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdjtcbiAgICB9XG4gICAgbGV0IGJhc2VYLCBiYXNlWTtcbiAgICBpZiAodGhpcy5faXNDb3B5KSB7XG4gICAgICBiYXNlWCA9IHRoaXMueDtcbiAgICAgIGJhc2VZID0gdGhpcy55O1xuICAgIH1cbiAgICBjb25zdCBkaXYgPSBzdXBlci5yZW5kZXIoKTtcbiAgICBkaXYuY2xhc3NMaXN0LmFkZChcImRyYXdcIik7XG4gICAgY29uc3QgZHJhd0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LmFwcGVuZChkcmF3RGl2KTtcbiAgICBkcmF3RGl2LnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICBkcmF3RGl2LmNsYXNzTmFtZSA9IFwiaW50ZXJuYWxcIjtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy5zZXREaW1zKHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgIHRoaXMuX3VpTWFuYWdlci5hZGRTaG91bGRSZXNjYWxlKHRoaXMpO1xuICAgIHRoaXMuZGlzYWJsZUVkaXRpbmcoKTtcbiAgICBpZiAodGhpcy5faXNDb3B5KSB7XG4gICAgICB0aGlzLl9tb3ZlQWZ0ZXJQYXN0ZShiYXNlWCwgYmFzZVkpO1xuICAgIH1cbiAgICByZXR1cm4gZGl2O1xuICB9XG4gIHN0YXRpYyBjcmVhdGVEcmF3ZXJJbnN0YW5jZShfeCwgX3ksIF9wYXJlbnRXaWR0aCwgX3BhcmVudEhlaWdodCwgX3JvdGF0aW9uKSB7XG4gICAgdW5yZWFjaGFibGUoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgc3RhdGljIHN0YXJ0RHJhd2luZyhwYXJlbnQsIHVpTWFuYWdlciwgX2lzTFRSLCBldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRhcmdldCxcbiAgICAgIG9mZnNldFg6IHgsXG4gICAgICBvZmZzZXRZOiB5LFxuICAgICAgcG9pbnRlcklkLFxuICAgICAgcG9pbnRlclR5cGVcbiAgICB9ID0gZXZlbnQ7XG4gICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVyVHlwZSAmJiBEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlclR5cGUgIT09IHBvaW50ZXJUeXBlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIHJvdGF0aW9uXG4gICAgICB9XG4gICAgfSA9IHBhcmVudDtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aDogcGFyZW50V2lkdGgsXG4gICAgICBoZWlnaHQ6IHBhcmVudEhlaWdodFxuICAgIH0gPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgYWMgPSBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhd2luZ0FDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHBhcmVudC5jb21iaW5lZFNpZ25hbChhYyk7XG4gICAgRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZCB8fD0gcG9pbnRlcklkO1xuICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVyVHlwZSA/Pz0gcG9pbnRlclR5cGU7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgZSA9PiB7XG4gICAgICBpZiAoRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQpIHtcbiAgICAgICAgdGhpcy5fZW5kRHJhdyhlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVySWRzPy5kZWxldGUoZS5wb2ludGVySWQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmNhbmNlbFwiLCBlID0+IHtcbiAgICAgIGlmIChEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlcklkID09PSBlLnBvaW50ZXJJZCkge1xuICAgICAgICB0aGlzLl9jdXJyZW50UGFyZW50LmVuZERyYXdpbmdTZXNzaW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlcklkcz8uZGVsZXRlKGUucG9pbnRlcklkKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGUgPT4ge1xuICAgICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVyVHlwZSAhPT0gZS5wb2ludGVyVHlwZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAoRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZHMgfHw9IG5ldyBTZXQoKSkuYWRkKGUucG9pbnRlcklkKTtcbiAgICAgIGlmIChEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdy5pc0NhbmNlbGxhYmxlKCkpIHtcbiAgICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcucmVtb3ZlTGFzdEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3LmlzRW1wdHkoKSkge1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRQYXJlbnQuZW5kRHJhd2luZ1Nlc3Npb24odHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZW5kRHJhdyhudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLl9kcmF3TW92ZS5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBlID0+IHtcbiAgICAgIGlmIChlLnRpbWVTdGFtcCA9PT0gRHJhd2luZ0VkaXRvci4jY3VycmVudE1vdmVUaW1lc3RhbXApIHtcbiAgICAgICAgc3RvcEV2ZW50KGUpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHBhcmVudC50b2dnbGVEcmF3aW5nKCk7XG4gICAgdWlNYW5hZ2VyLl9lZGl0b3JVbmRvQmFyPy5oaWRlKCk7XG4gICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3KSB7XG4gICAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fY3VycmVudERyYXdJZCwgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcuc3RhcnROZXcoeCwgeSwgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgcm90YXRpb24pKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdWlNYW5hZ2VyLnVwZGF0ZVVJRm9yRGVmYXVsdFByb3BlcnRpZXModGhpcyk7XG4gICAgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcgPSB0aGlzLmNyZWF0ZURyYXdlckluc3RhbmNlKHgsIHksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHJvdGF0aW9uKTtcbiAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhd2luZ09wdGlvbnMgPSB0aGlzLmdldERlZmF1bHREcmF3aW5nT3B0aW9ucygpO1xuICAgIHRoaXMuX2N1cnJlbnRQYXJlbnQgPSBwYXJlbnQ7XG4gICAgKHtcbiAgICAgIGlkOiB0aGlzLl9jdXJyZW50RHJhd0lkXG4gICAgfSA9IHBhcmVudC5kcmF3TGF5ZXIuZHJhdyh0aGlzLl9tZXJnZVNWR1Byb3BlcnRpZXMoRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXdpbmdPcHRpb25zLnRvU1ZHUHJvcGVydGllcygpLCBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdy5kZWZhdWx0U1ZHUHJvcGVydGllcyksIHRydWUsIGZhbHNlKSk7XG4gIH1cbiAgc3RhdGljIF9kcmF3TW92ZShldmVudCkge1xuICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRNb3ZlVGltZXN0YW1wID0gLTE7XG4gICAgaWYgKCFEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WSxcbiAgICAgIHBvaW50ZXJJZFxuICAgIH0gPSBldmVudDtcbiAgICBpZiAoRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZCAhPT0gcG9pbnRlcklkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChEcmF3aW5nRWRpdG9yLiNjdXJyZW50UG9pbnRlcklkcz8uc2l6ZSA+PSAxKSB7XG4gICAgICB0aGlzLl9lbmREcmF3KGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY3VycmVudFBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9jdXJyZW50RHJhd0lkLCBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdy5hZGQob2Zmc2V0WCwgb2Zmc2V0WSkpO1xuICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRNb3ZlVGltZXN0YW1wID0gZXZlbnQudGltZVN0YW1wO1xuICAgIHN0b3BFdmVudChldmVudCk7XG4gIH1cbiAgc3RhdGljIF9jbGVhbnVwKGFsbCkge1xuICAgIGlmIChhbGwpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnREcmF3SWQgPSAtMTtcbiAgICAgIHRoaXMuX2N1cnJlbnRQYXJlbnQgPSBudWxsO1xuICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcgPSBudWxsO1xuICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXdpbmdPcHRpb25zID0gbnVsbDtcbiAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVyVHlwZSA9IG51bGw7XG4gICAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50TW92ZVRpbWVzdGFtcCA9IE5hTjtcbiAgICB9XG4gICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3aW5nQUMpIHtcbiAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3aW5nQUMuYWJvcnQoKTtcbiAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3aW5nQUMgPSBudWxsO1xuICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudFBvaW50ZXJJZCA9IE5hTjtcbiAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnRQb2ludGVySWRzID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgc3RhdGljIF9lbmREcmF3KGV2ZW50KSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5fY3VycmVudFBhcmVudDtcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwYXJlbnQudG9nZ2xlRHJhd2luZyh0cnVlKTtcbiAgICB0aGlzLl9jbGVhbnVwKGZhbHNlKTtcbiAgICBpZiAoZXZlbnQ/LnRhcmdldCA9PT0gcGFyZW50LmRpdikge1xuICAgICAgcGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2N1cnJlbnREcmF3SWQsIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3LmVuZChldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnN1cHBvcnRNdWx0aXBsZURyYXdpbmdzKSB7XG4gICAgICBjb25zdCBkcmF3ID0gRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXc7XG4gICAgICBjb25zdCBkcmF3SWQgPSB0aGlzLl9jdXJyZW50RHJhd0lkO1xuICAgICAgY29uc3QgbGFzdEVsZW1lbnQgPSBkcmF3LmdldExhc3RFbGVtZW50KCk7XG4gICAgICBwYXJlbnQuYWRkQ29tbWFuZHMoe1xuICAgICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXMoZHJhd0lkLCBkcmF3LnNldExhc3RFbGVtZW50KGxhc3RFbGVtZW50KSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXMoZHJhd0lkLCBkcmF3LnJlbW92ZUxhc3RFbGVtZW50KCkpO1xuICAgICAgICB9LFxuICAgICAgICBtdXN0RXhlYzogZmFsc2UsXG4gICAgICAgIHR5cGU6IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkRSQVdfU1RFUFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW5kRHJhd2luZyhmYWxzZSk7XG4gIH1cbiAgc3RhdGljIGVuZERyYXdpbmcoaXNBYm9ydGVkKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5fY3VycmVudFBhcmVudDtcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHBhcmVudC50b2dnbGVEcmF3aW5nKHRydWUpO1xuICAgIHBhcmVudC5jbGVhblVuZG9TdGFjayhBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5EUkFXX1NURVApO1xuICAgIGlmICghRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcuaXNFbXB0eSgpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhZ2VEaW1lbnNpb25zOiBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSxcbiAgICAgICAgc2NhbGVcbiAgICAgIH0gPSBwYXJlbnQ7XG4gICAgICBjb25zdCBlZGl0b3IgPSBwYXJlbnQuY3JlYXRlQW5kQWRkTmV3RWRpdG9yKHtcbiAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgb2Zmc2V0WTogMFxuICAgICAgfSwgZmFsc2UsIHtcbiAgICAgICAgZHJhd0lkOiB0aGlzLl9jdXJyZW50RHJhd0lkLFxuICAgICAgICBkcmF3T3V0bGluZXM6IERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3LmdldE91dGxpbmVzKHBhZ2VXaWR0aCAqIHNjYWxlLCBwYWdlSGVpZ2h0ICogc2NhbGUsIHNjYWxlLCB0aGlzLl9JTk5FUl9NQVJHSU4pLFxuICAgICAgICBkcmF3aW5nT3B0aW9uczogRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXdpbmdPcHRpb25zLFxuICAgICAgICBtdXN0QmVDb21taXR0ZWQ6ICFpc0Fib3J0ZWRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fY2xlYW51cCh0cnVlKTtcbiAgICAgIHJldHVybiBlZGl0b3I7XG4gICAgfVxuICAgIHBhcmVudC5kcmF3TGF5ZXIucmVtb3ZlKHRoaXMuX2N1cnJlbnREcmF3SWQpO1xuICAgIHRoaXMuX2NsZWFudXAodHJ1ZSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY3JlYXRlRHJhd2luZ09wdGlvbnMoX2RhdGEpIHt9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZURyYXcoX3BhZ2VYLCBfcGFnZVksIF9wYWdlV2lkdGgsIF9wYWdlSGVpZ2h0LCBfaW5uZXJXaWR0aCwgX2RhdGEpIHtcbiAgICB1bnJlYWNoYWJsZShcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBjb25zdCB7XG4gICAgICByYXdEaW1zOiB7XG4gICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgcGFnZUhlaWdodCxcbiAgICAgICAgcGFnZVgsXG4gICAgICAgIHBhZ2VZXG4gICAgICB9XG4gICAgfSA9IHBhcmVudC52aWV3cG9ydDtcbiAgICBjb25zdCBkcmF3T3V0bGluZXMgPSB0aGlzLmRlc2VyaWFsaXplRHJhdyhwYWdlWCwgcGFnZVksIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgdGhpcy5fSU5ORVJfTUFSR0lOLCBkYXRhKTtcbiAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgZWRpdG9yLmNyZWF0ZURyYXdpbmdPcHRpb25zKGRhdGEpO1xuICAgIGVkaXRvci4jY3JlYXRlRHJhd091dGxpbmVzKHtcbiAgICAgIGRyYXdPdXRsaW5lc1xuICAgIH0pO1xuICAgIGVkaXRvci4jYWRkVG9EcmF3TGF5ZXIoKTtcbiAgICBlZGl0b3Iub25TY2FsZUNoYW5naW5nKCk7XG4gICAgZWRpdG9yLnJvdGF0ZSgpO1xuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgc2VyaWFsaXplRHJhdyhpc0ZvckNvcHlpbmcpIHtcbiAgICBjb25zdCBbcGFnZVgsIHBhZ2VZXSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uO1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICByZXR1cm4gdGhpcy4jZHJhd091dGxpbmVzLnNlcmlhbGl6ZShbcGFnZVgsIHBhZ2VZLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdLCBpc0ZvckNvcHlpbmcpO1xuICB9XG4gIHJlbmRlckFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pIHtcbiAgICBhbm5vdGF0aW9uLnVwZGF0ZUVkaXRlZCh7XG4gICAgICByZWN0OiB0aGlzLmdldFJlY3QoMCwgMClcbiAgICB9KTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzdGF0aWMgY2FuQ3JlYXRlTmV3RW1wdHlFZGl0b3IoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9kcmF3ZXJzL2lua2RyYXcuanNcblxuXG5jbGFzcyBJbmtEcmF3T3V0bGluZXIge1xuICAjbGFzdCA9IG5ldyBGbG9hdDY0QXJyYXkoNik7XG4gICNsaW5lO1xuICAjbGluZXM7XG4gICNyb3RhdGlvbjtcbiAgI3RoaWNrbmVzcztcbiAgI3BvaW50cztcbiAgI2xhc3RTVkdQYXRoID0gXCJcIjtcbiAgI2xhc3RJbmRleCA9IDA7XG4gICNvdXRsaW5lcyA9IG5ldyBJbmtEcmF3T3V0bGluZSgpO1xuICAjcGFyZW50V2lkdGg7XG4gICNwYXJlbnRIZWlnaHQ7XG4gIGNvbnN0cnVjdG9yKHgsIHksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHJvdGF0aW9uLCB0aGlja25lc3MpIHtcbiAgICB0aGlzLiNwYXJlbnRXaWR0aCA9IHBhcmVudFdpZHRoO1xuICAgIHRoaXMuI3BhcmVudEhlaWdodCA9IHBhcmVudEhlaWdodDtcbiAgICB0aGlzLiNyb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMuI3RoaWNrbmVzcyA9IHRoaWNrbmVzcztcbiAgICBbeCwgeV0gPSB0aGlzLiNub3JtYWxpemVQb2ludCh4LCB5KTtcbiAgICBjb25zdCBsaW5lID0gdGhpcy4jbGluZSA9IFtOYU4sIE5hTiwgTmFOLCBOYU4sIHgsIHldO1xuICAgIHRoaXMuI3BvaW50cyA9IFt4LCB5XTtcbiAgICB0aGlzLiNsaW5lcyA9IFt7XG4gICAgICBsaW5lLFxuICAgICAgcG9pbnRzOiB0aGlzLiNwb2ludHNcbiAgICB9XTtcbiAgICB0aGlzLiNsYXN0LnNldChsaW5lLCAwKTtcbiAgfVxuICB1cGRhdGVQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChuYW1lID09PSBcInN0cm9rZS13aWR0aFwiKSB7XG4gICAgICB0aGlzLiN0aGlja25lc3MgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgI25vcm1hbGl6ZVBvaW50KHgsIHkpIHtcbiAgICByZXR1cm4gT3V0bGluZS5fbm9ybWFsaXplUG9pbnQoeCwgeSwgdGhpcy4jcGFyZW50V2lkdGgsIHRoaXMuI3BhcmVudEhlaWdodCwgdGhpcy4jcm90YXRpb24pO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuICF0aGlzLiNsaW5lcyB8fCB0aGlzLiNsaW5lcy5sZW5ndGggPT09IDA7XG4gIH1cbiAgaXNDYW5jZWxsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9pbnRzLmxlbmd0aCA8PSAxMDtcbiAgfVxuICBhZGQoeCwgeSkge1xuICAgIFt4LCB5XSA9IHRoaXMuI25vcm1hbGl6ZVBvaW50KHgsIHkpO1xuICAgIGNvbnN0IFt4MSwgeTEsIHgyLCB5Ml0gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDIsIDYpO1xuICAgIGNvbnN0IGRpZmZYID0geCAtIHgyO1xuICAgIGNvbnN0IGRpZmZZID0geSAtIHkyO1xuICAgIGNvbnN0IGQgPSBNYXRoLmh5cG90KHRoaXMuI3BhcmVudFdpZHRoICogZGlmZlgsIHRoaXMuI3BhcmVudEhlaWdodCAqIGRpZmZZKTtcbiAgICBpZiAoZCA8PSAyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jcG9pbnRzLnB1c2goeCwgeSk7XG4gICAgaWYgKGlzTmFOKHgxKSkge1xuICAgICAgdGhpcy4jbGFzdC5zZXQoW3gyLCB5MiwgeCwgeV0sIDIpO1xuICAgICAgdGhpcy4jbGluZS5wdXNoKE5hTiwgTmFOLCBOYU4sIE5hTiwgeCwgeSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaXNOYU4odGhpcy4jbGFzdFswXSkpIHtcbiAgICAgIHRoaXMuI2xpbmUuc3BsaWNlKDYsIDYpO1xuICAgIH1cbiAgICB0aGlzLiNsYXN0LnNldChbeDEsIHkxLCB4MiwgeTIsIHgsIHldLCAwKTtcbiAgICB0aGlzLiNsaW5lLnB1c2goLi4uT3V0bGluZS5jcmVhdGVCZXppZXJQb2ludHMoeDEsIHkxLCB4MiwgeTIsIHgsIHkpKTtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDoge1xuICAgICAgICBkOiB0aGlzLnRvU1ZHUGF0aCgpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBlbmQoeCwgeSkge1xuICAgIGNvbnN0IGNoYW5nZSA9IHRoaXMuYWRkKHgsIHkpO1xuICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuICAgIGlmICh0aGlzLiNwb2ludHMubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzdGFydE5ldyh4LCB5LCBwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0LCByb3RhdGlvbikge1xuICAgIHRoaXMuI3BhcmVudFdpZHRoID0gcGFyZW50V2lkdGg7XG4gICAgdGhpcy4jcGFyZW50SGVpZ2h0ID0gcGFyZW50SGVpZ2h0O1xuICAgIHRoaXMuI3JvdGF0aW9uID0gcm90YXRpb247XG4gICAgW3gsIHldID0gdGhpcy4jbm9ybWFsaXplUG9pbnQoeCwgeSk7XG4gICAgY29uc3QgbGluZSA9IHRoaXMuI2xpbmUgPSBbTmFOLCBOYU4sIE5hTiwgTmFOLCB4LCB5XTtcbiAgICB0aGlzLiNwb2ludHMgPSBbeCwgeV07XG4gICAgY29uc3QgbGFzdCA9IHRoaXMuI2xpbmVzLmF0KC0xKTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5saW5lID0gbmV3IEZsb2F0MzJBcnJheShsYXN0LmxpbmUpO1xuICAgICAgbGFzdC5wb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KGxhc3QucG9pbnRzKTtcbiAgICB9XG4gICAgdGhpcy4jbGluZXMucHVzaCh7XG4gICAgICBsaW5lLFxuICAgICAgcG9pbnRzOiB0aGlzLiNwb2ludHNcbiAgICB9KTtcbiAgICB0aGlzLiNsYXN0LnNldChsaW5lLCAwKTtcbiAgICB0aGlzLiNsYXN0SW5kZXggPSAwO1xuICAgIHRoaXMudG9TVkdQYXRoKCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0TGFzdEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2xpbmVzLmF0KC0xKTtcbiAgfVxuICBzZXRMYXN0RWxlbWVudChlbGVtZW50KSB7XG4gICAgaWYgKCF0aGlzLiNsaW5lcykge1xuICAgICAgcmV0dXJuIHRoaXMuI291dGxpbmVzLnNldExhc3RFbGVtZW50KGVsZW1lbnQpO1xuICAgIH1cbiAgICB0aGlzLiNsaW5lcy5wdXNoKGVsZW1lbnQpO1xuICAgIHRoaXMuI2xpbmUgPSBlbGVtZW50LmxpbmU7XG4gICAgdGhpcy4jcG9pbnRzID0gZWxlbWVudC5wb2ludHM7XG4gICAgdGhpcy4jbGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDoge1xuICAgICAgICBkOiB0aGlzLnRvU1ZHUGF0aCgpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZW1vdmVMYXN0RWxlbWVudCgpIHtcbiAgICBpZiAoIXRoaXMuI2xpbmVzKSB7XG4gICAgICByZXR1cm4gdGhpcy4jb3V0bGluZXMucmVtb3ZlTGFzdEVsZW1lbnQoKTtcbiAgICB9XG4gICAgdGhpcy4jbGluZXMucG9wKCk7XG4gICAgdGhpcy4jbGFzdFNWR1BhdGggPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHRoaXMuI2xpbmVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgcG9pbnRzXG4gICAgICB9ID0gdGhpcy4jbGluZXNbaV07XG4gICAgICB0aGlzLiNsaW5lID0gbGluZTtcbiAgICAgIHRoaXMuI3BvaW50cyA9IHBvaW50cztcbiAgICAgIHRoaXMuI2xhc3RJbmRleCA9IDA7XG4gICAgICB0aGlzLnRvU1ZHUGF0aCgpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDoge1xuICAgICAgICBkOiB0aGlzLiNsYXN0U1ZHUGF0aFxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdG9TVkdQYXRoKCkge1xuICAgIGNvbnN0IGZpcnN0WCA9IE91dGxpbmUuc3ZnUm91bmQodGhpcy4jbGluZVs0XSk7XG4gICAgY29uc3QgZmlyc3RZID0gT3V0bGluZS5zdmdSb3VuZCh0aGlzLiNsaW5lWzVdKTtcbiAgICBpZiAodGhpcy4jcG9pbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdGhpcy4jbGFzdFNWR1BhdGggPSBgJHt0aGlzLiNsYXN0U1ZHUGF0aH0gTSAke2ZpcnN0WH0gJHtmaXJzdFl9IFpgO1xuICAgICAgcmV0dXJuIHRoaXMuI2xhc3RTVkdQYXRoO1xuICAgIH1cbiAgICBpZiAodGhpcy4jcG9pbnRzLmxlbmd0aCA8PSA2KSB7XG4gICAgICBjb25zdCBpID0gdGhpcy4jbGFzdFNWR1BhdGgubGFzdEluZGV4T2YoXCJNXCIpO1xuICAgICAgdGhpcy4jbGFzdFNWR1BhdGggPSBgJHt0aGlzLiNsYXN0U1ZHUGF0aC5zbGljZSgwLCBpKX0gTSAke2ZpcnN0WH0gJHtmaXJzdFl9YDtcbiAgICAgIHRoaXMuI2xhc3RJbmRleCA9IDY7XG4gICAgfVxuICAgIGlmICh0aGlzLiNwb2ludHMubGVuZ3RoID09PSA0KSB7XG4gICAgICBjb25zdCBzZWNvbmRYID0gT3V0bGluZS5zdmdSb3VuZCh0aGlzLiNsaW5lWzEwXSk7XG4gICAgICBjb25zdCBzZWNvbmRZID0gT3V0bGluZS5zdmdSb3VuZCh0aGlzLiNsaW5lWzExXSk7XG4gICAgICB0aGlzLiNsYXN0U1ZHUGF0aCA9IGAke3RoaXMuI2xhc3RTVkdQYXRofSBMICR7c2Vjb25kWH0gJHtzZWNvbmRZfWA7XG4gICAgICB0aGlzLiNsYXN0SW5kZXggPSAxMjtcbiAgICAgIHJldHVybiB0aGlzLiNsYXN0U1ZHUGF0aDtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgaWYgKHRoaXMuI2xhc3RJbmRleCA9PT0gMCkge1xuICAgICAgYnVmZmVyLnB1c2goYE0gJHtmaXJzdFh9ICR7Zmlyc3RZfWApO1xuICAgICAgdGhpcy4jbGFzdEluZGV4ID0gNjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHRoaXMuI2xhc3RJbmRleCwgaWkgPSB0aGlzLiNsaW5lLmxlbmd0aDsgaSA8IGlpOyBpICs9IDYpIHtcbiAgICAgIGNvbnN0IFtjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHldID0gdGhpcy4jbGluZS5zbGljZShpLCBpICsgNikubWFwKE91dGxpbmUuc3ZnUm91bmQpO1xuICAgICAgYnVmZmVyLnB1c2goYEMke2MxeH0gJHtjMXl9ICR7YzJ4fSAke2MyeX0gJHt4fSAke3l9YCk7XG4gICAgfVxuICAgIHRoaXMuI2xhc3RTVkdQYXRoICs9IGJ1ZmZlci5qb2luKFwiIFwiKTtcbiAgICB0aGlzLiNsYXN0SW5kZXggPSB0aGlzLiNsaW5lLmxlbmd0aDtcbiAgICByZXR1cm4gdGhpcy4jbGFzdFNWR1BhdGg7XG4gIH1cbiAgZ2V0T3V0bGluZXMocGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgc2NhbGUsIGlubmVyTWFyZ2luKSB7XG4gICAgY29uc3QgbGFzdCA9IHRoaXMuI2xpbmVzLmF0KC0xKTtcbiAgICBsYXN0LmxpbmUgPSBuZXcgRmxvYXQzMkFycmF5KGxhc3QubGluZSk7XG4gICAgbGFzdC5wb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KGxhc3QucG9pbnRzKTtcbiAgICB0aGlzLiNvdXRsaW5lcy5idWlsZCh0aGlzLiNsaW5lcywgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgc2NhbGUsIHRoaXMuI3JvdGF0aW9uLCB0aGlzLiN0aGlja25lc3MsIGlubmVyTWFyZ2luKTtcbiAgICB0aGlzLiNsYXN0ID0gbnVsbDtcbiAgICB0aGlzLiNsaW5lID0gbnVsbDtcbiAgICB0aGlzLiNsaW5lcyA9IG51bGw7XG4gICAgdGhpcy4jbGFzdFNWR1BhdGggPSBudWxsO1xuICAgIHJldHVybiB0aGlzLiNvdXRsaW5lcztcbiAgfVxuICBnZXQgZGVmYXVsdFNWR1Byb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgdmlld0JveDogXCIwIDAgMTAwMDAgMTAwMDBcIlxuICAgICAgfSxcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBkcmF3OiB0cnVlXG4gICAgICB9LFxuICAgICAgYmJveDogWzAsIDAsIDEsIDFdXG4gICAgfTtcbiAgfVxufVxuY2xhc3MgSW5rRHJhd091dGxpbmUgZXh0ZW5kcyBPdXRsaW5lIHtcbiAgI2Jib3g7XG4gICNjdXJyZW50Um90YXRpb24gPSAwO1xuICAjaW5uZXJNYXJnaW47XG4gICNsaW5lcztcbiAgI3BhcmVudFdpZHRoO1xuICAjcGFyZW50SGVpZ2h0O1xuICAjcGFyZW50U2NhbGU7XG4gICNyb3RhdGlvbjtcbiAgI3RoaWNrbmVzcztcbiAgYnVpbGQobGluZXMsIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHBhcmVudFNjYWxlLCByb3RhdGlvbiwgdGhpY2tuZXNzLCBpbm5lck1hcmdpbikge1xuICAgIHRoaXMuI3BhcmVudFdpZHRoID0gcGFyZW50V2lkdGg7XG4gICAgdGhpcy4jcGFyZW50SGVpZ2h0ID0gcGFyZW50SGVpZ2h0O1xuICAgIHRoaXMuI3BhcmVudFNjYWxlID0gcGFyZW50U2NhbGU7XG4gICAgdGhpcy4jcm90YXRpb24gPSByb3RhdGlvbjtcbiAgICB0aGlzLiN0aGlja25lc3MgPSB0aGlja25lc3M7XG4gICAgdGhpcy4jaW5uZXJNYXJnaW4gPSBpbm5lck1hcmdpbiA/PyAwO1xuICAgIHRoaXMuI2xpbmVzID0gbGluZXM7XG4gICAgdGhpcy4jY29tcHV0ZUJib3goKTtcbiAgfVxuICBnZXQgdGhpY2tuZXNzKCkge1xuICAgIHJldHVybiB0aGlzLiN0aGlja25lc3M7XG4gIH1cbiAgc2V0TGFzdEVsZW1lbnQoZWxlbWVudCkge1xuICAgIHRoaXMuI2xpbmVzLnB1c2goZWxlbWVudCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmVtb3ZlTGFzdEVsZW1lbnQoKSB7XG4gICAgdGhpcy4jbGluZXMucG9wKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdG9TVkdQYXRoKCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgbGluZVxuICAgIH0gb2YgdGhpcy4jbGluZXMpIHtcbiAgICAgIGJ1ZmZlci5wdXNoKGBNJHtPdXRsaW5lLnN2Z1JvdW5kKGxpbmVbNF0pfSAke091dGxpbmUuc3ZnUm91bmQobGluZVs1XSl9YCk7XG4gICAgICBpZiAobGluZS5sZW5ndGggPT09IDYpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goXCJaXCIpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lLmxlbmd0aCA9PT0gMTIgJiYgaXNOYU4obGluZVs2XSkpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goYEwke091dGxpbmUuc3ZnUm91bmQobGluZVsxMF0pfSAke091dGxpbmUuc3ZnUm91bmQobGluZVsxMV0pfWApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSA2LCBpaSA9IGxpbmUubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNikge1xuICAgICAgICBjb25zdCBbYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5XSA9IGxpbmUuc3ViYXJyYXkoaSwgaSArIDYpLm1hcChPdXRsaW5lLnN2Z1JvdW5kKTtcbiAgICAgICAgYnVmZmVyLnB1c2goYEMke2MxeH0gJHtjMXl9ICR7YzJ4fSAke2MyeX0gJHt4fSAke3l9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIuam9pbihcIlwiKTtcbiAgfVxuICBzZXJpYWxpemUoW3BhZ2VYLCBwYWdlWSwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSwgaXNGb3JDb3B5aW5nKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZExpbmVzID0gW107XG4gICAgY29uc3Qgc2VyaWFsaXplZFBvaW50cyA9IFtdO1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuI2dldEJCb3hXaXRoTm9NYXJnaW4oKTtcbiAgICBsZXQgdHgsIHR5LCBzeCwgc3ksIHgxLCB5MSwgeDIsIHkyLCByZXNjYWxlRm47XG4gICAgc3dpdGNoICh0aGlzLiNyb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlO1xuICAgICAgICB0eCA9IHBhZ2VYO1xuICAgICAgICB0eSA9IHBhZ2VZICsgcGFnZUhlaWdodDtcbiAgICAgICAgc3ggPSBwYWdlV2lkdGg7XG4gICAgICAgIHN5ID0gLXBhZ2VIZWlnaHQ7XG4gICAgICAgIHgxID0gcGFnZVggKyB4ICogcGFnZVdpZHRoO1xuICAgICAgICB5MSA9IHBhZ2VZICsgKDEgLSB5IC0gaGVpZ2h0KSAqIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHgyID0gcGFnZVggKyAoeCArIHdpZHRoKSAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTIgPSBwYWdlWSArICgxIC0geSkgKiBwYWdlSGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJlc2NhbGVGbiA9IE91dGxpbmUuX3Jlc2NhbGVBbmRTd2FwO1xuICAgICAgICB0eCA9IHBhZ2VYO1xuICAgICAgICB0eSA9IHBhZ2VZO1xuICAgICAgICBzeCA9IHBhZ2VXaWR0aDtcbiAgICAgICAgc3kgPSBwYWdlSGVpZ2h0O1xuICAgICAgICB4MSA9IHBhZ2VYICsgeSAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTEgPSBwYWdlWSArIHggKiBwYWdlSGVpZ2h0O1xuICAgICAgICB4MiA9IHBhZ2VYICsgKHkgKyBoZWlnaHQpICogcGFnZVdpZHRoO1xuICAgICAgICB5MiA9IHBhZ2VZICsgKHggKyB3aWR0aCkgKiBwYWdlSGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlO1xuICAgICAgICB0eCA9IHBhZ2VYICsgcGFnZVdpZHRoO1xuICAgICAgICB0eSA9IHBhZ2VZO1xuICAgICAgICBzeCA9IC1wYWdlV2lkdGg7XG4gICAgICAgIHN5ID0gcGFnZUhlaWdodDtcbiAgICAgICAgeDEgPSBwYWdlWCArICgxIC0geCAtIHdpZHRoKSAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTEgPSBwYWdlWSArIHkgKiBwYWdlSGVpZ2h0O1xuICAgICAgICB4MiA9IHBhZ2VYICsgKDEgLSB4KSAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTIgPSBwYWdlWSArICh5ICsgaGVpZ2h0KSAqIHBhZ2VIZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJlc2NhbGVGbiA9IE91dGxpbmUuX3Jlc2NhbGVBbmRTd2FwO1xuICAgICAgICB0eCA9IHBhZ2VYICsgcGFnZVdpZHRoO1xuICAgICAgICB0eSA9IHBhZ2VZICsgcGFnZUhlaWdodDtcbiAgICAgICAgc3ggPSAtcGFnZVdpZHRoO1xuICAgICAgICBzeSA9IC1wYWdlSGVpZ2h0O1xuICAgICAgICB4MSA9IHBhZ2VYICsgKDEgLSB5IC0gaGVpZ2h0KSAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTEgPSBwYWdlWSArICgxIC0geCAtIHdpZHRoKSAqIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHgyID0gcGFnZVggKyAoMSAtIHkpICogcGFnZVdpZHRoO1xuICAgICAgICB5MiA9IHBhZ2VZICsgKDEgLSB4KSAqIHBhZ2VIZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIGxpbmUsXG4gICAgICBwb2ludHNcbiAgICB9IG9mIHRoaXMuI2xpbmVzKSB7XG4gICAgICBzZXJpYWxpemVkTGluZXMucHVzaChyZXNjYWxlRm4obGluZSwgdHgsIHR5LCBzeCwgc3ksIGlzRm9yQ29weWluZyA/IG5ldyBBcnJheShsaW5lLmxlbmd0aCkgOiBudWxsKSk7XG4gICAgICBzZXJpYWxpemVkUG9pbnRzLnB1c2gocmVzY2FsZUZuKHBvaW50cywgdHgsIHR5LCBzeCwgc3ksIGlzRm9yQ29weWluZyA/IG5ldyBBcnJheShwb2ludHMubGVuZ3RoKSA6IG51bGwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmVzOiBzZXJpYWxpemVkTGluZXMsXG4gICAgICBwb2ludHM6IHNlcmlhbGl6ZWRQb2ludHMsXG4gICAgICByZWN0OiBbeDEsIHkxLCB4MiwgeTJdXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZGVzZXJpYWxpemUocGFnZVgsIHBhZ2VZLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIGlubmVyTWFyZ2luLCB7XG4gICAgcGF0aHM6IHtcbiAgICAgIGxpbmVzLFxuICAgICAgcG9pbnRzXG4gICAgfSxcbiAgICByb3RhdGlvbixcbiAgICB0aGlja25lc3NcbiAgfSkge1xuICAgIGNvbnN0IG5ld0xpbmVzID0gW107XG4gICAgbGV0IHR4LCB0eSwgc3gsIHN5LCByZXNjYWxlRm47XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlO1xuICAgICAgICB0eCA9IC1wYWdlWCAvIHBhZ2VXaWR0aDtcbiAgICAgICAgdHkgPSBwYWdlWSAvIHBhZ2VIZWlnaHQgKyAxO1xuICAgICAgICBzeCA9IDEgLyBwYWdlV2lkdGg7XG4gICAgICAgIHN5ID0gLTEgLyBwYWdlSGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJlc2NhbGVGbiA9IE91dGxpbmUuX3Jlc2NhbGVBbmRTd2FwO1xuICAgICAgICB0eCA9IC1wYWdlWSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHR5ID0gLXBhZ2VYIC8gcGFnZVdpZHRoO1xuICAgICAgICBzeCA9IDEgLyBwYWdlSGVpZ2h0O1xuICAgICAgICBzeSA9IDEgLyBwYWdlV2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJlc2NhbGVGbiA9IE91dGxpbmUuX3Jlc2NhbGU7XG4gICAgICAgIHR4ID0gcGFnZVggLyBwYWdlV2lkdGggKyAxO1xuICAgICAgICB0eSA9IC1wYWdlWSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHN4ID0gLTEgLyBwYWdlV2lkdGg7XG4gICAgICAgIHN5ID0gMSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJlc2NhbGVGbiA9IE91dGxpbmUuX3Jlc2NhbGVBbmRTd2FwO1xuICAgICAgICB0eCA9IHBhZ2VZIC8gcGFnZUhlaWdodCArIDE7XG4gICAgICAgIHR5ID0gcGFnZVggLyBwYWdlV2lkdGggKyAxO1xuICAgICAgICBzeCA9IC0xIC8gcGFnZUhlaWdodDtcbiAgICAgICAgc3kgPSAtMSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICghbGluZXMpIHtcbiAgICAgIGxpbmVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIHBvaW50cykge1xuICAgICAgICBjb25zdCBsZW4gPSBwb2ludC5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPT09IDIpIHtcbiAgICAgICAgICBsaW5lcy5wdXNoKG5ldyBGbG9hdDMyQXJyYXkoW05hTiwgTmFOLCBOYU4sIE5hTiwgcG9pbnRbMF0sIHBvaW50WzFdXSkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW4gPT09IDQpIHtcbiAgICAgICAgICBsaW5lcy5wdXNoKG5ldyBGbG9hdDMyQXJyYXkoW05hTiwgTmFOLCBOYU4sIE5hTiwgcG9pbnRbMF0sIHBvaW50WzFdLCBOYU4sIE5hTiwgTmFOLCBOYU4sIHBvaW50WzJdLCBwb2ludFszXV0pKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaW5lID0gbmV3IEZsb2F0MzJBcnJheSgzICogKGxlbiAtIDIpKTtcbiAgICAgICAgbGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgbGV0IFt4MSwgeTEsIHgyLCB5Ml0gPSBwb2ludC5zdWJhcnJheSgwLCA0KTtcbiAgICAgICAgbGluZS5zZXQoW05hTiwgTmFOLCBOYU4sIE5hTiwgeDEsIHkxXSwgMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSA0OyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgICAgICBjb25zdCB4ID0gcG9pbnRbaV07XG4gICAgICAgICAgY29uc3QgeSA9IHBvaW50W2kgKyAxXTtcbiAgICAgICAgICBsaW5lLnNldChPdXRsaW5lLmNyZWF0ZUJlemllclBvaW50cyh4MSwgeTEsIHgyLCB5MiwgeCwgeSksIChpIC0gMikgKiAzKTtcbiAgICAgICAgICBbeDEsIHkxLCB4MiwgeTJdID0gW3gyLCB5MiwgeCwgeV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGluZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgbmV3TGluZXMucHVzaCh7XG4gICAgICAgIGxpbmU6IHJlc2NhbGVGbihsaW5lc1tpXS5tYXAoeCA9PiB4ID8/IE5hTiksIHR4LCB0eSwgc3gsIHN5KSxcbiAgICAgICAgcG9pbnRzOiByZXNjYWxlRm4ocG9pbnRzW2ldLm1hcCh4ID0+IHggPz8gTmFOKSwgdHgsIHR5LCBzeCwgc3kpXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgb3V0bGluZXMgPSBuZXcgdGhpcy5wcm90b3R5cGUuY29uc3RydWN0b3IoKTtcbiAgICBvdXRsaW5lcy5idWlsZChuZXdMaW5lcywgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCAxLCByb3RhdGlvbiwgdGhpY2tuZXNzLCBpbm5lck1hcmdpbik7XG4gICAgcmV0dXJuIG91dGxpbmVzO1xuICB9XG4gICNnZXRNYXJnaW5Db21wb25lbnRzKHRoaWNrbmVzcyA9IHRoaXMuI3RoaWNrbmVzcykge1xuICAgIGNvbnN0IG1hcmdpbiA9IHRoaXMuI2lubmVyTWFyZ2luICsgdGhpY2tuZXNzIC8gMiAqIHRoaXMuI3BhcmVudFNjYWxlO1xuICAgIHJldHVybiB0aGlzLiNyb3RhdGlvbiAlIDE4MCA9PT0gMCA/IFttYXJnaW4gLyB0aGlzLiNwYXJlbnRXaWR0aCwgbWFyZ2luIC8gdGhpcy4jcGFyZW50SGVpZ2h0XSA6IFttYXJnaW4gLyB0aGlzLiNwYXJlbnRIZWlnaHQsIG1hcmdpbiAvIHRoaXMuI3BhcmVudFdpZHRoXTtcbiAgfVxuICAjZ2V0QkJveFdpdGhOb01hcmdpbigpIHtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNiYm94O1xuICAgIGNvbnN0IFttYXJnaW5YLCBtYXJnaW5ZXSA9IHRoaXMuI2dldE1hcmdpbkNvbXBvbmVudHMoMCk7XG4gICAgcmV0dXJuIFt4ICsgbWFyZ2luWCwgeSArIG1hcmdpblksIHdpZHRoIC0gMiAqIG1hcmdpblgsIGhlaWdodCAtIDIgKiBtYXJnaW5ZXTtcbiAgfVxuICAjY29tcHV0ZUJib3goKSB7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuI2Jib3ggPSBuZXcgRmxvYXQzMkFycmF5KFtJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XSk7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBsaW5lXG4gICAgfSBvZiB0aGlzLiNsaW5lcykge1xuICAgICAgaWYgKGxpbmUubGVuZ3RoIDw9IDEyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSA0LCBpaSA9IGxpbmUubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNikge1xuICAgICAgICAgIFV0aWwucG9pbnRCb3VuZGluZ0JveChsaW5lW2ldLCBsaW5lW2kgKyAxXSwgYmJveCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgbGFzdFggPSBsaW5lWzRdLFxuICAgICAgICBsYXN0WSA9IGxpbmVbNV07XG4gICAgICBmb3IgKGxldCBpID0gNiwgaWkgPSBsaW5lLmxlbmd0aDsgaSA8IGlpOyBpICs9IDYpIHtcbiAgICAgICAgY29uc3QgW2MxeCwgYzF5LCBjMngsIGMyeSwgeCwgeV0gPSBsaW5lLnN1YmFycmF5KGksIGkgKyA2KTtcbiAgICAgICAgVXRpbC5iZXppZXJCb3VuZGluZ0JveChsYXN0WCwgbGFzdFksIGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSwgYmJveCk7XG4gICAgICAgIGxhc3RYID0geDtcbiAgICAgICAgbGFzdFkgPSB5O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBbbWFyZ2luWCwgbWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKCk7XG4gICAgYmJveFswXSA9IE1hdGhDbGFtcChiYm94WzBdIC0gbWFyZ2luWCwgMCwgMSk7XG4gICAgYmJveFsxXSA9IE1hdGhDbGFtcChiYm94WzFdIC0gbWFyZ2luWSwgMCwgMSk7XG4gICAgYmJveFsyXSA9IE1hdGhDbGFtcChiYm94WzJdICsgbWFyZ2luWCwgMCwgMSk7XG4gICAgYmJveFszXSA9IE1hdGhDbGFtcChiYm94WzNdICsgbWFyZ2luWSwgMCwgMSk7XG4gICAgYmJveFsyXSAtPSBiYm94WzBdO1xuICAgIGJib3hbM10gLT0gYmJveFsxXTtcbiAgfVxuICBnZXQgYm94KCkge1xuICAgIHJldHVybiB0aGlzLiNiYm94O1xuICB9XG4gIHVwZGF0ZVByb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKG5hbWUgPT09IFwic3Ryb2tlLXdpZHRoXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLiN1cGRhdGVUaGlja25lc3ModmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAjdXBkYXRlVGhpY2tuZXNzKHRoaWNrbmVzcykge1xuICAgIGNvbnN0IFtvbGRNYXJnaW5YLCBvbGRNYXJnaW5ZXSA9IHRoaXMuI2dldE1hcmdpbkNvbXBvbmVudHMoKTtcbiAgICB0aGlzLiN0aGlja25lc3MgPSB0aGlja25lc3M7XG4gICAgY29uc3QgW25ld01hcmdpblgsIG5ld01hcmdpblldID0gdGhpcy4jZ2V0TWFyZ2luQ29tcG9uZW50cygpO1xuICAgIGNvbnN0IFtkaWZmTWFyZ2luWCwgZGlmZk1hcmdpblldID0gW25ld01hcmdpblggLSBvbGRNYXJnaW5YLCBuZXdNYXJnaW5ZIC0gb2xkTWFyZ2luWV07XG4gICAgY29uc3QgYmJveCA9IHRoaXMuI2Jib3g7XG4gICAgYmJveFswXSAtPSBkaWZmTWFyZ2luWDtcbiAgICBiYm94WzFdIC09IGRpZmZNYXJnaW5ZO1xuICAgIGJib3hbMl0gKz0gMiAqIGRpZmZNYXJnaW5YO1xuICAgIGJib3hbM10gKz0gMiAqIGRpZmZNYXJnaW5ZO1xuICAgIHJldHVybiBiYm94O1xuICB9XG4gIHVwZGF0ZVBhcmVudERpbWVuc2lvbnMoW3dpZHRoLCBoZWlnaHRdLCBzY2FsZSkge1xuICAgIGNvbnN0IFtvbGRNYXJnaW5YLCBvbGRNYXJnaW5ZXSA9IHRoaXMuI2dldE1hcmdpbkNvbXBvbmVudHMoKTtcbiAgICB0aGlzLiNwYXJlbnRXaWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuI3BhcmVudEhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLiNwYXJlbnRTY2FsZSA9IHNjYWxlO1xuICAgIGNvbnN0IFtuZXdNYXJnaW5YLCBuZXdNYXJnaW5ZXSA9IHRoaXMuI2dldE1hcmdpbkNvbXBvbmVudHMoKTtcbiAgICBjb25zdCBkaWZmTWFyZ2luWCA9IG5ld01hcmdpblggLSBvbGRNYXJnaW5YO1xuICAgIGNvbnN0IGRpZmZNYXJnaW5ZID0gbmV3TWFyZ2luWSAtIG9sZE1hcmdpblk7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuI2Jib3g7XG4gICAgYmJveFswXSAtPSBkaWZmTWFyZ2luWDtcbiAgICBiYm94WzFdIC09IGRpZmZNYXJnaW5ZO1xuICAgIGJib3hbMl0gKz0gMiAqIGRpZmZNYXJnaW5YO1xuICAgIGJib3hbM10gKz0gMiAqIGRpZmZNYXJnaW5ZO1xuICAgIHJldHVybiBiYm94O1xuICB9XG4gIHVwZGF0ZVJvdGF0aW9uKHJvdGF0aW9uKSB7XG4gICAgdGhpcy4jY3VycmVudFJvdGF0aW9uID0gcm90YXRpb247XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgdHJhbnNmb3JtOiB0aGlzLnJvdGF0aW9uVHJhbnNmb3JtXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBnZXQgdmlld0JveCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYmJveC5tYXAoT3V0bGluZS5zdmdSb3VuZCkuam9pbihcIiBcIik7XG4gIH1cbiAgZ2V0IGRlZmF1bHRQcm9wZXJ0aWVzKCkge1xuICAgIGNvbnN0IFt4LCB5XSA9IHRoaXMuI2Jib3g7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgdmlld0JveDogdGhpcy52aWV3Qm94XG4gICAgICB9LFxuICAgICAgcGF0aDoge1xuICAgICAgICBcInRyYW5zZm9ybS1vcmlnaW5cIjogYCR7T3V0bGluZS5zdmdSb3VuZCh4KX0gJHtPdXRsaW5lLnN2Z1JvdW5kKHkpfWBcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGdldCByb3RhdGlvblRyYW5zZm9ybSgpIHtcbiAgICBjb25zdCBbLCwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNiYm94O1xuICAgIGxldCBhID0gMCxcbiAgICAgIGIgPSAwLFxuICAgICAgYyA9IDAsXG4gICAgICBkID0gMCxcbiAgICAgIGUgPSAwLFxuICAgICAgZiA9IDA7XG4gICAgc3dpdGNoICh0aGlzLiNjdXJyZW50Um90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIGIgPSBoZWlnaHQgLyB3aWR0aDtcbiAgICAgICAgYyA9IC13aWR0aCAvIGhlaWdodDtcbiAgICAgICAgZSA9IHdpZHRoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICBhID0gLTE7XG4gICAgICAgIGQgPSAtMTtcbiAgICAgICAgZSA9IHdpZHRoO1xuICAgICAgICBmID0gaGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICBiID0gLWhlaWdodCAvIHdpZHRoO1xuICAgICAgICBjID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgICAgIGYgPSBoZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBgbWF0cml4KCR7YX0gJHtifSAke2N9ICR7ZH0gJHtPdXRsaW5lLnN2Z1JvdW5kKGUpfSAke091dGxpbmUuc3ZnUm91bmQoZil9KWA7XG4gIH1cbiAgZ2V0UGF0aFJlc2l6aW5nU1ZHUHJvcGVydGllcyhbbmV3WCwgbmV3WSwgbmV3V2lkdGgsIG5ld0hlaWdodF0pIHtcbiAgICBjb25zdCBbbWFyZ2luWCwgbWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKCk7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYmJveDtcbiAgICBpZiAoTWF0aC5hYnMod2lkdGggLSBtYXJnaW5YKSA8PSBPdXRsaW5lLlBSRUNJU0lPTiB8fCBNYXRoLmFicyhoZWlnaHQgLSBtYXJnaW5ZKSA8PSBPdXRsaW5lLlBSRUNJU0lPTikge1xuICAgICAgY29uc3QgdHggPSBuZXdYICsgbmV3V2lkdGggLyAyIC0gKHggKyB3aWR0aCAvIDIpO1xuICAgICAgY29uc3QgdHkgPSBuZXdZICsgbmV3SGVpZ2h0IC8gMiAtICh5ICsgaGVpZ2h0IC8gMik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6IGAke091dGxpbmUuc3ZnUm91bmQobmV3WCl9ICR7T3V0bGluZS5zdmdSb3VuZChuZXdZKX1gLFxuICAgICAgICAgIHRyYW5zZm9ybTogYCR7dGhpcy5yb3RhdGlvblRyYW5zZm9ybX0gdHJhbnNsYXRlKCR7dHh9ICR7dHl9KWBcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgczF4ID0gKG5ld1dpZHRoIC0gMiAqIG1hcmdpblgpIC8gKHdpZHRoIC0gMiAqIG1hcmdpblgpO1xuICAgIGNvbnN0IHMxeSA9IChuZXdIZWlnaHQgLSAyICogbWFyZ2luWSkgLyAoaGVpZ2h0IC0gMiAqIG1hcmdpblkpO1xuICAgIGNvbnN0IHMyeCA9IHdpZHRoIC8gbmV3V2lkdGg7XG4gICAgY29uc3QgczJ5ID0gaGVpZ2h0IC8gbmV3SGVpZ2h0O1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiB7XG4gICAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBgJHtPdXRsaW5lLnN2Z1JvdW5kKHgpfSAke091dGxpbmUuc3ZnUm91bmQoeSl9YCxcbiAgICAgICAgdHJhbnNmb3JtOiBgJHt0aGlzLnJvdGF0aW9uVHJhbnNmb3JtfSBzY2FsZSgke3MyeH0gJHtzMnl9KSBgICsgYHRyYW5zbGF0ZSgke091dGxpbmUuc3ZnUm91bmQobWFyZ2luWCl9ICR7T3V0bGluZS5zdmdSb3VuZChtYXJnaW5ZKX0pIHNjYWxlKCR7czF4fSAke3MxeX0pIGAgKyBgdHJhbnNsYXRlKCR7T3V0bGluZS5zdmdSb3VuZCgtbWFyZ2luWCl9ICR7T3V0bGluZS5zdmdSb3VuZCgtbWFyZ2luWSl9KWBcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGdldFBhdGhSZXNpemVkU1ZHUHJvcGVydGllcyhbbmV3WCwgbmV3WSwgbmV3V2lkdGgsIG5ld0hlaWdodF0pIHtcbiAgICBjb25zdCBbbWFyZ2luWCwgbWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKCk7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuI2Jib3g7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gYmJveDtcbiAgICBiYm94WzBdID0gbmV3WDtcbiAgICBiYm94WzFdID0gbmV3WTtcbiAgICBiYm94WzJdID0gbmV3V2lkdGg7XG4gICAgYmJveFszXSA9IG5ld0hlaWdodDtcbiAgICBpZiAoTWF0aC5hYnMod2lkdGggLSBtYXJnaW5YKSA8PSBPdXRsaW5lLlBSRUNJU0lPTiB8fCBNYXRoLmFicyhoZWlnaHQgLSBtYXJnaW5ZKSA8PSBPdXRsaW5lLlBSRUNJU0lPTikge1xuICAgICAgY29uc3QgdHggPSBuZXdYICsgbmV3V2lkdGggLyAyIC0gKHggKyB3aWR0aCAvIDIpO1xuICAgICAgY29uc3QgdHkgPSBuZXdZICsgbmV3SGVpZ2h0IC8gMiAtICh5ICsgaGVpZ2h0IC8gMik7XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgcG9pbnRzXG4gICAgICB9IG9mIHRoaXMuI2xpbmVzKSB7XG4gICAgICAgIE91dGxpbmUuX3RyYW5zbGF0ZShsaW5lLCB0eCwgdHksIGxpbmUpO1xuICAgICAgICBPdXRsaW5lLl90cmFuc2xhdGUocG9pbnRzLCB0eCwgdHksIHBvaW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb290OiB7XG4gICAgICAgICAgdmlld0JveDogdGhpcy52aWV3Qm94XG4gICAgICAgIH0sXG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICBcInRyYW5zZm9ybS1vcmlnaW5cIjogYCR7T3V0bGluZS5zdmdSb3VuZChuZXdYKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKG5ld1kpfWAsXG4gICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLnJvdGF0aW9uVHJhbnNmb3JtIHx8IG51bGwsXG4gICAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzMXggPSAobmV3V2lkdGggLSAyICogbWFyZ2luWCkgLyAod2lkdGggLSAyICogbWFyZ2luWCk7XG4gICAgY29uc3QgczF5ID0gKG5ld0hlaWdodCAtIDIgKiBtYXJnaW5ZKSAvIChoZWlnaHQgLSAyICogbWFyZ2luWSk7XG4gICAgY29uc3QgdHggPSAtczF4ICogKHggKyBtYXJnaW5YKSArIG5ld1ggKyBtYXJnaW5YO1xuICAgIGNvbnN0IHR5ID0gLXMxeSAqICh5ICsgbWFyZ2luWSkgKyBuZXdZICsgbWFyZ2luWTtcbiAgICBpZiAoczF4ICE9PSAxIHx8IHMxeSAhPT0gMSB8fCB0eCAhPT0gMCB8fCB0eSAhPT0gMCkge1xuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIHBvaW50c1xuICAgICAgfSBvZiB0aGlzLiNsaW5lcykge1xuICAgICAgICBPdXRsaW5lLl9yZXNjYWxlKGxpbmUsIHR4LCB0eSwgczF4LCBzMXksIGxpbmUpO1xuICAgICAgICBPdXRsaW5lLl9yZXNjYWxlKHBvaW50cywgdHgsIHR5LCBzMXgsIHMxeSwgcG9pbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgdmlld0JveDogdGhpcy52aWV3Qm94XG4gICAgICB9LFxuICAgICAgcGF0aDoge1xuICAgICAgICBcInRyYW5zZm9ybS1vcmlnaW5cIjogYCR7T3V0bGluZS5zdmdSb3VuZChuZXdYKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKG5ld1kpfWAsXG4gICAgICAgIHRyYW5zZm9ybTogdGhpcy5yb3RhdGlvblRyYW5zZm9ybSB8fCBudWxsLFxuICAgICAgICBkOiB0aGlzLnRvU1ZHUGF0aCgpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBnZXRQYXRoVHJhbnNsYXRlZFNWR1Byb3BlcnRpZXMoW25ld1gsIG5ld1ldLCBwYXJlbnREaW1lbnNpb25zKSB7XG4gICAgY29uc3QgW25ld1BhcmVudFdpZHRoLCBuZXdQYXJlbnRIZWlnaHRdID0gcGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCBiYm94ID0gdGhpcy4jYmJveDtcbiAgICBjb25zdCB0eCA9IG5ld1ggLSBiYm94WzBdO1xuICAgIGNvbnN0IHR5ID0gbmV3WSAtIGJib3hbMV07XG4gICAgaWYgKHRoaXMuI3BhcmVudFdpZHRoID09PSBuZXdQYXJlbnRXaWR0aCAmJiB0aGlzLiNwYXJlbnRIZWlnaHQgPT09IG5ld1BhcmVudEhlaWdodCkge1xuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIHBvaW50c1xuICAgICAgfSBvZiB0aGlzLiNsaW5lcykge1xuICAgICAgICBPdXRsaW5lLl90cmFuc2xhdGUobGluZSwgdHgsIHR5LCBsaW5lKTtcbiAgICAgICAgT3V0bGluZS5fdHJhbnNsYXRlKHBvaW50cywgdHgsIHR5LCBwb2ludHMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzeCA9IHRoaXMuI3BhcmVudFdpZHRoIC8gbmV3UGFyZW50V2lkdGg7XG4gICAgICBjb25zdCBzeSA9IHRoaXMuI3BhcmVudEhlaWdodCAvIG5ld1BhcmVudEhlaWdodDtcbiAgICAgIHRoaXMuI3BhcmVudFdpZHRoID0gbmV3UGFyZW50V2lkdGg7XG4gICAgICB0aGlzLiNwYXJlbnRIZWlnaHQgPSBuZXdQYXJlbnRIZWlnaHQ7XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgcG9pbnRzXG4gICAgICB9IG9mIHRoaXMuI2xpbmVzKSB7XG4gICAgICAgIE91dGxpbmUuX3Jlc2NhbGUobGluZSwgdHgsIHR5LCBzeCwgc3ksIGxpbmUpO1xuICAgICAgICBPdXRsaW5lLl9yZXNjYWxlKHBvaW50cywgdHgsIHR5LCBzeCwgc3ksIHBvaW50cyk7XG4gICAgICB9XG4gICAgICBiYm94WzJdICo9IHN4O1xuICAgICAgYmJveFszXSAqPSBzeTtcbiAgICB9XG4gICAgYmJveFswXSA9IG5ld1g7XG4gICAgYmJveFsxXSA9IG5ld1k7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgdmlld0JveDogdGhpcy52aWV3Qm94XG4gICAgICB9LFxuICAgICAgcGF0aDoge1xuICAgICAgICBkOiB0aGlzLnRvU1ZHUGF0aCgpLFxuICAgICAgICBcInRyYW5zZm9ybS1vcmlnaW5cIjogYCR7T3V0bGluZS5zdmdSb3VuZChuZXdYKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKG5ld1kpfWBcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGdldCBkZWZhdWx0U1ZHUHJvcGVydGllcygpIHtcbiAgICBjb25zdCBiYm94ID0gdGhpcy4jYmJveDtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vdDoge1xuICAgICAgICB2aWV3Qm94OiB0aGlzLnZpZXdCb3hcbiAgICAgIH0sXG4gICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgZHJhdzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKSxcbiAgICAgICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6IGAke091dGxpbmUuc3ZnUm91bmQoYmJveFswXSl9ICR7T3V0bGluZS5zdmdSb3VuZChiYm94WzFdKX1gLFxuICAgICAgICB0cmFuc2Zvcm06IHRoaXMucm90YXRpb25UcmFuc2Zvcm0gfHwgbnVsbFxuICAgICAgfSxcbiAgICAgIGJib3hcbiAgICB9O1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9pbmsuanNcblxuXG5cblxuXG5jbGFzcyBJbmtEcmF3aW5nT3B0aW9ucyBleHRlbmRzIERyYXdpbmdPcHRpb25zIHtcbiAgY29uc3RydWN0b3Iodmlld2VyUGFyYW1ldGVycykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fdmlld1BhcmFtZXRlcnMgPSB2aWV3ZXJQYXJhbWV0ZXJzO1xuICAgIHN1cGVyLnVwZGF0ZVByb3BlcnRpZXMoe1xuICAgICAgZmlsbDogXCJub25lXCIsXG4gICAgICBzdHJva2U6IEFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3IsXG4gICAgICBcInN0cm9rZS1vcGFjaXR5XCI6IDEsXG4gICAgICBcInN0cm9rZS13aWR0aFwiOiAxLFxuICAgICAgXCJzdHJva2UtbGluZWNhcFwiOiBcInJvdW5kXCIsXG4gICAgICBcInN0cm9rZS1saW5lam9pblwiOiBcInJvdW5kXCIsXG4gICAgICBcInN0cm9rZS1taXRlcmxpbWl0XCI6IDEwXG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlU1ZHUHJvcGVydHkobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobmFtZSA9PT0gXCJzdHJva2Utd2lkdGhcIikge1xuICAgICAgdmFsdWUgPz89IHRoaXNbXCJzdHJva2Utd2lkdGhcIl07XG4gICAgICB2YWx1ZSAqPSB0aGlzLl92aWV3UGFyYW1ldGVycy5yZWFsU2NhbGU7XG4gICAgfVxuICAgIHN1cGVyLnVwZGF0ZVNWR1Byb3BlcnR5KG5hbWUsIHZhbHVlKTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBJbmtEcmF3aW5nT3B0aW9ucyh0aGlzLl92aWV3UGFyYW1ldGVycyk7XG4gICAgY2xvbmUudXBkYXRlQWxsKHRoaXMpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuY2xhc3MgSW5rRWRpdG9yIGV4dGVuZHMgRHJhd2luZ0VkaXRvciB7XG4gIHN0YXRpYyBfdHlwZSA9IFwiaW5rXCI7XG4gIHN0YXRpYyBfZWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLklOSztcbiAgc3RhdGljIF9kZWZhdWx0RHJhd2luZ09wdGlvbnMgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBuYW1lOiBcImlua0VkaXRvclwiXG4gICAgfSk7XG4gICAgdGhpcy5fd2lsbEtlZXBBc3BlY3RSYXRpbyA9IHRydWU7XG4gICAgdGhpcy5kZWZhdWx0TDEwbklkID0gXCJwZGZqcy1lZGl0b3ItaW5rLWVkaXRvclwiO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcikge1xuICAgIEFubm90YXRpb25FZGl0b3IuaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpO1xuICAgIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucyA9IG5ldyBJbmtEcmF3aW5nT3B0aW9ucyh1aU1hbmFnZXIudmlld1BhcmFtZXRlcnMpO1xuICB9XG4gIHN0YXRpYyBnZXREZWZhdWx0RHJhd2luZ09wdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IGNsb25lID0gdGhpcy5fZGVmYXVsdERyYXdpbmdPcHRpb25zLmNsb25lKCk7XG4gICAgY2xvbmUudXBkYXRlUHJvcGVydGllcyhvcHRpb25zKTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbiAgc3RhdGljIGdldCBzdXBwb3J0TXVsdGlwbGVEcmF3aW5ncygpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGVzTWFwKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJ0eXBlc01hcFwiLCBuZXcgTWFwKFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX1RISUNLTkVTUywgXCJzdHJva2Utd2lkdGhcIl0sIFtBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfQ09MT1IsIFwic3Ryb2tlXCJdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX09QQUNJVFksIFwic3Ryb2tlLW9wYWNpdHlcIl1dKSk7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZURyYXdlckluc3RhbmNlKHgsIHksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHJvdGF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBJbmtEcmF3T3V0bGluZXIoeCwgeSwgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgcm90YXRpb24sIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9uc1tcInN0cm9rZS13aWR0aFwiXSk7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplRHJhdyhwYWdlWCwgcGFnZVksIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgaW5uZXJNYXJnaW4sIGRhdGEpIHtcbiAgICByZXR1cm4gSW5rRHJhd091dGxpbmUuZGVzZXJpYWxpemUocGFnZVgsIHBhZ2VZLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIGlubmVyTWFyZ2luLCBkYXRhKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBsZXQgaW5pdGlhbERhdGEgPSBudWxsO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgSW5rQW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGlua0xpc3RzLFxuICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgY29sb3IsXG4gICAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgICBib3JkZXJTdHlsZToge1xuICAgICAgICAgICAgcmF3V2lkdGg6IHRoaWNrbmVzc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcG9wdXBSZWZcbiAgICAgICAgfSxcbiAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgcGFnZU51bWJlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSA9IGRhdGE7XG4gICAgICBpbml0aWFsRGF0YSA9IGRhdGEgPSB7XG4gICAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5JTkssXG4gICAgICAgIGNvbG9yOiBBcnJheS5mcm9tKGNvbG9yKSxcbiAgICAgICAgdGhpY2tuZXNzLFxuICAgICAgICBvcGFjaXR5LFxuICAgICAgICBwYXRoczoge1xuICAgICAgICAgIHBvaW50czogaW5rTGlzdHNcbiAgICAgICAgfSxcbiAgICAgICAgYm94ZXM6IG51bGwsXG4gICAgICAgIHBhZ2VJbmRleDogcGFnZU51bWJlciAtIDEsXG4gICAgICAgIHJlY3Q6IHJlY3Quc2xpY2UoMCksXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBpZCxcbiAgICAgICAgZGVsZXRlZDogZmFsc2UsXG4gICAgICAgIHBvcHVwUmVmXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgPSBkYXRhLmlkIHx8IG51bGw7XG4gICAgZWRpdG9yLl9pbml0aWFsRGF0YSA9IGluaXRpYWxEYXRhO1xuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgb25TY2FsZUNoYW5naW5nKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIub25TY2FsZUNoYW5naW5nKCk7XG4gICAgY29uc3Qge1xuICAgICAgX2RyYXdJZCxcbiAgICAgIF9kcmF3aW5nT3B0aW9ucyxcbiAgICAgIHBhcmVudFxuICAgIH0gPSB0aGlzO1xuICAgIF9kcmF3aW5nT3B0aW9ucy51cGRhdGVTVkdQcm9wZXJ0eShcInN0cm9rZS13aWR0aFwiKTtcbiAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXMoX2RyYXdJZCwgX2RyYXdpbmdPcHRpb25zLnRvU1ZHUHJvcGVydGllcygpKTtcbiAgfVxuICBzdGF0aWMgb25TY2FsZUNoYW5naW5nV2hlbkRyYXdpbmcoKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5fY3VycmVudFBhcmVudDtcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5vblNjYWxlQ2hhbmdpbmdXaGVuRHJhd2luZygpO1xuICAgIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucy51cGRhdGVTVkdQcm9wZXJ0eShcInN0cm9rZS13aWR0aFwiKTtcbiAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fY3VycmVudERyYXdJZCwgdGhpcy5fZGVmYXVsdERyYXdpbmdPcHRpb25zLnRvU1ZHUHJvcGVydGllcygpKTtcbiAgfVxuICBjcmVhdGVEcmF3aW5nT3B0aW9ucyh7XG4gICAgY29sb3IsXG4gICAgdGhpY2tuZXNzLFxuICAgIG9wYWNpdHlcbiAgfSkge1xuICAgIHRoaXMuX2RyYXdpbmdPcHRpb25zID0gSW5rRWRpdG9yLmdldERlZmF1bHREcmF3aW5nT3B0aW9ucyh7XG4gICAgICBzdHJva2U6IFV0aWwubWFrZUhleENvbG9yKC4uLmNvbG9yKSxcbiAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IHRoaWNrbmVzcyxcbiAgICAgIFwic3Ryb2tlLW9wYWNpdHlcIjogb3BhY2l0eVxuICAgIH0pO1xuICB9XG4gIHNlcmlhbGl6ZShpc0ZvckNvcHlpbmcgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZURlbGV0ZWQoKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbGluZXMsXG4gICAgICBwb2ludHMsXG4gICAgICByZWN0XG4gICAgfSA9IHRoaXMuc2VyaWFsaXplRHJhdyhpc0ZvckNvcHlpbmcpO1xuICAgIGNvbnN0IHtcbiAgICAgIF9kcmF3aW5nT3B0aW9uczoge1xuICAgICAgICBzdHJva2UsXG4gICAgICAgIFwic3Ryb2tlLW9wYWNpdHlcIjogb3BhY2l0eSxcbiAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogdGhpY2tuZXNzXG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHtcbiAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5JTkssXG4gICAgICBjb2xvcjogQW5ub3RhdGlvbkVkaXRvci5fY29sb3JNYW5hZ2VyLmNvbnZlcnQoc3Ryb2tlKSxcbiAgICAgIG9wYWNpdHksXG4gICAgICB0aGlja25lc3MsXG4gICAgICBwYXRoczoge1xuICAgICAgICBsaW5lcyxcbiAgICAgICAgcG9pbnRzXG4gICAgICB9LFxuICAgICAgcGFnZUluZGV4OiB0aGlzLnBhZ2VJbmRleCxcbiAgICAgIHJlY3QsXG4gICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbixcbiAgICAgIHN0cnVjdFRyZWVQYXJlbnRJZDogdGhpcy5fc3RydWN0VHJlZVBhcmVudElkXG4gICAgfTtcbiAgICBpZiAoaXNGb3JDb3B5aW5nKSB7XG4gICAgICBzZXJpYWxpemVkLmlzQ29weSA9IHRydWU7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCAmJiAhdGhpcy4jaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzZXJpYWxpemVkLmlkID0gdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG4gICNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29sb3IsXG4gICAgICB0aGlja25lc3MsXG4gICAgICBvcGFjaXR5LFxuICAgICAgcGFnZUluZGV4XG4gICAgfSA9IHRoaXMuX2luaXRpYWxEYXRhO1xuICAgIHJldHVybiB0aGlzLl9oYXNCZWVuTW92ZWQgfHwgdGhpcy5faGFzQmVlblJlc2l6ZWQgfHwgc2VyaWFsaXplZC5jb2xvci5zb21lKChjLCBpKSA9PiBjICE9PSBjb2xvcltpXSkgfHwgc2VyaWFsaXplZC50aGlja25lc3MgIT09IHRoaWNrbmVzcyB8fCBzZXJpYWxpemVkLm9wYWNpdHkgIT09IG9wYWNpdHkgfHwgc2VyaWFsaXplZC5wYWdlSW5kZXggIT09IHBhZ2VJbmRleDtcbiAgfVxuICByZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgcG9pbnRzLFxuICAgICAgcmVjdFxuICAgIH0gPSB0aGlzLnNlcmlhbGl6ZURyYXcoZmFsc2UpO1xuICAgIGFubm90YXRpb24udXBkYXRlRWRpdGVkKHtcbiAgICAgIHJlY3QsXG4gICAgICB0aGlja25lc3M6IHRoaXMuX2RyYXdpbmdPcHRpb25zW1wic3Ryb2tlLXdpZHRoXCJdLFxuICAgICAgcG9pbnRzXG4gICAgfSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2RyYXdlcnMvY29udG91ci5qc1xuXG5jbGFzcyBDb250b3VyRHJhd091dGxpbmUgZXh0ZW5kcyBJbmtEcmF3T3V0bGluZSB7XG4gIHRvU1ZHUGF0aCgpIHtcbiAgICBsZXQgcGF0aCA9IHN1cGVyLnRvU1ZHUGF0aCgpO1xuICAgIGlmICghcGF0aC5lbmRzV2l0aChcIlpcIikpIHtcbiAgICAgIHBhdGggKz0gXCJaXCI7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9kcmF3ZXJzL3NpZ25hdHVyZWRyYXcuanNcblxuXG5cblxuY29uc3QgQkFTRV9IRUFERVJfTEVOR1RIID0gODtcbmNvbnN0IFBPSU5UU19QUk9QRVJUSUVTX05VTUJFUiA9IDM7XG5jbGFzcyBTaWduYXR1cmVFeHRyYWN0b3Ige1xuICBzdGF0aWMgI1BBUkFNRVRFUlMgPSB7XG4gICAgbWF4RGltOiA1MTIsXG4gICAgc2lnbWFTRmFjdG9yOiAwLjAyLFxuICAgIHNpZ21hUjogMjUsXG4gICAga2VybmVsU2l6ZTogMTZcbiAgfTtcbiAgc3RhdGljICNuZWlnaGJvckluZGV4VG9JZChpMCwgajAsIGksIGopIHtcbiAgICBpIC09IGkwO1xuICAgIGogLT0gajA7XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIHJldHVybiBqID4gMCA/IDAgOiA0O1xuICAgIH1cbiAgICBpZiAoaSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGogKyA2O1xuICAgIH1cbiAgICByZXR1cm4gMiAtIGo7XG4gIH1cbiAgc3RhdGljICNuZWlnaGJvcklkVG9JbmRleCA9IG5ldyBJbnQzMkFycmF5KFswLCAxLCAtMSwgMSwgLTEsIDAsIC0xLCAtMSwgMCwgLTEsIDEsIC0xLCAxLCAwLCAxLCAxXSk7XG4gIHN0YXRpYyAjY2xvY2t3aXNlTm9uWmVybyhidWYsIHdpZHRoLCBpMCwgajAsIGksIGosIG9mZnNldCkge1xuICAgIGNvbnN0IGlkID0gdGhpcy4jbmVpZ2hib3JJbmRleFRvSWQoaTAsIGowLCBpLCBqKTtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IDg7IGsrKykge1xuICAgICAgY29uc3Qga2sgPSAoLWsgKyBpZCAtIG9mZnNldCArIDE2KSAlIDg7XG4gICAgICBjb25zdCBzaGlmdEkgPSB0aGlzLiNuZWlnaGJvcklkVG9JbmRleFsyICoga2tdO1xuICAgICAgY29uc3Qgc2hpZnRKID0gdGhpcy4jbmVpZ2hib3JJZFRvSW5kZXhbMiAqIGtrICsgMV07XG4gICAgICBpZiAoYnVmWyhpMCArIHNoaWZ0SSkgKiB3aWR0aCArIChqMCArIHNoaWZ0SildICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBraztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHN0YXRpYyAjY291bnRlckNsb2Nrd2lzZU5vblplcm8oYnVmLCB3aWR0aCwgaTAsIGowLCBpLCBqLCBvZmZzZXQpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuI25laWdoYm9ySW5kZXhUb0lkKGkwLCBqMCwgaSwgaik7XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGNvbnN0IGtrID0gKGsgKyBpZCArIG9mZnNldCArIDE2KSAlIDg7XG4gICAgICBjb25zdCBzaGlmdEkgPSB0aGlzLiNuZWlnaGJvcklkVG9JbmRleFsyICoga2tdO1xuICAgICAgY29uc3Qgc2hpZnRKID0gdGhpcy4jbmVpZ2hib3JJZFRvSW5kZXhbMiAqIGtrICsgMV07XG4gICAgICBpZiAoYnVmWyhpMCArIHNoaWZ0SSkgKiB3aWR0aCArIChqMCArIHNoaWZ0SildICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBraztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHN0YXRpYyAjZmluZENvbnRvdXJzKGJ1Ziwgd2lkdGgsIGhlaWdodCwgdGhyZXNob2xkKSB7XG4gICAgY29uc3QgTiA9IGJ1Zi5sZW5ndGg7XG4gICAgY29uc3QgdHlwZXMgPSBuZXcgSW50MzJBcnJheShOKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgdHlwZXNbaV0gPSBidWZbaV0gPD0gdGhyZXNob2xkID8gMSA6IDA7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaGVpZ2h0IC0gMTsgaSsrKSB7XG4gICAgICB0eXBlc1tpICogd2lkdGhdID0gdHlwZXNbaSAqIHdpZHRoICsgd2lkdGggLSAxXSA9IDA7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgdHlwZXNbaV0gPSB0eXBlc1t3aWR0aCAqIGhlaWdodCAtIDEgLSBpXSA9IDA7XG4gICAgfVxuICAgIGxldCBuYmQgPSAxO1xuICAgIGxldCBsbmJkO1xuICAgIGNvbnN0IGNvbnRvdXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBoZWlnaHQgLSAxOyBpKyspIHtcbiAgICAgIGxuYmQgPSAxO1xuICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCB3aWR0aCAtIDE7IGorKykge1xuICAgICAgICBjb25zdCBpaiA9IGkgKiB3aWR0aCArIGo7XG4gICAgICAgIGNvbnN0IHBpeCA9IHR5cGVzW2lqXTtcbiAgICAgICAgaWYgKHBpeCA9PT0gMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpMiA9IGk7XG4gICAgICAgIGxldCBqMiA9IGo7XG4gICAgICAgIGlmIChwaXggPT09IDEgJiYgdHlwZXNbaWogLSAxXSA9PT0gMCkge1xuICAgICAgICAgIG5iZCArPSAxO1xuICAgICAgICAgIGoyIC09IDE7XG4gICAgICAgIH0gZWxzZSBpZiAocGl4ID49IDEgJiYgdHlwZXNbaWogKyAxXSA9PT0gMCkge1xuICAgICAgICAgIG5iZCArPSAxO1xuICAgICAgICAgIGoyICs9IDE7XG4gICAgICAgICAgaWYgKHBpeCA+IDEpIHtcbiAgICAgICAgICAgIGxuYmQgPSBwaXg7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwaXggIT09IDEpIHtcbiAgICAgICAgICAgIGxuYmQgPSBNYXRoLmFicyhwaXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb2ludHMgPSBbaiwgaV07XG4gICAgICAgIGNvbnN0IGlzSG9sZSA9IGoyID09PSBqICsgMTtcbiAgICAgICAgY29uc3QgY29udG91ciA9IHtcbiAgICAgICAgICBpc0hvbGUsXG4gICAgICAgICAgcG9pbnRzLFxuICAgICAgICAgIGlkOiBuYmQsXG4gICAgICAgICAgcGFyZW50OiAwXG4gICAgICAgIH07XG4gICAgICAgIGNvbnRvdXJzLnB1c2goY29udG91cik7XG4gICAgICAgIGxldCBjb250b3VyMDtcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIGNvbnRvdXJzKSB7XG4gICAgICAgICAgaWYgKGMuaWQgPT09IGxuYmQpIHtcbiAgICAgICAgICAgIGNvbnRvdXIwID0gYztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnRvdXIwKSB7XG4gICAgICAgICAgY29udG91ci5wYXJlbnQgPSBpc0hvbGUgPyBsbmJkIDogMDtcbiAgICAgICAgfSBlbHNlIGlmIChjb250b3VyMC5pc0hvbGUpIHtcbiAgICAgICAgICBjb250b3VyLnBhcmVudCA9IGlzSG9sZSA/IGNvbnRvdXIwLnBhcmVudCA6IGxuYmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udG91ci5wYXJlbnQgPSBpc0hvbGUgPyBsbmJkIDogY29udG91cjAucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGsgPSB0aGlzLiNjbG9ja3dpc2VOb25aZXJvKHR5cGVzLCB3aWR0aCwgaSwgaiwgaTIsIGoyLCAwKTtcbiAgICAgICAgaWYgKGsgPT09IC0xKSB7XG4gICAgICAgICAgdHlwZXNbaWpdID0gLW5iZDtcbiAgICAgICAgICBpZiAodHlwZXNbaWpdICE9PSAxKSB7XG4gICAgICAgICAgICBsbmJkID0gTWF0aC5hYnModHlwZXNbaWpdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNoaWZ0SSA9IHRoaXMuI25laWdoYm9ySWRUb0luZGV4WzIgKiBrXTtcbiAgICAgICAgbGV0IHNoaWZ0SiA9IHRoaXMuI25laWdoYm9ySWRUb0luZGV4WzIgKiBrICsgMV07XG4gICAgICAgIGNvbnN0IGkxID0gaSArIHNoaWZ0STtcbiAgICAgICAgY29uc3QgajEgPSBqICsgc2hpZnRKO1xuICAgICAgICBpMiA9IGkxO1xuICAgICAgICBqMiA9IGoxO1xuICAgICAgICBsZXQgaTMgPSBpO1xuICAgICAgICBsZXQgajMgPSBqO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IGtrID0gdGhpcy4jY291bnRlckNsb2Nrd2lzZU5vblplcm8odHlwZXMsIHdpZHRoLCBpMywgajMsIGkyLCBqMiwgMSk7XG4gICAgICAgICAgc2hpZnRJID0gdGhpcy4jbmVpZ2hib3JJZFRvSW5kZXhbMiAqIGtrXTtcbiAgICAgICAgICBzaGlmdEogPSB0aGlzLiNuZWlnaGJvcklkVG9JbmRleFsyICoga2sgKyAxXTtcbiAgICAgICAgICBjb25zdCBpNCA9IGkzICsgc2hpZnRJO1xuICAgICAgICAgIGNvbnN0IGo0ID0gajMgKyBzaGlmdEo7XG4gICAgICAgICAgcG9pbnRzLnB1c2goajQsIGk0KTtcbiAgICAgICAgICBjb25zdCBpajMgPSBpMyAqIHdpZHRoICsgajM7XG4gICAgICAgICAgaWYgKHR5cGVzW2lqMyArIDFdID09PSAwKSB7XG4gICAgICAgICAgICB0eXBlc1tpajNdID0gLW5iZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVzW2lqM10gPT09IDEpIHtcbiAgICAgICAgICAgIHR5cGVzW2lqM10gPSBuYmQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpNCA9PT0gaSAmJiBqNCA9PT0gaiAmJiBpMyA9PT0gaTEgJiYgajMgPT09IGoxKSB7XG4gICAgICAgICAgICBpZiAodHlwZXNbaWpdICE9PSAxKSB7XG4gICAgICAgICAgICAgIGxuYmQgPSBNYXRoLmFicyh0eXBlc1tpal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkyID0gaTM7XG4gICAgICAgICAgICBqMiA9IGozO1xuICAgICAgICAgICAgaTMgPSBpNDtcbiAgICAgICAgICAgIGozID0gajQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb250b3VycztcbiAgfVxuICBzdGF0aWMgI2RvdWdsYXNQZXVja2VySGVscGVyKHBvaW50cywgc3RhcnQsIGVuZCwgb3V0cHV0KSB7XG4gICAgaWYgKGVuZCAtIHN0YXJ0IDw9IDQpIHtcbiAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZCAtIDI7IGkgKz0gMikge1xuICAgICAgICBvdXRwdXQucHVzaChwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBheCA9IHBvaW50c1tzdGFydF07XG4gICAgY29uc3QgYXkgPSBwb2ludHNbc3RhcnQgKyAxXTtcbiAgICBjb25zdCBhYnggPSBwb2ludHNbZW5kIC0gNF0gLSBheDtcbiAgICBjb25zdCBhYnkgPSBwb2ludHNbZW5kIC0gM10gLSBheTtcbiAgICBjb25zdCBkaXN0ID0gTWF0aC5oeXBvdChhYngsIGFieSk7XG4gICAgY29uc3QgbmFieCA9IGFieCAvIGRpc3Q7XG4gICAgY29uc3QgbmFieSA9IGFieSAvIGRpc3Q7XG4gICAgY29uc3QgYWEgPSBuYWJ4ICogYXkgLSBuYWJ5ICogYXg7XG4gICAgY29uc3QgbSA9IGFieSAvIGFieDtcbiAgICBjb25zdCBpbnZTID0gMSAvIGRpc3Q7XG4gICAgY29uc3QgcGhpID0gTWF0aC5hdGFuKG0pO1xuICAgIGNvbnN0IGNvc1BoaSA9IE1hdGguY29zKHBoaSk7XG4gICAgY29uc3Qgc2luUGhpID0gTWF0aC5zaW4ocGhpKTtcbiAgICBjb25zdCB0bWF4ID0gaW52UyAqIChNYXRoLmFicyhjb3NQaGkpICsgTWF0aC5hYnMoc2luUGhpKSk7XG4gICAgY29uc3QgcG9seSA9IGludlMgKiAoMSAtIHRtYXggKyB0bWF4ICoqIDIpO1xuICAgIGNvbnN0IHBhcnRpYWxQaGkgPSBNYXRoLm1heChNYXRoLmF0YW4oTWF0aC5hYnMoc2luUGhpICsgY29zUGhpKSAqIHBvbHkpLCBNYXRoLmF0YW4oTWF0aC5hYnMoc2luUGhpIC0gY29zUGhpKSAqIHBvbHkpKTtcbiAgICBsZXQgZG1heCA9IDA7XG4gICAgbGV0IGluZGV4ID0gc3RhcnQ7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0ICsgMjsgaSA8IGVuZCAtIDI7IGkgKz0gMikge1xuICAgICAgY29uc3QgZCA9IE1hdGguYWJzKGFhIC0gbmFieCAqIHBvaW50c1tpICsgMV0gKyBuYWJ5ICogcG9pbnRzW2ldKTtcbiAgICAgIGlmIChkID4gZG1heCkge1xuICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgIGRtYXggPSBkO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZG1heCA+IChkaXN0ICogcGFydGlhbFBoaSkgKiogMikge1xuICAgICAgdGhpcy4jZG91Z2xhc1BldWNrZXJIZWxwZXIocG9pbnRzLCBzdGFydCwgaW5kZXggKyAyLCBvdXRwdXQpO1xuICAgICAgdGhpcy4jZG91Z2xhc1BldWNrZXJIZWxwZXIocG9pbnRzLCBpbmRleCwgZW5kLCBvdXRwdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaChheCwgYXkpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgI2RvdWdsYXNQZXVja2VyKHBvaW50cykge1xuICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgIGNvbnN0IGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgdGhpcy4jZG91Z2xhc1BldWNrZXJIZWxwZXIocG9pbnRzLCAwLCBsZW4sIG91dHB1dCk7XG4gICAgb3V0cHV0LnB1c2gocG9pbnRzW2xlbiAtIDJdLCBwb2ludHNbbGVuIC0gMV0pO1xuICAgIHJldHVybiBvdXRwdXQubGVuZ3RoIDw9IDQgPyBudWxsIDogb3V0cHV0O1xuICB9XG4gIHN0YXRpYyAjYmlsYXRlcmFsRmlsdGVyKGJ1Ziwgd2lkdGgsIGhlaWdodCwgc2lnbWFTLCBzaWdtYVIsIGtlcm5lbFNpemUpIHtcbiAgICBjb25zdCBrZXJuZWwgPSBuZXcgRmxvYXQzMkFycmF5KGtlcm5lbFNpemUgKiogMik7XG4gICAgY29uc3Qgc2lnbWFTMiA9IC0yICogc2lnbWFTICoqIDI7XG4gICAgY29uc3QgaGFsZlNpemUgPSBrZXJuZWxTaXplID4+IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuZWxTaXplOyBpKyspIHtcbiAgICAgIGNvbnN0IHggPSAoaSAtIGhhbGZTaXplKSAqKiAyO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBrZXJuZWxTaXplOyBqKyspIHtcbiAgICAgICAga2VybmVsW2kgKiBrZXJuZWxTaXplICsgal0gPSBNYXRoLmV4cCgoeCArIChqIC0gaGFsZlNpemUpICoqIDIpIC8gc2lnbWFTMik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJhbmdlVmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSgyNTYpO1xuICAgIGNvbnN0IHNpZ21hUjIgPSAtMiAqIHNpZ21hUiAqKiAyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIHJhbmdlVmFsdWVzW2ldID0gTWF0aC5leHAoaSAqKiAyIC8gc2lnbWFSMik7XG4gICAgfVxuICAgIGNvbnN0IE4gPSBidWYubGVuZ3RoO1xuICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KE4pO1xuICAgIGNvbnN0IGhpc3RvZ3JhbSA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgd2lkdGg7IGorKykge1xuICAgICAgICBjb25zdCBpaiA9IGkgKiB3aWR0aCArIGo7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IGJ1Zltpal07XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBsZXQgbm9ybSA9IDA7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwga2VybmVsU2l6ZTsgaysrKSB7XG4gICAgICAgICAgY29uc3QgeSA9IGkgKyBrIC0gaGFsZlNpemU7XG4gICAgICAgICAgaWYgKHkgPCAwIHx8IHkgPj0gaGVpZ2h0KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgbCA9IDA7IGwgPCBrZXJuZWxTaXplOyBsKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBqICsgbCAtIGhhbGZTaXplO1xuICAgICAgICAgICAgaWYgKHggPCAwIHx8IHggPj0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZWlnaGJvdXIgPSBidWZbeSAqIHdpZHRoICsgeF07XG4gICAgICAgICAgICBjb25zdCB3ID0ga2VybmVsW2sgKiBrZXJuZWxTaXplICsgbF0gKiByYW5nZVZhbHVlc1tNYXRoLmFicyhuZWlnaGJvdXIgLSBjZW50ZXIpXTtcbiAgICAgICAgICAgIHN1bSArPSBuZWlnaGJvdXIgKiB3O1xuICAgICAgICAgICAgbm9ybSArPSB3O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwaXggPSBvdXRbaWpdID0gTWF0aC5yb3VuZChzdW0gLyBub3JtKTtcbiAgICAgICAgaGlzdG9ncmFtW3BpeF0rKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtvdXQsIGhpc3RvZ3JhbV07XG4gIH1cbiAgc3RhdGljICNnZXRIaXN0b2dyYW0oYnVmKSB7XG4gICAgY29uc3QgaGlzdG9ncmFtID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgZm9yIChjb25zdCBnIG9mIGJ1Zikge1xuICAgICAgaGlzdG9ncmFtW2ddKys7XG4gICAgfVxuICAgIHJldHVybiBoaXN0b2dyYW07XG4gIH1cbiAgc3RhdGljICN0b1VpbnQ4KGJ1Zikge1xuICAgIGNvbnN0IE4gPSBidWYubGVuZ3RoO1xuICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OENsYW1wZWRBcnJheShOID4+IDIpO1xuICAgIGxldCBtYXggPSAtSW5maW5pdHk7XG4gICAgbGV0IG1pbiA9IEluZmluaXR5O1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IG91dC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBjb25zdCBBID0gYnVmWyhpIDw8IDIpICsgM107XG4gICAgICBpZiAoQSA9PT0gMCkge1xuICAgICAgICBtYXggPSBvdXRbaV0gPSAweGZmO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBpeCA9IG91dFtpXSA9IGJ1ZltpIDw8IDJdO1xuICAgICAgaWYgKHBpeCA+IG1heCkge1xuICAgICAgICBtYXggPSBwaXg7XG4gICAgICB9XG4gICAgICBpZiAocGl4IDwgbWluKSB7XG4gICAgICAgIG1pbiA9IHBpeDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmF0aW8gPSAyNTUgLyAobWF4IC0gbWluKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgb3V0W2ldID0gKG91dFtpXSAtIG1pbikgKiByYXRpbztcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICBzdGF0aWMgI2d1ZXNzVGhyZXNob2xkKGhpc3RvZ3JhbSkge1xuICAgIGxldCBpO1xuICAgIGxldCBNID0gLUluZmluaXR5O1xuICAgIGxldCBMID0gLUluZmluaXR5O1xuICAgIGNvbnN0IG1pbiA9IGhpc3RvZ3JhbS5maW5kSW5kZXgodiA9PiB2ICE9PSAwKTtcbiAgICBsZXQgcG9zID0gbWluO1xuICAgIGxldCBzcG9zID0gbWluO1xuICAgIGZvciAoaSA9IG1pbjsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBjb25zdCB2ID0gaGlzdG9ncmFtW2ldO1xuICAgICAgaWYgKHYgPiBNKSB7XG4gICAgICAgIGlmIChpIC0gcG9zID4gTCkge1xuICAgICAgICAgIEwgPSBpIC0gcG9zO1xuICAgICAgICAgIHNwb3MgPSBpIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBNID0gdjtcbiAgICAgICAgcG9zID0gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gc3BvcyAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoaGlzdG9ncmFtW2ldID4gaGlzdG9ncmFtW2kgKyAxXSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgc3RhdGljICNnZXRHcmF5UGl4ZWxzKGJpdG1hcCkge1xuICAgIGNvbnN0IG9yaWdpbmFsQml0bWFwID0gYml0bWFwO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGJpdG1hcDtcbiAgICBjb25zdCB7XG4gICAgICBtYXhEaW1cbiAgICB9ID0gdGhpcy4jUEFSQU1FVEVSUztcbiAgICBsZXQgbmV3V2lkdGggPSB3aWR0aDtcbiAgICBsZXQgbmV3SGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGlmICh3aWR0aCA+IG1heERpbSB8fCBoZWlnaHQgPiBtYXhEaW0pIHtcbiAgICAgIGxldCBwcmV2V2lkdGggPSB3aWR0aDtcbiAgICAgIGxldCBwcmV2SGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgbGV0IHN0ZXBzID0gTWF0aC5sb2cyKE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpIC8gbWF4RGltKTtcbiAgICAgIGNvbnN0IGlzdGVwcyA9IE1hdGguZmxvb3Ioc3RlcHMpO1xuICAgICAgc3RlcHMgPSBzdGVwcyA9PT0gaXN0ZXBzID8gaXN0ZXBzIC0gMSA6IGlzdGVwcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RlcHM7IGkrKykge1xuICAgICAgICBuZXdXaWR0aCA9IHByZXZXaWR0aDtcbiAgICAgICAgbmV3SGVpZ2h0ID0gcHJldkhlaWdodDtcbiAgICAgICAgaWYgKG5ld1dpZHRoID4gbWF4RGltKSB7XG4gICAgICAgICAgbmV3V2lkdGggPSBNYXRoLmNlaWwobmV3V2lkdGggLyAyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3SGVpZ2h0ID4gbWF4RGltKSB7XG4gICAgICAgICAgbmV3SGVpZ2h0ID0gTWF0aC5jZWlsKG5ld0hlaWdodCAvIDIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMobmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICAgIGNvbnN0IGN0eCA9IG9mZnNjcmVlbi5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCBwcmV2V2lkdGgsIHByZXZIZWlnaHQsIDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgICBwcmV2V2lkdGggPSBuZXdXaWR0aDtcbiAgICAgICAgcHJldkhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgICAgaWYgKGJpdG1hcCAhPT0gb3JpZ2luYWxCaXRtYXApIHtcbiAgICAgICAgICBiaXRtYXAuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBiaXRtYXAgPSBvZmZzY3JlZW4udHJhbnNmZXJUb0ltYWdlQml0bWFwKCk7XG4gICAgICB9XG4gICAgICBjb25zdCByYXRpbyA9IE1hdGgubWluKG1heERpbSAvIG5ld1dpZHRoLCBtYXhEaW0gLyBuZXdIZWlnaHQpO1xuICAgICAgbmV3V2lkdGggPSBNYXRoLnJvdW5kKG5ld1dpZHRoICogcmF0aW8pO1xuICAgICAgbmV3SGVpZ2h0ID0gTWF0aC5yb3VuZChuZXdIZWlnaHQgKiByYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMobmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgY29uc3QgY3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWVcbiAgICB9KTtcbiAgICBjdHguZmlsdGVyID0gXCJncmF5c2NhbGUoMSlcIjtcbiAgICBjdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCwgYml0bWFwLndpZHRoLCBiaXRtYXAuaGVpZ2h0LCAwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICBjb25zdCBncmF5SW1hZ2UgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpLmRhdGE7XG4gICAgY29uc3QgdWludDhCdWYgPSB0aGlzLiN0b1VpbnQ4KGdyYXlJbWFnZSk7XG4gICAgcmV0dXJuIFt1aW50OEJ1ZiwgbmV3V2lkdGgsIG5ld0hlaWdodF07XG4gIH1cbiAgc3RhdGljIGV4dHJhY3RDb250b3Vyc0Zyb21UZXh0KHRleHQsIHtcbiAgICBmb250RmFtaWx5LFxuICAgIGZvbnRTdHlsZSxcbiAgICBmb250V2VpZ2h0XG4gIH0sIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgcm90YXRpb24sIGlubmVyTWFyZ2luKSB7XG4gICAgbGV0IGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSk7XG4gICAgbGV0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgYWxwaGE6IGZhbHNlXG4gICAgfSk7XG4gICAgY29uc3QgZm9udFNpemUgPSAyMDA7XG4gICAgY29uc3QgZm9udCA9IGN0eC5mb250ID0gYCR7Zm9udFN0eWxlfSAke2ZvbnRXZWlnaHR9ICR7Zm9udFNpemV9cHggJHtmb250RmFtaWx5fWA7XG4gICAgY29uc3Qge1xuICAgICAgYWN0dWFsQm91bmRpbmdCb3hMZWZ0LFxuICAgICAgYWN0dWFsQm91bmRpbmdCb3hSaWdodCxcbiAgICAgIGFjdHVhbEJvdW5kaW5nQm94QXNjZW50LFxuICAgICAgYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50LFxuICAgICAgZm9udEJvdW5kaW5nQm94QXNjZW50LFxuICAgICAgZm9udEJvdW5kaW5nQm94RGVzY2VudCxcbiAgICAgIHdpZHRoXG4gICAgfSA9IGN0eC5tZWFzdXJlVGV4dCh0ZXh0KTtcbiAgICBjb25zdCBTQ0FMRSA9IDEuNTtcbiAgICBjb25zdCBjYW52YXNXaWR0aCA9IE1hdGguY2VpbChNYXRoLm1heChNYXRoLmFicyhhY3R1YWxCb3VuZGluZ0JveExlZnQpICsgTWF0aC5hYnMoYWN0dWFsQm91bmRpbmdCb3hSaWdodCkgfHwgMCwgd2lkdGgpICogU0NBTEUpO1xuICAgIGNvbnN0IGNhbnZhc0hlaWdodCA9IE1hdGguY2VpbChNYXRoLm1heChNYXRoLmFicyhhY3R1YWxCb3VuZGluZ0JveEFzY2VudCkgKyBNYXRoLmFicyhhY3R1YWxCb3VuZGluZ0JveERlc2NlbnQpIHx8IGZvbnRTaXplLCBNYXRoLmFicyhmb250Qm91bmRpbmdCb3hBc2NlbnQpICsgTWF0aC5hYnMoZm9udEJvdW5kaW5nQm94RGVzY2VudCkgfHwgZm9udFNpemUpICogU0NBTEUpO1xuICAgIGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICBhbHBoYTogdHJ1ZSxcbiAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICAgIH0pO1xuICAgIGN0eC5mb250ID0gZm9udDtcbiAgICBjdHguZmlsdGVyID0gXCJncmF5c2NhbGUoMSlcIjtcbiAgICBjdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgICBjdHguZmlsbFN0eWxlID0gXCJibGFja1wiO1xuICAgIGN0eC5maWxsVGV4dCh0ZXh0LCBjYW52YXNXaWR0aCAqIChTQ0FMRSAtIDEpIC8gMiwgY2FudmFzSGVpZ2h0ICogKDMgLSBTQ0FMRSkgLyAyKTtcbiAgICBjb25zdCB1aW50OEJ1ZiA9IHRoaXMuI3RvVWludDgoY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KS5kYXRhKTtcbiAgICBjb25zdCBoaXN0b2dyYW0gPSB0aGlzLiNnZXRIaXN0b2dyYW0odWludDhCdWYpO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IHRoaXMuI2d1ZXNzVGhyZXNob2xkKGhpc3RvZ3JhbSk7XG4gICAgY29uc3QgY29udG91ckxpc3QgPSB0aGlzLiNmaW5kQ29udG91cnModWludDhCdWYsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQsIHRocmVzaG9sZCk7XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc0RyYXduTGluZXMoe1xuICAgICAgbGluZXM6IHtcbiAgICAgICAgY3VydmVzOiBjb250b3VyTGlzdCxcbiAgICAgICAgd2lkdGg6IGNhbnZhc1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNhbnZhc0hlaWdodFxuICAgICAgfSxcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICByb3RhdGlvbixcbiAgICAgIGlubmVyTWFyZ2luLFxuICAgICAgbXVzdFNtb290aDogdHJ1ZSxcbiAgICAgIGFyZUNvbnRvdXJzOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIHByb2Nlc3MoYml0bWFwLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIHJvdGF0aW9uLCBpbm5lck1hcmdpbikge1xuICAgIGNvbnN0IFt1aW50OEJ1Ziwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNnZXRHcmF5UGl4ZWxzKGJpdG1hcCk7XG4gICAgY29uc3QgW2J1ZmZlciwgaGlzdG9ncmFtXSA9IHRoaXMuI2JpbGF0ZXJhbEZpbHRlcih1aW50OEJ1Ziwgd2lkdGgsIGhlaWdodCwgTWF0aC5oeXBvdCh3aWR0aCwgaGVpZ2h0KSAqIHRoaXMuI1BBUkFNRVRFUlMuc2lnbWFTRmFjdG9yLCB0aGlzLiNQQVJBTUVURVJTLnNpZ21hUiwgdGhpcy4jUEFSQU1FVEVSUy5rZXJuZWxTaXplKTtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSB0aGlzLiNndWVzc1RocmVzaG9sZChoaXN0b2dyYW0pO1xuICAgIGNvbnN0IGNvbnRvdXJMaXN0ID0gdGhpcy4jZmluZENvbnRvdXJzKGJ1ZmZlciwgd2lkdGgsIGhlaWdodCwgdGhyZXNob2xkKTtcbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzRHJhd25MaW5lcyh7XG4gICAgICBsaW5lczoge1xuICAgICAgICBjdXJ2ZXM6IGNvbnRvdXJMaXN0LFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9LFxuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgaW5uZXJNYXJnaW4sXG4gICAgICBtdXN0U21vb3RoOiB0cnVlLFxuICAgICAgYXJlQ29udG91cnM6IHRydWVcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgcHJvY2Vzc0RyYXduTGluZXMoe1xuICAgIGxpbmVzLFxuICAgIHBhZ2VXaWR0aCxcbiAgICBwYWdlSGVpZ2h0LFxuICAgIHJvdGF0aW9uLFxuICAgIGlubmVyTWFyZ2luLFxuICAgIG11c3RTbW9vdGgsXG4gICAgYXJlQ29udG91cnNcbiAgfSkge1xuICAgIGlmIChyb3RhdGlvbiAlIDE4MCAhPT0gMCkge1xuICAgICAgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSBbcGFnZUhlaWdodCwgcGFnZVdpZHRoXTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY3VydmVzLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gbGluZXM7XG4gICAgY29uc3QgdGhpY2tuZXNzID0gbGluZXMudGhpY2tuZXNzID8/IDA7XG4gICAgY29uc3QgbGluZXNBbmRQb2ludHMgPSBbXTtcbiAgICBjb25zdCByYXRpbyA9IE1hdGgubWluKHBhZ2VXaWR0aCAvIHdpZHRoLCBwYWdlSGVpZ2h0IC8gaGVpZ2h0KTtcbiAgICBjb25zdCB4U2NhbGUgPSByYXRpbyAvIHBhZ2VXaWR0aDtcbiAgICBjb25zdCB5U2NhbGUgPSByYXRpbyAvIHBhZ2VIZWlnaHQ7XG4gICAgY29uc3QgbmV3Q3VydmVzID0gW107XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBwb2ludHNcbiAgICB9IG9mIGN1cnZlcykge1xuICAgICAgY29uc3QgcmVkdWNlZFBvaW50cyA9IG11c3RTbW9vdGggPyB0aGlzLiNkb3VnbGFzUGV1Y2tlcihwb2ludHMpIDogcG9pbnRzO1xuICAgICAgaWYgKCFyZWR1Y2VkUG9pbnRzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbmV3Q3VydmVzLnB1c2gocmVkdWNlZFBvaW50cyk7XG4gICAgICBjb25zdCBsZW4gPSByZWR1Y2VkUG9pbnRzLmxlbmd0aDtcbiAgICAgIGNvbnN0IG5ld1BvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkobGVuKTtcbiAgICAgIGNvbnN0IGxpbmUgPSBuZXcgRmxvYXQzMkFycmF5KDMgKiAobGVuID09PSAyID8gMiA6IGxlbiAtIDIpKTtcbiAgICAgIGxpbmVzQW5kUG9pbnRzLnB1c2goe1xuICAgICAgICBsaW5lLFxuICAgICAgICBwb2ludHM6IG5ld1BvaW50c1xuICAgICAgfSk7XG4gICAgICBpZiAobGVuID09PSAyKSB7XG4gICAgICAgIG5ld1BvaW50c1swXSA9IHJlZHVjZWRQb2ludHNbMF0gKiB4U2NhbGU7XG4gICAgICAgIG5ld1BvaW50c1sxXSA9IHJlZHVjZWRQb2ludHNbMV0gKiB5U2NhbGU7XG4gICAgICAgIGxpbmUuc2V0KFtOYU4sIE5hTiwgTmFOLCBOYU4sIG5ld1BvaW50c1swXSwgbmV3UG9pbnRzWzFdXSwgMCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IFt4MSwgeTEsIHgyLCB5Ml0gPSByZWR1Y2VkUG9pbnRzO1xuICAgICAgeDEgKj0geFNjYWxlO1xuICAgICAgeTEgKj0geVNjYWxlO1xuICAgICAgeDIgKj0geFNjYWxlO1xuICAgICAgeTIgKj0geVNjYWxlO1xuICAgICAgbmV3UG9pbnRzLnNldChbeDEsIHkxLCB4MiwgeTJdLCAwKTtcbiAgICAgIGxpbmUuc2V0KFtOYU4sIE5hTiwgTmFOLCBOYU4sIHgxLCB5MV0sIDApO1xuICAgICAgZm9yIChsZXQgaSA9IDQ7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICBjb25zdCB4ID0gbmV3UG9pbnRzW2ldID0gcmVkdWNlZFBvaW50c1tpXSAqIHhTY2FsZTtcbiAgICAgICAgY29uc3QgeSA9IG5ld1BvaW50c1tpICsgMV0gPSByZWR1Y2VkUG9pbnRzW2kgKyAxXSAqIHlTY2FsZTtcbiAgICAgICAgbGluZS5zZXQoT3V0bGluZS5jcmVhdGVCZXppZXJQb2ludHMoeDEsIHkxLCB4MiwgeTIsIHgsIHkpLCAoaSAtIDIpICogMyk7XG4gICAgICAgIFt4MSwgeTEsIHgyLCB5Ml0gPSBbeDIsIHkyLCB4LCB5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxpbmVzQW5kUG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG91dGxpbmUgPSBhcmVDb250b3VycyA/IG5ldyBDb250b3VyRHJhd091dGxpbmUoKSA6IG5ldyBJbmtEcmF3T3V0bGluZSgpO1xuICAgIG91dGxpbmUuYnVpbGQobGluZXNBbmRQb2ludHMsIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgMSwgcm90YXRpb24sIGFyZUNvbnRvdXJzID8gMCA6IHRoaWNrbmVzcywgaW5uZXJNYXJnaW4pO1xuICAgIHJldHVybiB7XG4gICAgICBvdXRsaW5lLFxuICAgICAgbmV3Q3VydmVzLFxuICAgICAgYXJlQ29udG91cnMsXG4gICAgICB0aGlja25lc3MsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH07XG4gIH1cbiAgc3RhdGljIGFzeW5jIGNvbXByZXNzU2lnbmF0dXJlKHtcbiAgICBvdXRsaW5lcyxcbiAgICBhcmVDb250b3VycyxcbiAgICB0aGlja25lc3MsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0pIHtcbiAgICBsZXQgbWluRGlmZiA9IEluZmluaXR5O1xuICAgIGxldCBtYXhEaWZmID0gLUluZmluaXR5O1xuICAgIGxldCBvdXRsaW5lc0xlbmd0aCA9IDA7XG4gICAgZm9yIChjb25zdCBwb2ludHMgb2Ygb3V0bGluZXMpIHtcbiAgICAgIG91dGxpbmVzTGVuZ3RoICs9IHBvaW50cy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMiwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBjb25zdCBkeCA9IHBvaW50c1tpXSAtIHBvaW50c1tpIC0gMl07XG4gICAgICAgIG1pbkRpZmYgPSBNYXRoLm1pbihtaW5EaWZmLCBkeCk7XG4gICAgICAgIG1heERpZmYgPSBNYXRoLm1heChtYXhEaWZmLCBkeCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBidWZmZXJUeXBlO1xuICAgIGlmIChtaW5EaWZmID49IC0xMjggJiYgbWF4RGlmZiA8PSAxMjcpIHtcbiAgICAgIGJ1ZmZlclR5cGUgPSBJbnQ4QXJyYXk7XG4gICAgfSBlbHNlIGlmIChtaW5EaWZmID49IC0zMjc2OCAmJiBtYXhEaWZmIDw9IDMyNzY3KSB7XG4gICAgICBidWZmZXJUeXBlID0gSW50MTZBcnJheTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyVHlwZSA9IEludDMyQXJyYXk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IG91dGxpbmVzLmxlbmd0aDtcbiAgICBjb25zdCBoZWFkZXJMZW5ndGggPSBCQVNFX0hFQURFUl9MRU5HVEggKyBQT0lOVFNfUFJPUEVSVElFU19OVU1CRVIgKiBsZW47XG4gICAgY29uc3QgaGVhZGVyID0gbmV3IFVpbnQzMkFycmF5KGhlYWRlckxlbmd0aCk7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgaGVhZGVyW29mZnNldCsrXSA9IGhlYWRlckxlbmd0aCAqIFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICsgKG91dGxpbmVzTGVuZ3RoIC0gMiAqIGxlbikgKiBidWZmZXJUeXBlLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgIGhlYWRlcltvZmZzZXQrK10gPSAwO1xuICAgIGhlYWRlcltvZmZzZXQrK10gPSB3aWR0aDtcbiAgICBoZWFkZXJbb2Zmc2V0KytdID0gaGVpZ2h0O1xuICAgIGhlYWRlcltvZmZzZXQrK10gPSBhcmVDb250b3VycyA/IDAgOiAxO1xuICAgIGhlYWRlcltvZmZzZXQrK10gPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHRoaWNrbmVzcyA/PyAwKSk7XG4gICAgaGVhZGVyW29mZnNldCsrXSA9IGxlbjtcbiAgICBoZWFkZXJbb2Zmc2V0KytdID0gYnVmZmVyVHlwZS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICBmb3IgKGNvbnN0IHBvaW50cyBvZiBvdXRsaW5lcykge1xuICAgICAgaGVhZGVyW29mZnNldCsrXSA9IHBvaW50cy5sZW5ndGggLSAyO1xuICAgICAgaGVhZGVyW29mZnNldCsrXSA9IHBvaW50c1swXTtcbiAgICAgIGhlYWRlcltvZmZzZXQrK10gPSBwb2ludHNbMV07XG4gICAgfVxuICAgIGNvbnN0IGNzID0gbmV3IENvbXByZXNzaW9uU3RyZWFtKFwiZGVmbGF0ZS1yYXdcIik7XG4gICAgY29uc3Qgd3JpdGVyID0gY3Mud3JpdGFibGUuZ2V0V3JpdGVyKCk7XG4gICAgYXdhaXQgd3JpdGVyLnJlYWR5O1xuICAgIHdyaXRlci53cml0ZShoZWFkZXIpO1xuICAgIGNvbnN0IEJ1ZmZlckN0b3IgPSBidWZmZXJUeXBlLnByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcbiAgICBmb3IgKGNvbnN0IHBvaW50cyBvZiBvdXRsaW5lcykge1xuICAgICAgY29uc3QgZGlmZnMgPSBuZXcgQnVmZmVyQ3Rvcihwb2ludHMubGVuZ3RoIC0gMik7XG4gICAgICBmb3IgKGxldCBpID0gMiwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBkaWZmc1tpIC0gMl0gPSBwb2ludHNbaV0gLSBwb2ludHNbaSAtIDJdO1xuICAgICAgfVxuICAgICAgd3JpdGVyLndyaXRlKGRpZmZzKTtcbiAgICB9XG4gICAgd3JpdGVyLmNsb3NlKCk7XG4gICAgY29uc3QgYnVmID0gYXdhaXQgbmV3IFJlc3BvbnNlKGNzLnJlYWRhYmxlKS5hcnJheUJ1ZmZlcigpO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbiAgICByZXR1cm4gdG9CYXNlNjRVdGlsKGJ5dGVzKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVjb21wcmVzc1NpZ25hdHVyZShzaWduYXR1cmVEYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gZnJvbUJhc2U2NFV0aWwoc2lnbmF0dXJlRGF0YSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlYWRhYmxlLFxuICAgICAgICB3cml0YWJsZVxuICAgICAgfSA9IG5ldyBEZWNvbXByZXNzaW9uU3RyZWFtKFwiZGVmbGF0ZS1yYXdcIik7XG4gICAgICBjb25zdCB3cml0ZXIgPSB3cml0YWJsZS5nZXRXcml0ZXIoKTtcbiAgICAgIGF3YWl0IHdyaXRlci5yZWFkeTtcbiAgICAgIHdyaXRlci53cml0ZShieXRlcykudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IHdyaXRlci5yZWFkeTtcbiAgICAgICAgYXdhaXQgd3JpdGVyLmNsb3NlKCk7XG4gICAgICB9KS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgICBsZXQgZGF0YSA9IG51bGw7XG4gICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcmVhZGFibGUpIHtcbiAgICAgICAgZGF0YSB8fD0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KGNodW5rLmJ1ZmZlciwgMCwgNClbMF0pO1xuICAgICAgICBkYXRhLnNldChjaHVuaywgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IGNodW5rLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhlYWRlciA9IG5ldyBVaW50MzJBcnJheShkYXRhLmJ1ZmZlciwgMCwgZGF0YS5sZW5ndGggPj4gMik7XG4gICAgICBjb25zdCB2ZXJzaW9uID0gaGVhZGVyWzFdO1xuICAgICAgaWYgKHZlcnNpb24gIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZlcnNpb246ICR7dmVyc2lvbn1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdpZHRoID0gaGVhZGVyWzJdO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gaGVhZGVyWzNdO1xuICAgICAgY29uc3QgYXJlQ29udG91cnMgPSBoZWFkZXJbNF0gPT09IDA7XG4gICAgICBjb25zdCB0aGlja25lc3MgPSBoZWFkZXJbNV07XG4gICAgICBjb25zdCBudW1iZXJPZkRyYXdpbmdzID0gaGVhZGVyWzZdO1xuICAgICAgY29uc3QgYnVmZmVyVHlwZSA9IGhlYWRlcls3XTtcbiAgICAgIGNvbnN0IG91dGxpbmVzID0gW107XG4gICAgICBjb25zdCBkaWZmc09mZnNldCA9IChCQVNFX0hFQURFUl9MRU5HVEggKyBQT0lOVFNfUFJPUEVSVElFU19OVU1CRVIgKiBudW1iZXJPZkRyYXdpbmdzKSAqIFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgICAgbGV0IGRpZmZzO1xuICAgICAgc3dpdGNoIChidWZmZXJUeXBlKSB7XG4gICAgICAgIGNhc2UgSW50OEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UOlxuICAgICAgICAgIGRpZmZzID0gbmV3IEludDhBcnJheShkYXRhLmJ1ZmZlciwgZGlmZnNPZmZzZXQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEludDE2QXJyYXkuQllURVNfUEVSX0VMRU1FTlQ6XG4gICAgICAgICAgZGlmZnMgPSBuZXcgSW50MTZBcnJheShkYXRhLmJ1ZmZlciwgZGlmZnNPZmZzZXQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ6XG4gICAgICAgICAgZGlmZnMgPSBuZXcgSW50MzJBcnJheShkYXRhLmJ1ZmZlciwgZGlmZnNPZmZzZXQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZEcmF3aW5nczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IGhlYWRlcltQT0lOVFNfUFJPUEVSVElFU19OVU1CRVIgKiBpICsgQkFTRV9IRUFERVJfTEVOR1RIXTtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheShsZW4gKyAyKTtcbiAgICAgICAgb3V0bGluZXMucHVzaChwb2ludHMpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IFBPSU5UU19QUk9QRVJUSUVTX05VTUJFUiAtIDE7IGorKykge1xuICAgICAgICAgIHBvaW50c1tqXSA9IGhlYWRlcltQT0lOVFNfUFJPUEVSVElFU19OVU1CRVIgKiBpICsgQkFTRV9IRUFERVJfTEVOR1RIICsgaiArIDFdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICBwb2ludHNbaiArIDJdID0gcG9pbnRzW2pdICsgZGlmZnNbb2Zmc2V0KytdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhcmVDb250b3VycyxcbiAgICAgICAgdGhpY2tuZXNzLFxuICAgICAgICBvdXRsaW5lcyxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3YXJuKGBkZWNvbXByZXNzU2lnbmF0dXJlOiAke2V9YCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL3NpZ25hdHVyZS5qc1xuXG5cblxuXG5cblxuXG5jbGFzcyBTaWduYXR1cmVPcHRpb25zIGV4dGVuZHMgRHJhd2luZ09wdGlvbnMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHN1cGVyLnVwZGF0ZVByb3BlcnRpZXMoe1xuICAgICAgZmlsbDogQW5ub3RhdGlvbkVkaXRvci5fZGVmYXVsdExpbmVDb2xvcixcbiAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IDBcbiAgICB9KTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBTaWduYXR1cmVPcHRpb25zKCk7XG4gICAgY2xvbmUudXBkYXRlQWxsKHRoaXMpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuY2xhc3MgRHJhd25TaWduYXR1cmVPcHRpb25zIGV4dGVuZHMgSW5rRHJhd2luZ09wdGlvbnMge1xuICBjb25zdHJ1Y3Rvcih2aWV3ZXJQYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIodmlld2VyUGFyYW1ldGVycyk7XG4gICAgc3VwZXIudXBkYXRlUHJvcGVydGllcyh7XG4gICAgICBzdHJva2U6IEFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3IsXG4gICAgICBcInN0cm9rZS13aWR0aFwiOiAxXG4gICAgfSk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgRHJhd25TaWduYXR1cmVPcHRpb25zKHRoaXMuX3ZpZXdQYXJhbWV0ZXJzKTtcbiAgICBjbG9uZS51cGRhdGVBbGwodGhpcyk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG5jbGFzcyBTaWduYXR1cmVFZGl0b3IgZXh0ZW5kcyBEcmF3aW5nRWRpdG9yIHtcbiAgI2lzRXh0cmFjdGVkID0gZmFsc2U7XG4gICNkZXNjcmlwdGlvbiA9IG51bGw7XG4gICNzaWduYXR1cmVEYXRhID0gbnVsbDtcbiAgI3NpZ25hdHVyZVVVSUQgPSBudWxsO1xuICBzdGF0aWMgX3R5cGUgPSBcInNpZ25hdHVyZVwiO1xuICBzdGF0aWMgX2VkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TSUdOQVRVUkU7XG4gIHN0YXRpYyBfZGVmYXVsdERyYXdpbmdPcHRpb25zID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgbXVzdEJlQ29tbWl0dGVkOiB0cnVlLFxuICAgICAgbmFtZTogXCJzaWduYXR1cmVFZGl0b3JcIlxuICAgIH0pO1xuICAgIHRoaXMuX3dpbGxLZWVwQXNwZWN0UmF0aW8gPSB0cnVlO1xuICAgIHRoaXMuI3NpZ25hdHVyZURhdGEgPSBwYXJhbXMuc2lnbmF0dXJlRGF0YSB8fCBudWxsO1xuICAgIHRoaXMuI2Rlc2NyaXB0aW9uID0gbnVsbDtcbiAgICB0aGlzLmRlZmF1bHRMMTBuSWQgPSBcInBkZmpzLWVkaXRvci1zaWduYXR1cmUtZWRpdG9yMVwiO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcikge1xuICAgIEFubm90YXRpb25FZGl0b3IuaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpO1xuICAgIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucyA9IG5ldyBTaWduYXR1cmVPcHRpb25zKCk7XG4gICAgdGhpcy5fZGVmYXVsdERyYXduU2lnbmF0dXJlT3B0aW9ucyA9IG5ldyBEcmF3blNpZ25hdHVyZU9wdGlvbnModWlNYW5hZ2VyLnZpZXdQYXJhbWV0ZXJzKTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVmYXVsdERyYXdpbmdPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBjb25zdCBjbG9uZSA9IHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucy5jbG9uZSgpO1xuICAgIGNsb25lLnVwZGF0ZVByb3BlcnRpZXMob3B0aW9ucyk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIHN0YXRpYyBnZXQgc3VwcG9ydE11bHRpcGxlRHJhd2luZ3MoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZXNNYXAoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcInR5cGVzTWFwXCIsIG5ldyBNYXAoKSk7XG4gIH1cbiAgc3RhdGljIGdldCBpc0RyYXdlcigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0IHRlbGVtZXRyeUZpbmFsRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzaWduYXR1cmVcIixcbiAgICAgIGhhc0Rlc2NyaXB0aW9uOiAhIXRoaXMuI2Rlc2NyaXB0aW9uXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgY29tcHV0ZVRlbGVtZXRyeUZpbmFsRGF0YShkYXRhKSB7XG4gICAgY29uc3QgaGFzRGVzY3JpcHRpb25TdGF0cyA9IGRhdGEuZ2V0KFwiaGFzRGVzY3JpcHRpb25cIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhc0FsdFRleHQ6IGhhc0Rlc2NyaXB0aW9uU3RhdHMuZ2V0KHRydWUpID8/IDAsXG4gICAgICBoYXNOb0FsdFRleHQ6IGhhc0Rlc2NyaXB0aW9uU3RhdHMuZ2V0KGZhbHNlKSA/PyAwXG4gICAgfTtcbiAgfVxuICBnZXQgaXNSZXNpemFibGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgb25TY2FsZUNoYW5naW5nKCkge1xuICAgIGlmICh0aGlzLl9kcmF3SWQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIub25TY2FsZUNoYW5naW5nKCk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2O1xuICAgIH1cbiAgICBsZXQgYmFzZVgsIGJhc2VZO1xuICAgIGNvbnN0IHtcbiAgICAgIF9pc0NvcHlcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoX2lzQ29weSkge1xuICAgICAgdGhpcy5faXNDb3B5ID0gZmFsc2U7XG4gICAgICBiYXNlWCA9IHRoaXMueDtcbiAgICAgIGJhc2VZID0gdGhpcy55O1xuICAgIH1cbiAgICBzdXBlci5yZW5kZXIoKTtcbiAgICBpZiAodGhpcy5fZHJhd0lkID09PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy4jc2lnbmF0dXJlRGF0YSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbGluZXMsXG4gICAgICAgICAgbXVzdFNtb290aCxcbiAgICAgICAgICBhcmVDb250b3VycyxcbiAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICB1dWlkLFxuICAgICAgICAgIGhlaWdodEluUGFnZVxuICAgICAgICB9ID0gdGhpcy4jc2lnbmF0dXJlRGF0YTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgICAgIHBhZ2VIZWlnaHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJvdGF0aW9uXG4gICAgICAgIH0gPSB0aGlzLnBhcmVudC52aWV3cG9ydDtcbiAgICAgICAgY29uc3Qgb3V0bGluZSA9IFNpZ25hdHVyZUV4dHJhY3Rvci5wcm9jZXNzRHJhd25MaW5lcyh7XG4gICAgICAgICAgbGluZXMsXG4gICAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgaW5uZXJNYXJnaW46IFNpZ25hdHVyZUVkaXRvci5fSU5ORVJfTUFSR0lOLFxuICAgICAgICAgIG11c3RTbW9vdGgsXG4gICAgICAgICAgYXJlQ29udG91cnNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWRkU2lnbmF0dXJlKG91dGxpbmUsIGhlaWdodEluUGFnZSwgZGVzY3JpcHRpb24sIHV1aWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWFyZ3NcIiwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5kaXYuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdWlNYW5hZ2VyLmdldFNpZ25hdHVyZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKF9pc0NvcHkpIHtcbiAgICAgIHRoaXMuX2lzQ29weSA9IHRydWU7XG4gICAgICB0aGlzLl9tb3ZlQWZ0ZXJQYXN0ZShiYXNlWCwgYmFzZVkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgc2V0VXVpZCh1dWlkKSB7XG4gICAgdGhpcy4jc2lnbmF0dXJlVVVJRCA9IHV1aWQ7XG4gICAgdGhpcy5hZGRFZGl0VG9vbGJhcigpO1xuICB9XG4gIGdldFV1aWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NpZ25hdHVyZVVVSUQ7XG4gIH1cbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiNkZXNjcmlwdGlvbjtcbiAgfVxuICBzZXQgZGVzY3JpcHRpb24oZGVzY3JpcHRpb24pIHtcbiAgICB0aGlzLiNkZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgIHN1cGVyLmFkZEVkaXRUb29sYmFyKCkudGhlbih0b29sYmFyID0+IHtcbiAgICAgIHRvb2xiYXI/LnVwZGF0ZUVkaXRTaWduYXR1cmVCdXR0b24oZGVzY3JpcHRpb24pO1xuICAgIH0pO1xuICB9XG4gIGdldFNpZ25hdHVyZVByZXZpZXcoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmV3Q3VydmVzLFxuICAgICAgYXJlQ29udG91cnMsXG4gICAgICB0aGlja25lc3MsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzLiNzaWduYXR1cmVEYXRhO1xuICAgIGNvbnN0IG1heERpbSA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IG91dGxpbmVEYXRhID0gU2lnbmF0dXJlRXh0cmFjdG9yLnByb2Nlc3NEcmF3bkxpbmVzKHtcbiAgICAgIGxpbmVzOiB7XG4gICAgICAgIGN1cnZlczogbmV3Q3VydmVzLm1hcChwb2ludHMgPT4gKHtcbiAgICAgICAgICBwb2ludHNcbiAgICAgICAgfSkpLFxuICAgICAgICB0aGlja25lc3MsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0sXG4gICAgICBwYWdlV2lkdGg6IG1heERpbSxcbiAgICAgIHBhZ2VIZWlnaHQ6IG1heERpbSxcbiAgICAgIHJvdGF0aW9uOiAwLFxuICAgICAgaW5uZXJNYXJnaW46IDAsXG4gICAgICBtdXN0U21vb3RoOiBmYWxzZSxcbiAgICAgIGFyZUNvbnRvdXJzXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFyZUNvbnRvdXJzLFxuICAgICAgb3V0bGluZTogb3V0bGluZURhdGEub3V0bGluZVxuICAgIH07XG4gIH1cbiAgYXN5bmMgYWRkRWRpdFRvb2xiYXIoKSB7XG4gICAgY29uc3QgdG9vbGJhciA9IGF3YWl0IHN1cGVyLmFkZEVkaXRUb29sYmFyKCk7XG4gICAgaWYgKCF0b29sYmFyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3VpTWFuYWdlci5zaWduYXR1cmVNYW5hZ2VyICYmIHRoaXMuI2Rlc2NyaXB0aW9uICE9PSBudWxsKSB7XG4gICAgICBhd2FpdCB0b29sYmFyLmFkZEVkaXRTaWduYXR1cmVCdXR0b24odGhpcy5fdWlNYW5hZ2VyLnNpZ25hdHVyZU1hbmFnZXIsIHRoaXMuI3NpZ25hdHVyZVVVSUQsIHRoaXMuI2Rlc2NyaXB0aW9uKTtcbiAgICAgIHRvb2xiYXIuc2hvdygpO1xuICAgIH1cbiAgICByZXR1cm4gdG9vbGJhcjtcbiAgfVxuICBhZGRTaWduYXR1cmUoZGF0YSwgaGVpZ2h0SW5QYWdlLCBkZXNjcmlwdGlvbiwgdXVpZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHg6IHNhdmVkWCxcbiAgICAgIHk6IHNhdmVkWVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIG91dGxpbmVcbiAgICB9ID0gdGhpcy4jc2lnbmF0dXJlRGF0YSA9IGRhdGE7XG4gICAgdGhpcy4jaXNFeHRyYWN0ZWQgPSBvdXRsaW5lIGluc3RhbmNlb2YgQ29udG91ckRyYXdPdXRsaW5lO1xuICAgIHRoaXMuI2Rlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWFyZ3NcIiwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgZGVzY3JpcHRpb25cbiAgICB9KSk7XG4gICAgbGV0IGRyYXdpbmdPcHRpb25zO1xuICAgIGlmICh0aGlzLiNpc0V4dHJhY3RlZCkge1xuICAgICAgZHJhd2luZ09wdGlvbnMgPSBTaWduYXR1cmVFZGl0b3IuZ2V0RGVmYXVsdERyYXdpbmdPcHRpb25zKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRyYXdpbmdPcHRpb25zID0gU2lnbmF0dXJlRWRpdG9yLl9kZWZhdWx0RHJhd25TaWduYXR1cmVPcHRpb25zLmNsb25lKCk7XG4gICAgICBkcmF3aW5nT3B0aW9ucy51cGRhdGVQcm9wZXJ0aWVzKHtcbiAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogb3V0bGluZS50aGlja25lc3NcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9hZGRPdXRsaW5lcyh7XG4gICAgICBkcmF3T3V0bGluZXM6IG91dGxpbmUsXG4gICAgICBkcmF3aW5nT3B0aW9uc1xuICAgIH0pO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCBbLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgbGV0IG5ld0hlaWdodCA9IGhlaWdodEluUGFnZSAvIHBhZ2VIZWlnaHQ7XG4gICAgbmV3SGVpZ2h0ID0gbmV3SGVpZ2h0ID49IDEgPyAwLjUgOiBuZXdIZWlnaHQ7XG4gICAgdGhpcy53aWR0aCAqPSBuZXdIZWlnaHQgLyB0aGlzLmhlaWdodDtcbiAgICBpZiAodGhpcy53aWR0aCA+PSAxKSB7XG4gICAgICBuZXdIZWlnaHQgKj0gMC45IC8gdGhpcy53aWR0aDtcbiAgICAgIHRoaXMud2lkdGggPSAwLjk7XG4gICAgfVxuICAgIHRoaXMuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgIHRoaXMuc2V0RGltcyhwYXJlbnRXaWR0aCAqIHRoaXMud2lkdGgsIHBhcmVudEhlaWdodCAqIHRoaXMuaGVpZ2h0KTtcbiAgICB0aGlzLnggPSBzYXZlZFg7XG4gICAgdGhpcy55ID0gc2F2ZWRZO1xuICAgIHRoaXMuY2VudGVyKCk7XG4gICAgdGhpcy5fb25SZXNpemVkKCk7XG4gICAgdGhpcy5vblNjYWxlQ2hhbmdpbmcoKTtcbiAgICB0aGlzLnJvdGF0ZSgpO1xuICAgIHRoaXMuX3VpTWFuYWdlci5hZGRUb0Fubm90YXRpb25TdG9yYWdlKHRoaXMpO1xuICAgIHRoaXMuc2V0VXVpZCh1dWlkKTtcbiAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgYWN0aW9uOiBcInBkZmpzLnNpZ25hdHVyZS5pbnNlcnRlZFwiLFxuICAgICAgZGF0YToge1xuICAgICAgICBoYXNCZWVuU2F2ZWQ6ICEhdXVpZCxcbiAgICAgICAgaGFzRGVzY3JpcHRpb246ICEhZGVzY3JpcHRpb25cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgfVxuICBnZXRGcm9tSW1hZ2UoYml0bWFwKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmF3RGltczoge1xuICAgICAgICBwYWdlV2lkdGgsXG4gICAgICAgIHBhZ2VIZWlnaHRcbiAgICAgIH0sXG4gICAgICByb3RhdGlvblxuICAgIH0gPSB0aGlzLnBhcmVudC52aWV3cG9ydDtcbiAgICByZXR1cm4gU2lnbmF0dXJlRXh0cmFjdG9yLnByb2Nlc3MoYml0bWFwLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIHJvdGF0aW9uLCBTaWduYXR1cmVFZGl0b3IuX0lOTkVSX01BUkdJTik7XG4gIH1cbiAgZ2V0RnJvbVRleHQodGV4dCwgZm9udEluZm8pIHtcbiAgICBjb25zdCB7XG4gICAgICByYXdEaW1zOiB7XG4gICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgcGFnZUhlaWdodFxuICAgICAgfSxcbiAgICAgIHJvdGF0aW9uXG4gICAgfSA9IHRoaXMucGFyZW50LnZpZXdwb3J0O1xuICAgIHJldHVybiBTaWduYXR1cmVFeHRyYWN0b3IuZXh0cmFjdENvbnRvdXJzRnJvbVRleHQodGV4dCwgZm9udEluZm8sIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgcm90YXRpb24sIFNpZ25hdHVyZUVkaXRvci5fSU5ORVJfTUFSR0lOKTtcbiAgfVxuICBnZXREcmF3blNpZ25hdHVyZShjdXJ2ZXMpIHtcbiAgICBjb25zdCB7XG4gICAgICByYXdEaW1zOiB7XG4gICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgcGFnZUhlaWdodFxuICAgICAgfSxcbiAgICAgIHJvdGF0aW9uXG4gICAgfSA9IHRoaXMucGFyZW50LnZpZXdwb3J0O1xuICAgIHJldHVybiBTaWduYXR1cmVFeHRyYWN0b3IucHJvY2Vzc0RyYXduTGluZXMoe1xuICAgICAgbGluZXM6IGN1cnZlcyxcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICByb3RhdGlvbixcbiAgICAgIGlubmVyTWFyZ2luOiBTaWduYXR1cmVFZGl0b3IuX0lOTkVSX01BUkdJTixcbiAgICAgIG11c3RTbW9vdGg6IGZhbHNlLFxuICAgICAgYXJlQ29udG91cnM6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlRHJhd2luZ09wdGlvbnMoe1xuICAgIGFyZUNvbnRvdXJzLFxuICAgIHRoaWNrbmVzc1xuICB9KSB7XG4gICAgaWYgKGFyZUNvbnRvdXJzKSB7XG4gICAgICB0aGlzLl9kcmF3aW5nT3B0aW9ucyA9IFNpZ25hdHVyZUVkaXRvci5nZXREZWZhdWx0RHJhd2luZ09wdGlvbnMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZHJhd2luZ09wdGlvbnMgPSBTaWduYXR1cmVFZGl0b3IuX2RlZmF1bHREcmF3blNpZ25hdHVyZU9wdGlvbnMuY2xvbmUoKTtcbiAgICAgIHRoaXMuX2RyYXdpbmdPcHRpb25zLnVwZGF0ZVByb3BlcnRpZXMoe1xuICAgICAgICBcInN0cm9rZS13aWR0aFwiOiB0aGlja25lc3NcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBsaW5lcyxcbiAgICAgIHBvaW50cyxcbiAgICAgIHJlY3RcbiAgICB9ID0gdGhpcy5zZXJpYWxpemVEcmF3KGlzRm9yQ29weWluZyk7XG4gICAgY29uc3Qge1xuICAgICAgX2RyYXdpbmdPcHRpb25zOiB7XG4gICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IHRoaWNrbmVzc1xuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7XG4gICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuU0lHTkFUVVJFLFxuICAgICAgaXNTaWduYXR1cmU6IHRydWUsXG4gICAgICBhcmVDb250b3VyczogdGhpcy4jaXNFeHRyYWN0ZWQsXG4gICAgICBjb2xvcjogWzAsIDAsIDBdLFxuICAgICAgdGhpY2tuZXNzOiB0aGlzLiNpc0V4dHJhY3RlZCA/IDAgOiB0aGlja25lc3MsXG4gICAgICBwYWdlSW5kZXg6IHRoaXMucGFnZUluZGV4LFxuICAgICAgcmVjdCxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxuICAgICAgc3RydWN0VHJlZVBhcmVudElkOiB0aGlzLl9zdHJ1Y3RUcmVlUGFyZW50SWRcbiAgICB9O1xuICAgIGlmIChpc0ZvckNvcHlpbmcpIHtcbiAgICAgIHNlcmlhbGl6ZWQucGF0aHMgPSB7XG4gICAgICAgIGxpbmVzLFxuICAgICAgICBwb2ludHNcbiAgICAgIH07XG4gICAgICBzZXJpYWxpemVkLnV1aWQgPSB0aGlzLiNzaWduYXR1cmVVVUlEO1xuICAgICAgc2VyaWFsaXplZC5pc0NvcHkgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXJpYWxpemVkLmxpbmVzID0gbGluZXM7XG4gICAgfVxuICAgIGlmICh0aGlzLiNkZXNjcmlwdGlvbikge1xuICAgICAgc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YSA9IHtcbiAgICAgICAgdHlwZTogXCJGaWd1cmVcIixcbiAgICAgICAgYWx0OiB0aGlzLiNkZXNjcmlwdGlvblxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplRHJhdyhwYWdlWCwgcGFnZVksIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgaW5uZXJNYXJnaW4sIGRhdGEpIHtcbiAgICBpZiAoZGF0YS5hcmVDb250b3Vycykge1xuICAgICAgcmV0dXJuIENvbnRvdXJEcmF3T3V0bGluZS5kZXNlcmlhbGl6ZShwYWdlWCwgcGFnZVksIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgaW5uZXJNYXJnaW4sIGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gSW5rRHJhd091dGxpbmUuZGVzZXJpYWxpemUocGFnZVgsIHBhZ2VZLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIGlubmVyTWFyZ2luLCBkYXRhKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgZWRpdG9yLiNpc0V4dHJhY3RlZCA9IGRhdGEuYXJlQ29udG91cnM7XG4gICAgZWRpdG9yLiNkZXNjcmlwdGlvbiA9IGRhdGEuYWNjZXNzaWJpbGl0eURhdGE/LmFsdCB8fCBcIlwiO1xuICAgIGVkaXRvci4jc2lnbmF0dXJlVVVJRCA9IGRhdGEudXVpZDtcbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9zdGFtcC5qc1xuXG5cblxuXG5jbGFzcyBTdGFtcEVkaXRvciBleHRlbmRzIEFubm90YXRpb25FZGl0b3Ige1xuICAjYml0bWFwID0gbnVsbDtcbiAgI2JpdG1hcElkID0gbnVsbDtcbiAgI2JpdG1hcFByb21pc2UgPSBudWxsO1xuICAjYml0bWFwVXJsID0gbnVsbDtcbiAgI2JpdG1hcEZpbGUgPSBudWxsO1xuICAjYml0bWFwRmlsZU5hbWUgPSBcIlwiO1xuICAjY2FudmFzID0gbnVsbDtcbiAgI21pc3NpbmdDYW52YXMgPSBmYWxzZTtcbiAgI3Jlc2l6ZVRpbWVvdXRJZCA9IG51bGw7XG4gICNpc1N2ZyA9IGZhbHNlO1xuICAjaGFzQmVlbkFkZGVkSW5VbmRvU3RhY2sgPSBmYWxzZTtcbiAgc3RhdGljIF90eXBlID0gXCJzdGFtcFwiO1xuICBzdGF0aWMgX2VkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUDtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgbmFtZTogXCJzdGFtcEVkaXRvclwiXG4gICAgfSk7XG4gICAgdGhpcy4jYml0bWFwVXJsID0gcGFyYW1zLmJpdG1hcFVybDtcbiAgICB0aGlzLiNiaXRtYXBGaWxlID0gcGFyYW1zLmJpdG1hcEZpbGU7XG4gICAgdGhpcy5kZWZhdWx0TDEwbklkID0gXCJwZGZqcy1lZGl0b3Itc3RhbXAtZWRpdG9yXCI7XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKSB7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5pbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcik7XG4gIH1cbiAgc3RhdGljIGlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyhtaW1lKSB7XG4gICAgcmV0dXJuIFN1cHBvcnRlZEltYWdlTWltZVR5cGVzLmluY2x1ZGVzKG1pbWUpO1xuICB9XG4gIHN0YXRpYyBwYXN0ZShpdGVtLCBwYXJlbnQpIHtcbiAgICBwYXJlbnQucGFzdGVFZGl0b3IoQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVAsIHtcbiAgICAgIGJpdG1hcEZpbGU6IGl0ZW0uZ2V0QXNGaWxlKClcbiAgICB9KTtcbiAgfVxuICBhbHRUZXh0RmluaXNoKCkge1xuICAgIGlmICh0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dEZsb3cpIHtcbiAgICAgIHRoaXMuZGl2LmhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgICBzdXBlci5hbHRUZXh0RmluaXNoKCk7XG4gIH1cbiAgZ2V0IHRlbGVtZXRyeUZpbmFsRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzdGFtcFwiLFxuICAgICAgaGFzQWx0VGV4dDogISF0aGlzLmFsdFRleHREYXRhPy5hbHRUZXh0XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgY29tcHV0ZVRlbGVtZXRyeUZpbmFsRGF0YShkYXRhKSB7XG4gICAgY29uc3QgaGFzQWx0VGV4dFN0YXRzID0gZGF0YS5nZXQoXCJoYXNBbHRUZXh0XCIpO1xuICAgIHJldHVybiB7XG4gICAgICBoYXNBbHRUZXh0OiBoYXNBbHRUZXh0U3RhdHMuZ2V0KHRydWUpID8/IDAsXG4gICAgICBoYXNOb0FsdFRleHQ6IGhhc0FsdFRleHRTdGF0cy5nZXQoZmFsc2UpID8/IDBcbiAgICB9O1xuICB9XG4gICNnZXRCaXRtYXBGZXRjaGVkKGRhdGEsIGZyb21JZCA9IGZhbHNlKSB7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNiaXRtYXAgPSBkYXRhLmJpdG1hcDtcbiAgICBpZiAoIWZyb21JZCkge1xuICAgICAgdGhpcy4jYml0bWFwSWQgPSBkYXRhLmlkO1xuICAgICAgdGhpcy4jaXNTdmcgPSBkYXRhLmlzU3ZnO1xuICAgIH1cbiAgICBpZiAoZGF0YS5maWxlKSB7XG4gICAgICB0aGlzLiNiaXRtYXBGaWxlTmFtZSA9IGRhdGEuZmlsZS5uYW1lO1xuICAgIH1cbiAgICB0aGlzLiNjcmVhdGVDYW52YXMoKTtcbiAgfVxuICAjZ2V0Qml0bWFwRG9uZSgpIHtcbiAgICB0aGlzLiNiaXRtYXBQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyhmYWxzZSk7XG4gICAgaWYgKCF0aGlzLiNjYW52YXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3VpTWFuYWdlci51c2VOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlICYmIHRoaXMuX3VpTWFuYWdlci51c2VOZXdBbHRUZXh0RmxvdyAmJiB0aGlzLiNiaXRtYXApIHtcbiAgICAgIHRoaXMuX2VkaXRUb29sYmFyLmhpZGUoKTtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5lZGl0QWx0VGV4dCh0aGlzLCB0cnVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSAmJiB0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dEZsb3cgJiYgdGhpcy4jYml0bWFwKSB7XG4gICAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgICBhY3Rpb246IFwicGRmanMuaW1hZ2UuaW1hZ2VfYWRkZWRcIixcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGFsdF90ZXh0X21vZGFsOiBmYWxzZSxcbiAgICAgICAgICBhbHRfdGV4dF90eXBlOiBcImVtcHR5XCJcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLm1sR3Vlc3NBbHRUZXh0KCk7XG4gICAgICB9IGNhdGNoIHt9XG4gICAgfVxuICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gIH1cbiAgYXN5bmMgbWxHdWVzc0FsdFRleHQoaW1hZ2VEYXRhID0gbnVsbCwgdXBkYXRlQWx0VGV4dERhdGEgPSB0cnVlKSB7XG4gICAgaWYgKHRoaXMuaGFzQWx0VGV4dERhdGEoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIG1sTWFuYWdlclxuICAgIH0gPSB0aGlzLl91aU1hbmFnZXI7XG4gICAgaWYgKCFtbE1hbmFnZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIE1MLlwiKTtcbiAgICB9XG4gICAgaWYgKCEoYXdhaXQgbWxNYW5hZ2VyLmlzRW5hYmxlZEZvcihcImFsdFRleHRcIikpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNTCBpc24ndCBlbmFibGVkIGZvciBhbHQgdGV4dC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBpbWFnZURhdGEgfHwgdGhpcy5jb3B5Q2FudmFzKG51bGwsIG51bGwsIHRydWUpLmltYWdlRGF0YTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG1sTWFuYWdlci5ndWVzcyh7XG4gICAgICBuYW1lOiBcImFsdFRleHRcIixcbiAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgY2hhbm5lbHM6IGRhdGEubGVuZ3RoIC8gKHdpZHRoICogaGVpZ2h0KVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlc3BvbnNlIGZyb20gdGhlIEFJIHNlcnZpY2UuXCIpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGZyb20gdGhlIEFJIHNlcnZpY2UuXCIpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2UuY2FuY2VsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5vdXRwdXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHZhbGlkIHJlc3BvbnNlIGZyb20gdGhlIEFJIHNlcnZpY2UuXCIpO1xuICAgIH1cbiAgICBjb25zdCBhbHRUZXh0ID0gcmVzcG9uc2Uub3V0cHV0O1xuICAgIGF3YWl0IHRoaXMuc2V0R3Vlc3NlZEFsdFRleHQoYWx0VGV4dCk7XG4gICAgaWYgKHVwZGF0ZUFsdFRleHREYXRhICYmICF0aGlzLmhhc0FsdFRleHREYXRhKCkpIHtcbiAgICAgIHRoaXMuYWx0VGV4dERhdGEgPSB7XG4gICAgICAgIGFsdDogYWx0VGV4dCxcbiAgICAgICAgZGVjb3JhdGl2ZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBhbHRUZXh0O1xuICB9XG4gICNnZXRCaXRtYXAoKSB7XG4gICAgaWYgKHRoaXMuI2JpdG1hcElkKSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyh0cnVlKTtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0RnJvbUlkKHRoaXMuI2JpdG1hcElkKS50aGVuKGRhdGEgPT4gdGhpcy4jZ2V0Qml0bWFwRmV0Y2hlZChkYXRhLCB0cnVlKSkuZmluYWxseSgoKSA9PiB0aGlzLiNnZXRCaXRtYXBEb25lKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYml0bWFwVXJsKSB7XG4gICAgICBjb25zdCB1cmwgPSB0aGlzLiNiaXRtYXBVcmw7XG4gICAgICB0aGlzLiNiaXRtYXBVcmwgPSBudWxsO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcodHJ1ZSk7XG4gICAgICB0aGlzLiNiaXRtYXBQcm9taXNlID0gdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tVXJsKHVybCkudGhlbihkYXRhID0+IHRoaXMuI2dldEJpdG1hcEZldGNoZWQoZGF0YSkpLmZpbmFsbHkoKCkgPT4gdGhpcy4jZ2V0Qml0bWFwRG9uZSgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2JpdG1hcEZpbGUpIHtcbiAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLiNiaXRtYXBGaWxlO1xuICAgICAgdGhpcy4jYml0bWFwRmlsZSA9IG51bGw7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyh0cnVlKTtcbiAgICAgIHRoaXMuI2JpdG1hcFByb21pc2UgPSB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21GaWxlKGZpbGUpLnRoZW4oZGF0YSA9PiB0aGlzLiNnZXRCaXRtYXBGZXRjaGVkKGRhdGEpKS5maW5hbGx5KCgpID0+IHRoaXMuI2dldEJpdG1hcERvbmUoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIGlucHV0LnR5cGUgPSBcImZpbGVcIjtcbiAgICBpbnB1dC5hY2NlcHQgPSBTdXBwb3J0ZWRJbWFnZU1pbWVUeXBlcy5qb2luKFwiLFwiKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl91aU1hbmFnZXIuX3NpZ25hbDtcbiAgICB0aGlzLiNiaXRtYXBQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKCFpbnB1dC5maWxlcyB8fCBpbnB1dC5maWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKHRydWUpO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21GaWxlKGlucHV0LmZpbGVzWzBdKTtcbiAgICAgICAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgICAgICAgYWN0aW9uOiBcInBkZmpzLmltYWdlLmltYWdlX3NlbGVjdGVkXCIsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGFsdF90ZXh0X21vZGFsOiB0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dEZsb3dcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLiNnZXRCaXRtYXBGZXRjaGVkKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0sIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJjYW5jZWxcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgfSkuZmluYWxseSgoKSA9PiB0aGlzLiNnZXRCaXRtYXBEb25lKCkpO1xuICAgIGlucHV0LmNsaWNrKCk7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLiNiaXRtYXBJZCkge1xuICAgICAgdGhpcy4jYml0bWFwID0gbnVsbDtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZGVsZXRlSWQodGhpcy4jYml0bWFwSWQpO1xuICAgICAgdGhpcy4jY2FudmFzPy5yZW1vdmUoKTtcbiAgICAgIHRoaXMuI2NhbnZhcyA9IG51bGw7XG4gICAgICBpZiAodGhpcy4jcmVzaXplVGltZW91dElkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNyZXNpemVUaW1lb3V0SWQpO1xuICAgICAgICB0aGlzLiNyZXNpemVUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIGlmICh0aGlzLiNiaXRtYXBJZCkge1xuICAgICAgICB0aGlzLiNnZXRCaXRtYXAoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucmVidWlsZCgpO1xuICAgIGlmICh0aGlzLmRpdiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYml0bWFwSWQgJiYgdGhpcy4jY2FudmFzID09PSBudWxsKSB7XG4gICAgICB0aGlzLiNnZXRCaXRtYXAoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkKHRoaXMpO1xuICAgIH1cbiAgfVxuICBvbmNlQWRkZWQoZm9jdXMpIHtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IHRydWU7XG4gICAgaWYgKGZvY3VzKSB7XG4gICAgICB0aGlzLmRpdi5mb2N1cygpO1xuICAgIH1cbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiAhKHRoaXMuI2JpdG1hcFByb21pc2UgfHwgdGhpcy4jYml0bWFwIHx8IHRoaXMuI2JpdG1hcFVybCB8fCB0aGlzLiNiaXRtYXBGaWxlIHx8IHRoaXMuI2JpdG1hcElkIHx8IHRoaXMuI21pc3NpbmdDYW52YXMpO1xuICB9XG4gIGdldCBpc1Jlc2l6YWJsZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXY7XG4gICAgfVxuICAgIGxldCBiYXNlWCwgYmFzZVk7XG4gICAgaWYgKHRoaXMuX2lzQ29weSkge1xuICAgICAgYmFzZVggPSB0aGlzLng7XG4gICAgICBiYXNlWSA9IHRoaXMueTtcbiAgICB9XG4gICAgc3VwZXIucmVuZGVyKCk7XG4gICAgdGhpcy5kaXYuaGlkZGVuID0gdHJ1ZTtcbiAgICB0aGlzLmFkZEFsdFRleHRCdXR0b24oKTtcbiAgICBpZiAoIXRoaXMuI21pc3NpbmdDYW52YXMpIHtcbiAgICAgIGlmICh0aGlzLiNiaXRtYXApIHtcbiAgICAgICAgdGhpcy4jY3JlYXRlQ2FudmFzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiNnZXRCaXRtYXAoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX2lzQ29weSkge1xuICAgICAgdGhpcy5fbW92ZUFmdGVyUGFzdGUoYmFzZVgsIGJhc2VZKTtcbiAgICB9XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmFkZFNob3VsZFJlc2NhbGUodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gIHNldENhbnZhcyhhbm5vdGF0aW9uRWxlbWVudElkLCBjYW52YXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZDogYml0bWFwSWQsXG4gICAgICBiaXRtYXBcbiAgICB9ID0gdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tQ2FudmFzKGFubm90YXRpb25FbGVtZW50SWQsIGNhbnZhcyk7XG4gICAgY2FudmFzLnJlbW92ZSgpO1xuICAgIGlmIChiaXRtYXBJZCAmJiB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmlzVmFsaWRJZChiaXRtYXBJZCkpIHtcbiAgICAgIHRoaXMuI2JpdG1hcElkID0gYml0bWFwSWQ7XG4gICAgICBpZiAoYml0bWFwKSB7XG4gICAgICAgIHRoaXMuI2JpdG1hcCA9IGJpdG1hcDtcbiAgICAgIH1cbiAgICAgIHRoaXMuI21pc3NpbmdDYW52YXMgPSBmYWxzZTtcbiAgICAgIHRoaXMuI2NyZWF0ZUNhbnZhcygpO1xuICAgIH1cbiAgfVxuICBfb25SZXNpemVkKCkge1xuICAgIHRoaXMub25TY2FsZUNoYW5naW5nKCk7XG4gIH1cbiAgb25TY2FsZUNoYW5naW5nKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCk7XG4gICAgfVxuICAgIGNvbnN0IFRJTUVfVE9fV0FJVCA9IDIwMDtcbiAgICB0aGlzLiNyZXNpemVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB0aGlzLiNkcmF3Qml0bWFwKCk7XG4gICAgfSwgVElNRV9UT19XQUlUKTtcbiAgfVxuICAjY3JlYXRlQ2FudmFzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpdlxuICAgIH0gPSB0aGlzO1xuICAgIGxldCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzLiNiaXRtYXA7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgIGNvbnN0IE1BWF9SQVRJTyA9IDAuNzU7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIHdpZHRoID0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aDtcbiAgICAgIGhlaWdodCA9IHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodDtcbiAgICB9IGVsc2UgaWYgKHdpZHRoID4gTUFYX1JBVElPICogcGFnZVdpZHRoIHx8IGhlaWdodCA+IE1BWF9SQVRJTyAqIHBhZ2VIZWlnaHQpIHtcbiAgICAgIGNvbnN0IGZhY3RvciA9IE1hdGgubWluKE1BWF9SQVRJTyAqIHBhZ2VXaWR0aCAvIHdpZHRoLCBNQVhfUkFUSU8gKiBwYWdlSGVpZ2h0IC8gaGVpZ2h0KTtcbiAgICAgIHdpZHRoICo9IGZhY3RvcjtcbiAgICAgIGhlaWdodCAqPSBmYWN0b3I7XG4gICAgfVxuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLnNldERpbXMod2lkdGggKiBwYXJlbnRXaWR0aCAvIHBhZ2VXaWR0aCwgaGVpZ2h0ICogcGFyZW50SGVpZ2h0IC8gcGFnZUhlaWdodCk7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcoZmFsc2UpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuI2NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJpbWdcIik7XG4gICAgdGhpcy5hZGRDb250YWluZXIoY2FudmFzKTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGggLyBwYWdlV2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgLyBwYWdlSGVpZ2h0O1xuICAgIGlmICh0aGlzLl9pbml0aWFsT3B0aW9ucz8uaXNDZW50ZXJlZCkge1xuICAgICAgdGhpcy5jZW50ZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgIH1cbiAgICB0aGlzLl9pbml0aWFsT3B0aW9ucyA9IG51bGw7XG4gICAgaWYgKCF0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSB8fCAhdGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRGbG93IHx8IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgZGl2LmhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLiNkcmF3Qml0bWFwKCk7XG4gICAgaWYgKCF0aGlzLiNoYXNCZWVuQWRkZWRJblVuZG9TdGFjaykge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkVW5kb2FibGVFZGl0b3IodGhpcyk7XG4gICAgICB0aGlzLiNoYXNCZWVuQWRkZWRJblVuZG9TdGFjayA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICBhY3Rpb246IFwiaW5zZXJ0ZWRfaW1hZ2VcIlxuICAgIH0pO1xuICAgIGlmICh0aGlzLiNiaXRtYXBGaWxlTmFtZSkge1xuICAgICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1kZXNjcmlwdGlvblwiLCB0aGlzLiNiaXRtYXBGaWxlTmFtZSk7XG4gICAgfVxuICB9XG4gIGNvcHlDYW52YXMobWF4RGF0YURpbWVuc2lvbiwgbWF4UHJldmlld0RpbWVuc2lvbiwgY3JlYXRlSW1hZ2VEYXRhID0gZmFsc2UpIHtcbiAgICBpZiAoIW1heERhdGFEaW1lbnNpb24pIHtcbiAgICAgIG1heERhdGFEaW1lbnNpb24gPSAyMjQ7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoOiBiaXRtYXBXaWR0aCxcbiAgICAgIGhlaWdodDogYml0bWFwSGVpZ2h0XG4gICAgfSA9IHRoaXMuI2JpdG1hcDtcbiAgICBjb25zdCBvdXRwdXRTY2FsZSA9IG5ldyBPdXRwdXRTY2FsZSgpO1xuICAgIGxldCBiaXRtYXAgPSB0aGlzLiNiaXRtYXA7XG4gICAgbGV0IHdpZHRoID0gYml0bWFwV2lkdGgsXG4gICAgICBoZWlnaHQgPSBiaXRtYXBIZWlnaHQ7XG4gICAgbGV0IGNhbnZhcyA9IG51bGw7XG4gICAgaWYgKG1heFByZXZpZXdEaW1lbnNpb24pIHtcbiAgICAgIGlmIChiaXRtYXBXaWR0aCA+IG1heFByZXZpZXdEaW1lbnNpb24gfHwgYml0bWFwSGVpZ2h0ID4gbWF4UHJldmlld0RpbWVuc2lvbikge1xuICAgICAgICBjb25zdCByYXRpbyA9IE1hdGgubWluKG1heFByZXZpZXdEaW1lbnNpb24gLyBiaXRtYXBXaWR0aCwgbWF4UHJldmlld0RpbWVuc2lvbiAvIGJpdG1hcEhlaWdodCk7XG4gICAgICAgIHdpZHRoID0gTWF0aC5mbG9vcihiaXRtYXBXaWR0aCAqIHJhdGlvKTtcbiAgICAgICAgaGVpZ2h0ID0gTWF0aC5mbG9vcihiaXRtYXBIZWlnaHQgKiByYXRpbyk7XG4gICAgICB9XG4gICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgY29uc3Qgc2NhbGVkV2lkdGggPSBjYW52YXMud2lkdGggPSBNYXRoLmNlaWwod2lkdGggKiBvdXRwdXRTY2FsZS5zeCk7XG4gICAgICBjb25zdCBzY2FsZWRIZWlnaHQgPSBjYW52YXMuaGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCAqIG91dHB1dFNjYWxlLnN5KTtcbiAgICAgIGlmICghdGhpcy4jaXNTdmcpIHtcbiAgICAgICAgYml0bWFwID0gdGhpcy4jc2NhbGVCaXRtYXAoc2NhbGVkV2lkdGgsIHNjYWxlZEhlaWdodCk7XG4gICAgICB9XG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY3R4LmZpbHRlciA9IHRoaXMuX3VpTWFuYWdlci5oY21GaWx0ZXI7XG4gICAgICBsZXQgd2hpdGUgPSBcIndoaXRlXCIsXG4gICAgICAgIGJsYWNrID0gXCIjY2ZjZmQ4XCI7XG4gICAgICBpZiAodGhpcy5fdWlNYW5hZ2VyLmhjbUZpbHRlciAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgYmxhY2sgPSBcImJsYWNrXCI7XG4gICAgICB9IGVsc2UgaWYgKHdpbmRvdy5tYXRjaE1lZGlhPy4oXCIocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspXCIpLm1hdGNoZXMpIHtcbiAgICAgICAgd2hpdGUgPSBcIiM4ZjhmOWRcIjtcbiAgICAgICAgYmxhY2sgPSBcIiM0MjQxNGRcIjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJveERpbSA9IDE1O1xuICAgICAgY29uc3QgYm94RGltV2lkdGggPSBib3hEaW0gKiBvdXRwdXRTY2FsZS5zeDtcbiAgICAgIGNvbnN0IGJveERpbUhlaWdodCA9IGJveERpbSAqIG91dHB1dFNjYWxlLnN5O1xuICAgICAgY29uc3QgcGF0dGVybiA9IG5ldyBPZmZzY3JlZW5DYW52YXMoYm94RGltV2lkdGggKiAyLCBib3hEaW1IZWlnaHQgKiAyKTtcbiAgICAgIGNvbnN0IHBhdHRlcm5DdHggPSBwYXR0ZXJuLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIHBhdHRlcm5DdHguZmlsbFN0eWxlID0gd2hpdGU7XG4gICAgICBwYXR0ZXJuQ3R4LmZpbGxSZWN0KDAsIDAsIGJveERpbVdpZHRoICogMiwgYm94RGltSGVpZ2h0ICogMik7XG4gICAgICBwYXR0ZXJuQ3R4LmZpbGxTdHlsZSA9IGJsYWNrO1xuICAgICAgcGF0dGVybkN0eC5maWxsUmVjdCgwLCAwLCBib3hEaW1XaWR0aCwgYm94RGltSGVpZ2h0KTtcbiAgICAgIHBhdHRlcm5DdHguZmlsbFJlY3QoYm94RGltV2lkdGgsIGJveERpbUhlaWdodCwgYm94RGltV2lkdGgsIGJveERpbUhlaWdodCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gY3R4LmNyZWF0ZVBhdHRlcm4ocGF0dGVybiwgXCJyZXBlYXRcIik7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgc2NhbGVkV2lkdGgsIHNjYWxlZEhlaWdodCk7XG4gICAgICBjdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCwgYml0bWFwLndpZHRoLCBiaXRtYXAuaGVpZ2h0LCAwLCAwLCBzY2FsZWRXaWR0aCwgc2NhbGVkSGVpZ2h0KTtcbiAgICB9XG4gICAgbGV0IGltYWdlRGF0YSA9IG51bGw7XG4gICAgaWYgKGNyZWF0ZUltYWdlRGF0YSkge1xuICAgICAgbGV0IGRhdGFXaWR0aCwgZGF0YUhlaWdodDtcbiAgICAgIGlmIChvdXRwdXRTY2FsZS5zeW1tZXRyaWMgJiYgYml0bWFwLndpZHRoIDwgbWF4RGF0YURpbWVuc2lvbiAmJiBiaXRtYXAuaGVpZ2h0IDwgbWF4RGF0YURpbWVuc2lvbikge1xuICAgICAgICBkYXRhV2lkdGggPSBiaXRtYXAud2lkdGg7XG4gICAgICAgIGRhdGFIZWlnaHQgPSBiaXRtYXAuaGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYml0bWFwID0gdGhpcy4jYml0bWFwO1xuICAgICAgICBpZiAoYml0bWFwV2lkdGggPiBtYXhEYXRhRGltZW5zaW9uIHx8IGJpdG1hcEhlaWdodCA+IG1heERhdGFEaW1lbnNpb24pIHtcbiAgICAgICAgICBjb25zdCByYXRpbyA9IE1hdGgubWluKG1heERhdGFEaW1lbnNpb24gLyBiaXRtYXBXaWR0aCwgbWF4RGF0YURpbWVuc2lvbiAvIGJpdG1hcEhlaWdodCk7XG4gICAgICAgICAgZGF0YVdpZHRoID0gTWF0aC5mbG9vcihiaXRtYXBXaWR0aCAqIHJhdGlvKTtcbiAgICAgICAgICBkYXRhSGVpZ2h0ID0gTWF0aC5mbG9vcihiaXRtYXBIZWlnaHQgKiByYXRpbyk7XG4gICAgICAgICAgaWYgKCF0aGlzLiNpc1N2Zykge1xuICAgICAgICAgICAgYml0bWFwID0gdGhpcy4jc2NhbGVCaXRtYXAoZGF0YVdpZHRoLCBkYXRhSGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMoZGF0YVdpZHRoLCBkYXRhSGVpZ2h0KTtcbiAgICAgIGNvbnN0IG9mZnNjcmVlbkN0eCA9IG9mZnNjcmVlbi5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWVcbiAgICAgIH0pO1xuICAgICAgb2Zmc2NyZWVuQ3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDAsIGJpdG1hcC53aWR0aCwgYml0bWFwLmhlaWdodCwgMCwgMCwgZGF0YVdpZHRoLCBkYXRhSGVpZ2h0KTtcbiAgICAgIGltYWdlRGF0YSA9IHtcbiAgICAgICAgd2lkdGg6IGRhdGFXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBkYXRhSGVpZ2h0LFxuICAgICAgICBkYXRhOiBvZmZzY3JlZW5DdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGRhdGFXaWR0aCwgZGF0YUhlaWdodCkuZGF0YVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhcyxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgaW1hZ2VEYXRhXG4gICAgfTtcbiAgfVxuICAjc2NhbGVCaXRtYXAod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoOiBiaXRtYXBXaWR0aCxcbiAgICAgIGhlaWdodDogYml0bWFwSGVpZ2h0XG4gICAgfSA9IHRoaXMuI2JpdG1hcDtcbiAgICBsZXQgbmV3V2lkdGggPSBiaXRtYXBXaWR0aDtcbiAgICBsZXQgbmV3SGVpZ2h0ID0gYml0bWFwSGVpZ2h0O1xuICAgIGxldCBiaXRtYXAgPSB0aGlzLiNiaXRtYXA7XG4gICAgd2hpbGUgKG5ld1dpZHRoID4gMiAqIHdpZHRoIHx8IG5ld0hlaWdodCA+IDIgKiBoZWlnaHQpIHtcbiAgICAgIGNvbnN0IHByZXZXaWR0aCA9IG5ld1dpZHRoO1xuICAgICAgY29uc3QgcHJldkhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgIGlmIChuZXdXaWR0aCA+IDIgKiB3aWR0aCkge1xuICAgICAgICBuZXdXaWR0aCA9IG5ld1dpZHRoID49IDE2Mzg0ID8gTWF0aC5mbG9vcihuZXdXaWR0aCAvIDIpIC0gMSA6IE1hdGguY2VpbChuZXdXaWR0aCAvIDIpO1xuICAgICAgfVxuICAgICAgaWYgKG5ld0hlaWdodCA+IDIgKiBoZWlnaHQpIHtcbiAgICAgICAgbmV3SGVpZ2h0ID0gbmV3SGVpZ2h0ID49IDE2Mzg0ID8gTWF0aC5mbG9vcihuZXdIZWlnaHQgLyAyKSAtIDEgOiBNYXRoLmNlaWwobmV3SGVpZ2h0IC8gMik7XG4gICAgICB9XG4gICAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgY29uc3QgY3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCBwcmV2V2lkdGgsIHByZXZIZWlnaHQsIDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgYml0bWFwID0gb2Zmc2NyZWVuLnRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpO1xuICAgIH1cbiAgICByZXR1cm4gYml0bWFwO1xuICB9XG4gICNkcmF3Qml0bWFwKCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IG91dHB1dFNjYWxlID0gbmV3IE91dHB1dFNjYWxlKCk7XG4gICAgY29uc3Qgc2NhbGVkV2lkdGggPSBNYXRoLmNlaWwod2lkdGggKiBwYXJlbnRXaWR0aCAqIG91dHB1dFNjYWxlLnN4KTtcbiAgICBjb25zdCBzY2FsZWRIZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0ICogcGFyZW50SGVpZ2h0ICogb3V0cHV0U2NhbGUuc3kpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuI2NhbnZhcztcbiAgICBpZiAoIWNhbnZhcyB8fCBjYW52YXMud2lkdGggPT09IHNjYWxlZFdpZHRoICYmIGNhbnZhcy5oZWlnaHQgPT09IHNjYWxlZEhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYW52YXMud2lkdGggPSBzY2FsZWRXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gc2NhbGVkSGVpZ2h0O1xuICAgIGNvbnN0IGJpdG1hcCA9IHRoaXMuI2lzU3ZnID8gdGhpcy4jYml0bWFwIDogdGhpcy4jc2NhbGVCaXRtYXAoc2NhbGVkV2lkdGgsIHNjYWxlZEhlaWdodCk7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBjdHguZmlsdGVyID0gdGhpcy5fdWlNYW5hZ2VyLmhjbUZpbHRlcjtcbiAgICBjdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCwgYml0bWFwLndpZHRoLCBiaXRtYXAuaGVpZ2h0LCAwLCAwLCBzY2FsZWRXaWR0aCwgc2NhbGVkSGVpZ2h0KTtcbiAgfVxuICAjc2VyaWFsaXplQml0bWFwKHRvVXJsKSB7XG4gICAgaWYgKHRvVXJsKSB7XG4gICAgICBpZiAodGhpcy4jaXNTdmcpIHtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRTdmdVcmwodGhpcy4jYml0bWFwSWQpO1xuICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICh7XG4gICAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogY2FudmFzLmhlaWdodFxuICAgICAgfSA9IHRoaXMuI2JpdG1hcCk7XG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLiNiaXRtYXAsIDAsIDApO1xuICAgICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2lzU3ZnKSB7XG4gICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgICBjb25zdCB3aWR0aCA9IE1hdGgucm91bmQodGhpcy53aWR0aCAqIHBhZ2VXaWR0aCAqIFBpeGVsc1BlckluY2guUERGX1RPX0NTU19VTklUUyk7XG4gICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLnJvdW5kKHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodCAqIFBpeGVsc1BlckluY2guUERGX1RPX0NTU19VTklUUyk7XG4gICAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3QgY3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy4jYml0bWFwLCAwLCAwLCB0aGlzLiNiaXRtYXAud2lkdGgsIHRoaXMuI2JpdG1hcC5oZWlnaHQsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgcmV0dXJuIG9mZnNjcmVlbi50cmFuc2ZlclRvSW1hZ2VCaXRtYXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cnVjdHVyZWRDbG9uZSh0aGlzLiNiaXRtYXApO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcikge1xuICAgIGxldCBpbml0aWFsRGF0YSA9IG51bGw7XG4gICAgbGV0IG1pc3NpbmdDYW52YXMgPSBmYWxzZTtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIFN0YW1wQW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgc3RydWN0UGFyZW50LFxuICAgICAgICAgIHBvcHVwUmVmXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgcGFnZU51bWJlclxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2FudmFzXG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGxldCBiaXRtYXBJZCwgYml0bWFwO1xuICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICBkZWxldGUgZGF0YS5jYW52YXM7XG4gICAgICAgICh7XG4gICAgICAgICAgaWQ6IGJpdG1hcElkLFxuICAgICAgICAgIGJpdG1hcFxuICAgICAgICB9ID0gdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tQ2FudmFzKGNvbnRhaW5lci5pZCwgY2FudmFzKSk7XG4gICAgICAgIGNhbnZhcy5yZW1vdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pc3NpbmdDYW52YXMgPSB0cnVlO1xuICAgICAgICBkYXRhLl9oYXNOb0NhbnZhcyA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBhbHRUZXh0ID0gKGF3YWl0IHBhcmVudC5fc3RydWN0VHJlZS5nZXRBcmlhQXR0cmlidXRlcyhgJHtBbm5vdGF0aW9uUHJlZml4fSR7aWR9YCkpPy5nZXQoXCJhcmlhLWxhYmVsXCIpIHx8IFwiXCI7XG4gICAgICBpbml0aWFsRGF0YSA9IGRhdGEgPSB7XG4gICAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUCxcbiAgICAgICAgYml0bWFwSWQsXG4gICAgICAgIGJpdG1hcCxcbiAgICAgICAgcGFnZUluZGV4OiBwYWdlTnVtYmVyIC0gMSxcbiAgICAgICAgcmVjdDogcmVjdC5zbGljZSgwKSxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGlkLFxuICAgICAgICBkZWxldGVkOiBmYWxzZSxcbiAgICAgICAgYWNjZXNzaWJpbGl0eURhdGE6IHtcbiAgICAgICAgICBkZWNvcmF0aXZlOiBmYWxzZSxcbiAgICAgICAgICBhbHRUZXh0XG4gICAgICAgIH0sXG4gICAgICAgIGlzU3ZnOiBmYWxzZSxcbiAgICAgICAgc3RydWN0UGFyZW50LFxuICAgICAgICBwb3B1cFJlZlxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9yID0gYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlY3QsXG4gICAgICBiaXRtYXAsXG4gICAgICBiaXRtYXBVcmwsXG4gICAgICBiaXRtYXBJZCxcbiAgICAgIGlzU3ZnLFxuICAgICAgYWNjZXNzaWJpbGl0eURhdGFcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAobWlzc2luZ0NhbnZhcykge1xuICAgICAgdWlNYW5hZ2VyLmFkZE1pc3NpbmdDYW52YXMoZGF0YS5pZCwgZWRpdG9yKTtcbiAgICAgIGVkaXRvci4jbWlzc2luZ0NhbnZhcyA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChiaXRtYXBJZCAmJiB1aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmlzVmFsaWRJZChiaXRtYXBJZCkpIHtcbiAgICAgIGVkaXRvci4jYml0bWFwSWQgPSBiaXRtYXBJZDtcbiAgICAgIGlmIChiaXRtYXApIHtcbiAgICAgICAgZWRpdG9yLiNiaXRtYXAgPSBiaXRtYXA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVkaXRvci4jYml0bWFwVXJsID0gYml0bWFwVXJsO1xuICAgIH1cbiAgICBlZGl0b3IuI2lzU3ZnID0gaXNTdmc7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gZWRpdG9yLnBhZ2VEaW1lbnNpb25zO1xuICAgIGVkaXRvci53aWR0aCA9IChyZWN0WzJdIC0gcmVjdFswXSkgLyBwYXJlbnRXaWR0aDtcbiAgICBlZGl0b3IuaGVpZ2h0ID0gKHJlY3RbM10gLSByZWN0WzFdKSAvIHBhcmVudEhlaWdodDtcbiAgICBlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IGRhdGEuaWQgfHwgbnVsbDtcbiAgICBpZiAoYWNjZXNzaWJpbGl0eURhdGEpIHtcbiAgICAgIGVkaXRvci5hbHRUZXh0RGF0YSA9IGFjY2Vzc2liaWxpdHlEYXRhO1xuICAgIH1cbiAgICBlZGl0b3IuX2luaXRpYWxEYXRhID0gaW5pdGlhbERhdGE7XG4gICAgZWRpdG9yLiNoYXNCZWVuQWRkZWRJblVuZG9TdGFjayA9ICEhaW5pdGlhbERhdGE7XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nID0gZmFsc2UsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVsZXRlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplRGVsZXRlZCgpO1xuICAgIH1cbiAgICBjb25zdCBzZXJpYWxpemVkID0ge1xuICAgICAgYW5ub3RhdGlvblR5cGU6IEFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QLFxuICAgICAgYml0bWFwSWQ6IHRoaXMuI2JpdG1hcElkLFxuICAgICAgcGFnZUluZGV4OiB0aGlzLnBhZ2VJbmRleCxcbiAgICAgIHJlY3Q6IHRoaXMuZ2V0UmVjdCgwLCAwKSxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxuICAgICAgaXNTdmc6IHRoaXMuI2lzU3ZnLFxuICAgICAgc3RydWN0VHJlZVBhcmVudElkOiB0aGlzLl9zdHJ1Y3RUcmVlUGFyZW50SWRcbiAgICB9O1xuICAgIGlmIChpc0ZvckNvcHlpbmcpIHtcbiAgICAgIHNlcmlhbGl6ZWQuYml0bWFwVXJsID0gdGhpcy4jc2VyaWFsaXplQml0bWFwKHRydWUpO1xuICAgICAgc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YSA9IHRoaXMuc2VyaWFsaXplQWx0VGV4dCh0cnVlKTtcbiAgICAgIHNlcmlhbGl6ZWQuaXNDb3B5ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkZWNvcmF0aXZlLFxuICAgICAgYWx0VGV4dFxuICAgIH0gPSB0aGlzLnNlcmlhbGl6ZUFsdFRleHQoZmFsc2UpO1xuICAgIGlmICghZGVjb3JhdGl2ZSAmJiBhbHRUZXh0KSB7XG4gICAgICBzZXJpYWxpemVkLmFjY2Vzc2liaWxpdHlEYXRhID0ge1xuICAgICAgICB0eXBlOiBcIkZpZ3VyZVwiLFxuICAgICAgICBhbHQ6IGFsdFRleHRcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLiNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKTtcbiAgICAgIGlmIChjaGFuZ2VzLmlzU2FtZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFuZ2VzLmlzU2FtZUFsdFRleHQpIHtcbiAgICAgICAgZGVsZXRlIHNlcmlhbGl6ZWQuYWNjZXNzaWJpbGl0eURhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXJpYWxpemVkLmFjY2Vzc2liaWxpdHlEYXRhLnN0cnVjdFBhcmVudCA9IHRoaXMuX2luaXRpYWxEYXRhLnN0cnVjdFBhcmVudCA/PyAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VyaWFsaXplZC5pZCA9IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZDtcbiAgICBpZiAoY29udGV4dCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICAgIGNvbnRleHQuc3RhbXBzIHx8PSBuZXcgTWFwKCk7XG4gICAgY29uc3QgYXJlYSA9IHRoaXMuI2lzU3ZnID8gKHNlcmlhbGl6ZWQucmVjdFsyXSAtIHNlcmlhbGl6ZWQucmVjdFswXSkgKiAoc2VyaWFsaXplZC5yZWN0WzNdIC0gc2VyaWFsaXplZC5yZWN0WzFdKSA6IG51bGw7XG4gICAgaWYgKCFjb250ZXh0LnN0YW1wcy5oYXModGhpcy4jYml0bWFwSWQpKSB7XG4gICAgICBjb250ZXh0LnN0YW1wcy5zZXQodGhpcy4jYml0bWFwSWQsIHtcbiAgICAgICAgYXJlYSxcbiAgICAgICAgc2VyaWFsaXplZFxuICAgICAgfSk7XG4gICAgICBzZXJpYWxpemVkLmJpdG1hcCA9IHRoaXMuI3NlcmlhbGl6ZUJpdG1hcChmYWxzZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNpc1N2Zykge1xuICAgICAgY29uc3QgcHJldkRhdGEgPSBjb250ZXh0LnN0YW1wcy5nZXQodGhpcy4jYml0bWFwSWQpO1xuICAgICAgaWYgKGFyZWEgPiBwcmV2RGF0YS5hcmVhKSB7XG4gICAgICAgIHByZXZEYXRhLmFyZWEgPSBhcmVhO1xuICAgICAgICBwcmV2RGF0YS5zZXJpYWxpemVkLmJpdG1hcC5jbG9zZSgpO1xuICAgICAgICBwcmV2RGF0YS5zZXJpYWxpemVkLmJpdG1hcCA9IHRoaXMuI3NlcmlhbGl6ZUJpdG1hcChmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG4gICNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFnZUluZGV4LFxuICAgICAgYWNjZXNzaWJpbGl0eURhdGE6IHtcbiAgICAgICAgYWx0VGV4dFxuICAgICAgfVxuICAgIH0gPSB0aGlzLl9pbml0aWFsRGF0YTtcbiAgICBjb25zdCBpc1NhbWVQYWdlSW5kZXggPSBzZXJpYWxpemVkLnBhZ2VJbmRleCA9PT0gcGFnZUluZGV4O1xuICAgIGNvbnN0IGlzU2FtZUFsdFRleHQgPSAoc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YT8uYWx0IHx8IFwiXCIpID09PSBhbHRUZXh0O1xuICAgIHJldHVybiB7XG4gICAgICBpc1NhbWU6ICF0aGlzLl9oYXNCZWVuTW92ZWQgJiYgIXRoaXMuX2hhc0JlZW5SZXNpemVkICYmIGlzU2FtZVBhZ2VJbmRleCAmJiBpc1NhbWVBbHRUZXh0LFxuICAgICAgaXNTYW1lQWx0VGV4dFxuICAgIH07XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGFubm90YXRpb24udXBkYXRlRWRpdGVkKHtcbiAgICAgIHJlY3Q6IHRoaXMuZ2V0UmVjdCgwLCAwKVxuICAgIH0pO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9hbm5vdGF0aW9uX2VkaXRvcl9sYXllci5qc1xuXG5cblxuXG5cblxuXG5cbmNsYXNzIEFubm90YXRpb25FZGl0b3JMYXllciB7XG4gICNhY2Nlc3NpYmlsaXR5TWFuYWdlcjtcbiAgI2FsbG93Q2xpY2sgPSBmYWxzZTtcbiAgI2Fubm90YXRpb25MYXllciA9IG51bGw7XG4gICNjbGlja0FDID0gbnVsbDtcbiAgI2VkaXRvckZvY3VzVGltZW91dElkID0gbnVsbDtcbiAgI2VkaXRvcnMgPSBuZXcgTWFwKCk7XG4gICNoYWRQb2ludGVyRG93biA9IGZhbHNlO1xuICAjaXNEaXNhYmxpbmcgPSBmYWxzZTtcbiAgI2lzRW5hYmxpbmcgPSBmYWxzZTtcbiAgI2RyYXdpbmdBQyA9IG51bGw7XG4gICNmb2N1c2VkRWxlbWVudCA9IG51bGw7XG4gICN0ZXh0TGF5ZXIgPSBudWxsO1xuICAjdGV4dFNlbGVjdGlvbkFDID0gbnVsbDtcbiAgI3VpTWFuYWdlcjtcbiAgc3RhdGljIF9pbml0aWFsaXplZCA9IGZhbHNlO1xuICBzdGF0aWMgI2VkaXRvclR5cGVzID0gbmV3IE1hcChbRnJlZVRleHRFZGl0b3IsIElua0VkaXRvciwgU3RhbXBFZGl0b3IsIEhpZ2hsaWdodEVkaXRvciwgU2lnbmF0dXJlRWRpdG9yXS5tYXAodHlwZSA9PiBbdHlwZS5fZWRpdG9yVHlwZSwgdHlwZV0pKTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHVpTWFuYWdlcixcbiAgICBwYWdlSW5kZXgsXG4gICAgZGl2LFxuICAgIHN0cnVjdFRyZWVMYXllcixcbiAgICBhY2Nlc3NpYmlsaXR5TWFuYWdlcixcbiAgICBhbm5vdGF0aW9uTGF5ZXIsXG4gICAgZHJhd0xheWVyLFxuICAgIHRleHRMYXllcixcbiAgICB2aWV3cG9ydCxcbiAgICBsMTBuXG4gIH0pIHtcbiAgICBjb25zdCBlZGl0b3JUeXBlcyA9IFsuLi5Bbm5vdGF0aW9uRWRpdG9yTGF5ZXIuI2VkaXRvclR5cGVzLnZhbHVlcygpXTtcbiAgICBpZiAoIUFubm90YXRpb25FZGl0b3JMYXllci5faW5pdGlhbGl6ZWQpIHtcbiAgICAgIEFubm90YXRpb25FZGl0b3JMYXllci5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIGVkaXRvclR5cGVzKSB7XG4gICAgICAgIGVkaXRvclR5cGUuaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICB1aU1hbmFnZXIucmVnaXN0ZXJFZGl0b3JUeXBlcyhlZGl0b3JUeXBlcyk7XG4gICAgdGhpcy4jdWlNYW5hZ2VyID0gdWlNYW5hZ2VyO1xuICAgIHRoaXMucGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgIHRoaXMuZGl2ID0gZGl2O1xuICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyID0gYWNjZXNzaWJpbGl0eU1hbmFnZXI7XG4gICAgdGhpcy4jYW5ub3RhdGlvbkxheWVyID0gYW5ub3RhdGlvbkxheWVyO1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICB0aGlzLiN0ZXh0TGF5ZXIgPSB0ZXh0TGF5ZXI7XG4gICAgdGhpcy5kcmF3TGF5ZXIgPSBkcmF3TGF5ZXI7XG4gICAgdGhpcy5fc3RydWN0VHJlZSA9IHN0cnVjdFRyZWVMYXllcjtcbiAgICB0aGlzLiN1aU1hbmFnZXIuYWRkTGF5ZXIodGhpcyk7XG4gIH1cbiAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2VkaXRvcnMuc2l6ZSA9PT0gMDtcbiAgfVxuICBnZXQgaXNJbnZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNFbXB0eSAmJiB0aGlzLiN1aU1hbmFnZXIuZ2V0TW9kZSgpID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FO1xuICB9XG4gIHVwZGF0ZVRvb2xiYXIobW9kZSkge1xuICAgIHRoaXMuI3VpTWFuYWdlci51cGRhdGVUb29sYmFyKG1vZGUpO1xuICB9XG4gIHVwZGF0ZU1vZGUobW9kZSA9IHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCkpIHtcbiAgICB0aGlzLiNjbGVhbnVwKCk7XG4gICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkU6XG4gICAgICAgIHRoaXMuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy50b2dnbGVQb2ludGVyRXZlbnRzKGZhbHNlKTtcbiAgICAgICAgdGhpcy50b2dnbGVBbm5vdGF0aW9uTGF5ZXJQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgICAgICB0aGlzLmRpc2FibGVDbGljaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JUeXBlLklOSzpcbiAgICAgICAgdGhpcy5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnRvZ2dsZVBvaW50ZXJFdmVudHModHJ1ZSk7XG4gICAgICAgIHRoaXMuZW5hYmxlQ2xpY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVDpcbiAgICAgICAgdGhpcy5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMudG9nZ2xlUG9pbnRlckV2ZW50cyhmYWxzZSk7XG4gICAgICAgIHRoaXMuZGlzYWJsZUNsaWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnRvZ2dsZVBvaW50ZXJFdmVudHModHJ1ZSk7XG4gICAgICAgIHRoaXMuZW5hYmxlQ2xpY2soKTtcbiAgICB9XG4gICAgdGhpcy50b2dnbGVBbm5vdGF0aW9uTGF5ZXJQb2ludGVyRXZlbnRzKGZhbHNlKTtcbiAgICBjb25zdCB7XG4gICAgICBjbGFzc0xpc3RcbiAgICB9ID0gdGhpcy5kaXY7XG4gICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIEFubm90YXRpb25FZGl0b3JMYXllci4jZWRpdG9yVHlwZXMudmFsdWVzKCkpIHtcbiAgICAgIGNsYXNzTGlzdC50b2dnbGUoYCR7ZWRpdG9yVHlwZS5fdHlwZX1FZGl0aW5nYCwgbW9kZSA9PT0gZWRpdG9yVHlwZS5fZWRpdG9yVHlwZSk7XG4gICAgfVxuICAgIHRoaXMuZGl2LmhpZGRlbiA9IGZhbHNlO1xuICB9XG4gIGhhc1RleHRMYXllcih0ZXh0TGF5ZXIpIHtcbiAgICByZXR1cm4gdGV4dExheWVyID09PSB0aGlzLiN0ZXh0TGF5ZXI/LmRpdjtcbiAgfVxuICBzZXRFZGl0aW5nU3RhdGUoaXNFZGl0aW5nKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnNldEVkaXRpbmdTdGF0ZShpc0VkaXRpbmcpO1xuICB9XG4gIGFkZENvbW1hbmRzKHBhcmFtcykge1xuICAgIHRoaXMuI3VpTWFuYWdlci5hZGRDb21tYW5kcyhwYXJhbXMpO1xuICB9XG4gIGNsZWFuVW5kb1N0YWNrKHR5cGUpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIuY2xlYW5VbmRvU3RhY2sodHlwZSk7XG4gIH1cbiAgdG9nZ2xlRHJhd2luZyhlbmFibGVkID0gZmFsc2UpIHtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZHJhd2luZ1wiLCAhZW5hYmxlZCk7XG4gIH1cbiAgdG9nZ2xlUG9pbnRlckV2ZW50cyhlbmFibGVkID0gZmFsc2UpIHtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZGlzYWJsZWRcIiwgIWVuYWJsZWQpO1xuICB9XG4gIHRvZ2dsZUFubm90YXRpb25MYXllclBvaW50ZXJFdmVudHMoZW5hYmxlZCA9IGZhbHNlKSB7XG4gICAgdGhpcy4jYW5ub3RhdGlvbkxheWVyPy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRpc2FibGVkXCIsICFlbmFibGVkKTtcbiAgfVxuICBhc3luYyBlbmFibGUoKSB7XG4gICAgdGhpcy4jaXNFbmFibGluZyA9IHRydWU7XG4gICAgdGhpcy5kaXYudGFiSW5kZXggPSAwO1xuICAgIHRoaXMudG9nZ2xlUG9pbnRlckV2ZW50cyh0cnVlKTtcbiAgICBjb25zdCBhbm5vdGF0aW9uRWxlbWVudElkcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBlZGl0b3IuZW5hYmxlRWRpdGluZygpO1xuICAgICAgZWRpdG9yLnNob3codHJ1ZSk7XG4gICAgICBpZiAoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgICAgdGhpcy4jdWlNYW5hZ2VyLnJlbW92ZUNoYW5nZWRFeGlzdGluZ0Fubm90YXRpb24oZWRpdG9yKTtcbiAgICAgICAgYW5ub3RhdGlvbkVsZW1lbnRJZHMuYWRkKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLiNhbm5vdGF0aW9uTGF5ZXIpIHtcbiAgICAgIHRoaXMuI2lzRW5hYmxpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWRpdGFibGVzID0gdGhpcy4jYW5ub3RhdGlvbkxheWVyLmdldEVkaXRhYmxlQW5ub3RhdGlvbnMoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRhYmxlIG9mIGVkaXRhYmxlcykge1xuICAgICAgZWRpdGFibGUuaGlkZSgpO1xuICAgICAgaWYgKHRoaXMuI3VpTWFuYWdlci5pc0RlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0YWJsZS5kYXRhLmlkKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChhbm5vdGF0aW9uRWxlbWVudElkcy5oYXMoZWRpdGFibGUuZGF0YS5pZCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCB0aGlzLmRlc2VyaWFsaXplKGVkaXRhYmxlKTtcbiAgICAgIGlmICghZWRpdG9yKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGRPclJlYnVpbGQoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5lbmFibGVFZGl0aW5nKCk7XG4gICAgfVxuICAgIHRoaXMuI2lzRW5hYmxpbmcgPSBmYWxzZTtcbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIHRoaXMuI2lzRGlzYWJsaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmRpdi50YWJJbmRleCA9IC0xO1xuICAgIHRoaXMudG9nZ2xlUG9pbnRlckV2ZW50cyhmYWxzZSk7XG4gICAgY29uc3QgY2hhbmdlZEFubm90YXRpb25zID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHJlc2V0QW5ub3RhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgZWRpdG9yLmRpc2FibGVFZGl0aW5nKCk7XG4gICAgICBpZiAoIWVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGVkaXRvci5zZXJpYWxpemUoKSAhPT0gbnVsbCkge1xuICAgICAgICBjaGFuZ2VkQW5ub3RhdGlvbnMuc2V0KGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkLCBlZGl0b3IpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0QW5ub3RhdGlvbnMuc2V0KGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkLCBlZGl0b3IpO1xuICAgICAgfVxuICAgICAgdGhpcy5nZXRFZGl0YWJsZUFubm90YXRpb24oZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpPy5zaG93KCk7XG4gICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNhbm5vdGF0aW9uTGF5ZXIpIHtcbiAgICAgIGNvbnN0IGVkaXRhYmxlcyA9IHRoaXMuI2Fubm90YXRpb25MYXllci5nZXRFZGl0YWJsZUFubm90YXRpb25zKCk7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRhYmxlIG9mIGVkaXRhYmxlcykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IGVkaXRhYmxlLmRhdGE7XG4gICAgICAgIGlmICh0aGlzLiN1aU1hbmFnZXIuaXNEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoaWQpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVkaXRvciA9IHJlc2V0QW5ub3RhdGlvbnMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGVkaXRvcikge1xuICAgICAgICAgIGVkaXRvci5yZXNldEFubm90YXRpb25FbGVtZW50KGVkaXRhYmxlKTtcbiAgICAgICAgICBlZGl0b3Iuc2hvdyhmYWxzZSk7XG4gICAgICAgICAgZWRpdGFibGUuc2hvdygpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVkaXRvciA9IGNoYW5nZWRBbm5vdGF0aW9ucy5nZXQoaWQpO1xuICAgICAgICBpZiAoZWRpdG9yKSB7XG4gICAgICAgICAgdGhpcy4jdWlNYW5hZ2VyLmFkZENoYW5nZWRFeGlzdGluZ0Fubm90YXRpb24oZWRpdG9yKTtcbiAgICAgICAgICBpZiAoZWRpdG9yLnJlbmRlckFubm90YXRpb25FbGVtZW50KGVkaXRhYmxlKSkge1xuICAgICAgICAgICAgZWRpdG9yLnNob3coZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlZGl0YWJsZS5zaG93KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2NsZWFudXAoKTtcbiAgICBpZiAodGhpcy5pc0VtcHR5KSB7XG4gICAgICB0aGlzLmRpdi5oaWRkZW4gPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjbGFzc0xpc3RcbiAgICB9ID0gdGhpcy5kaXY7XG4gICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIEFubm90YXRpb25FZGl0b3JMYXllci4jZWRpdG9yVHlwZXMudmFsdWVzKCkpIHtcbiAgICAgIGNsYXNzTGlzdC5yZW1vdmUoYCR7ZWRpdG9yVHlwZS5fdHlwZX1FZGl0aW5nYCk7XG4gICAgfVxuICAgIHRoaXMuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgICB0aGlzLnRvZ2dsZUFubm90YXRpb25MYXllclBvaW50ZXJFdmVudHModHJ1ZSk7XG4gICAgdGhpcy4jaXNEaXNhYmxpbmcgPSBmYWxzZTtcbiAgfVxuICBnZXRFZGl0YWJsZUFubm90YXRpb24oaWQpIHtcbiAgICByZXR1cm4gdGhpcy4jYW5ub3RhdGlvbkxheWVyPy5nZXRFZGl0YWJsZUFubm90YXRpb24oaWQpIHx8IG51bGw7XG4gIH1cbiAgc2V0QWN0aXZlRWRpdG9yKGVkaXRvcikge1xuICAgIGNvbnN0IGN1cnJlbnRBY3RpdmUgPSB0aGlzLiN1aU1hbmFnZXIuZ2V0QWN0aXZlKCk7XG4gICAgaWYgKGN1cnJlbnRBY3RpdmUgPT09IGVkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiN1aU1hbmFnZXIuc2V0QWN0aXZlRWRpdG9yKGVkaXRvcik7XG4gIH1cbiAgZW5hYmxlVGV4dFNlbGVjdGlvbigpIHtcbiAgICB0aGlzLmRpdi50YWJJbmRleCA9IC0xO1xuICAgIGlmICh0aGlzLiN0ZXh0TGF5ZXI/LmRpdiAmJiAhdGhpcy4jdGV4dFNlbGVjdGlvbkFDKSB7XG4gICAgICB0aGlzLiN0ZXh0U2VsZWN0aW9uQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICBjb25zdCBzaWduYWwgPSB0aGlzLiN1aU1hbmFnZXIuY29tYmluZWRTaWduYWwodGhpcy4jdGV4dFNlbGVjdGlvbkFDKTtcbiAgICAgIHRoaXMuI3RleHRMYXllci5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMuI3RleHRMYXllclBvaW50ZXJEb3duLmJpbmQodGhpcyksIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIHRoaXMuI3RleHRMYXllci5kaXYuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodGluZ1wiKTtcbiAgICB9XG4gIH1cbiAgZGlzYWJsZVRleHRTZWxlY3Rpb24oKSB7XG4gICAgdGhpcy5kaXYudGFiSW5kZXggPSAwO1xuICAgIGlmICh0aGlzLiN0ZXh0TGF5ZXI/LmRpdiAmJiB0aGlzLiN0ZXh0U2VsZWN0aW9uQUMpIHtcbiAgICAgIHRoaXMuI3RleHRTZWxlY3Rpb25BQy5hYm9ydCgpO1xuICAgICAgdGhpcy4jdGV4dFNlbGVjdGlvbkFDID0gbnVsbDtcbiAgICAgIHRoaXMuI3RleHRMYXllci5kaXYuY2xhc3NMaXN0LnJlbW92ZShcImhpZ2hsaWdodGluZ1wiKTtcbiAgICB9XG4gIH1cbiAgI3RleHRMYXllclBvaW50ZXJEb3duKGV2ZW50KSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnVuc2VsZWN0QWxsKCk7XG4gICAgY29uc3Qge1xuICAgICAgdGFyZ2V0XG4gICAgfSA9IGV2ZW50O1xuICAgIGlmICh0YXJnZXQgPT09IHRoaXMuI3RleHRMYXllci5kaXYgfHwgKHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJyb2xlXCIpID09PSBcImltZ1wiIHx8IHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoXCJlbmRPZkNvbnRlbnRcIikpICYmIHRoaXMuI3RleHRMYXllci5kaXYuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBpc01hY1xuICAgICAgfSA9IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgJiYgaXNNYWMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy4jdWlNYW5hZ2VyLnNob3dBbGxFZGl0b3JzKFwiaGlnaGxpZ2h0XCIsIHRydWUsIHRydWUpO1xuICAgICAgdGhpcy4jdGV4dExheWVyLmRpdi5jbGFzc0xpc3QuYWRkKFwiZnJlZVwiKTtcbiAgICAgIHRoaXMudG9nZ2xlRHJhd2luZygpO1xuICAgICAgSGlnaGxpZ2h0RWRpdG9yLnN0YXJ0SGlnaGxpZ2h0aW5nKHRoaXMsIHRoaXMuI3VpTWFuYWdlci5kaXJlY3Rpb24gPT09IFwibHRyXCIsIHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLiN0ZXh0TGF5ZXIuZGl2LFxuICAgICAgICB4OiBldmVudC54LFxuICAgICAgICB5OiBldmVudC55XG4gICAgICB9KTtcbiAgICAgIHRoaXMuI3RleHRMYXllci5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuI3RleHRMYXllci5kaXYuY2xhc3NMaXN0LnJlbW92ZShcImZyZWVcIik7XG4gICAgICAgIHRoaXMudG9nZ2xlRHJhd2luZyh0cnVlKTtcbiAgICAgIH0sIHtcbiAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgc2lnbmFsOiB0aGlzLiN1aU1hbmFnZXIuX3NpZ25hbFxuICAgICAgfSk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuICBlbmFibGVDbGljaygpIHtcbiAgICBpZiAodGhpcy4jY2xpY2tBQykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjbGlja0FDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbCh0aGlzLiNjbGlja0FDKTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy5wb2ludGVyZG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBjb25zdCBwb2ludGVydXAgPSB0aGlzLnBvaW50ZXJ1cC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgcG9pbnRlcnVwLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmNhbmNlbFwiLCBwb2ludGVydXAsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gIGRpc2FibGVDbGljaygpIHtcbiAgICB0aGlzLiNjbGlja0FDPy5hYm9ydCgpO1xuICAgIHRoaXMuI2NsaWNrQUMgPSBudWxsO1xuICB9XG4gIGF0dGFjaChlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3JzLnNldChlZGl0b3IuaWQsIGVkaXRvcik7XG4gICAgY29uc3Qge1xuICAgICAgYW5ub3RhdGlvbkVsZW1lbnRJZFxuICAgIH0gPSBlZGl0b3I7XG4gICAgaWYgKGFubm90YXRpb25FbGVtZW50SWQgJiYgdGhpcy4jdWlNYW5hZ2VyLmlzRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGFubm90YXRpb25FbGVtZW50SWQpKSB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIucmVtb3ZlRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRvcik7XG4gICAgfVxuICB9XG4gIGRldGFjaChlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3JzLmRlbGV0ZShlZGl0b3IuaWQpO1xuICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyPy5yZW1vdmVQb2ludGVySW5UZXh0TGF5ZXIoZWRpdG9yLmNvbnRlbnREaXYpO1xuICAgIGlmICghdGhpcy4jaXNEaXNhYmxpbmcgJiYgZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5hZGREZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlKGVkaXRvcikge1xuICAgIHRoaXMuZGV0YWNoKGVkaXRvcik7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnJlbW92ZUVkaXRvcihlZGl0b3IpO1xuICAgIGVkaXRvci5kaXYucmVtb3ZlKCk7XG4gICAgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSA9IGZhbHNlO1xuICB9XG4gIGNoYW5nZVBhcmVudChlZGl0b3IpIHtcbiAgICBpZiAoZWRpdG9yLnBhcmVudCA9PT0gdGhpcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZWRpdG9yLnBhcmVudCAmJiBlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLmFkZERlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgICBBbm5vdGF0aW9uRWRpdG9yLmRlbGV0ZUFubm90YXRpb25FbGVtZW50KGVkaXRvcik7XG4gICAgICBlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuYXR0YWNoKGVkaXRvcik7XG4gICAgZWRpdG9yLnBhcmVudD8uZGV0YWNoKGVkaXRvcik7XG4gICAgZWRpdG9yLnNldFBhcmVudCh0aGlzKTtcbiAgICBpZiAoZWRpdG9yLmRpdiAmJiBlZGl0b3IuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICBlZGl0b3IuZGl2LnJlbW92ZSgpO1xuICAgICAgdGhpcy5kaXYuYXBwZW5kKGVkaXRvci5kaXYpO1xuICAgIH1cbiAgfVxuICBhZGQoZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvci5wYXJlbnQgPT09IHRoaXMgJiYgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZVBhcmVudChlZGl0b3IpO1xuICAgIHRoaXMuI3VpTWFuYWdlci5hZGRFZGl0b3IoZWRpdG9yKTtcbiAgICB0aGlzLmF0dGFjaChlZGl0b3IpO1xuICAgIGlmICghZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgY29uc3QgZGl2ID0gZWRpdG9yLnJlbmRlcigpO1xuICAgICAgdGhpcy5kaXYuYXBwZW5kKGRpdik7XG4gICAgICBlZGl0b3IuaXNBdHRhY2hlZFRvRE9NID0gdHJ1ZTtcbiAgICB9XG4gICAgZWRpdG9yLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgZWRpdG9yLm9uY2VBZGRlZCghdGhpcy4jaXNFbmFibGluZyk7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoZWRpdG9yKTtcbiAgICBlZGl0b3IuX3JlcG9ydFRlbGVtZXRyeShlZGl0b3IudGVsZW1ldHJ5SW5pdGlhbERhdGEpO1xuICB9XG4gIG1vdmVFZGl0b3JJbkRPTShlZGl0b3IpIHtcbiAgICBpZiAoIWVkaXRvci5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYWN0aXZlRWxlbWVudFxuICAgIH0gPSBkb2N1bWVudDtcbiAgICBpZiAoZWRpdG9yLmRpdi5jb250YWlucyhhY3RpdmVFbGVtZW50KSAmJiAhdGhpcy4jZWRpdG9yRm9jdXNUaW1lb3V0SWQpIHtcbiAgICAgIGVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gZmFsc2U7XG4gICAgICB0aGlzLiNlZGl0b3JGb2N1c1RpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLiNlZGl0b3JGb2N1c1RpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgIGlmICghZWRpdG9yLmRpdi5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgICAgIGVkaXRvci5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgKCkgPT4ge1xuICAgICAgICAgICAgZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSB0cnVlO1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgICAgICBzaWduYWw6IHRoaXMuI3VpTWFuYWdlci5fc2lnbmFsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSwgMCk7XG4gICAgfVxuICAgIGVkaXRvci5fc3RydWN0VHJlZVBhcmVudElkID0gdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXI/Lm1vdmVFbGVtZW50SW5ET00odGhpcy5kaXYsIGVkaXRvci5kaXYsIGVkaXRvci5jb250ZW50RGl2LCB0cnVlKTtcbiAgfVxuICBhZGRPclJlYnVpbGQoZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvci5uZWVkc1RvQmVSZWJ1aWx0KCkpIHtcbiAgICAgIGVkaXRvci5wYXJlbnQgfHw9IHRoaXM7XG4gICAgICBlZGl0b3IucmVidWlsZCgpO1xuICAgICAgZWRpdG9yLnNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGQoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgYWRkVW5kb2FibGVFZGl0b3IoZWRpdG9yKSB7XG4gICAgY29uc3QgY21kID0gKCkgPT4gZWRpdG9yLl91aU1hbmFnZXIucmVidWlsZChlZGl0b3IpO1xuICAgIGNvbnN0IHVuZG8gPSAoKSA9PiB7XG4gICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZCxcbiAgICAgIHVuZG8sXG4gICAgICBtdXN0RXhlYzogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBnZXROZXh0SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3VpTWFuYWdlci5nZXRJZCgpO1xuICB9XG4gIGdldCAjY3VycmVudEVkaXRvclR5cGUoKSB7XG4gICAgcmV0dXJuIEFubm90YXRpb25FZGl0b3JMYXllci4jZWRpdG9yVHlwZXMuZ2V0KHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCkpO1xuICB9XG4gIGNvbWJpbmVkU2lnbmFsKGFjKSB7XG4gICAgcmV0dXJuIHRoaXMuI3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbChhYyk7XG4gIH1cbiAgI2NyZWF0ZU5ld0VkaXRvcihwYXJhbXMpIHtcbiAgICBjb25zdCBlZGl0b3JUeXBlID0gdGhpcy4jY3VycmVudEVkaXRvclR5cGU7XG4gICAgcmV0dXJuIGVkaXRvclR5cGUgPyBuZXcgZWRpdG9yVHlwZS5wcm90b3R5cGUuY29uc3RydWN0b3IocGFyYW1zKSA6IG51bGw7XG4gIH1cbiAgY2FuQ3JlYXRlTmV3RW1wdHlFZGl0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlPy5jYW5DcmVhdGVOZXdFbXB0eUVkaXRvcigpO1xuICB9XG4gIGFzeW5jIHBhc3RlRWRpdG9yKG1vZGUsIHBhcmFtcykge1xuICAgIHRoaXMuI3VpTWFuYWdlci51cGRhdGVUb29sYmFyKG1vZGUpO1xuICAgIGF3YWl0IHRoaXMuI3VpTWFuYWdlci51cGRhdGVNb2RlKG1vZGUpO1xuICAgIGNvbnN0IHtcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZXG4gICAgfSA9IHRoaXMuI2dldENlbnRlclBvaW50KCk7XG4gICAgY29uc3QgaWQgPSB0aGlzLmdldE5leHRJZCgpO1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI2NyZWF0ZU5ld0VkaXRvcih7XG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBpZCxcbiAgICAgIHg6IG9mZnNldFgsXG4gICAgICB5OiBvZmZzZXRZLFxuICAgICAgdWlNYW5hZ2VyOiB0aGlzLiN1aU1hbmFnZXIsXG4gICAgICBpc0NlbnRlcmVkOiB0cnVlLFxuICAgICAgLi4ucGFyYW1zXG4gICAgfSk7XG4gICAgaWYgKGVkaXRvcikge1xuICAgICAgdGhpcy5hZGQoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSkge1xuICAgIHJldHVybiAoYXdhaXQgQW5ub3RhdGlvbkVkaXRvckxheWVyLiNlZGl0b3JUeXBlcy5nZXQoZGF0YS5hbm5vdGF0aW9uVHlwZSA/PyBkYXRhLmFubm90YXRpb25FZGl0b3JUeXBlKT8uZGVzZXJpYWxpemUoZGF0YSwgdGhpcywgdGhpcy4jdWlNYW5hZ2VyKSkgfHwgbnVsbDtcbiAgfVxuICBjcmVhdGVBbmRBZGROZXdFZGl0b3IoZXZlbnQsIGlzQ2VudGVyZWQsIGRhdGEgPSB7fSkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXROZXh0SWQoKTtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLiNjcmVhdGVOZXdFZGl0b3Ioe1xuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgaWQsXG4gICAgICB4OiBldmVudC5vZmZzZXRYLFxuICAgICAgeTogZXZlbnQub2Zmc2V0WSxcbiAgICAgIHVpTWFuYWdlcjogdGhpcy4jdWlNYW5hZ2VyLFxuICAgICAgaXNDZW50ZXJlZCxcbiAgICAgIC4uLmRhdGFcbiAgICB9KTtcbiAgICBpZiAoZWRpdG9yKSB7XG4gICAgICB0aGlzLmFkZChlZGl0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gICNnZXRDZW50ZXJQb2ludCgpIHtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHRsWCA9IE1hdGgubWF4KDAsIHgpO1xuICAgIGNvbnN0IHRsWSA9IE1hdGgubWF4KDAsIHkpO1xuICAgIGNvbnN0IGJyWCA9IE1hdGgubWluKHdpbmRvdy5pbm5lcldpZHRoLCB4ICsgd2lkdGgpO1xuICAgIGNvbnN0IGJyWSA9IE1hdGgubWluKHdpbmRvdy5pbm5lckhlaWdodCwgeSArIGhlaWdodCk7XG4gICAgY29uc3QgY2VudGVyWCA9ICh0bFggKyBiclgpIC8gMiAtIHg7XG4gICAgY29uc3QgY2VudGVyWSA9ICh0bFkgKyBiclkpIC8gMiAtIHk7XG4gICAgY29uc3QgW29mZnNldFgsIG9mZnNldFldID0gdGhpcy52aWV3cG9ydC5yb3RhdGlvbiAlIDE4MCA9PT0gMCA/IFtjZW50ZXJYLCBjZW50ZXJZXSA6IFtjZW50ZXJZLCBjZW50ZXJYXTtcbiAgICByZXR1cm4ge1xuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFlcbiAgICB9O1xuICB9XG4gIGFkZE5ld0VkaXRvcihkYXRhID0ge30pIHtcbiAgICB0aGlzLmNyZWF0ZUFuZEFkZE5ld0VkaXRvcih0aGlzLiNnZXRDZW50ZXJQb2ludCgpLCB0cnVlLCBkYXRhKTtcbiAgfVxuICBzZXRTZWxlY3RlZChlZGl0b3IpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIuc2V0U2VsZWN0ZWQoZWRpdG9yKTtcbiAgfVxuICB0b2dnbGVTZWxlY3RlZChlZGl0b3IpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIudG9nZ2xlU2VsZWN0ZWQoZWRpdG9yKTtcbiAgfVxuICB1bnNlbGVjdChlZGl0b3IpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIudW5zZWxlY3QoZWRpdG9yKTtcbiAgfVxuICBwb2ludGVydXAoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmRpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2hhZFBvaW50ZXJEb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2hhZFBvaW50ZXJEb3duID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlPy5pc0RyYXdlciAmJiB0aGlzLiNjdXJyZW50RWRpdG9yVHlwZS5zdXBwb3J0TXVsdGlwbGVEcmF3aW5ncykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2FsbG93Q2xpY2spIHtcbiAgICAgIHRoaXMuI2FsbG93Q2xpY2sgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50TW9kZSA9IHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCk7XG4gICAgaWYgKGN1cnJlbnRNb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUCB8fCBjdXJyZW50TW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuU0lHTkFUVVJFKSB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jcmVhdGVBbmRBZGROZXdFZGl0b3IoZXZlbnQsIGZhbHNlKTtcbiAgfVxuICBwb2ludGVyZG93bihldmVudCkge1xuICAgIGlmICh0aGlzLiN1aU1hbmFnZXIuZ2V0TW9kZSgpID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQpIHtcbiAgICAgIHRoaXMuZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jaGFkUG9pbnRlckRvd24pIHtcbiAgICAgIHRoaXMuI2hhZFBvaW50ZXJEb3duID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5jdHJsS2V5ICYmIGlzTWFjKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChldmVudC50YXJnZXQgIT09IHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2hhZFBvaW50ZXJEb3duID0gdHJ1ZTtcbiAgICBpZiAodGhpcy4jY3VycmVudEVkaXRvclR5cGU/LmlzRHJhd2VyKSB7XG4gICAgICB0aGlzLnN0YXJ0RHJhd2luZ1Nlc3Npb24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLiN1aU1hbmFnZXIuZ2V0QWN0aXZlKCk7XG4gICAgdGhpcy4jYWxsb3dDbGljayA9ICFlZGl0b3IgfHwgZWRpdG9yLmlzRW1wdHkoKTtcbiAgfVxuICBzdGFydERyYXdpbmdTZXNzaW9uKGV2ZW50KSB7XG4gICAgdGhpcy5kaXYuZm9jdXMoe1xuICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgIH0pO1xuICAgIGlmICh0aGlzLiNkcmF3aW5nQUMpIHtcbiAgICAgIHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlLnN0YXJ0RHJhd2luZyh0aGlzLCB0aGlzLiN1aU1hbmFnZXIsIGZhbHNlLCBldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3VpTWFuYWdlci5zZXRDdXJyZW50RHJhd2luZ1Nlc3Npb24odGhpcyk7XG4gICAgdGhpcy4jZHJhd2luZ0FDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbCh0aGlzLiNkcmF3aW5nQUMpO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsICh7XG4gICAgICByZWxhdGVkVGFyZ2V0XG4gICAgfSkgPT4ge1xuICAgICAgaWYgKHJlbGF0ZWRUYXJnZXQgJiYgIXRoaXMuZGl2LmNvbnRhaW5zKHJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgIHRoaXMuI2ZvY3VzZWRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlLnN0YXJ0RHJhd2luZyh0aGlzLCB0aGlzLiN1aU1hbmFnZXIsIGZhbHNlLCBldmVudCk7XG4gIH1cbiAgcGF1c2Uob24pIHtcbiAgICBpZiAob24pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWN0aXZlRWxlbWVudFxuICAgICAgfSA9IGRvY3VtZW50O1xuICAgICAgaWYgKHRoaXMuZGl2LmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgIHRoaXMuI2ZvY3VzZWRFbGVtZW50ID0gYWN0aXZlRWxlbWVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2ZvY3VzZWRFbGVtZW50KSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy4jZm9jdXNlZEVsZW1lbnQ/LmZvY3VzKCk7XG4gICAgICAgIHRoaXMuI2ZvY3VzZWRFbGVtZW50ID0gbnVsbDtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfVxuICBlbmREcmF3aW5nU2Vzc2lvbihpc0Fib3J0ZWQgPSBmYWxzZSkge1xuICAgIGlmICghdGhpcy4jZHJhd2luZ0FDKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnNldEN1cnJlbnREcmF3aW5nU2Vzc2lvbihudWxsKTtcbiAgICB0aGlzLiNkcmF3aW5nQUMuYWJvcnQoKTtcbiAgICB0aGlzLiNkcmF3aW5nQUMgPSBudWxsO1xuICAgIHRoaXMuI2ZvY3VzZWRFbGVtZW50ID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcy4jY3VycmVudEVkaXRvclR5cGUuZW5kRHJhd2luZyhpc0Fib3J0ZWQpO1xuICB9XG4gIGZpbmROZXdQYXJlbnQoZWRpdG9yLCB4LCB5KSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLiN1aU1hbmFnZXIuZmluZFBhcmVudCh4LCB5KTtcbiAgICBpZiAobGF5ZXIgPT09IG51bGwgfHwgbGF5ZXIgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGF5ZXIuY2hhbmdlUGFyZW50KGVkaXRvcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29tbWl0T3JSZW1vdmUoKSB7XG4gICAgaWYgKHRoaXMuI2RyYXdpbmdBQykge1xuICAgICAgdGhpcy5lbmREcmF3aW5nU2Vzc2lvbigpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBvblNjYWxlQ2hhbmdpbmcoKSB7XG4gICAgaWYgKCF0aGlzLiNkcmF3aW5nQUMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY3VycmVudEVkaXRvclR5cGUub25TY2FsZUNoYW5naW5nV2hlbkRyYXdpbmcodGhpcyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgaWYgKHRoaXMuI3VpTWFuYWdlci5nZXRBY3RpdmUoKT8ucGFyZW50ID09PSB0aGlzKSB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuY29tbWl0T3JSZW1vdmUoKTtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5zZXRBY3RpdmVFZGl0b3IobnVsbCk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNlZGl0b3JGb2N1c1RpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2VkaXRvckZvY3VzVGltZW91dElkKTtcbiAgICAgIHRoaXMuI2VkaXRvckZvY3VzVGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXI/LnJlbW92ZVBvaW50ZXJJblRleHRMYXllcihlZGl0b3IuY29udGVudERpdik7XG4gICAgICBlZGl0b3Iuc2V0UGFyZW50KG51bGwpO1xuICAgICAgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSA9IGZhbHNlO1xuICAgICAgZWRpdG9yLmRpdi5yZW1vdmUoKTtcbiAgICB9XG4gICAgdGhpcy5kaXYgPSBudWxsO1xuICAgIHRoaXMuI2VkaXRvcnMuY2xlYXIoKTtcbiAgICB0aGlzLiN1aU1hbmFnZXIucmVtb3ZlTGF5ZXIodGhpcyk7XG4gIH1cbiAgI2NsZWFudXAoKSB7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVkaXRvci5pc0VtcHR5KCkpIHtcbiAgICAgICAgZWRpdG9yLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZW5kZXIoe1xuICAgIHZpZXdwb3J0XG4gIH0pIHtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgc2V0TGF5ZXJEaW1lbnNpb25zKHRoaXMuZGl2LCB2aWV3cG9ydCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jdWlNYW5hZ2VyLmdldEVkaXRvcnModGhpcy5wYWdlSW5kZXgpKSB7XG4gICAgICB0aGlzLmFkZChlZGl0b3IpO1xuICAgICAgZWRpdG9yLnJlYnVpbGQoKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVNb2RlKCk7XG4gIH1cbiAgdXBkYXRlKHtcbiAgICB2aWV3cG9ydFxuICB9KSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgdGhpcy4jY2xlYW51cCgpO1xuICAgIGNvbnN0IG9sZFJvdGF0aW9uID0gdGhpcy52aWV3cG9ydC5yb3RhdGlvbjtcbiAgICBjb25zdCByb3RhdGlvbiA9IHZpZXdwb3J0LnJvdGF0aW9uO1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICBzZXRMYXllckRpbWVuc2lvbnModGhpcy5kaXYsIHtcbiAgICAgIHJvdGF0aW9uXG4gICAgfSk7XG4gICAgaWYgKG9sZFJvdGF0aW9uICE9PSByb3RhdGlvbikge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgICBlZGl0b3Iucm90YXRlKHJvdGF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IHBhZ2VEaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHRcbiAgICB9ID0gdGhpcy52aWV3cG9ydC5yYXdEaW1zO1xuICAgIHJldHVybiBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XTtcbiAgfVxuICBnZXQgc2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3VpTWFuYWdlci52aWV3UGFyYW1ldGVycy5yZWFsU2NhbGU7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZHJhd19sYXllci5qc1xuXG5cbmNsYXNzIERyYXdMYXllciB7XG4gICNwYXJlbnQgPSBudWxsO1xuICAjbWFwcGluZyA9IG5ldyBNYXAoKTtcbiAgI3RvVXBkYXRlID0gbmV3IE1hcCgpO1xuICBzdGF0aWMgI2lkID0gMDtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHBhZ2VJbmRleFxuICB9KSB7XG4gICAgdGhpcy5wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gIH1cbiAgc2V0UGFyZW50KHBhcmVudCkge1xuICAgIGlmICghdGhpcy4jcGFyZW50KSB7XG4gICAgICB0aGlzLiNwYXJlbnQgPSBwYXJlbnQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNwYXJlbnQgIT09IHBhcmVudCkge1xuICAgICAgaWYgKHRoaXMuI21hcHBpbmcuc2l6ZSA+IDApIHtcbiAgICAgICAgZm9yIChjb25zdCByb290IG9mIHRoaXMuI21hcHBpbmcudmFsdWVzKCkpIHtcbiAgICAgICAgICByb290LnJlbW92ZSgpO1xuICAgICAgICAgIHBhcmVudC5hcHBlbmQocm9vdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuI3BhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBfc3ZnRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX3N2Z0ZhY3RvcnlcIiwgbmV3IERPTVNWR0ZhY3RvcnkoKSk7XG4gIH1cbiAgc3RhdGljICNzZXRCb3goZWxlbWVudCwgW3gsIHksIHdpZHRoLCBoZWlnaHRdKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gZWxlbWVudDtcbiAgICBzdHlsZS50b3AgPSBgJHsxMDAgKiB5fSVgO1xuICAgIHN0eWxlLmxlZnQgPSBgJHsxMDAgKiB4fSVgO1xuICAgIHN0eWxlLndpZHRoID0gYCR7MTAwICogd2lkdGh9JWA7XG4gICAgc3R5bGUuaGVpZ2h0ID0gYCR7MTAwICogaGVpZ2h0fSVgO1xuICB9XG4gICNjcmVhdGVTVkcoKSB7XG4gICAgY29uc3Qgc3ZnID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZSgxLCAxLCB0cnVlKTtcbiAgICB0aGlzLiNwYXJlbnQuYXBwZW5kKHN2Zyk7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIHRydWUpO1xuICAgIHJldHVybiBzdmc7XG4gIH1cbiAgI2NyZWF0ZUNsaXBQYXRoKGRlZnMsIHBhdGhJZCkge1xuICAgIGNvbnN0IGNsaXBQYXRoID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJjbGlwUGF0aFwiKTtcbiAgICBkZWZzLmFwcGVuZChjbGlwUGF0aCk7XG4gICAgY29uc3QgY2xpcFBhdGhJZCA9IGBjbGlwXyR7cGF0aElkfWA7XG4gICAgY2xpcFBhdGguc2V0QXR0cmlidXRlKFwiaWRcIiwgY2xpcFBhdGhJZCk7XG4gICAgY2xpcFBhdGguc2V0QXR0cmlidXRlKFwiY2xpcFBhdGhVbml0c1wiLCBcIm9iamVjdEJvdW5kaW5nQm94XCIpO1xuICAgIGNvbnN0IGNsaXBQYXRoVXNlID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJ1c2VcIik7XG4gICAgY2xpcFBhdGguYXBwZW5kKGNsaXBQYXRoVXNlKTtcbiAgICBjbGlwUGF0aFVzZS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGAjJHtwYXRoSWR9YCk7XG4gICAgY2xpcFBhdGhVc2UuY2xhc3NMaXN0LmFkZChcImNsaXBcIik7XG4gICAgcmV0dXJuIGNsaXBQYXRoSWQ7XG4gIH1cbiAgI3VwZGF0ZVByb3BlcnRpZXMoZWxlbWVudCwgcHJvcGVydGllcykge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BlcnRpZXMpKSB7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkcmF3KHByb3BlcnRpZXMsIGlzUGF0aFVwZGF0YWJsZSA9IGZhbHNlLCBoYXNDbGlwID0gZmFsc2UpIHtcbiAgICBjb25zdCBpZCA9IERyYXdMYXllci4jaWQrKztcbiAgICBjb25zdCByb290ID0gdGhpcy4jY3JlYXRlU1ZHKCk7XG4gICAgY29uc3QgZGVmcyA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiZGVmc1wiKTtcbiAgICByb290LmFwcGVuZChkZWZzKTtcbiAgICBjb25zdCBwYXRoID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIpO1xuICAgIGRlZnMuYXBwZW5kKHBhdGgpO1xuICAgIGNvbnN0IHBhdGhJZCA9IGBwYXRoX3Ake3RoaXMucGFnZUluZGV4fV8ke2lkfWA7XG4gICAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBwYXRoSWQpO1xuICAgIHBhdGguc2V0QXR0cmlidXRlKFwidmVjdG9yLWVmZmVjdFwiLCBcIm5vbi1zY2FsaW5nLXN0cm9rZVwiKTtcbiAgICBpZiAoaXNQYXRoVXBkYXRhYmxlKSB7XG4gICAgICB0aGlzLiN0b1VwZGF0ZS5zZXQoaWQsIHBhdGgpO1xuICAgIH1cbiAgICBjb25zdCBjbGlwUGF0aElkID0gaGFzQ2xpcCA/IHRoaXMuI2NyZWF0ZUNsaXBQYXRoKGRlZnMsIHBhdGhJZCkgOiBudWxsO1xuICAgIGNvbnN0IHVzZSA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwidXNlXCIpO1xuICAgIHJvb3QuYXBwZW5kKHVzZSk7XG4gICAgdXNlLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgYCMke3BhdGhJZH1gKTtcbiAgICB0aGlzLnVwZGF0ZVByb3BlcnRpZXMocm9vdCwgcHJvcGVydGllcyk7XG4gICAgdGhpcy4jbWFwcGluZy5zZXQoaWQsIHJvb3QpO1xuICAgIHJldHVybiB7XG4gICAgICBpZCxcbiAgICAgIGNsaXBQYXRoSWQ6IGB1cmwoIyR7Y2xpcFBhdGhJZH0pYFxuICAgIH07XG4gIH1cbiAgZHJhd091dGxpbmUocHJvcGVydGllcywgbXVzdFJlbW92ZVNlbGZJbnRlcnNlY3Rpb25zKSB7XG4gICAgY29uc3QgaWQgPSBEcmF3TGF5ZXIuI2lkKys7XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuI2NyZWF0ZVNWRygpO1xuICAgIGNvbnN0IGRlZnMgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcImRlZnNcIik7XG4gICAgcm9vdC5hcHBlbmQoZGVmcyk7XG4gICAgY29uc3QgcGF0aCA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwicGF0aFwiKTtcbiAgICBkZWZzLmFwcGVuZChwYXRoKTtcbiAgICBjb25zdCBwYXRoSWQgPSBgcGF0aF9wJHt0aGlzLnBhZ2VJbmRleH1fJHtpZH1gO1xuICAgIHBhdGguc2V0QXR0cmlidXRlKFwiaWRcIiwgcGF0aElkKTtcbiAgICBwYXRoLnNldEF0dHJpYnV0ZShcInZlY3Rvci1lZmZlY3RcIiwgXCJub24tc2NhbGluZy1zdHJva2VcIik7XG4gICAgbGV0IG1hc2tJZDtcbiAgICBpZiAobXVzdFJlbW92ZVNlbGZJbnRlcnNlY3Rpb25zKSB7XG4gICAgICBjb25zdCBtYXNrID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJtYXNrXCIpO1xuICAgICAgZGVmcy5hcHBlbmQobWFzayk7XG4gICAgICBtYXNrSWQgPSBgbWFza19wJHt0aGlzLnBhZ2VJbmRleH1fJHtpZH1gO1xuICAgICAgbWFzay5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBtYXNrSWQpO1xuICAgICAgbWFzay5zZXRBdHRyaWJ1dGUoXCJtYXNrVW5pdHNcIiwgXCJvYmplY3RCb3VuZGluZ0JveFwiKTtcbiAgICAgIGNvbnN0IHJlY3QgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInJlY3RcIik7XG4gICAgICBtYXNrLmFwcGVuZChyZWN0KTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIxXCIpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCIxXCIpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwid2hpdGVcIik7XG4gICAgICBjb25zdCB1c2UgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInVzZVwiKTtcbiAgICAgIG1hc2suYXBwZW5kKHVzZSk7XG4gICAgICB1c2Uuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBgIyR7cGF0aElkfWApO1xuICAgICAgdXNlLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcIm5vbmVcIik7XG4gICAgICB1c2Uuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcImJsYWNrXCIpO1xuICAgICAgdXNlLnNldEF0dHJpYnV0ZShcImZpbGwtcnVsZVwiLCBcIm5vbnplcm9cIik7XG4gICAgICB1c2UuY2xhc3NMaXN0LmFkZChcIm1hc2tcIik7XG4gICAgfVxuICAgIGNvbnN0IHVzZTEgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInVzZVwiKTtcbiAgICByb290LmFwcGVuZCh1c2UxKTtcbiAgICB1c2UxLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgYCMke3BhdGhJZH1gKTtcbiAgICBpZiAobWFza0lkKSB7XG4gICAgICB1c2UxLnNldEF0dHJpYnV0ZShcIm1hc2tcIiwgYHVybCgjJHttYXNrSWR9KWApO1xuICAgIH1cbiAgICBjb25zdCB1c2UyID0gdXNlMS5jbG9uZU5vZGUoKTtcbiAgICByb290LmFwcGVuZCh1c2UyKTtcbiAgICB1c2UxLmNsYXNzTGlzdC5hZGQoXCJtYWluT3V0bGluZVwiKTtcbiAgICB1c2UyLmNsYXNzTGlzdC5hZGQoXCJzZWNvbmRhcnlPdXRsaW5lXCIpO1xuICAgIHRoaXMudXBkYXRlUHJvcGVydGllcyhyb290LCBwcm9wZXJ0aWVzKTtcbiAgICB0aGlzLiNtYXBwaW5nLnNldChpZCwgcm9vdCk7XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIGZpbmFsaXplRHJhdyhpZCwgcHJvcGVydGllcykge1xuICAgIHRoaXMuI3RvVXBkYXRlLmRlbGV0ZShpZCk7XG4gICAgdGhpcy51cGRhdGVQcm9wZXJ0aWVzKGlkLCBwcm9wZXJ0aWVzKTtcbiAgfVxuICB1cGRhdGVQcm9wZXJ0aWVzKGVsZW1lbnRPcklkLCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCFwcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHJvb3QsXG4gICAgICBiYm94LFxuICAgICAgcm9vdENsYXNzLFxuICAgICAgcGF0aFxuICAgIH0gPSBwcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0eXBlb2YgZWxlbWVudE9ySWQgPT09IFwibnVtYmVyXCIgPyB0aGlzLiNtYXBwaW5nLmdldChlbGVtZW50T3JJZCkgOiBlbGVtZW50T3JJZDtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJvb3QpIHtcbiAgICAgIHRoaXMuI3VwZGF0ZVByb3BlcnRpZXMoZWxlbWVudCwgcm9vdCk7XG4gICAgfVxuICAgIGlmIChiYm94KSB7XG4gICAgICBEcmF3TGF5ZXIuI3NldEJveChlbGVtZW50LCBiYm94KTtcbiAgICB9XG4gICAgaWYgKHJvb3RDbGFzcykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbGFzc0xpc3RcbiAgICAgIH0gPSBlbGVtZW50O1xuICAgICAgZm9yIChjb25zdCBbY2xhc3NOYW1lLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocm9vdENsYXNzKSkge1xuICAgICAgICBjbGFzc0xpc3QudG9nZ2xlKGNsYXNzTmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGF0aCkge1xuICAgICAgY29uc3QgZGVmcyA9IGVsZW1lbnQuZmlyc3RDaGlsZDtcbiAgICAgIGNvbnN0IHBhdGhFbGVtZW50ID0gZGVmcy5maXJzdENoaWxkO1xuICAgICAgdGhpcy4jdXBkYXRlUHJvcGVydGllcyhwYXRoRWxlbWVudCwgcGF0aCk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVBhcmVudChpZCwgbGF5ZXIpIHtcbiAgICBpZiAobGF5ZXIgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuI21hcHBpbmcuZ2V0KGlkKTtcbiAgICBpZiAoIXJvb3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGF5ZXIuI3BhcmVudC5hcHBlbmQocm9vdCk7XG4gICAgdGhpcy4jbWFwcGluZy5kZWxldGUoaWQpO1xuICAgIGxheWVyLiNtYXBwaW5nLnNldChpZCwgcm9vdCk7XG4gIH1cbiAgcmVtb3ZlKGlkKSB7XG4gICAgdGhpcy4jdG9VcGRhdGUuZGVsZXRlKGlkKTtcbiAgICBpZiAodGhpcy4jcGFyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI21hcHBpbmcuZ2V0KGlkKS5yZW1vdmUoKTtcbiAgICB0aGlzLiNtYXBwaW5nLmRlbGV0ZShpZCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNwYXJlbnQgPSBudWxsO1xuICAgIGZvciAoY29uc3Qgcm9vdCBvZiB0aGlzLiNtYXBwaW5nLnZhbHVlcygpKSB7XG4gICAgICByb290LnJlbW92ZSgpO1xuICAgIH1cbiAgICB0aGlzLiNtYXBwaW5nLmNsZWFyKCk7XG4gICAgdGhpcy4jdG9VcGRhdGUuY2xlYXIoKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvcGRmLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5jb25zdCBwZGZqc1ZlcnNpb24gPSBcIjUuMi4xMzNcIjtcbmNvbnN0IHBkZmpzQnVpbGQgPSBcIjRmNzc2MTM1M1wiO1xue1xuICBnbG9iYWxUaGlzLnBkZmpzVGVzdGluZ1V0aWxzID0ge1xuICAgIEhpZ2hsaWdodE91dGxpbmVyOiBIaWdobGlnaHRPdXRsaW5lclxuICB9O1xufVxuZ2xvYmFsVGhpcy5wZGZqc0xpYiA9IHtcbiAgQWJvcnRFeGNlcHRpb246IEFib3J0RXhjZXB0aW9uLFxuICBBbm5vdGF0aW9uRWRpdG9yTGF5ZXI6IEFubm90YXRpb25FZGl0b3JMYXllcixcbiAgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGU6IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLFxuICBBbm5vdGF0aW9uRWRpdG9yVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUsXG4gIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXI6IEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIsXG4gIEFubm90YXRpb25MYXllcjogQW5ub3RhdGlvbkxheWVyLFxuICBBbm5vdGF0aW9uTW9kZTogQW5ub3RhdGlvbk1vZGUsXG4gIEFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uVHlwZSxcbiAgYnVpbGQ6IGJ1aWxkLFxuICBDb2xvclBpY2tlcjogQ29sb3JQaWNrZXIsXG4gIGNyZWF0ZVZhbGlkQWJzb2x1dGVVcmw6IGNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwsXG4gIERPTVNWR0ZhY3Rvcnk6IERPTVNWR0ZhY3RvcnksXG4gIERyYXdMYXllcjogRHJhd0xheWVyLFxuICBGZWF0dXJlVGVzdDogdXRpbF9GZWF0dXJlVGVzdCxcbiAgZmV0Y2hEYXRhOiBmZXRjaERhdGEsXG4gIGdldERvY3VtZW50OiBnZXREb2N1bWVudCxcbiAgZ2V0RmlsZW5hbWVGcm9tVXJsOiBnZXRGaWxlbmFtZUZyb21VcmwsXG4gIGdldFBkZkZpbGVuYW1lRnJvbVVybDogZ2V0UGRmRmlsZW5hbWVGcm9tVXJsLFxuICBnZXRVdWlkOiBnZXRVdWlkLFxuICBnZXRYZmFQYWdlVmlld3BvcnQ6IGdldFhmYVBhZ2VWaWV3cG9ydCxcbiAgR2xvYmFsV29ya2VyT3B0aW9uczogR2xvYmFsV29ya2VyT3B0aW9ucyxcbiAgSW1hZ2VLaW5kOiB1dGlsX0ltYWdlS2luZCxcbiAgSW52YWxpZFBERkV4Y2VwdGlvbjogSW52YWxpZFBERkV4Y2VwdGlvbixcbiAgaXNEYXRhU2NoZW1lOiBpc0RhdGFTY2hlbWUsXG4gIGlzUGRmRmlsZTogaXNQZGZGaWxlLFxuICBpc1ZhbGlkRXhwbGljaXREZXN0OiBpc1ZhbGlkRXhwbGljaXREZXN0LFxuICBNYXRoQ2xhbXA6IE1hdGhDbGFtcCxcbiAgbm9Db250ZXh0TWVudTogbm9Db250ZXh0TWVudSxcbiAgbm9ybWFsaXplVW5pY29kZTogbm9ybWFsaXplVW5pY29kZSxcbiAgT1BTOiBPUFMsXG4gIE91dHB1dFNjYWxlOiBPdXRwdXRTY2FsZSxcbiAgUGFzc3dvcmRSZXNwb25zZXM6IFBhc3N3b3JkUmVzcG9uc2VzLFxuICBQREZEYXRhUmFuZ2VUcmFuc3BvcnQ6IFBERkRhdGFSYW5nZVRyYW5zcG9ydCxcbiAgUERGRGF0ZVN0cmluZzogUERGRGF0ZVN0cmluZyxcbiAgUERGV29ya2VyOiBQREZXb3JrZXIsXG4gIFBlcm1pc3Npb25GbGFnOiBQZXJtaXNzaW9uRmxhZyxcbiAgUGl4ZWxzUGVySW5jaDogUGl4ZWxzUGVySW5jaCxcbiAgUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uOiBSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24sXG4gIFJlc3BvbnNlRXhjZXB0aW9uOiBSZXNwb25zZUV4Y2VwdGlvbixcbiAgc2V0TGF5ZXJEaW1lbnNpb25zOiBzZXRMYXllckRpbWVuc2lvbnMsXG4gIHNoYWRvdzogc2hhZG93LFxuICBTaWduYXR1cmVFeHRyYWN0b3I6IFNpZ25hdHVyZUV4dHJhY3RvcixcbiAgc3RvcEV2ZW50OiBzdG9wRXZlbnQsXG4gIFN1cHBvcnRlZEltYWdlTWltZVR5cGVzOiBTdXBwb3J0ZWRJbWFnZU1pbWVUeXBlcyxcbiAgVGV4dExheWVyOiBUZXh0TGF5ZXIsXG4gIFRvdWNoTWFuYWdlcjogVG91Y2hNYW5hZ2VyLFxuICB1cGRhdGVVcmxIYXNoOiB1cGRhdGVVcmxIYXNoLFxuICBVdGlsOiBVdGlsLFxuICBWZXJib3NpdHlMZXZlbDogVmVyYm9zaXR5TGV2ZWwsXG4gIHZlcnNpb246IHZlcnNpb24sXG4gIFhmYUxheWVyOiBYZmFMYXllclxufTtcblxuZXhwb3J0IHsgQWJvcnRFeGNlcHRpb24sIEFubm90YXRpb25FZGl0b3JMYXllciwgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUsIEFubm90YXRpb25FZGl0b3JUeXBlLCBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLCBBbm5vdGF0aW9uTGF5ZXIsIEFubm90YXRpb25Nb2RlLCBBbm5vdGF0aW9uVHlwZSwgQ29sb3JQaWNrZXIsIERPTVNWR0ZhY3RvcnksIERyYXdMYXllciwgdXRpbF9GZWF0dXJlVGVzdCBhcyBGZWF0dXJlVGVzdCwgR2xvYmFsV29ya2VyT3B0aW9ucywgdXRpbF9JbWFnZUtpbmQgYXMgSW1hZ2VLaW5kLCBJbnZhbGlkUERGRXhjZXB0aW9uLCBNYXRoQ2xhbXAsIE9QUywgT3V0cHV0U2NhbGUsIFBERkRhdGFSYW5nZVRyYW5zcG9ydCwgUERGRGF0ZVN0cmluZywgUERGV29ya2VyLCBQYXNzd29yZFJlc3BvbnNlcywgUGVybWlzc2lvbkZsYWcsIFBpeGVsc1BlckluY2gsIFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiwgUmVzcG9uc2VFeGNlcHRpb24sIFNpZ25hdHVyZUV4dHJhY3RvciwgU3VwcG9ydGVkSW1hZ2VNaW1lVHlwZXMsIFRleHRMYXllciwgVG91Y2hNYW5hZ2VyLCBVdGlsLCBWZXJib3NpdHlMZXZlbCwgWGZhTGF5ZXIsIGJ1aWxkLCBjcmVhdGVWYWxpZEFic29sdXRlVXJsLCBmZXRjaERhdGEsIGdldERvY3VtZW50LCBnZXRGaWxlbmFtZUZyb21VcmwsIGdldFBkZkZpbGVuYW1lRnJvbVVybCwgZ2V0VXVpZCwgZ2V0WGZhUGFnZVZpZXdwb3J0LCBpc0RhdGFTY2hlbWUsIGlzUGRmRmlsZSwgaXNWYWxpZEV4cGxpY2l0RGVzdCwgbm9Db250ZXh0TWVudSwgbm9ybWFsaXplVW5pY29kZSwgc2V0TGF5ZXJEaW1lbnNpb25zLCBzaGFkb3csIHN0b3BFdmVudCwgdXBkYXRlVXJsSGFzaCwgdmVyc2lvbiB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wZGYubWpzLm1hcCJdLCJuYW1lcyI6WyJpc05vZGVKUyIsInByb2Nlc3MiLCJ2ZXJzaW9ucyIsIm53IiwiZWxlY3Ryb24iLCJ0eXBlIiwiRk9OVF9JREVOVElUWV9NQVRSSVgiLCJMSU5FX0ZBQ1RPUiIsIkxJTkVfREVTQ0VOVF9GQUNUT1IiLCJCQVNFTElORV9GQUNUT1IiLCJSZW5kZXJpbmdJbnRlbnRGbGFnIiwiQU5ZIiwiRElTUExBWSIsIlBSSU5UIiwiU0FWRSIsIkFOTk9UQVRJT05TX0ZPUk1TIiwiQU5OT1RBVElPTlNfU1RPUkFHRSIsIkFOTk9UQVRJT05TX0RJU0FCTEUiLCJJU19FRElUSU5HIiwiT1BMSVNUIiwiQW5ub3RhdGlvbk1vZGUiLCJESVNBQkxFIiwiRU5BQkxFIiwiRU5BQkxFX0ZPUk1TIiwiRU5BQkxFX1NUT1JBR0UiLCJBbm5vdGF0aW9uRWRpdG9yUHJlZml4IiwiQW5ub3RhdGlvbkVkaXRvclR5cGUiLCJOT05FIiwiRlJFRVRFWFQiLCJISUdITElHSFQiLCJTVEFNUCIsIklOSyIsIlNJR05BVFVSRSIsIkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlIiwiUkVTSVpFIiwiQ1JFQVRFIiwiRlJFRVRFWFRfU0laRSIsIkZSRUVURVhUX0NPTE9SIiwiRlJFRVRFWFRfT1BBQ0lUWSIsIklOS19DT0xPUiIsIklOS19USElDS05FU1MiLCJJTktfT1BBQ0lUWSIsIkhJR0hMSUdIVF9DT0xPUiIsIkhJR0hMSUdIVF9ERUZBVUxUX0NPTE9SIiwiSElHSExJR0hUX1RISUNLTkVTUyIsIkhJR0hMSUdIVF9GUkVFIiwiSElHSExJR0hUX1NIT1dfQUxMIiwiRFJBV19TVEVQIiwiUGVybWlzc2lvbkZsYWciLCJNT0RJRllfQ09OVEVOVFMiLCJDT1BZIiwiTU9ESUZZX0FOTk9UQVRJT05TIiwiRklMTF9JTlRFUkFDVElWRV9GT1JNUyIsIkNPUFlfRk9SX0FDQ0VTU0lCSUxJVFkiLCJBU1NFTUJMRSIsIlBSSU5UX0hJR0hfUVVBTElUWSIsIlRleHRSZW5kZXJpbmdNb2RlIiwiRklMTCIsIlNUUk9LRSIsIkZJTExfU1RST0tFIiwiSU5WSVNJQkxFIiwiRklMTF9BRERfVE9fUEFUSCIsIlNUUk9LRV9BRERfVE9fUEFUSCIsIkZJTExfU1RST0tFX0FERF9UT19QQVRIIiwiQUREX1RPX1BBVEgiLCJGSUxMX1NUUk9LRV9NQVNLIiwiQUREX1RPX1BBVEhfRkxBRyIsInV0aWxfSW1hZ2VLaW5kIiwiR1JBWVNDQUxFXzFCUFAiLCJSR0JfMjRCUFAiLCJSR0JBXzMyQlBQIiwiQW5ub3RhdGlvblR5cGUiLCJURVhUIiwiTElOSyIsIkxJTkUiLCJTUVVBUkUiLCJDSVJDTEUiLCJQT0xZR09OIiwiUE9MWUxJTkUiLCJVTkRFUkxJTkUiLCJTUVVJR0dMWSIsIlNUUklLRU9VVCIsIkNBUkVUIiwiUE9QVVAiLCJGSUxFQVRUQUNITUVOVCIsIlNPVU5EIiwiTU9WSUUiLCJXSURHRVQiLCJTQ1JFRU4iLCJQUklOVEVSTUFSSyIsIlRSQVBORVQiLCJXQVRFUk1BUksiLCJUSFJFRUQiLCJSRURBQ1QiLCJBbm5vdGF0aW9uUmVwbHlUeXBlIiwiR1JPVVAiLCJSRVBMWSIsIkFubm90YXRpb25GbGFnIiwiSElEREVOIiwiTk9aT09NIiwiTk9ST1RBVEUiLCJOT1ZJRVciLCJSRUFET05MWSIsIkxPQ0tFRCIsIlRPR0dMRU5PVklFVyIsIkxPQ0tFRENPTlRFTlRTIiwiQW5ub3RhdGlvbkZpZWxkRmxhZyIsIlJFUVVJUkVEIiwiTk9FWFBPUlQiLCJNVUxUSUxJTkUiLCJQQVNTV09SRCIsIk5PVE9HR0xFVE9PRkYiLCJSQURJTyIsIlBVU0hCVVRUT04iLCJDT01CTyIsIkVESVQiLCJTT1JUIiwiRklMRVNFTEVDVCIsIk1VTFRJU0VMRUNUIiwiRE9OT1RTUEVMTENIRUNLIiwiRE9OT1RTQ1JPTEwiLCJDT01CIiwiUklDSFRFWFQiLCJSQURJT1NJTlVOSVNPTiIsIkNPTU1JVE9OU0VMQ0hBTkdFIiwiQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZSIsIlNPTElEIiwiREFTSEVEIiwiQkVWRUxFRCIsIklOU0VUIiwiQW5ub3RhdGlvbkFjdGlvbkV2ZW50VHlwZSIsIkUiLCJYIiwiRCIsIlUiLCJGbyIsIkJsIiwiUE8iLCJQQyIsIlBWIiwiUEkiLCJLIiwiRiIsIlYiLCJDIiwiRG9jdW1lbnRBY3Rpb25FdmVudFR5cGUiLCJXQyIsIldTIiwiRFMiLCJXUCIsIkRQIiwiUGFnZUFjdGlvbkV2ZW50VHlwZSIsIk8iLCJWZXJib3NpdHlMZXZlbCIsIkVSUk9SUyIsIldBUk5JTkdTIiwiSU5GT1MiLCJPUFMiLCJkZXBlbmRlbmN5Iiwic2V0TGluZVdpZHRoIiwic2V0TGluZUNhcCIsInNldExpbmVKb2luIiwic2V0TWl0ZXJMaW1pdCIsInNldERhc2giLCJzZXRSZW5kZXJpbmdJbnRlbnQiLCJzZXRGbGF0bmVzcyIsInNldEdTdGF0ZSIsInNhdmUiLCJyZXN0b3JlIiwidHJhbnNmb3JtIiwibW92ZVRvIiwibGluZVRvIiwiY3VydmVUbyIsImN1cnZlVG8yIiwiY3VydmVUbzMiLCJjbG9zZVBhdGgiLCJyZWN0YW5nbGUiLCJzdHJva2UiLCJjbG9zZVN0cm9rZSIsImZpbGwiLCJlb0ZpbGwiLCJmaWxsU3Ryb2tlIiwiZW9GaWxsU3Ryb2tlIiwiY2xvc2VGaWxsU3Ryb2tlIiwiY2xvc2VFT0ZpbGxTdHJva2UiLCJlbmRQYXRoIiwiY2xpcCIsImVvQ2xpcCIsImJlZ2luVGV4dCIsImVuZFRleHQiLCJzZXRDaGFyU3BhY2luZyIsInNldFdvcmRTcGFjaW5nIiwic2V0SFNjYWxlIiwic2V0TGVhZGluZyIsInNldEZvbnQiLCJzZXRUZXh0UmVuZGVyaW5nTW9kZSIsInNldFRleHRSaXNlIiwibW92ZVRleHQiLCJzZXRMZWFkaW5nTW92ZVRleHQiLCJzZXRUZXh0TWF0cml4IiwibmV4dExpbmUiLCJzaG93VGV4dCIsInNob3dTcGFjZWRUZXh0IiwibmV4dExpbmVTaG93VGV4dCIsIm5leHRMaW5lU2V0U3BhY2luZ1Nob3dUZXh0Iiwic2V0Q2hhcldpZHRoIiwic2V0Q2hhcldpZHRoQW5kQm91bmRzIiwic2V0U3Ryb2tlQ29sb3JTcGFjZSIsInNldEZpbGxDb2xvclNwYWNlIiwic2V0U3Ryb2tlQ29sb3IiLCJzZXRTdHJva2VDb2xvck4iLCJzZXRGaWxsQ29sb3IiLCJzZXRGaWxsQ29sb3JOIiwic2V0U3Ryb2tlR3JheSIsInNldEZpbGxHcmF5Iiwic2V0U3Ryb2tlUkdCQ29sb3IiLCJzZXRGaWxsUkdCQ29sb3IiLCJzZXRTdHJva2VDTVlLQ29sb3IiLCJzZXRGaWxsQ01ZS0NvbG9yIiwic2hhZGluZ0ZpbGwiLCJiZWdpbklubGluZUltYWdlIiwiYmVnaW5JbWFnZURhdGEiLCJlbmRJbmxpbmVJbWFnZSIsInBhaW50WE9iamVjdCIsIm1hcmtQb2ludCIsIm1hcmtQb2ludFByb3BzIiwiYmVnaW5NYXJrZWRDb250ZW50IiwiYmVnaW5NYXJrZWRDb250ZW50UHJvcHMiLCJlbmRNYXJrZWRDb250ZW50IiwiYmVnaW5Db21wYXQiLCJlbmRDb21wYXQiLCJwYWludEZvcm1YT2JqZWN0QmVnaW4iLCJwYWludEZvcm1YT2JqZWN0RW5kIiwiYmVnaW5Hcm91cCIsImVuZEdyb3VwIiwiYmVnaW5Bbm5vdGF0aW9uIiwiZW5kQW5ub3RhdGlvbiIsInBhaW50SW1hZ2VNYXNrWE9iamVjdCIsInBhaW50SW1hZ2VNYXNrWE9iamVjdEdyb3VwIiwicGFpbnRJbWFnZVhPYmplY3QiLCJwYWludElubGluZUltYWdlWE9iamVjdCIsInBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXAiLCJwYWludEltYWdlWE9iamVjdFJlcGVhdCIsInBhaW50SW1hZ2VNYXNrWE9iamVjdFJlcGVhdCIsInBhaW50U29saWRDb2xvckltYWdlTWFzayIsImNvbnN0cnVjdFBhdGgiLCJzZXRTdHJva2VUcmFuc3BhcmVudCIsInNldEZpbGxUcmFuc3BhcmVudCIsInJhd0ZpbGxQYXRoIiwiRHJhd09QUyIsIlBhc3N3b3JkUmVzcG9uc2VzIiwiTkVFRF9QQVNTV09SRCIsIklOQ09SUkVDVF9QQVNTV09SRCIsInZlcmJvc2l0eSIsInNldFZlcmJvc2l0eUxldmVsIiwibGV2ZWwiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJnZXRWZXJib3NpdHlMZXZlbCIsImluZm8iLCJtc2ciLCJjb25zb2xlIiwibG9nIiwid2FybiIsInVucmVhY2hhYmxlIiwiRXJyb3IiLCJhc3NlcnQiLCJjb25kIiwiX2lzVmFsaWRQcm90b2NvbCIsInVybCIsInByb3RvY29sIiwiY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCIsImJhc2VVcmwiLCJvcHRpb25zIiwiYWRkRGVmYXVsdFByb3RvY29sIiwic3RhcnRzV2l0aCIsImRvdHMiLCJtYXRjaCIsImxlbmd0aCIsInRyeUNvbnZlcnRFbmNvZGluZyIsInN0cmluZ1RvVVRGOFN0cmluZyIsImFic29sdXRlVXJsIiwiVVJMIiwicGFyc2UiLCJ1cGRhdGVVcmxIYXNoIiwiaGFzaCIsImFsbG93UmVsIiwicmVzIiwiaHJlZiIsInNwbGl0Iiwic2hhZG93Iiwib2JqIiwicHJvcCIsInZhbHVlIiwibm9uU2VyaWFsaXphYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJCYXNlRXhjZXB0aW9uIiwiQmFzZUV4Y2VwdGlvbkNsb3N1cmUiLCJtZXNzYWdlIiwibmFtZSIsInByb3RvdHlwZSIsImNvbnN0cnVjdG9yIiwiUGFzc3dvcmRFeGNlcHRpb24iLCJjb2RlIiwiVW5rbm93bkVycm9yRXhjZXB0aW9uIiwiZGV0YWlscyIsIkludmFsaWRQREZFeGNlcHRpb24iLCJSZXNwb25zZUV4Y2VwdGlvbiIsInN0YXR1cyIsIm1pc3NpbmciLCJGb3JtYXRFcnJvciIsIkFib3J0RXhjZXB0aW9uIiwiYnl0ZXNUb1N0cmluZyIsImJ5dGVzIiwidW5kZWZpbmVkIiwiTUFYX0FSR1VNRU5UX0NPVU5UIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiYXBwbHkiLCJzdHJCdWYiLCJpIiwiY2h1bmtFbmQiLCJNYXRoIiwibWluIiwiY2h1bmsiLCJzdWJhcnJheSIsInB1c2giLCJqb2luIiwic3RyaW5nVG9CeXRlcyIsInN0ciIsIlVpbnQ4QXJyYXkiLCJjaGFyQ29kZUF0Iiwic3RyaW5nMzIiLCJvYmplY3RTaXplIiwia2V5cyIsImlzTGl0dGxlRW5kaWFuIiwiYnVmZmVyOCIsInZpZXczMiIsIlVpbnQzMkFycmF5IiwiYnVmZmVyIiwiaXNFdmFsU3VwcG9ydGVkIiwiRnVuY3Rpb24iLCJ1dGlsX0ZlYXR1cmVUZXN0IiwiaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQiLCJPZmZzY3JlZW5DYW52YXMiLCJpc0ltYWdlRGVjb2RlclN1cHBvcnRlZCIsIkltYWdlRGVjb2RlciIsInBsYXRmb3JtIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaXNBbmRyb2lkIiwiaW5jbHVkZXMiLCJpc0xpbnV4IiwiaXNNYWMiLCJpc1dpbmRvd3MiLCJpc0ZpcmVmb3giLCJpc0NTU1JvdW5kU3VwcG9ydGVkIiwiZ2xvYmFsVGhpcyIsIkNTUyIsInN1cHBvcnRzIiwiaGV4TnVtYmVycyIsIkFycmF5IiwiZnJvbSIsIm4iLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiVXRpbCIsIm1ha2VIZXhDb2xvciIsInIiLCJnIiwiYiIsInNjYWxlTWluTWF4IiwibWluTWF4IiwidGVtcCIsIm0xIiwibTIiLCJhcHBseVRyYW5zZm9ybSIsInAiLCJtIiwicG9zIiwicDAiLCJwMSIsImFwcGx5VHJhbnNmb3JtVG9CZXppZXIiLCJtMCIsIm0zIiwibTQiLCJtNSIsInBJIiwicEkxIiwiYXBwbHlJbnZlcnNlVHJhbnNmb3JtIiwiZCIsImF4aWFsQWxpZ25lZEJvdW5kaW5nQm94IiwicmVjdCIsIm91dHB1dCIsInIwIiwicjEiLCJyMiIsInIzIiwiYTAiLCJhMiIsImExIiwiYTMiLCJiMCIsImIyIiwiYjEiLCJiMyIsIm0xcjAiLCJtMXIyIiwibTJyMSIsIm0ycjMiLCJtYXgiLCJpbnZlcnNlVHJhbnNmb3JtIiwic2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUiLCJtYXRyaXgiLCJhIiwiYyIsImZpcnN0Iiwic2Vjb25kIiwic3FydCIsIm5vcm1hbGl6ZVJlY3QiLCJzbGljZSIsImludGVyc2VjdCIsInJlY3QxIiwicmVjdDIiLCJ4TG93IiwieEhpZ2giLCJ5TG93IiwieUhpZ2giLCJwb2ludEJvdW5kaW5nQm94IiwieCIsInkiLCJyZWN0Qm91bmRpbmdCb3giLCJ4MCIsInkwIiwieDEiLCJ5MSIsImdldEV4dHJlbXVtT25DdXJ2ZSIsIngyIiwieDMiLCJ5MiIsInkzIiwidCIsIm10IiwidHQiLCJ0dHQiLCJnZXRFeHRyZW11bSIsImFicyIsImRlbHRhIiwic3FydERlbHRhIiwiYmV6aWVyQm91bmRpbmdCb3giLCJQREZTdHJpbmdUcmFuc2xhdGVUYWJsZSIsInN0cmluZ1RvUERGU3RyaW5nIiwiZW5jb2RpbmciLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJmYXRhbCIsImRlY29kZWQiLCJkZWNvZGUiLCJyZXBsYWNlQWxsIiwiZXgiLCJpaSIsImNoYXJDb2RlIiwiY2hhckF0IiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZXNjYXBlIiwidXRmOFN0cmluZ1RvU3RyaW5nIiwidW5lc2NhcGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJpc0FycmF5RXF1YWwiLCJhcnIxIiwiYXJyMiIsImdldE1vZGlmaWNhdGlvbkRhdGUiLCJkYXRlIiwiRGF0ZSIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiZ2V0VVRDSG91cnMiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDU2Vjb25kcyIsIk5vcm1hbGl6ZVJlZ2V4IiwiTm9ybWFsaXphdGlvbk1hcCIsIm5vcm1hbGl6ZVVuaWNvZGUiLCJNYXAiLCJfIiwicDIiLCJub3JtYWxpemUiLCJnZXQiLCJnZXRVdWlkIiwiY3J5cHRvIiwicmFuZG9tVVVJRCIsImJ1ZiIsImdldFJhbmRvbVZhbHVlcyIsIkFubm90YXRpb25QcmVmaXgiLCJfaXNWYWxpZEV4cGxpY2l0RGVzdCIsInZhbGlkUmVmIiwidmFsaWROYW1lIiwiZGVzdCIsImlzQXJyYXkiLCJwYWdlIiwiem9vbSIsImFyZ3MiLCJhcmdzTGVuIiwiYWxsb3dOdWxsIiwiYXJnIiwiTWF0aENsYW1wIiwidiIsInRvSGV4VXRpbCIsImFyciIsInRvSGV4IiwibnVtIiwidG9CYXNlNjRVdGlsIiwidG9CYXNlNjQiLCJidG9hIiwiZnJvbUJhc2U2NFV0aWwiLCJmcm9tQmFzZTY0IiwiYXRvYiIsIlByb21pc2UiLCJ0cnkiLCJmbiIsInJlc29sdmUiLCJzdW1QcmVjaXNlIiwibnVtYmVycyIsInJlZHVjZSIsIlNWR19OUyIsIlBpeGVsc1BlckluY2giLCJQREYiLCJQREZfVE9fQ1NTX1VOSVRTIiwiZmV0Y2hEYXRhIiwiaXNWYWxpZEZldGNoVXJsIiwiZG9jdW1lbnQiLCJiYXNlVVJJIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwic3RhdHVzVGV4dCIsImFycmF5QnVmZmVyIiwiYmxvYiIsImpzb24iLCJ0ZXh0IiwicmVqZWN0IiwicmVxdWVzdCIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsInJlc3BvbnNlVHlwZSIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlYWR5U3RhdGUiLCJET05FIiwicmVzcG9uc2VUZXh0Iiwic2VuZCIsIlBhZ2VWaWV3cG9ydCIsInZpZXdCb3giLCJ1c2VyVW5pdCIsInNjYWxlIiwicm90YXRpb24iLCJvZmZzZXRYIiwib2Zmc2V0WSIsImRvbnRGbGlwIiwiY2VudGVyWCIsImNlbnRlclkiLCJyb3RhdGVBIiwicm90YXRlQiIsInJvdGF0ZUMiLCJyb3RhdGVEIiwib2Zmc2V0Q2FudmFzWCIsIm9mZnNldENhbnZhc1kiLCJ3aWR0aCIsImhlaWdodCIsInJhd0RpbXMiLCJkaW1zIiwicGFnZVdpZHRoIiwicGFnZUhlaWdodCIsInBhZ2VYIiwicGFnZVkiLCJjbG9uZSIsImNvbnZlcnRUb1ZpZXdwb3J0UG9pbnQiLCJjb252ZXJ0VG9WaWV3cG9ydFJlY3RhbmdsZSIsInRvcExlZnQiLCJib3R0b21SaWdodCIsImNvbnZlcnRUb1BkZlBvaW50IiwiUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uIiwiZXh0cmFEZWxheSIsImlzRGF0YVNjaGVtZSIsInRyaW0iLCJzdWJzdHJpbmciLCJ0b0xvd2VyQ2FzZSIsImlzUGRmRmlsZSIsImZpbGVuYW1lIiwidGVzdCIsImdldEZpbGVuYW1lRnJvbVVybCIsImxhc3RJbmRleE9mIiwiZ2V0UGRmRmlsZW5hbWVGcm9tVXJsIiwiZGVmYXVsdEZpbGVuYW1lIiwicmVVUkkiLCJyZUZpbGVuYW1lIiwic3BsaXRVUkkiLCJleGVjIiwic3VnZ2VzdGVkRmlsZW5hbWUiLCJTdGF0VGltZXIiLCJ0aW1lIiwic3RhcnRlZCIsIm5vdyIsInRpbWVFbmQiLCJ0aW1lcyIsInN0YXJ0IiwiZW5kIiwib3V0QnVmIiwibG9uZ2VzdCIsInBhZEVuZCIsImNyZWF0ZSIsIm5vQ29udGV4dE1lbnUiLCJlIiwicHJldmVudERlZmF1bHQiLCJzdG9wRXZlbnQiLCJzdG9wUHJvcGFnYXRpb24iLCJkZXByZWNhdGVkIiwiUERGRGF0ZVN0cmluZyIsInJlZ2V4IiwidG9EYXRlT2JqZWN0IiwiaW5wdXQiLCJSZWdFeHAiLCJtYXRjaGVzIiwieWVhciIsInBhcnNlSW50IiwibW9udGgiLCJkYXkiLCJob3VyIiwibWludXRlIiwidW5pdmVyc2FsVGltZVJlbGF0aW9uIiwib2Zmc2V0SG91ciIsIm9mZnNldE1pbnV0ZSIsIlVUQyIsImdldFhmYVBhZ2VWaWV3cG9ydCIsInhmYVBhZ2UiLCJhdHRyaWJ1dGVzIiwic3R5bGUiLCJnZXRSR0IiLCJjb2xvciIsImNvbG9yUkdCIiwibWFwIiwiZ2V0Q29sb3JWYWx1ZXMiLCJjb2xvcnMiLCJzcGFuIiwiY3JlYXRlRWxlbWVudCIsInZpc2liaWxpdHkiLCJjb2xvclNjaGVtZSIsImJvZHkiLCJhcHBlbmQiLCJjb21wdXRlZENvbG9yIiwid2luZG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInNldCIsInJlbW92ZSIsImdldEN1cnJlbnRUcmFuc2Zvcm0iLCJjdHgiLCJmIiwiZ2V0VHJhbnNmb3JtIiwiZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UiLCJpbnZlcnRTZWxmIiwic2V0TGF5ZXJEaW1lbnNpb25zIiwiZGl2Iiwidmlld3BvcnQiLCJtdXN0RmxpcCIsIm11c3RSb3RhdGUiLCJ1c2VSb3VuZCIsInciLCJoIiwid2lkdGhTdHIiLCJoZWlnaHRTdHIiLCJzZXRBdHRyaWJ1dGUiLCJPdXRwdXRTY2FsZSIsInBpeGVsUmF0aW8iLCJzeCIsInN5Iiwic2NhbGVkIiwic3ltbWV0cmljIiwibGltaXRDYW52YXMiLCJtYXhQaXhlbHMiLCJtYXhEaW0iLCJtYXhBcmVhU2NhbGUiLCJJbmZpbml0eSIsIm1heFdpZHRoU2NhbGUiLCJtYXhIZWlnaHRTY2FsZSIsIm1heFNjYWxlIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIlN1cHBvcnRlZEltYWdlTWltZVR5cGVzIiwiRWRpdG9yVG9vbGJhciIsInRvb2xiYXIiLCJjb2xvclBpY2tlciIsImVkaXRvciIsImJ1dHRvbnMiLCJhbHRUZXh0Iiwic2lnbmF0dXJlRGVzY3JpcHRpb25CdXR0b24iLCJsMTBuUmVtb3ZlIiwiZnJlZXplIiwiZnJlZXRleHQiLCJoaWdobGlnaHQiLCJpbmsiLCJzdGFtcCIsInNpZ25hdHVyZSIsInJlbmRlciIsImVkaXRUb29sYmFyIiwiY2xhc3NMaXN0IiwiYWRkIiwic2lnbmFsIiwiX3VpTWFuYWdlciIsIl9zaWduYWwiLCJhZGRFdmVudExpc3RlbmVyIiwicG9pbnRlckRvd24iLCJjbGFzc05hbWUiLCJwb3NpdGlvbiIsInRvb2xiYXJQb3NpdGlvbiIsImRpcmVjdGlvbiIsImluc2V0SW5saW5lRW5kIiwidG9wIiwiYWRkRGVsZXRlQnV0dG9uIiwiZm9jdXNJbiIsIl9mb2N1c0V2ZW50c0FsbG93ZWQiLCJmb2N1c091dCIsImFkZExpc3RlbmVyc1RvRWxlbWVudCIsImVsZW1lbnQiLCJiaW5kIiwiY2FwdHVyZSIsImhpZGUiLCJoaWRlRHJvcGRvd24iLCJzaG93Iiwic2hvd24iLCJlZGl0b3JUeXBlIiwiYnV0dG9uIiwidGFiSW5kZXgiLCJkZWxldGUiLCJkaXZpZGVyIiwiYWRkQWx0VGV4dCIsInByZXBlbmQiLCJhZGRDb2xvclBpY2tlciIsInJlbmRlckJ1dHRvbiIsImFkZEVkaXRTaWduYXR1cmVCdXR0b24iLCJzaWduYXR1cmVNYW5hZ2VyIiwicmVuZGVyRWRpdEJ1dHRvbiIsInVwZGF0ZUVkaXRTaWduYXR1cmVCdXR0b24iLCJkZXNjcmlwdGlvbiIsInRpdGxlIiwiZGVzdHJveSIsIkhpZ2hsaWdodFRvb2xiYXIiLCJ1aU1hbmFnZXIiLCJhZGRIaWdobGlnaHRCdXR0b24iLCJnZXRMYXN0UG9pbnQiLCJib3hlcyIsImlzTFRSIiwibGFzdFkiLCJsYXN0WCIsImJveCIsInBhcmVudCIsImhpZ2hsaWdodFNlbGVjdGlvbiIsImJpbmRFdmVudHMiLCJuYW1lcyIsIklkTWFuYWdlciIsImlkIiwiSW1hZ2VNYW5hZ2VyIiwiYmFzZUlkIiwiY2FjaGUiLCJfaXNTVkdGaXR0aW5nQ2FudmFzIiwic3ZnIiwiY2FudmFzIiwiZ2V0Q29udGV4dCIsIndpbGxSZWFkRnJlcXVlbnRseSIsImltYWdlIiwiSW1hZ2UiLCJzcmMiLCJwcm9taXNlIiwidGhlbiIsImRyYXdJbWFnZSIsImdldEltYWdlRGF0YSIsImRhdGEiLCJrZXkiLCJyYXdEYXRhIiwiYml0bWFwIiwicmVmQ291bnRlciIsImlzU3ZnIiwiRmlsZSIsImZpbGUiLCJCbG9iIiwibXVzdFJlbW92ZUFzcGVjdFJhdGlvUHJvbWlzZSIsImZpbGVSZWFkZXIiLCJGaWxlUmVhZGVyIiwiaW1hZ2VFbGVtZW50IiwiaW1hZ2VQcm9taXNlIiwib25sb2FkIiwic3ZnVXJsIiwicmVzdWx0Iiwib25lcnJvciIsInJlYWRBc0RhdGFVUkwiLCJjcmVhdGVJbWFnZUJpdG1hcCIsImdldEZyb21GaWxlIiwibGFzdE1vZGlmaWVkIiwic2l6ZSIsImdldEZyb21VcmwiLCJnZXRGcm9tQmxvYiIsImJsb2JQcm9taXNlIiwiZ2V0RnJvbUlkIiwiZ2V0RnJvbUNhbnZhcyIsIm9mZnNjcmVlbiIsInRyYW5zZmVyVG9JbWFnZUJpdG1hcCIsImdldFN2Z1VybCIsImRlbGV0ZUlkIiwidHJhbnNmZXJGcm9tSW1hZ2VCaXRtYXAiLCJjb252ZXJ0VG9CbG9iIiwiY2xvc2UiLCJpc1ZhbGlkSWQiLCJDb21tYW5kTWFuYWdlciIsImNvbW1hbmRzIiwibG9ja2VkIiwibWF4U2l6ZSIsImNtZCIsInVuZG8iLCJwb3N0IiwibXVzdEV4ZWMiLCJOYU4iLCJvdmVyd3JpdGVJZlNhbWVUeXBlIiwia2VlcFVuZG8iLCJuZXh0Iiwic3BsaWNlIiwicmVkbyIsImhhc1NvbWV0aGluZ1RvVW5kbyIsImhhc1NvbWV0aGluZ1RvUmVkbyIsImNsZWFuVHlwZSIsIktleWJvYXJkTWFuYWdlciIsImNhbGxiYWNrcyIsImFsbEtleXMiLCJTZXQiLCJjYWxsYmFjayIsImlzTWFjS2V5IiwiYXQiLCJzZXJpYWxpemUiLCJldmVudCIsImFsdEtleSIsImN0cmxLZXkiLCJtZXRhS2V5Iiwic2hpZnRLZXkiLCJzZWxmIiwiaGFzIiwiYnViYmxlcyIsImNoZWNrZXIiLCJDb2xvck1hbmFnZXIiLCJfY29sb3JzTWFwcGluZyIsIl9jb2xvcnMiLCJjb252ZXJ0IiwicmdiIiwibWF0Y2hNZWRpYSIsIlJHQiIsImV2ZXJ5IiwiZ2V0SGV4Q29kZSIsIkFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIiLCJhYm9ydENvbnRyb2xsZXIiLCJhY3RpdmVFZGl0b3IiLCJhbGxFZGl0b3JzIiwiYWxsTGF5ZXJzIiwiYWx0VGV4dE1hbmFnZXIiLCJhbm5vdGF0aW9uU3RvcmFnZSIsImNoYW5nZWRFeGlzdGluZ0Fubm90YXRpb25zIiwiY29tbWFuZE1hbmFnZXIiLCJjb3B5UGFzdGVBQyIsImN1cnJlbnREcmF3aW5nU2Vzc2lvbiIsImN1cnJlbnRQYWdlSW5kZXgiLCJkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzIiwiZHJhZ2dpbmdFZGl0b3JzIiwiZWRpdG9yVHlwZXMiLCJlZGl0b3JzVG9SZXNjYWxlIiwiZW5hYmxlSGlnaGxpZ2h0RmxvYXRpbmdCdXR0b24iLCJlbmFibGVVcGRhdGVkQWRkSW1hZ2UiLCJlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlIiwiZmlsdGVyRmFjdG9yeSIsImZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCIsImZvY3VzTWFuYWdlckFDIiwiaGlnaGxpZ2h0Q29sb3JzIiwiaGlnaGxpZ2h0V2hlblNoaWZ0VXAiLCJoaWdobGlnaHRUb29sYmFyIiwiaWRNYW5hZ2VyIiwiaXNFbmFibGVkIiwiaXNXYWl0aW5nIiwia2V5Ym9hcmRNYW5hZ2VyQUMiLCJsYXN0QWN0aXZlRWxlbWVudCIsIm1haW5IaWdobGlnaHRDb2xvclBpY2tlciIsIm1pc3NpbmdDYW52YXNlcyIsIm1sTWFuYWdlciIsIm1vZGUiLCJzZWxlY3RlZEVkaXRvcnMiLCJzZWxlY3RlZFRleHROb2RlIiwicGFnZUNvbG9ycyIsInNob3dBbGxTdGF0ZXMiLCJwcmV2aW91c1N0YXRlcyIsInRyYW5zbGF0aW9uIiwidHJhbnNsYXRpb25UaW1lb3V0SWQiLCJjb250YWluZXIiLCJ2aWV3ZXIiLCJ1cGRhdGVNb2RlQ2FwYWJpbGl0eSIsIlRSQU5TTEFURV9TTUFMTCIsIlRSQU5TTEFURV9CSUciLCJfa2V5Ym9hcmRNYW5hZ2VyIiwicHJvdG8iLCJhcnJvd0NoZWNrZXIiLCJjb250YWlucyIsImFjdGl2ZUVsZW1lbnQiLCJ0YWdOYW1lIiwiaGFzU29tZXRoaW5nVG9Db250cm9sIiwidGV4dElucHV0Q2hlY2tlciIsIl9zZWxmIiwidGFyZ2V0IiwiZWwiLCJIVE1MSW5wdXRFbGVtZW50Iiwic21hbGwiLCJiaWciLCJzZWxlY3RBbGwiLCJhZGROZXdFZGl0b3JGcm9tS2V5Ym9hcmQiLCJIVE1MQnV0dG9uRWxlbWVudCIsImlzRW50ZXJIYW5kbGVkIiwidW5zZWxlY3RBbGwiLCJ0cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMiLCJldmVudEJ1cyIsInBkZkRvY3VtZW50IiwiZWRpdG9yVW5kb0JhciIsInN1cHBvcnRzUGluY2hUb1pvb20iLCJBYm9ydENvbnRyb2xsZXIiLCJfZWRpdG9yVW5kb0JhciIsImlzRWRpdGluZyIsImlzRW1wdHkiLCJoYXNTZWxlY3RlZEVkaXRvciIsImhhc1NlbGVjdGVkVGV4dCIsIl9ldmVudEJ1cyIsIl9vbiIsIm9uRWRpdGluZ0FjdGlvbiIsIm9uUGFnZUNoYW5naW5nIiwib25TY2FsZUNoYW5naW5nIiwib25Sb3RhdGlvbkNoYW5naW5nIiwib25TZXRQcmVmZXJlbmNlIiwiZXZ0IiwidXBkYXRlUGFyYW1zIiwiYWRkU2VsZWN0aW9uTGlzdGVuZXIiLCJhZGREcmFnQW5kRHJvcExpc3RlbmVycyIsImFkZEtleWJvYXJkTWFuYWdlciIsInZpZXdQYXJhbWV0ZXJzIiwicmVhbFNjYWxlIiwiaXNTaGlmdEtleURvd24iLCJfc3VwcG9ydHNQaW5jaFRvWm9vbSIsImFib3J0IiwibGF5ZXIiLCJ2YWx1ZXMiLCJjbGVhciIsImNsZWFyVGltZW91dCIsImNvbWJpbmVkU2lnbmFsIiwiYWMiLCJBYm9ydFNpZ25hbCIsImFueSIsInVzZU5ld0FsdFRleHRGbG93IiwidXNlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSIsImhjbUZpbHRlciIsImFkZEhDTUZpbHRlciIsImZvcmVncm91bmQiLCJiYWNrZ3JvdW5kIiwicGFpciIsImhpZ2hsaWdodENvbG9yTmFtZXMiLCJyZXZlcnNlIiwic2V0Q3VycmVudERyYXdpbmdTZXNzaW9uIiwiZGlzYWJsZVVzZXJTZWxlY3QiLCJzZXRNYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXIiLCJlZGl0QWx0VGV4dCIsImZpcnN0VGltZSIsImdldFNpZ25hdHVyZSIsInN3aXRjaFRvTW9kZSIsIm9uIiwib25jZSIsImRpc3BhdGNoIiwic291cmNlIiwic2V0UHJlZmVyZW5jZSIsInBhZ2VOdW1iZXIiLCJmb2N1c01haW5Db250YWluZXIiLCJmb2N1cyIsImZpbmRQYXJlbnQiLCJsYXllclgiLCJsYXllclkiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0b2dnbGUiLCJhZGRTaG91bGRSZXNjYWxlIiwicmVtb3ZlU2hvdWxkUmVzY2FsZSIsImNvbW1pdE9yUmVtb3ZlIiwicGFnZXNSb3RhdGlvbiIsImdldEFuY2hvckVsZW1lbnRGb3JTZWxlY3Rpb24iLCJhbmNob3JOb2RlIiwibm9kZVR5cGUiLCJOb2RlIiwiVEVYVF9OT0RFIiwicGFyZW50RWxlbWVudCIsImdldExheWVyRm9yVGV4dExheWVyIiwidGV4dExheWVyIiwiY3VycmVudExheWVyIiwiaGFzVGV4dExheWVyIiwibWV0aG9kT2ZDcmVhdGlvbiIsInNlbGVjdGlvbiIsImdldFNlbGVjdGlvbiIsImlzQ29sbGFwc2VkIiwiYW5jaG9yT2Zmc2V0IiwiZm9jdXNOb2RlIiwiZm9jdXNPZmZzZXQiLCJhbmNob3JFbGVtZW50IiwiY2xvc2VzdCIsImdldFNlbGVjdGlvbkJveGVzIiwiZW1wdHkiLCJpc05vbmVNb2RlIiwiY3JlYXRlQW5kQWRkTmV3RWRpdG9yIiwic2hvd0FsbEVkaXRvcnMiLCJkaXNwbGF5SGlnaGxpZ2h0VG9vbGJhciIsImFkZFRvQW5ub3RhdGlvblN0b3JhZ2UiLCJzZXRWYWx1ZSIsInNlbGVjdGlvbkNoYW5nZSIsImRpc3BhdGNoVXBkYXRlU3RhdGVzIiwiYWN0aXZlTGF5ZXIiLCJ0b2dnbGVEcmF3aW5nIiwicG9pbnRlcnVwIiwib25TZWxlY3RFbmQiLCJhZGRGb2N1c01hbmFnZXIiLCJibHVyIiwicmVtb3ZlRm9jdXNNYW5hZ2VyIiwiaGFzU2VsZWN0aW9uIiwibGFzdEVkaXRvciIsImtleWRvd24iLCJrZXl1cCIsInJlbW92ZUtleWJvYXJkTWFuYWdlciIsImFkZENvcHlQYXN0ZUxpc3RlbmVycyIsImNvcHkiLCJjdXQiLCJwYXN0ZSIsInJlbW92ZUNvcHlQYXN0ZUxpc3RlbmVycyIsImRyYWdPdmVyIiwiZHJvcCIsImFkZEVkaXRMaXN0ZW5lcnMiLCJyZW1vdmVFZGl0TGlzdGVuZXJzIiwiZGF0YVRyYW5zZmVyIiwiaXRlbXMiLCJpc0hhbmRsaW5nTWltZUZvclBhc3RpbmciLCJkcm9wRWZmZWN0IiwiaXRlbSIsImVkaXRvcnMiLCJzZXJpYWxpemVkIiwiY2xpcGJvYXJkRGF0YSIsInNldERhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwiZ2V0RGF0YSIsIm5ld0VkaXRvcnMiLCJkZXNlcmlhbGl6ZWRFZGl0b3IiLCJkZXNlcmlhbGl6ZSIsImFkZEVkaXRvclRvTGF5ZXIiLCJzZWxlY3RFZGl0b3JzIiwiYWRkQ29tbWFuZHMiLCJpc0VkaXRvckhhbmRsaW5nS2V5Ym9hcmQiLCJoYXNDaGFuZ2VkIiwiZW50cmllcyIsInNvbWUiLCJhc3NpZ24iLCJkaXNwYXRjaFVwZGF0ZVVJIiwic2V0RWRpdGluZ1N0YXRlIiwicmVnaXN0ZXJFZGl0b3JUeXBlcyIsInR5cGVzIiwiZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSIsImdldElkIiwiZ2V0TGF5ZXIiLCJwYWdlSW5kZXgiLCJhZGRMYXllciIsImVuYWJsZSIsImRpc2FibGUiLCJyZW1vdmVMYXllciIsInVwZGF0ZU1vZGUiLCJlZGl0SWQiLCJpc0Zyb21LZXlib2FyZCIsIndpdGhSZXNvbHZlcnMiLCJkaXNhYmxlQWxsIiwibG9hZFNpZ25hdHVyZXMiLCJlbmFibGVBbGwiLCJhbm5vdGF0aW9uRWxlbWVudElkIiwic2V0U2VsZWN0ZWQiLCJlbnRlckluRWRpdE1vZGUiLCJ1bnNlbGVjdCIsImNhbkNyZWF0ZU5ld0VtcHR5RWRpdG9yIiwiYWRkTmV3RWRpdG9yIiwidXBkYXRlVG9vbGJhciIsInVwZGF0ZUNvbG9yIiwiYWN0aW9uIiwidXBkYXRlRGVmYXVsdFBhcmFtcyIsInZpc2libGUiLCJ1cGRhdGVCdXR0b24iLCJzdGF0ZSIsImVuYWJsZVdhaXRpbmciLCJtdXN0V2FpdCIsImRpc2FibGVDbGljayIsImVuYWJsZUNsaWNrIiwicHJvbWlzZXMiLCJhbGwiLCJnZXRFZGl0b3JzIiwiZ2V0RWRpdG9yIiwiYWRkRWRpdG9yIiwicmVtb3ZlRWRpdG9yIiwic2V0VGltZW91dCIsImFkZERlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudCIsImFkZENoYW5nZWRFeGlzdGluZ0Fubm90YXRpb24iLCJkZWxldGVkIiwiaXNEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQiLCJyZW1vdmVEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQiLCJyZW1vdmVDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uIiwiYWRkT3JSZWJ1aWxkIiwic2V0QWN0aXZlRWRpdG9yIiwicHJvcGVydGllc1RvVXBkYXRlIiwibGFzdFNlbGVjdGVkRWRpdG9yIiwiZWQiLCJ1cGRhdGVVSSIsInVwZGF0ZVVJRm9yRGVmYXVsdFByb3BlcnRpZXMiLCJ0b2dnbGVTZWxlY3RlZCIsInNlbGVjdCIsImlzU2VsZWN0ZWQiLCJmaXJzdFNlbGVjdGVkRWRpdG9yIiwicGFyYW1zIiwiY2xlYW5VbmRvU3RhY2siLCJkcmF3aW5nRWRpdG9yIiwiZW5kRHJhd2luZ1Nlc3Npb24iLCJjb21taXQiLCJub0NvbW1pdCIsInRvdGFsWCIsInRvdGFsWSIsIlRJTUVfVE9fV0FJVCIsInRyYW5zbGF0ZUluUGFnZSIsInRyYW5zbGF0aW9uRG9uZSIsInNldFVwRHJhZ1Nlc3Npb24iLCJzYXZlZFgiLCJzYXZlZFkiLCJzYXZlZFBhZ2VJbmRleCIsIm5ld1giLCJuZXdZIiwibmV3UGFnZUluZGV4IiwiZW5kRHJhZ1Nlc3Npb24iLCJtdXN0QmVBZGRlZEluVW5kb1N0YWNrIiwibW92ZSIsIl9zZXRQYXJlbnRBbmRQb3NpdGlvbiIsImRyYWdTZWxlY3RlZEVkaXRvcnMiLCJ0eCIsInR5IiwiZHJhZyIsInJlYnVpbGQiLCJjaGFuZ2VQYXJlbnQiLCJnZXRBY3RpdmUiLCJzaG91bGRHZXRLZXlib2FyZEV2ZW50cyIsImlzQWN0aXZlIiwiZ2V0TW9kZSIsImltYWdlTWFuYWdlciIsInJhbmdlQ291bnQiLCJnZXRSYW5nZUF0IiwiY29tbW9uQW5jZXN0b3JDb250YWluZXIiLCJwYXJlbnRXaWR0aCIsInBhcmVudEhlaWdodCIsInJvdGF0b3IiLCJnZXRBdHRyaWJ1dGUiLCJyYW5nZSIsImNvbGxhcHNlZCIsImdldENsaWVudFJlY3RzIiwicmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQiLCJhbm5vdGF0aW9uIiwiZWRpdG9ySWQiLCJnZXRSYXdWYWx1ZSIsImhhc0JlZW5Nb2RpZmllZCIsInNldE1pc3NpbmdDYW52YXMiLCJhbm5vdGF0aW9uSWQiLCJzZXRDYW52YXMiLCJhZGRNaXNzaW5nQ2FudmFzIiwiQWx0VGV4dCIsImFsdFRleHREZWNvcmF0aXZlIiwiYWx0VGV4dEJ1dHRvbiIsImFsdFRleHRCdXR0b25MYWJlbCIsImFsdFRleHRUb29sdGlwIiwiYWx0VGV4dFRvb2x0aXBUaW1lb3V0IiwiYWx0VGV4dFdhc0Zyb21LZXlCb2FyZCIsImJhZGdlIiwiZ3Vlc3NlZFRleHQiLCJ0ZXh0V2l0aERpc2NsYWltZXIiLCJsMTBuTmV3QnV0dG9uIiwiX2wxMG4iLCJhZGRlZCIsInJldmlldyIsImluaXRpYWxpemUiLCJsMTBuIiwibGFiZWwiLCJvbkNsaWNrIiwiX3JlcG9ydFRlbGVtZXRyeSIsInNldFN0YXRlIiwiZmluaXNoIiwiZm9jdXNWaXNpYmxlIiwiaGFzRGF0YSIsInNldEd1ZXNzZWRUZXh0IiwiZ2VuZXJhdGVkQWx0VGV4dCIsInRvZ2dsZUFsdFRleHRCYWRnZSIsImlzRm9yQ29weWluZyIsImRlY29yYXRpdmUiLCJjYW5jZWwiLCJlbmFibGVkIiwiZGlzYWJsZWQiLCJ0b29sdGlwIiwiREVMQVlfVE9fU0hPV19UT09MVElQIiwicmVtb3ZlQXR0cmlidXRlIiwidGV4dENvbnRlbnQiLCJwYXJlbnROb2RlIiwiZ2V0RWxlbWVudEZvckFsdFRleHQiLCJUb3VjaE1hbmFnZXIiLCJpc1BpbmNoaW5nIiwiaXNQaW5jaGluZ1N0b3BwZWQiLCJpc1BpbmNoaW5nRGlzYWJsZWQiLCJvblBpbmNoU3RhcnQiLCJvblBpbmNoaW5nIiwib25QaW5jaEVuZCIsInBvaW50ZXJEb3duQUMiLCJ0b3VjaEluZm8iLCJ0b3VjaE1hbmFnZXJBQyIsInRvdWNoTW92ZUFDIiwib25Ub3VjaFN0YXJ0IiwicGFzc2l2ZSIsIk1JTl9UT1VDSF9ESVNUQU5DRV9UT19QSU5DSCIsInRvdWNoZXMiLCJvcHRzIiwiY2FuY2VsUG9pbnRlckRvd24iLCJwb2ludGVyVHlwZSIsIm9wdCIsIm9uVG91Y2hNb3ZlIiwib25Ub3VjaEVuZCIsInRvdWNoMCIsInRvdWNoMSIsImlkZW50aWZpZXIiLCJ0b3VjaDBYIiwic2NyZWVuWCIsInRvdWNoMFkiLCJzY3JlZW5ZIiwidG91Y2gxWCIsInRvdWNoMVkiLCJzY3JlZW4wWCIsInNjcmVlbjBZIiwic2NyZWVuMVgiLCJzY3JlZW4xWSIsInBUb3VjaDBYIiwicFRvdWNoMFkiLCJwVG91Y2gxWCIsInBUb3VjaDFZIiwicHJldkdhcFgiLCJwcmV2R2FwWSIsImN1cnJHYXBYIiwiY3VyckdhcFkiLCJkaXN0YW5jZSIsImh5cG90IiwicERpc3RhbmNlIiwib3JpZ2luIiwiQW5ub3RhdGlvbkVkaXRvciIsImFjY2Vzc2liaWxpdHlEYXRhIiwiYWxsUmVzaXplckRpdnMiLCJkcmFnUG9pbnRlcklkIiwiZHJhZ1BvaW50ZXJUeXBlIiwia2VlcEFzcGVjdFJhdGlvIiwicmVzaXplcnNEaXYiLCJsYXN0UG9pbnRlckNvb3JkcyIsInNhdmVkRGltZW5zaW9ucyIsImZvY3VzQUMiLCJmb2N1c2VkUmVzaXplck5hbWUiLCJoYXNCZWVuQ2xpY2tlZCIsImluaXRpYWxSZWN0IiwiaXNJbkVkaXRNb2RlIiwiaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkIiwibW92ZUluRE9NVGltZW91dCIsInByZXZEcmFnWCIsInByZXZEcmFnWSIsInRlbGVtZXRyeVRpbWVvdXRzIiwidG91Y2hNYW5hZ2VyIiwiX2wxMG5SZXNpemVyIiwiaXNEcmFnZ2FibGUiLCJ6SW5kZXgiLCJfYm9yZGVyTGluZVdpZHRoIiwiX2NvbG9yTWFuYWdlciIsIl96SW5kZXgiLCJfdGVsZW1ldHJ5VGltZW91dCIsIl9yZXNpemVyS2V5Ym9hcmRNYW5hZ2VyIiwicmVzaXplIiwiX3Jlc2l6ZVdpdGhLZXlib2FyZCIsIl9zdG9wUmVzaXppbmdXaXRoS2V5Ym9hcmQiLCJwYXJhbWV0ZXJzIiwiX2lzQ29weSIsIl9lZGl0VG9vbGJhciIsIl9pbml0aWFsT3B0aW9ucyIsIl9pbml0aWFsRGF0YSIsIl9pc1Zpc2libGUiLCJfd2lsbEtlZXBBc3BlY3RSYXRpbyIsImlzQ2VudGVyZWQiLCJfc3RydWN0VHJlZVBhcmVudElkIiwicGFnZVJvdGF0aW9uIiwicGFnZURpbWVuc2lvbnMiLCJwYWdlVHJhbnNsYXRpb24iLCJwYXJlbnREaW1lbnNpb25zIiwiaXNBdHRhY2hlZFRvRE9NIiwiZ2V0UHJvdG90eXBlT2YiLCJfdHlwZSIsImlzRHJhd2VyIiwiX2RlZmF1bHRMaW5lQ29sb3IiLCJkZWxldGVBbm5vdGF0aW9uRWxlbWVudCIsImZha2VFZGl0b3IiLCJGYWtlRWRpdG9yIiwiZ2V0TmV4dElkIiwidG9wTWlkZGxlIiwidG9wUmlnaHQiLCJtaWRkbGVSaWdodCIsImJvdHRvbU1pZGRsZSIsImJvdHRvbUxlZnQiLCJtaWRkbGVMZWZ0IiwiZG9jdW1lbnRFbGVtZW50IiwicGFyc2VGbG9hdCIsImdldFByb3BlcnR5VmFsdWUiLCJfdmFsdWUiLCJtaW1lIiwiX2lzRHJhZ2dhYmxlIiwiY2VudGVyIiwicGFyZW50Um90YXRpb24iLCJmaXhBbmRTZXRQb3NpdGlvbiIsInNldEluQmFja2dyb3VuZCIsInNldEluRm9yZWdyb3VuZCIsInNldFBhcmVudCIsInN0b3BSZXNpemluZyIsImZvY3VzaW4iLCJmb2N1c291dCIsInJlbGF0ZWRUYXJnZXQiLCJpc011bHRpcGxlU2VsZWN0aW9uIiwic2V0QXQiLCJzY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbiIsIl9tb3ZlQWZ0ZXJQYXN0ZSIsImJhc2VYIiwiYmFzZVkiLCJfb25UcmFuc2xhdGVkIiwidHJhbnNsYXRlIiwiX29uVHJhbnNsYXRpbmciLCJzY3JvbGxJbnRvVmlldyIsImJsb2NrIiwiZmluZE5ld1BhcmVudCIsImZsb29yIiwiYngiLCJieSIsImdldEJhc2VUcmFuc2xhdGlvbiIsImxlZnQiLCJ0b0ZpeGVkIiwiX2hhc0JlZW5Nb3ZlZCIsIl9oYXNCZWVuUmVzaXplZCIsIl9tdXN0Rml4UG9zaXRpb24iLCJtb3ZlSW5ET00iLCJyb3RhdGVQb2ludCIsImFuZ2xlIiwicGFnZVRyYW5zbGF0aW9uVG9TY3JlZW4iLCJnZXRSb3RhdGlvbk1hdHJpeCIsInBhcmVudFNjYWxlIiwic2V0RGltcyIsImZpeERpbXMiLCJ3aWR0aFBlcmNlbnQiLCJlbmRzV2l0aCIsImhlaWdodFBlcmNlbnQiLCJnZXRJbml0aWFsVHJhbnNsYXRpb24iLCJjcmVhdGVSZXNpemVycyIsImNsYXNzZXMiLCJyZXNpemVyUG9pbnRlcmRvd24iLCJzYXZlZERyYWdnYWJsZSIsInRvZ2dsZVBvaW50ZXJFdmVudHMiLCJyZXNpemVyUG9pbnRlcm1vdmUiLCJzYXZlZFdpZHRoIiwic2F2ZWRIZWlnaHQiLCJzYXZlZFBhcmVudEN1cnNvciIsImN1cnNvciIsInNhdmVkQ3Vyc29yIiwicG9pbnRlclVwQ2FsbGJhY2siLCJhZGRSZXNpemVUb1VuZG9TdGFjayIsIl9vblJlc2l6ZWQiLCJuZXdXaWR0aCIsIm5ld0hlaWdodCIsIl9yb3VuZCIsInJvdW5kIiwibWluV2lkdGgiLCJNSU5fU0laRSIsIm1pbkhlaWdodCIsInJvdGF0aW9uTWF0cml4IiwidHJhbnNmIiwiaW52Um90YXRpb25NYXRyaXgiLCJpbnZUcmFuc2YiLCJnZXRQb2ludCIsImdldE9wcG9zaXRlIiwiaXNEaWFnb25hbCIsImlzSG9yaXpvbnRhbCIsInBvaW50Iiwib3Bwb3NpdGVQb2ludCIsInRyYW5zZk9wcG9zaXRlUG9pbnQiLCJvcHBvc2l0ZVgiLCJvcHBvc2l0ZVkiLCJyYXRpb1giLCJyYXRpb1kiLCJkZWx0YVgiLCJkZWx0YVkiLCJmcm9tS2V5Ym9hcmQiLCJsYXN0U2NyZWVuWCIsImxhc3RTY3JlZW5ZIiwib2xkRGlhZyIsIl9vblJlc2l6aW5nIiwiYWx0VGV4dEZpbmlzaCIsImFkZEVkaXRUb29sYmFyIiwicmVtb3ZlRWRpdFRvb2xiYXIiLCJhZGRDb250YWluZXIiLCJlZGl0VG9vbGJhckRpdiIsImJlZm9yZSIsImdldENsaWVudERpbWVuc2lvbnMiLCJhZGRBbHRUZXh0QnV0dG9uIiwiYWx0VGV4dERhdGEiLCJndWVzc2VkQWx0VGV4dCIsInNldEd1ZXNzZWRBbHRUZXh0Iiwic2VyaWFsaXplQWx0VGV4dCIsImhhc0FsdFRleHQiLCJoYXNBbHRUZXh0RGF0YSIsImRlZmF1bHRMMTBuSWQiLCJhZGRGb2N1c0xpc3RlbmVycyIsIm1heFdpZHRoIiwibWF4SGVpZ2h0IiwiaXNSZXNpemFibGUiLCJ0b3VjaFBpbmNoU3RhcnRDYWxsYmFjayIsInRvdWNoUGluY2hDYWxsYmFjayIsInRvdWNoUGluY2hFbmRDYWxsYmFjayIsIl9vcmlnaW4iLCJwcmV2RGlzdGFuY2UiLCJzbG93RG93bkZhY3RvciIsImZhY3RvciIsInRyYW5zZkNlbnRlclBvaW50IiwibmV3VHJhbnNmQ2VudGVyUG9pbnQiLCJwb2ludGVyZG93biIsInNlbGVjdE9uUG9pbnRlckV2ZW50IiwiaGFzRHJhZ2dpbmdTdGFydGVkIiwiY2FuY2VsRHJhZyIsIl9vblN0b3BEcmFnZ2luZyIsImNsaWVudFgiLCJjbGllbnRZIiwicG9pbnRlcklkIiwiX29uU3RhcnREcmFnZ2luZyIsImlzUHJpbWFyeSIsIm1vdmVFZGl0b3JJbkRPTSIsImdldFJlY3QiLCJzaGlmdFgiLCJzaGlmdFkiLCJnZXRSZWN0SW5DdXJyZW50Q29vcmRzIiwib25jZUFkZGVkIiwiZW5hYmxlRWRpdE1vZGUiLCJkaXNhYmxlRWRpdE1vZGUiLCJuZWVkc1RvQmVSZWJ1aWx0IiwiaXNPblNjcmVlbiIsImJvdHRvbSIsInJpZ2h0IiwiaW5uZXJIZWlnaHQiLCJpbm5lcldpZHRoIiwicm90YXRlIiwiX2FuZ2xlIiwic2VyaWFsaXplRGVsZXRlZCIsInBvcHVwUmVmIiwiY29udGV4dCIsImlzQ29weSIsInRpbWVvdXQiLCJtYWtlUmVzaXphYmxlIiwiY2hpbGRyZW4iLCJib3VuZFJlc2l6ZXJLZXlkb3duIiwicmVzaXplcktleWRvd24iLCJib3VuZFJlc2l6ZXJCbHVyIiwicmVzaXplckJsdXIiLCJyZXNpemVyRm9jdXMiLCJmaXJzdFBvc2l0aW9uIiwibmV4dEZpcnN0UG9zaXRpb24iLCJmaXJzdENoaWxkIiwibGFzdENoaWxkIiwiY2hpbGQiLCJzZXRSZXNpemVyVGFiSW5kZXgiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJwcmV2ZW50U2Nyb2xsIiwiZGlzYWJsZUVkaXRpbmciLCJlbmFibGVFZGl0aW5nIiwiY29udGVudERpdiIsInNldEFzcGVjdFJhdGlvIiwiYXNwZWN0UmF0aW8iLCJ0ZWxlbWV0cnlJbml0aWFsRGF0YSIsInRlbGVtZXRyeUZpbmFsRGF0YSIsImNvbnRlbnQiLCJxdWVyeVNlbGVjdG9yIiwibm9kZU5hbWUiLCJyZXNldEFubm90YXRpb25FbGVtZW50IiwiU0VFRCIsIk1BU0tfSElHSCIsIk1BU0tfTE9XIiwiTXVybXVySGFzaDNfNjQiLCJzZWVkIiwiaDEiLCJoMiIsInVwZGF0ZSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiYnl0ZUxlbmd0aCIsImJsb2NrQ291bnRzIiwidGFpbExlbmd0aCIsImRhdGFVaW50MzIiLCJrMSIsImsyIiwiQzEiLCJDMiIsIkMxX0xPVyIsIkMyX0xPVyIsImhleGRpZ2VzdCIsIlNlcmlhbGl6YWJsZUVtcHR5IiwidHJhbnNmZXIiLCJBbm5vdGF0aW9uU3RvcmFnZSIsIm1vZGlmaWVkIiwibW9kaWZpZWRJZHMiLCJzdG9yYWdlIiwib25TZXRNb2RpZmllZCIsIm9uUmVzZXRNb2RpZmllZCIsIm9uQW5ub3RhdGlvbkVkaXRvciIsImdldFZhbHVlIiwiZGVmYXVsdFZhbHVlIiwicmVzZXRNb2RpZmllZCIsImVudHJ5IiwidmFsIiwic2V0TW9kaWZpZWQiLCJwcmludCIsIlByaW50QW5ub3RhdGlvblN0b3JhZ2UiLCJzZXJpYWxpemFibGUiLCJoYXNCaXRtYXAiLCJlZGl0b3JTdGF0cyIsInN0YXRzIiwidHlwZVRvRWRpdG9yIiwiY291bnRlcnMiLCJjb3VudCIsImNvbXB1dGVUZWxlbWV0cnlGaW5hbERhdGEiLCJyZXNldE1vZGlmaWVkSWRzIiwiaWRzIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJzdHJ1Y3R1cmVkQ2xvbmUiLCJGb250TG9hZGVyIiwic3lzdGVtRm9udHMiLCJvd25lckRvY3VtZW50Iiwic3R5bGVFbGVtZW50IiwiX2RvY3VtZW50IiwibmF0aXZlRm9udEZhY2VzIiwibG9hZGluZ1JlcXVlc3RzIiwibG9hZFRlc3RGb250SWQiLCJhZGROYXRpdmVGb250RmFjZSIsIm5hdGl2ZUZvbnRGYWNlIiwiZm9udHMiLCJyZW1vdmVOYXRpdmVGb250RmFjZSIsImluc2VydFJ1bGUiLCJydWxlIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJzdHlsZVNoZWV0Iiwic2hlZXQiLCJjc3NSdWxlcyIsImxvYWRTeXN0ZW1Gb250Iiwic3lzdGVtRm9udEluZm8iLCJkaXNhYmxlRm9udEZhY2UiLCJfaW5zcGVjdEZvbnQiLCJsb2FkZWROYW1lIiwiaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZCIsImZvbnRGYWNlIiwiRm9udEZhY2UiLCJsb2FkIiwiYmFzZUZvbnROYW1lIiwiZm9udCIsImF0dGFjaGVkIiwibWlzc2luZ0ZpbGUiLCJjcmVhdGVOYXRpdmVGb250RmFjZSIsImxvYWRlZCIsImZhbWlseSIsImNyZWF0ZUZvbnRGYWNlUnVsZSIsImlzU3luY0ZvbnRMb2FkaW5nU3VwcG9ydGVkIiwiX3F1ZXVlTG9hZGluZ0NhbGxiYWNrIiwiX3ByZXBhcmVGb250TG9hZEV2ZW50IiwiaGFzRm9udHMiLCJjb21wbGV0ZVJlcXVlc3QiLCJkb25lIiwib3RoZXJSZXF1ZXN0Iiwic2hpZnQiLCJjb21wbGV0ZSIsIl9sb2FkVGVzdEZvbnQiLCJ0ZXN0Rm9udCIsImludDMyIiwib2Zmc2V0Iiwic3BsaWNlU3RyaW5nIiwicyIsImluc2VydCIsImNodW5rMSIsImNodW5rMiIsImNhbGxlZCIsImlzRm9udFJlYWR5IiwiZmlsbFRleHQiLCJpbWFnZURhdGEiLCJDT01NRU5UX09GRlNFVCIsIkNGRl9DSEVDS1NVTV9PRkZTRVQiLCJYWFhYX1ZBTFVFIiwiY2hlY2tzdW0iLCJmb250RmFtaWx5IiwiRm9udEZhY2VPYmplY3QiLCJ0cmFuc2xhdGVkRGF0YSIsImluc3BlY3RGb250IiwiY29tcGlsZWRHbHlwaHMiLCJjc3NGb250SW5mbyIsImNzcyIsIndlaWdodCIsImZvbnRXZWlnaHQiLCJpdGFsaWNBbmdsZSIsIm1pbWV0eXBlIiwiZ2V0UGF0aEdlbmVyYXRvciIsIm9ianMiLCJjaGFyYWN0ZXIiLCJvYmpJZCIsImNtZHMiLCJwYXRoIiwiUGF0aDJEIiwiZm9udEV4dHJhUHJvcGVydGllcyIsIkNhbGxiYWNrS2luZCIsIkRBVEEiLCJFUlJPUiIsIlN0cmVhbUtpbmQiLCJDQU5DRUwiLCJDQU5DRUxfQ09NUExFVEUiLCJDTE9TRSIsIkVOUVVFVUUiLCJQVUxMIiwiUFVMTF9DT01QTEVURSIsIlNUQVJUX0NPTVBMRVRFIiwib25GbiIsIndyYXBSZWFzb24iLCJNZXNzYWdlSGFuZGxlciIsIm1lc3NhZ2VBQyIsInNvdXJjZU5hbWUiLCJ0YXJnZXROYW1lIiwiY29tT2JqIiwiY2FsbGJhY2tJZCIsInN0cmVhbUlkIiwic3RyZWFtU2lua3MiLCJzdHJlYW1Db250cm9sbGVycyIsImNhbGxiYWNrQ2FwYWJpbGl0aWVzIiwiYWN0aW9uSGFuZGxlciIsIm9uTWVzc2FnZSIsInN0cmVhbSIsInByb2Nlc3NTdHJlYW1NZXNzYWdlIiwiY2FwYWJpbGl0eSIsInJlYXNvbiIsInBvc3RNZXNzYWdlIiwiY3JlYXRlU3RyZWFtU2luayIsImFjdGlvbk5hbWUiLCJoYW5kbGVyIiwiYWgiLCJ0cmFuc2ZlcnMiLCJzZW5kV2l0aFByb21pc2UiLCJzZW5kV2l0aFN0cmVhbSIsInF1ZXVlaW5nU3RyYXRlZ3kiLCJSZWFkYWJsZVN0cmVhbSIsImNvbnRyb2xsZXIiLCJzdGFydENhcGFiaWxpdHkiLCJzdGFydENhbGwiLCJwdWxsQ2FsbCIsImNhbmNlbENhbGwiLCJpc0Nsb3NlZCIsImRlc2lyZWRTaXplIiwicHVsbCIsInB1bGxDYXBhYmlsaXR5IiwiY2FuY2VsQ2FwYWJpbGl0eSIsInN0cmVhbVNpbmsiLCJlbnF1ZXVlIiwiaXNDYW5jZWxsZWQiLCJsYXN0RGVzaXJlZFNpemUiLCJzaW5rQ2FwYWJpbGl0eSIsInJlYWR5IiwiZXJyb3IiLCJvblB1bGwiLCJvbkNhbmNlbCIsInN1Y2Nlc3MiLCJzdHJlYW1Db250cm9sbGVyIiwiZGVsZXRlU3RyZWFtQ29udHJvbGxlciIsImRhdGFSZWFzb24iLCJhbGxTZXR0bGVkIiwiQmFzZUNhbnZhc0ZhY3RvcnkiLCJlbmFibGVIV0EiLCJfY3JlYXRlQ2FudmFzIiwicmVzZXQiLCJjYW52YXNBbmRDb250ZXh0IiwiRE9NQ2FudmFzRmFjdG9yeSIsIkJhc2VDTWFwUmVhZGVyRmFjdG9yeSIsImlzQ29tcHJlc3NlZCIsIl9mZXRjaCIsImNNYXBEYXRhIiwiY2F0Y2giLCJET01DTWFwUmVhZGVyRmFjdG9yeSIsIkJhc2VGaWx0ZXJGYWN0b3J5IiwiYWRkRmlsdGVyIiwibWFwcyIsImZnQ29sb3IiLCJiZ0NvbG9yIiwiYWRkQWxwaGFGaWx0ZXIiLCJhZGRMdW1pbm9zaXR5RmlsdGVyIiwiYWRkSGlnaGxpZ2h0SENNRmlsdGVyIiwiZmlsdGVyTmFtZSIsIm5ld0ZnQ29sb3IiLCJuZXdCZ0NvbG9yIiwia2VlcEhDTSIsIkRPTUZpbHRlckZhY3RvcnkiLCJfY2FjaGUiLCJfZGVmcyIsImRvY0lkIiwiX2hjbUNhY2hlIiwiaGNtQ2FjaGUiLCJkZWZzIiwiY29udGFpbiIsImNyZWF0ZUVsZW1lbnROUyIsImNyZWF0ZVRhYmxlcyIsIm1hcFIiLCJ0YWJsZSIsIm1hcEciLCJtYXBCIiwiYnVmZmVyUiIsImJ1ZmZlckciLCJidWZmZXJCIiwiY3JlYXRlVXJsIiwidGFibGVSIiwidGFibGVHIiwidGFibGVCIiwiZmlsdGVyIiwiY3JlYXRlRmlsdGVyIiwiYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uIiwiZmdSR0IiLCJiZ1JHQiIsImFkZEdyYXlDb252ZXJzaW9uIiwiZ2V0U3RlcHMiLCJ0YWJsZUEiLCJhZGRUcmFuc2Zlck1hcEFscGhhQ29udmVyc2lvbiIsImFkZEx1bWlub3NpdHlDb252ZXJzaW9uIiwiZmdHcmF5IiwiYmdHcmF5IiwibmV3RmdSR0IiLCJuZXdCZ1JHQiIsImZnIiwiYmciLCJzdGVwIiwibmV3U3RhcnQiLCJuZXdTdGVwIiwicHJldiIsImsiLCJqIiwiZmVDb2xvck1hdHJpeCIsImFwcGVuZEZlRnVuYyIsImZlQ29tcG9uZW50VHJhbnNmZXIiLCJmdW5jIiwiZmVGdW5jIiwiclRhYmxlIiwiZ1RhYmxlIiwiYlRhYmxlIiwiYVRhYmxlIiwiQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IiwiRE9NU3RhbmRhcmRGb250RGF0YUZhY3RvcnkiLCJCYXNlV2FzbUZhY3RvcnkiLCJET01XYXNtRmFjdG9yeSIsIm5vZGVfdXRpbHNfZmV0Y2hEYXRhIiwiZnMiLCJnZXRCdWlsdGluTW9kdWxlIiwicmVhZEZpbGUiLCJOb2RlRmlsdGVyRmFjdG9yeSIsIk5vZGVDYW52YXNGYWN0b3J5IiwicmVxdWlyZSIsImNyZWF0ZVJlcXVpcmUiLCJjcmVhdGVDYW52YXMiLCJOb2RlQ01hcFJlYWRlckZhY3RvcnkiLCJOb2RlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkiLCJOb2RlV2FzbUZhY3RvcnkiLCJQYXRoVHlwZSIsIlNIQURJTkciLCJhcHBseUJvdW5kaW5nQm94IiwiYmJveCIsInJlZ2lvbiIsIkJhc2VTaGFkaW5nUGF0dGVybiIsImlzTW9kaWZ5aW5nQ3VycmVudFRyYW5zZm9ybSIsImdldFBhdHRlcm4iLCJSYWRpYWxBeGlhbFNoYWRpbmdQYXR0ZXJuIiwiSVIiLCJfYmJveCIsIl9jb2xvclN0b3BzIiwiX3AwIiwiX3AxIiwiX3IwIiwiX3IxIiwiX2NyZWF0ZUdyYWRpZW50IiwiZ3JhZCIsImNyZWF0ZUxpbmVhckdyYWRpZW50IiwiY3JlYXRlUmFkaWFsR3JhZGllbnQiLCJjb2xvclN0b3AiLCJhZGRDb2xvclN0b3AiLCJvd25lciIsImludmVyc2UiLCJwYXRoVHlwZSIsInBhdHRlcm4iLCJvd25lckJCb3giLCJjdXJyZW50IiwiZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveCIsImNlaWwiLCJ0bXBDYW52YXMiLCJjYWNoZWRDYW52YXNlcyIsImdldENhbnZhcyIsInRtcEN0eCIsImNsZWFyUmVjdCIsImJlZ2luUGF0aCIsImJhc2VUcmFuc2Zvcm0iLCJmaWxsU3R5bGUiLCJjcmVhdGVQYXR0ZXJuIiwiZG9tTWF0cml4IiwiRE9NTWF0cml4Iiwic2V0VHJhbnNmb3JtIiwiZHJhd1RyaWFuZ2xlIiwicDMiLCJjMSIsImMyIiwiYzMiLCJjb29yZHMiLCJyb3dTaXplIiwidG1wIiwic2NhbGVYIiwic2NhbGVZIiwiYzFyIiwiYzFnIiwiYzFiIiwiYzJyIiwiYzJnIiwiYzJiIiwiYzNyIiwiYzNnIiwiYzNiIiwibWluWSIsIm1heFkiLCJ4YSIsImNhciIsImNhZyIsImNhYiIsInhiIiwiY2JyIiwiY2JnIiwiY2JiIiwieDFfIiwieDJfIiwiZHJhd0ZpZ3VyZSIsImZpZ3VyZSIsInBzIiwiY3MiLCJ2ZXJ0aWNlc1BlclJvdyIsInJvd3MiLCJjb2xzIiwicSIsIk1lc2hTaGFkaW5nUGF0dGVybiIsIl9jb29yZHMiLCJfZmlndXJlcyIsIl9ib3VuZHMiLCJfYmFja2dyb3VuZCIsIl9jcmVhdGVNZXNoQ2FudmFzIiwiY29tYmluZWRTY2FsZSIsImJhY2tncm91bmRDb2xvciIsIkVYUEVDVEVEX1NDQUxFIiwiTUFYX1BBVFRFUk5fU0laRSIsIkJPUkRFUl9TSVpFIiwiYm91bmRzV2lkdGgiLCJib3VuZHNIZWlnaHQiLCJwYWRkZWRXaWR0aCIsInBhZGRlZEhlaWdodCIsImNyZWF0ZUltYWdlRGF0YSIsInB1dEltYWdlRGF0YSIsIkZsb2F0MzJBcnJheSIsIm1hdHJpeFNjYWxlWCIsIm1hdHJpeFNjYWxlWSIsInRlbXBvcmFyeVBhdHRlcm5DYW52YXMiLCJEdW1teVNoYWRpbmdQYXR0ZXJuIiwiZ2V0U2hhZGluZ1BhdHRlcm4iLCJQYWludFR5cGUiLCJDT0xPUkVEIiwiVU5DT0xPUkVEIiwiVGlsaW5nUGF0dGVybiIsImNhbnZhc0dyYXBoaWNzRmFjdG9yeSIsIm9wZXJhdG9yTGlzdCIsInhzdGVwIiwieXN0ZXAiLCJwYWludFR5cGUiLCJ0aWxpbmdUeXBlIiwiY3JlYXRlUGF0dGVybkNhbnZhcyIsImNvbWJpbmVkU2NhbGVYIiwiY29tYmluZWRTY2FsZVkiLCJjYW52YXNXaWR0aCIsImNhbnZhc0hlaWdodCIsInJlZHJhd0hvcml6b250YWxseSIsInJlZHJhd1ZlcnRpY2FsbHkiLCJ4U2NhbGVkU3RlcCIsInlTY2FsZWRTdGVwIiwieFNjYWxlZFdpZHRoIiwieVNjYWxlZEhlaWdodCIsImRpbXgiLCJnZXRTaXplQW5kU2NhbGUiLCJkaW15IiwiZ3JhcGhpY3MiLCJjcmVhdGVDYW52YXNHcmFwaGljcyIsImdyb3VwTGV2ZWwiLCJzZXRGaWxsQW5kU3Ryb2tlU3R5bGVUb0NvbnRleHQiLCJjbGlwQmJveCIsImV4ZWN1dGVPcGVyYXRvckxpc3QiLCJlbmREcmF3aW5nIiwiZGlteDIiLCJkaW15MiIsInhTaXplIiwieVNpemUiLCJ0bXBDYW52YXMyIiwidG1wQ3R4MiIsImpqIiwicmVhbE91dHB1dFNpemUiLCJiYm94V2lkdGgiLCJiYm94SGVpZ2h0Iiwic3Ryb2tlU3R5bGUiLCJmaWxsQ29sb3IiLCJzdHJva2VDb2xvciIsImNzc0NvbG9yIiwiY29udmVydFRvUkdCQSIsImtpbmQiLCJJbWFnZUtpbmQiLCJjb252ZXJ0QmxhY2tBbmRXaGl0ZVRvUkdCQSIsImNvbnZlcnRSR0JUb1JHQkEiLCJzcmNQb3MiLCJub25CbGFja0NvbG9yIiwiaW52ZXJzZURlY29kZSIsImJsYWNrIiwiemVyb01hcHBpbmciLCJvbmVNYXBwaW5nIiwid2lkdGhJblNvdXJjZSIsIndpZHRoUmVtYWluZGVyIiwic3JjTGVuZ3RoIiwiZGVzdFBvcyIsImVsZW0iLCJsZW4iLCJsZW4zMiIsInNyYzMyIiwiRmVhdHVyZVRlc3QiLCJzMSIsInMyIiwiczMiLCJncmF5VG9SR0JBIiwiTUlOX0ZPTlRfU0laRSIsIk1BWF9GT05UX1NJWkUiLCJFWEVDVVRJT05fVElNRSIsIkVYRUNVVElPTl9TVEVQUyIsIkZVTExfQ0hVTktfSEVJR0hUIiwiU0NBTEVfTUFUUklYIiwiWFkiLCJNSU5fTUFYX0lOSVQiLCJtaXJyb3JDb250ZXh0T3BlcmF0aW9ucyIsImRlc3RDdHgiLCJfcmVtb3ZlTWlycm9yaW5nIiwiX19vcmlnaW5hbFNhdmUiLCJfX29yaWdpbmFsUmVzdG9yZSIsIl9fb3JpZ2luYWxSb3RhdGUiLCJfX29yaWdpbmFsU2NhbGUiLCJfX29yaWdpbmFsVHJhbnNsYXRlIiwiX19vcmlnaW5hbFRyYW5zZm9ybSIsIl9fb3JpZ2luYWxTZXRUcmFuc2Zvcm0iLCJfX29yaWdpbmFsUmVzZXRUcmFuc2Zvcm0iLCJyZXNldFRyYW5zZm9ybSIsIl9fb3JpZ2luYWxDbGlwIiwiX19vcmlnaW5hbE1vdmVUbyIsIl9fb3JpZ2luYWxMaW5lVG8iLCJfX29yaWdpbmFsQmV6aWVyQ3VydmVUbyIsImJlemllckN1cnZlVG8iLCJfX29yaWdpbmFsUmVjdCIsIl9fb3JpZ2luYWxDbG9zZVBhdGgiLCJfX29yaWdpbmFsQmVnaW5QYXRoIiwiY3AxeCIsImNwMXkiLCJjcDJ4IiwiY3AyeSIsIkNhY2hlZENhbnZhc2VzIiwiY2FudmFzRmFjdG9yeSIsImNhbnZhc0VudHJ5IiwiZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzIiwic3JjSW1nIiwic3JjWCIsInNyY1kiLCJzcmNXIiwic3JjSCIsImRlc3RYIiwiZGVzdFkiLCJkZXN0VyIsImRlc3RIIiwidGxYIiwiclRsWCIsInRsWSIsInJUbFkiLCJiclgiLCJyV2lkdGgiLCJiclkiLCJySGVpZ2h0Iiwic2lnbiIsIkNhbnZhc0V4dHJhU3RhdGUiLCJhbHBoYUlzU2hhcGUiLCJmb250U2l6ZSIsImZvbnRTaXplU2NhbGUiLCJ0ZXh0TWF0cml4IiwidGV4dE1hdHJpeFNjYWxlIiwiZm9udE1hdHJpeCIsImxlYWRpbmciLCJsaW5lWCIsImxpbmVZIiwiY2hhclNwYWNpbmciLCJ3b3JkU3BhY2luZyIsInRleHRIU2NhbGUiLCJ0ZXh0UmVuZGVyaW5nTW9kZSIsInRleHRSaXNlIiwicGF0dGVybkZpbGwiLCJwYXR0ZXJuU3Ryb2tlIiwiZmlsbEFscGhhIiwic3Ryb2tlQWxwaGEiLCJsaW5lV2lkdGgiLCJhY3RpdmVTTWFzayIsInRyYW5zZmVyTWFwcyIsImNsaXBCb3giLCJnZXRQYXRoQm91bmRpbmdCb3giLCJ4U3Ryb2tlUGFkIiwieVN0cm9rZVBhZCIsInVwZGF0ZUNsaXBGcm9tUGF0aCIsInN0YXJ0TmV3UGF0aEFuZENsaXBCb3giLCJpc0VtcHR5Q2xpcCIsInB1dEJpbmFyeUltYWdlRGF0YSIsImltZ0RhdGEiLCJJbWFnZURhdGEiLCJwYXJ0aWFsQ2h1bmtIZWlnaHQiLCJmdWxsQ2h1bmtzIiwidG90YWxDaHVua3MiLCJjaHVua0ltZ0RhdGEiLCJ0aGlzQ2h1bmtIZWlnaHQiLCJlbGVtc0luVGhpc0NodW5rIiwiZGVzdDMyIiwiZGVzdDMyRGF0YUxlbmd0aCIsImZ1bGxTcmNEaWZmIiwid2hpdGUiLCJzcmNEaWZmIiwia0VuZCIsImtFbmRVbnJvbGxlZCIsIm1hc2siLCJzcmNCeXRlIiwicHV0QmluYXJ5SW1hZ2VNYXNrIiwiY29weUN0eFN0YXRlIiwic291cmNlQ3R4IiwicHJvcGVydGllcyIsInByb3BlcnR5Iiwic2V0TGluZURhc2giLCJnZXRMaW5lRGFzaCIsImxpbmVEYXNoT2Zmc2V0IiwicmVzZXRDdHhUb0RlZmF1bHQiLCJmaWxsUnVsZSIsImdsb2JhbEFscGhhIiwibGluZUNhcCIsImxpbmVKb2luIiwibWl0ZXJMaW1pdCIsImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiIsImdldEltYWdlU21vb3RoaW5nRW5hYmxlZCIsImludGVycG9sYXRlIiwiYWN0dWFsU2NhbGUiLCJmcm91bmQiLCJMSU5FX0NBUF9TVFlMRVMiLCJMSU5FX0pPSU5fU1RZTEVTIiwiTk9STUFMX0NMSVAiLCJFT19DTElQIiwiQ2FudmFzR3JhcGhpY3MiLCJjYW52YXNDdHgiLCJjb21tb25PYmpzIiwib3B0aW9uYWxDb250ZW50Q29uZmlnIiwibWFya2VkQ29udGVudFN0YWNrIiwiYW5ub3RhdGlvbkNhbnZhc01hcCIsInN0YXRlU3RhY2siLCJwZW5kaW5nQ2xpcCIsInBlbmRpbmdFT0ZpbGwiLCJ4b2JqcyIsImdyb3VwU3RhY2siLCJiYXNlVHJhbnNmb3JtU3RhY2siLCJzbWFza1N0YWNrIiwic21hc2tDb3VudGVyIiwidGVtcFNNYXNrIiwic3VzcGVuZGVkQ3R4IiwiY29udGVudFZpc2libGUiLCJjYWNoZWRQYXR0ZXJucyIsInZpZXdwb3J0U2NhbGUiLCJvdXRwdXRTY2FsZVgiLCJvdXRwdXRTY2FsZVkiLCJfY2FjaGVkU2NhbGVGb3JTdHJva2luZyIsIl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoIiwiX2NhY2hlZEJpdG1hcHNNYXAiLCJnZXRPYmplY3QiLCJmYWxsYmFjayIsImJlZ2luRHJhd2luZyIsInRyYW5zcGFyZW5jeSIsInNhdmVkRmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJ0cmFuc3BhcmVudENhbnZhcyIsImNvbXBvc2l0ZUN0eCIsImV4ZWN1dGlvblN0YXJ0SWR4IiwiY29udGludWVDYWxsYmFjayIsInN0ZXBwZXIiLCJhcmdzQXJyYXkiLCJmbkFycmF5IiwiYXJnc0FycmF5TGVuIiwiY2h1bmtPcGVyYXRpb25zIiwiZW5kVGltZSIsInN0ZXBzIiwiZm5JZCIsIm5leHRCcmVha1BvaW50IiwiYnJlYWtJdCIsImRlcE9iaklkIiwib2Jqc1Bvb2wiLCJyZXN0b3JlSW5pdGlhbFN0YXRlIiwiaW5TTWFza01vZGUiLCJIVE1MQ2FudmFzRWxlbWVudCIsImRyYXdGaWx0ZXIiLCJoY21GaWx0ZXJJZCIsInNhdmVkRmlsdGVyIiwiX3NjYWxlSW1hZ2UiLCJpbWciLCJkaXNwbGF5V2lkdGgiLCJkaXNwbGF5SGVpZ2h0Iiwid2lkdGhTY2FsZSIsImhlaWdodFNjYWxlIiwicGFpbnRXaWR0aCIsInBhaW50SGVpZ2h0IiwidG1wQ2FudmFzSWQiLCJfY3JlYXRlTWFza0NhbnZhcyIsImlzUGF0dGVybkZpbGwiLCJjdXJyZW50VHJhbnNmb3JtIiwiY2FjaGVLZXkiLCJtYXNrQ2FudmFzIiwibWFpbktleSIsImNhY2hlZEltYWdlIiwibWFza1RvQ2FudmFzIiwibWluWCIsIm1heFgiLCJkcmF3bldpZHRoIiwiZHJhd25IZWlnaHQiLCJmaWxsQ2FudmFzIiwiZmlsbEN0eCIsImltYWdlU21vb3RoaW5nRW5hYmxlZCIsImxpbWl0IiwiZGFzaEFycmF5IiwiZGFzaFBoYXNlIiwiaW50ZW50IiwiZmxhdG5lc3MiLCJzdGF0ZXMiLCJjaGVja1NNYXNrU3RhdGUiLCJiZWdpblNNYXNrTW9kZSIsImVuZFNNYXNrTW9kZSIsImNhY2hlSWQiLCJzY3JhdGNoQ2FudmFzIiwiY29tcG9zZSIsImRpcnR5Qm94Iiwic21hc2siLCJjb21wb3NlU01hc2siLCJsYXllckN0eCIsImxheWVyQm94IiwibGF5ZXJPZmZzZXRYIiwibGF5ZXJPZmZzZXRZIiwibGF5ZXJXaWR0aCIsImxheWVySGVpZ2h0IiwiZ2VuZXJpY0NvbXBvc2VTTWFzayIsInN1YnR5cGUiLCJiYWNrZHJvcCIsInRyYW5zZmVyTWFwIiwibWFza0N0eCIsIm1hc2tPZmZzZXRYIiwibWFza09mZnNldFkiLCJtYXNrWCIsIm1hc2tZIiwiYmFja2Ryb3BSR0IiLCJvbGQiLCJwb3AiLCJvcCIsInBhdGgyZCIsImNvbnN1bWVQYXRoIiwibmV3UGF0aCIsImFkZFBhdGgiLCJtdWx0aXBseVNlbGYiLCJyZXNjYWxlQW5kU3Ryb2tlIiwibmVlZFJlc3RvcmUiLCJwYXRocyIsInBlbmRpbmdUZXh0UGF0aHMiLCJwcmVNdWx0aXBseVNlbGYiLCJzcGFjaW5nIiwiZm9udFJlZk5hbWUiLCJmb250T2JqIiwiZm9udERpcmVjdGlvbiIsImlzVHlwZTNGb250IiwidHlwZWZhY2UiLCJmYWxsYmFja05hbWUiLCJib2xkIiwiaXRhbGljIiwiYnJvd3NlckZvbnRTaXplIiwicmlzZSIsImdldFNjYWxlZFBhdGgiLCJwYWludENoYXIiLCJwYXR0ZXJuRmlsbFRyYW5zZm9ybSIsInBhdHRlcm5TdHJva2VUcmFuc2Zvcm0iLCJmaWxsU3Ryb2tlTW9kZSIsImlzQWRkVG9QYXRoU2V0IiwiaW52UGF0dGVyblRyYW5zZm9ybSIsInN0cm9rZVRleHQiLCJpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZCIsImdseXBocyIsInNob3dUeXBlM1RleHQiLCJnbHlwaHNMZW5ndGgiLCJ2ZXJ0aWNhbCIsInNwYWNpbmdEaXIiLCJkZWZhdWx0Vk1ldHJpY3MiLCJ3aWR0aEFkdmFuY2VTY2FsZSIsInNpbXBsZUZpbGxUZXh0IiwiZ2V0U2luZ2xlUGl4ZWxXaWR0aCIsImlzSW52YWxpZFBERmpzRm9udCIsImNoYXJzIiwiZ2x5cGgiLCJ1bmljb2RlIiwicmVzdG9yZU5lZWRlZCIsImlzU3BhY2UiLCJmb250Q2hhciIsImFjY2VudCIsInNjYWxlZFgiLCJzY2FsZWRZIiwidm1ldHJpYyIsInZ4IiwidnkiLCJyZW1lYXN1cmUiLCJtZWFzdXJlZFdpZHRoIiwibWVhc3VyZVRleHQiLCJjaGFyYWN0ZXJTY2FsZVgiLCJpc0luRm9udCIsInNjYWxlZEFjY2VudFgiLCJzY2FsZWRBY2NlbnRZIiwiY2hhcldpZHRoIiwiaXNUZXh0SW52aXNpYmxlIiwic3BhY2luZ0xlbmd0aCIsImNoYXJQcm9jT3BlcmF0b3JMaXN0Iiwib3BlcmF0b3JMaXN0SWQiLCJ4V2lkdGgiLCJ5V2lkdGgiLCJsbHgiLCJsbHkiLCJ1cngiLCJ1cnkiLCJnZXRDb2xvck5fUGF0dGVybiIsIl9nZXRQYXR0ZXJuIiwiYXJndW1lbnRzIiwiaW52IiwiZ3JvdXAiLCJjdXJyZW50Q3R4IiwiaXNvbGF0ZWQiLCJrbm9ja291dCIsImJvdW5kcyIsImNhbnZhc0JvdW5kcyIsImdyb3VwQ3R4Iiwic3RhcnRUcmFuc2Zvcm1JbnZlcnNlIiwiY3VycmVudE10eCIsImhhc093bkNhbnZhcyIsImFubm90YXRpb25DYW52YXMiLCJzYXZlZEN0eCIsInNrZXdYIiwic2tld1kiLCJwb3NpdGlvbnMiLCJ0cmFucyIsImltYWdlcyIsImFwcGx5VHJhbnNmZXJNYXBzVG9DYW52YXMiLCJhcHBseVRyYW5zZmVyTWFwc1RvQml0bWFwIiwiaW1nVG9QYWludCIsIkhUTUxFbGVtZW50IiwidGFnIiwiaXNWaXNpYmxlIiwiaXNDb250ZW50VmlzaWJsZSIsImFic0RldCIsIm5vcm1YIiwibm9ybVkiLCJnZXRTY2FsZUZvclN0cm9raW5nIiwic2NhbGVkTGluZVdpZHRoIiwic2NhbGVkWExpbmVXaWR0aCIsInNjYWxlZFlMaW5lV2lkdGgiLCJiYXNlQXJlYSIsInNhdmVSZXN0b3JlIiwiZGFzaGVzIiwiR2xvYmFsV29ya2VyT3B0aW9ucyIsInBvcnQiLCJ3b3JrZXJQb3J0IiwiV29ya2VyIiwid29ya2VyU3JjIiwiTWV0YWRhdGEiLCJwYXJzZWREYXRhIiwiZ2V0UmF3IiwiSU5URVJOQUwiLCJPcHRpb25hbENvbnRlbnRHcm91cCIsImlzRGlzcGxheSIsImlzUHJpbnQiLCJ1c2VyU2V0IiwicmVuZGVyaW5nSW50ZW50IiwidXNhZ2UiLCJyYkdyb3VwcyIsInZpZXciLCJ2aWV3U3RhdGUiLCJwcmludFN0YXRlIiwiX3NldFZpc2libGUiLCJpbnRlcm5hbCIsIk9wdGlvbmFsQ29udGVudENvbmZpZyIsImNhY2hlZEdldEhhc2giLCJncm91cHMiLCJpbml0aWFsSGFzaCIsIm9yZGVyIiwiY3JlYXRvciIsImJhc2VTdGF0ZSIsIm9mZiIsImdldEhhc2giLCJldmFsdWF0ZVZpc2liaWxpdHlFeHByZXNzaW9uIiwiYXJyYXkiLCJvcGVyYXRvciIsImV4cHJlc3Npb24iLCJwb2xpY3kiLCJzZXRWaXNpYmlsaXR5IiwicHJlc2VydmVSQiIsInJiR3JvdXAiLCJvdGhlcklkIiwic2V0T0NHU3RhdGUiLCJoYXNJbml0aWFsVmlzaWJpbGl0eSIsImdldE9yZGVyIiwiZ2V0R3JvdXAiLCJQREZEYXRhVHJhbnNwb3J0U3RyZWFtIiwicGRmRGF0YVJhbmdlVHJhbnNwb3J0IiwiZGlzYWJsZVJhbmdlIiwiZGlzYWJsZVN0cmVhbSIsImluaXRpYWxEYXRhIiwicHJvZ3Jlc3NpdmVEb25lIiwiY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUiLCJfcXVldWVkQ2h1bmtzIiwiX3Byb2dyZXNzaXZlRG9uZSIsIl9jb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSIsIl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQiLCJfaXNTdHJlYW1pbmdTdXBwb3J0ZWQiLCJfaXNSYW5nZVN1cHBvcnRlZCIsIl9jb250ZW50TGVuZ3RoIiwiX2Z1bGxSZXF1ZXN0UmVhZGVyIiwiX3JhbmdlUmVhZGVycyIsImFkZFJhbmdlTGlzdGVuZXIiLCJiZWdpbiIsIl9vblJlY2VpdmVEYXRhIiwiYWRkUHJvZ3Jlc3NMaXN0ZW5lciIsInRvdGFsIiwiX29uUHJvZ3Jlc3MiLCJhZGRQcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lciIsImFkZFByb2dyZXNzaXZlRG9uZUxpc3RlbmVyIiwiX29uUHJvZ3Jlc3NpdmVEb25lIiwidHJhbnNwb3J0UmVhZHkiLCJfZW5xdWV1ZSIsImZvdW5kIiwicmFuZ2VSZWFkZXIiLCJfYmVnaW4iLCJfcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoIiwiX2xvYWRlZCIsIm9uUHJvZ3Jlc3MiLCJfcmVtb3ZlUmFuZ2VSZWFkZXIiLCJyZWFkZXIiLCJpbmRleE9mIiwiZ2V0RnVsbFJlYWRlciIsInF1ZXVlZENodW5rcyIsIlBERkRhdGFUcmFuc3BvcnRTdHJlYW1SZWFkZXIiLCJnZXRSYW5nZVJlYWRlciIsIlBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlciIsInJlcXVlc3REYXRhUmFuZ2UiLCJjYW5jZWxBbGxSZXF1ZXN0cyIsIl9zdHJlYW0iLCJfZG9uZSIsIl9maWxlbmFtZSIsIl9yZXF1ZXN0cyIsIl9oZWFkZXJzUmVhZHkiLCJyZXF1ZXN0Q2FwYWJpbGl0eSIsImhlYWRlcnNSZWFkeSIsImlzUmFuZ2VTdXBwb3J0ZWQiLCJpc1N0cmVhbWluZ1N1cHBvcnRlZCIsImNvbnRlbnRMZW5ndGgiLCJyZWFkIiwiX2VuZCIsIl9xdWV1ZWRDaHVuayIsInJlcXVlc3RzQ2FwYWJpbGl0eSIsImdldEZpbGVuYW1lRnJvbUNvbnRlbnREaXNwb3NpdGlvbkhlYWRlciIsImNvbnRlbnREaXNwb3NpdGlvbiIsIm5lZWRzRW5jb2RpbmdGaXh1cCIsInRvUGFyYW1SZWdFeHAiLCJyZmMyNjE2dW5xdW90ZSIsInJmYzU5ODdkZWNvZGUiLCJyZmMyMDQ3ZGVjb2RlIiwiZml4dXBFbmNvZGluZyIsInJmYzIyMzFnZXRwYXJhbSIsImF0dHJpYnV0ZVBhdHRlcm4iLCJmbGFncyIsInRleHRkZWNvZGUiLCJjb250ZW50RGlzcG9zaXRpb25TdHIiLCJpdGVyIiwicXVvdCIsInBhcnQiLCJwYXJ0cyIsInF1b3RpbmRleCIsImV4dHZhbHVlIiwiZW5jb2RpbmdlbmQiLCJsYW5ndmFsdWUiLCJyZXBsYWNlIiwiY2hhcnNldCIsImhleCIsImNyZWF0ZUhlYWRlcnMiLCJpc0h0dHAiLCJodHRwSGVhZGVycyIsImhlYWRlcnMiLCJIZWFkZXJzIiwiZ2V0UmVzcG9uc2VPcmlnaW4iLCJ2YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyIsInJlc3BvbnNlSGVhZGVycyIsInJhbmdlQ2h1bmtTaXplIiwicmV0dXJuVmFsdWVzIiwiYWxsb3dSYW5nZVJlcXVlc3RzIiwic3VnZ2VzdGVkTGVuZ3RoIiwiY29udGVudEVuY29kaW5nIiwiZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlciIsImNyZWF0ZVJlc3BvbnNlRXJyb3IiLCJ2YWxpZGF0ZVJlc3BvbnNlU3RhdHVzIiwiY3JlYXRlRmV0Y2hPcHRpb25zIiwid2l0aENyZWRlbnRpYWxzIiwibWV0aG9kIiwiY3JlZGVudGlhbHMiLCJyZWRpcmVjdCIsImdldEFycmF5QnVmZmVyIiwiUERGRmV0Y2hTdHJlYW0iLCJfcmVzcG9uc2VPcmlnaW4iLCJfcmFuZ2VSZXF1ZXN0UmVhZGVycyIsIlBERkZldGNoU3RyZWFtUmVhZGVyIiwiUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlciIsIl9yZWFkZXIiLCJfd2l0aENyZWRlbnRpYWxzIiwiX2hlYWRlcnNDYXBhYmlsaXR5IiwiX2Rpc2FibGVSYW5nZSIsIl9yYW5nZUNodW5rU2l6ZSIsIl9hYm9ydENvbnRyb2xsZXIiLCJnZXRSZWFkZXIiLCJfcmVhZENhcGFiaWxpdHkiLCJyZXNwb25zZU9yaWdpbiIsIk9LX1JFU1BPTlNFIiwiUEFSVElBTF9DT05URU5UX1JFU1BPTlNFIiwibmV0d29ya19nZXRBcnJheUJ1ZmZlciIsInhociIsIk5ldHdvcmtNYW5hZ2VyIiwiY3VyclhocklkIiwicGVuZGluZ1JlcXVlc3RzIiwieGhySWQiLCJwZW5kaW5nUmVxdWVzdCIsInNldFJlcXVlc3RIZWFkZXIiLCJleHBlY3RlZFN0YXR1cyIsIm9uRXJyb3IiLCJvblN0YXRlQ2hhbmdlIiwib25wcm9ncmVzcyIsIm9uSGVhZGVyc1JlY2VpdmVkIiwib25Eb25lIiwieGhyU3RhdHVzIiwib2tfcmVzcG9uc2Vfb25fcmFuZ2VfcmVxdWVzdCIsInJhbmdlSGVhZGVyIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJnZXRSZXF1ZXN0WGhyIiwiaXNQZW5kaW5nUmVxdWVzdCIsImFib3J0UmVxdWVzdCIsIlBERk5ldHdvcmtTdHJlYW0iLCJfc291cmNlIiwiX21hbmFnZXIiLCJfb25SYW5nZVJlcXVlc3RSZWFkZXJDbG9zZWQiLCJQREZOZXR3b3JrU3RyZWFtRnVsbFJlcXVlc3RSZWFkZXIiLCJQREZOZXR3b3JrU3RyZWFtUmFuZ2VSZXF1ZXN0UmVhZGVyIiwib25DbG9zZWQiLCJtYW5hZ2VyIiwiX3VybCIsIl9mdWxsUmVxdWVzdElkIiwiX29uSGVhZGVyc1JlY2VpdmVkIiwiX29uRG9uZSIsIl9vbkVycm9yIiwiX2NhY2hlZENodW5rcyIsIl9zdG9yZWRFcnJvciIsImZ1bGxSZXF1ZXN0WGhySWQiLCJmdWxsUmVxdWVzdFhociIsInJlc3BvbnNlVVJMIiwicmF3UmVzcG9uc2VIZWFkZXJzIiwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIiwidHJpbVN0YXJ0IiwibGVuZ3RoQ29tcHV0YWJsZSIsIl9yZXF1ZXN0SWQiLCJfY2xvc2UiLCJ1cmxSZWdleCIsInBhcnNlVXJsT3JQYXRoIiwic291cmNlVXJsIiwicGF0aFRvRmlsZVVSTCIsIlBERk5vZGVTdHJlYW0iLCJQREZOb2RlU3RyZWFtRnNGdWxsUmVhZGVyIiwiUERGTm9kZVN0cmVhbUZzUmFuZ2VSZWFkZXIiLCJfcmVhZGFibGVTdHJlYW0iLCJsc3RhdCIsInN0YXQiLCJfc2V0UmVhZGFibGVTdHJlYW0iLCJjcmVhdGVSZWFkU3RyZWFtIiwiX2Vycm9yIiwicmVhZGFibGVTdHJlYW0iLCJNQVhfVEVYVF9ESVZTX1RPX1JFTkRFUiIsIkRFRkFVTFRfRk9OVF9TSVpFIiwiVGV4dExheWVyIiwiZGlzYWJsZVByb2Nlc3NJdGVtcyIsImZvbnRJbnNwZWN0b3JFbmFibGVkIiwibGFuZyIsImxheW91dFRleHRQYXJhbXMiLCJyb290Q29udGFpbmVyIiwic3R5bGVDYWNoZSIsInRleHRDb250ZW50SXRlbXNTdHIiLCJ0ZXh0Q29udGVudFNvdXJjZSIsInRleHREaXZzIiwidGV4dERpdlByb3BlcnRpZXMiLCJhc2NlbnRDYWNoZSIsImNhbnZhc0NvbnRleHRzIiwiY2FudmFzQ3R4Rm9udHMiLCJXZWFrTWFwIiwibWluRm9udFNpemUiLCJwZW5kaW5nVGV4dExheWVycyIsIkZvbnRJbnNwZWN0b3IiLCJlbnN1cmVNaW5Gb250U2l6ZUNvbXB1dGVkIiwiZmluYWxseSIsImZvbnRGYW1pbHlNYXAiLCJwdW1wIiwic3R5bGVzIiwicHJvY2Vzc0l0ZW1zIiwib25CZWZvcmUiLCJnZXRDdHgiLCJsYXlvdXQiLCJhYm9ydEV4IiwiYXBwZW5kVGV4dCIsImdlb20iLCJ0ZXh0RGl2IiwiaGFzVGV4dCIsImhhc0VPTCIsImF0YW4yIiwiZm9udE5hbWUiLCJmb250U3Vic3RpdHV0aW9uIiwiZm9udEhlaWdodCIsImZvbnRBc2NlbnQiLCJnZXRBc2NlbnQiLCJzaW4iLCJjb3MiLCJzY2FsZUZhY3RvclN0ciIsImRpdlN0eWxlIiwiZGlyIiwiZGF0YXNldCIsImZvbnRTdWJzdGl0dXRpb25Mb2FkZWROYW1lIiwic2hvdWxkU2NhbGVUZXh0IiwiYWJzU2NhbGVYIiwiYWJzU2NhbGVZIiwiYnIiLCJlbnN1cmVDdHhGb250IiwiY2xlYW51cCIsImFscGhhIiwiY2FjaGVkIiwib3BhY2l0eSIsImxpbmVIZWlnaHQiLCJjYWNoZWRBc2NlbnQiLCJtZXRyaWNzIiwiYXNjZW50IiwiZm9udEJvdW5kaW5nQm94QXNjZW50IiwiZGVzY2VudCIsImZvbnRCb3VuZGluZ0JveERlc2NlbnQiLCJyYXRpbyIsIlhmYVRleHQiLCJ4ZmEiLCJ3YWxrIiwibm9kZSIsInNob3VsZEJ1aWxkVGV4dCIsIkRFRkFVTFRfUkFOR0VfQ0hVTktfU0laRSIsIlJFTkRFUklOR19DQU5DRUxMRURfVElNRU9VVCIsImdldERvY3VtZW50IiwidGFzayIsIlBERkRvY3VtZW50TG9hZGluZ1Rhc2siLCJnZXRVcmxQcm9wIiwiZ2V0RGF0YVByb3AiLCJwYXNzd29yZCIsInJhbmdlVHJhbnNwb3J0IiwiUERGRGF0YVJhbmdlVHJhbnNwb3J0Iiwid29ya2VyIiwiUERGV29ya2VyIiwiZG9jQmFzZVVybCIsImNNYXBVcmwiLCJnZXRGYWN0b3J5VXJsUHJvcCIsImNNYXBQYWNrZWQiLCJDTWFwUmVhZGVyRmFjdG9yeSIsImljY1VybCIsInN0YW5kYXJkRm9udERhdGFVcmwiLCJTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSIsIndhc21VcmwiLCJXYXNtRmFjdG9yeSIsImlnbm9yZUVycm9ycyIsInN0b3BBdEVycm9ycyIsIm1heEltYWdlU2l6ZSIsImNocm9tZSIsImNhbnZhc01heEFyZWFJbkJ5dGVzIiwiZW5hYmxlWGZhIiwiZGlzYWJsZUF1dG9GZXRjaCIsInBkZkJ1ZyIsIkNhbnZhc0ZhY3RvcnkiLCJGaWx0ZXJGYWN0b3J5IiwidXNlV2FzbSIsInVzZVN5c3RlbUZvbnRzIiwidXNlV29ya2VyRmV0Y2giLCJ0cmFuc3BvcnRGYWN0b3J5IiwiY01hcFJlYWRlckZhY3RvcnkiLCJzdGFuZGFyZEZvbnREYXRhRmFjdG9yeSIsIndhc21GYWN0b3J5Iiwid29ya2VyUGFyYW1zIiwiZnJvbVBvcnQiLCJfd29ya2VyIiwiZG9jUGFyYW1zIiwiYXBpVmVyc2lvbiIsImV2YWx1YXRvck9wdGlvbnMiLCJ0cmFuc3BvcnRQYXJhbXMiLCJsb2FkaW5nUGFyYW1zIiwiZGVzdHJveWVkIiwid29ya2VySWRQcm9taXNlIiwibWVzc2FnZUhhbmRsZXIiLCJuZXR3b3JrU3RyZWFtIiwiTmV0d29ya1N0cmVhbSIsIlJlc3BvbnNlIiwid29ya2VySWQiLCJ0cmFuc3BvcnQiLCJXb3JrZXJUcmFuc3BvcnQiLCJfdHJhbnNwb3J0IiwiX2NhcGFiaWxpdHkiLCJsb2NhdGlvbiIsIkJ1ZmZlciIsImlzTmFOIiwiaXNSZWZQcm94eSIsImdlbiIsImlzTmFtZVByb3h5IiwiaXNWYWxpZEV4cGxpY2l0RGVzdCIsIl9wZW5kaW5nRGVzdHJveSIsIm9uUGFzc3dvcmQiLCJfcmFuZ2VMaXN0ZW5lcnMiLCJfcHJvZ3Jlc3NMaXN0ZW5lcnMiLCJfcHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJzIiwiX3Byb2dyZXNzaXZlRG9uZUxpc3RlbmVycyIsIl9yZWFkeUNhcGFiaWxpdHkiLCJsaXN0ZW5lciIsIm9uRGF0YVJhbmdlIiwib25EYXRhUHJvZ3Jlc3MiLCJvbkRhdGFQcm9ncmVzc2l2ZVJlYWQiLCJvbkRhdGFQcm9ncmVzc2l2ZURvbmUiLCJQREZEb2N1bWVudFByb3h5IiwicGRmSW5mbyIsIl9wZGZJbmZvIiwibnVtUGFnZXMiLCJmaW5nZXJwcmludHMiLCJpc1B1cmVYZmEiLCJfaHRtbEZvclhmYSIsImFsbFhmYUh0bWwiLCJnZXRQYWdlIiwiZ2V0UGFnZUluZGV4IiwicmVmIiwiZ2V0RGVzdGluYXRpb25zIiwiZ2V0RGVzdGluYXRpb24iLCJnZXRQYWdlTGFiZWxzIiwiZ2V0UGFnZUxheW91dCIsImdldFBhZ2VNb2RlIiwiZ2V0Vmlld2VyUHJlZmVyZW5jZXMiLCJnZXRPcGVuQWN0aW9uIiwiZ2V0QXR0YWNobWVudHMiLCJnZXRKU0FjdGlvbnMiLCJnZXREb2NKU0FjdGlvbnMiLCJnZXRPdXRsaW5lIiwiZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnIiwiZ2V0UmVuZGVyaW5nSW50ZW50IiwiZ2V0UGVybWlzc2lvbnMiLCJnZXRNZXRhZGF0YSIsImdldE1hcmtJbmZvIiwic2F2ZURvY3VtZW50IiwiZ2V0RG93bmxvYWRJbmZvIiwiZG93bmxvYWRJbmZvQ2FwYWJpbGl0eSIsImtlZXBMb2FkZWRGb250cyIsInN0YXJ0Q2xlYW51cCIsImxvYWRpbmdUYXNrIiwiY2FjaGVkUGFnZU51bWJlciIsImdldEZpZWxkT2JqZWN0cyIsImhhc0pTQWN0aW9ucyIsImdldENhbGN1bGF0aW9uT3JkZXJJZHMiLCJQREZQYWdlUHJveHkiLCJwZW5kaW5nQ2xlYW51cCIsInBhZ2VJbmZvIiwiX3BhZ2VJbmRleCIsIl9wYWdlSW5mbyIsIl9zdGF0cyIsIl9wZGZCdWciLCJQREZPYmplY3RzIiwiX2ludGVudFN0YXRlcyIsImdldFZpZXdwb3J0IiwiZ2V0QW5ub3RhdGlvbnMiLCJnZXRQYWdlSlNBY3Rpb25zIiwiZ2V0WGZhIiwiY2FudmFzQ29udGV4dCIsImFubm90YXRpb25Nb2RlIiwib3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZSIsInByaW50QW5ub3RhdGlvblN0b3JhZ2UiLCJpbnRlbnRBcmdzIiwiaW50ZW50U3RhdGUiLCJzdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0IiwiaW50ZW50UHJpbnQiLCJkaXNwbGF5UmVhZHlDYXBhYmlsaXR5IiwibGFzdENodW5rIiwic2VwYXJhdGVBbm5vdHMiLCJfcHVtcE9wZXJhdG9yTGlzdCIsInJlbmRlclRhc2tzIiwiaW50ZXJuYWxSZW5kZXJUYXNrIiwidHJ5Q2xlYW51cCIsIl9hYm9ydE9wZXJhdG9yTGlzdCIsIlN0YXRzIiwiSW50ZXJuYWxSZW5kZXJUYXNrIiwidXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicmVuZGVyVGFzayIsImluaXRpYWxpemVHcmFwaGljcyIsIm9wZXJhdG9yTGlzdENoYW5nZWQiLCJnZXRPcGVyYXRvckxpc3QiLCJvcExpc3RSZWFkQ2FwYWJpbGl0eSIsIm9wTGlzdFRhc2siLCJzdHJlYW1UZXh0Q29udGVudCIsImluY2x1ZGVNYXJrZWRDb250ZW50IiwiZGlzYWJsZU5vcm1hbGl6YXRpb24iLCJURVhUX0NPTlRFTlRfQ0hVTktfU0laRSIsImhpZ2hXYXRlck1hcmsiLCJnZXRUZXh0Q29udGVudCIsImdldFN0cnVjdFRyZWUiLCJfZGVzdHJveSIsIndhaXRPbiIsImZvcmNlIiwiY29tcGxldGVkIiwicmVzZXRTdGF0cyIsIl9zdGFydFJlbmRlclBhZ2UiLCJfcmVuZGVyUGFnZUNodW5rIiwib3BlcmF0b3JMaXN0Q2h1bmsiLCJhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZSIsInN0cmVhbVJlYWRlciIsImRlbGF5IiwiY3VyQ2FjaGVLZXkiLCJjdXJJbnRlbnRTdGF0ZSIsIkxvb3BiYWNrUG9ydCIsImxpc3RlbmVycyIsImRlZmVycmVkIiwiY2FsbCIsInJtQWJvcnQiLCJhYm9ydGVkIiwib25BYm9ydCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ0ZXJtaW5hdGUiLCJmYWtlV29ya2VySWQiLCJpc1dvcmtlckRpc2FibGVkIiwid29ya2VyUG9ydHMiLCJfaXNTYW1lT3JpZ2luIiwib3RoZXJVcmwiLCJiYXNlIiwib3RoZXIiLCJfY3JlYXRlQ0ROV3JhcHBlciIsIndyYXBwZXIiLCJjcmVhdGVPYmplY3RVUkwiLCJfcG9ydCIsIl93ZWJXb3JrZXIiLCJfbWVzc2FnZUhhbmRsZXIiLCJfaW5pdGlhbGl6ZUZyb21Qb3J0IiwiX2luaXRpYWxpemUiLCJtYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXIiLCJfc2V0dXBGYWtlV29ya2VyIiwidGVybWluYXRlRWFybHkiLCJzZW5kVGVzdCIsInRlc3RPYmoiLCJfc2V0dXBGYWtlV29ya2VyR2xvYmFsIiwiV29ya2VyTWVzc2FnZUhhbmRsZXIiLCJ3b3JrZXJIYW5kbGVyIiwic2V0dXAiLCJjYWNoZWRQb3J0IiwicGRmanNXb3JrZXIiLCJsb2FkZXIiLCJtZXRob2RQcm9taXNlcyIsInBhZ2VDYWNoZSIsInBhZ2VQcm9taXNlcyIsInBhZ2VSZWZDYWNoZSIsInBhc3N3b3JkQ2FwYWJpbGl0eSIsImZhY3RvcnkiLCJmb250TG9hZGVyIiwiX3BhcmFtcyIsImRlc3Ryb3lDYXBhYmlsaXR5IiwiX25ldHdvcmtTdHJlYW0iLCJfZnVsbFJlYWRlciIsIl9sYXN0UHJvZ3Jlc3MiLCJzZXR1cE1lc3NhZ2VIYW5kbGVyIiwiY2FjaGVTaW1wbGVNZXRob2QiLCJjYWNoZWRQcm9taXNlIiwiaXNPcExpc3QiLCJtb2RpZmllZElkc0hhc2giLCJjYWNoZUtleUJ1ZiIsImhhc093blByb3BlcnR5IiwidGVybWluYXRlZCIsInNpbmsiLCJyZWFkeVJlYXNvbiIsIl9udW1QYWdlcyIsImh0bWxGb3JYZmEiLCJ1cGRhdGVQYXNzd29yZCIsImVyciIsImV4cG9ydGVkRGF0YSIsImV4cG9ydGVkRXJyb3IiLCJmb250QWRkZWQiLCJpbWFnZVJlZiIsInBhZ2VQcm94eSIsImRhdGFMZW4iLCJyZWZTdHIiLCJyZXN1bHRzIiwibWV0YWRhdGEiLCJjbGVhbnVwU3VjY2Vzc2Z1bCIsIklOSVRJQUxfREFUQSIsImVuc3VyZU9iaiIsIlJlbmRlclRhc2siLCJvbkNvbnRpbnVlIiwiZm9ybSIsInJBRiIsImNhbnZhc0luVXNlIiwiV2Vha1NldCIsIm9wZXJhdG9yTGlzdElkeCIsInJ1bm5pbmciLCJncmFwaGljc1JlYWR5Q2FsbGJhY2siLCJncmFwaGljc1JlYWR5IiwiX3VzZVJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbGxlZCIsIl9jYW5jZWxCb3VuZCIsIl9jb250aW51ZUJvdW5kIiwiX2NvbnRpbnVlIiwiX3NjaGVkdWxlTmV4dEJvdW5kIiwiX3NjaGVkdWxlTmV4dCIsIl9uZXh0Qm91bmQiLCJfbmV4dCIsIl9jYW52YXMiLCJTdGVwcGVyTWFuYWdlciIsImluaXQiLCJnZXROZXh0QnJlYWtQb2ludCIsImdmeCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwidXBkYXRlT3BlcmF0b3JMaXN0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwidmVyc2lvbiIsImJ1aWxkIiwibWFrZUNvbG9yQ29tcCIsInNjYWxlQW5kQ2xhbXAiLCJDb2xvckNvbnZlcnRlcnMiLCJDTVlLX0ciLCJHX0NNWUsiLCJHX1JHQiIsIkdfcmdiIiwiR19IVE1MIiwiRyIsIlJHQl9HIiwiUkdCX3JnYiIsIlJHQl9IVE1MIiwiVF9IVE1MIiwiVF9yZ2IiLCJDTVlLX1JHQiIsIkNNWUtfcmdiIiwiQ01ZS19IVE1MIiwiY29tcG9uZW50cyIsIlJHQl9DTVlLIiwiQmFzZVNWR0ZhY3RvcnkiLCJza2lwRGltZW5zaW9ucyIsIl9jcmVhdGVTVkciLCJET01TVkdGYWN0b3J5IiwiWGZhTGF5ZXIiLCJzZXR1cFN0b3JhZ2UiLCJodG1sIiwic3RvcmVkRGF0YSIsInhmYU9uIiwieGZhT2ZmIiwiY2hlY2tlZCIsIm9wdGlvbiIsInNlbGVjdGVkIiwic2VsZWN0ZWRJbmRleCIsInNldEF0dHJpYnV0ZXMiLCJsaW5rU2VydmljZSIsImlzSFRNTEFuY2hvckVsZW1lbnQiLCJIVE1MQW5jaG9yRWxlbWVudCIsImFkZExpbmtBdHRyaWJ1dGVzIiwibmV3V2luZG93IiwiZGF0YUlkIiwicm9vdCIsInhmYUh0bWwiLCJyb290SHRtbCIsImlzTm90Rm9yUmljaFRleHQiLCJyb290RGl2IiwiY3JlYXRlVGV4dE5vZGUiLCJzdGFjayIsImNoaWxkSHRtbCIsInhtbG5zIiwicXVlcnlTZWxlY3RvckFsbCIsImhpZGRlbiIsIkRFRkFVTFRfVEFCX0lOREVYIiwiYW5ub3RhdGlvbl9sYXllcl9ERUZBVUxUX0ZPTlRfU0laRSIsIkdldEVsZW1lbnRzQnlOYW1lU2V0IiwiQW5ub3RhdGlvbkVsZW1lbnRGYWN0b3J5IiwiYW5ub3RhdGlvblR5cGUiLCJMaW5rQW5ub3RhdGlvbkVsZW1lbnQiLCJUZXh0QW5ub3RhdGlvbkVsZW1lbnQiLCJmaWVsZFR5cGUiLCJUZXh0V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJyYWRpb0J1dHRvbiIsIlJhZGlvQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJjaGVja0JveCIsIkNoZWNrYm94V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJQdXNoQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJDaG9pY2VXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsIlNpZ25hdHVyZVdpZGdldEFubm90YXRpb25FbGVtZW50IiwiV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJQb3B1cEFubm90YXRpb25FbGVtZW50IiwiRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudCIsIkxpbmVBbm5vdGF0aW9uRWxlbWVudCIsIlNxdWFyZUFubm90YXRpb25FbGVtZW50IiwiQ2lyY2xlQW5ub3RhdGlvbkVsZW1lbnQiLCJQb2x5bGluZUFubm90YXRpb25FbGVtZW50IiwiQ2FyZXRBbm5vdGF0aW9uRWxlbWVudCIsIklua0Fubm90YXRpb25FbGVtZW50IiwiUG9seWdvbkFubm90YXRpb25FbGVtZW50IiwiSGlnaGxpZ2h0QW5ub3RhdGlvbkVsZW1lbnQiLCJVbmRlcmxpbmVBbm5vdGF0aW9uRWxlbWVudCIsIlNxdWlnZ2x5QW5ub3RhdGlvbkVsZW1lbnQiLCJTdHJpa2VPdXRBbm5vdGF0aW9uRWxlbWVudCIsIlN0YW1wQW5ub3RhdGlvbkVsZW1lbnQiLCJGaWxlQXR0YWNobWVudEFubm90YXRpb25FbGVtZW50IiwiQW5ub3RhdGlvbkVsZW1lbnQiLCJ1cGRhdGVzIiwiaGFzQm9yZGVyIiwicG9wdXBFbGVtZW50IiwiaXNSZW5kZXJhYmxlIiwiaWdub3JlQm9yZGVyIiwiY3JlYXRlUXVhZHJpbGF0ZXJhbHMiLCJkb3dubG9hZE1hbmFnZXIiLCJpbWFnZVJlc291cmNlc1BhdGgiLCJyZW5kZXJGb3JtcyIsInN2Z0ZhY3RvcnkiLCJlbmFibGVTY3JpcHRpbmciLCJfZmllbGRPYmplY3RzIiwiZmllbGRPYmplY3RzIiwiX2NyZWF0ZUNvbnRhaW5lciIsIl9jcmVhdGVRdWFkcmlsYXRlcmFscyIsIl9oYXNQb3B1cERhdGEiLCJ0aXRsZU9iaiIsImNvbnRlbnRzT2JqIiwicmljaFRleHQiLCJfaXNFZGl0YWJsZSIsImlzRWRpdGFibGUiLCJoYXNQb3B1cERhdGEiLCJ1cGRhdGVFZGl0ZWQiLCJzZXRSZWN0RWRpdGVkIiwicG9wdXAiLCJyZXNldEVkaXRlZCIsImN1cnJlbnRSZWN0Iiwic2V0Um90YXRpb24iLCJhbHRlcm5hdGl2ZVRleHQiLCJub1JvdGF0ZSIsImJvcmRlclN0eWxlIiwiYm9yZGVyV2lkdGgiLCJob3Jpem9udGFsUmFkaXVzIiwiaG9yaXpvbnRhbENvcm5lclJhZGl1cyIsInZlcnRpY2FsUmFkaXVzIiwidmVydGljYWxDb3JuZXJSYWRpdXMiLCJyYWRpdXMiLCJib3JkZXJSYWRpdXMiLCJib3JkZXJCb3R0b21TdHlsZSIsImJvcmRlckNvbG9yIiwiX2NvbW1vbkFjdGlvbnMiLCJzZXRDb2xvciIsImpzTmFtZSIsInN0eWxlTmFtZSIsImRldGFpbCIsImNvbG9yVHlwZSIsImNvbG9yQXJyYXkiLCJkaXNwbGF5Iiwibm9WaWV3Iiwibm9QcmludCIsInVzZXJOYW1lIiwicmVhZG9ubHkiLCJyZXF1aXJlZCIsIl9zZXRSZXF1aXJlZCIsInRleHRDb2xvciIsIl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3giLCJhY3Rpb25zIiwianNFdmVudCIsImNvbW1vbkFjdGlvbnMiLCJfc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMiLCJldmVudFByb3h5IiwicXVhZFBvaW50cyIsInJlY3RCbFgiLCJyZWN0QmxZIiwicmVjdFRyWCIsInJlY3RUclkiLCJ0clgiLCJ0clkiLCJibFgiLCJibFkiLCJzdmdCdWZmZXIiLCJjbGlwUGF0aCIsInJlY3RXaWR0aCIsInJlY3RIZWlnaHQiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJfY3JlYXRlUG9wdXAiLCJtb2RpZmljYXRpb25EYXRlIiwicGFyZW50UmVjdCIsImVsZW1lbnRzIiwiX2dldEVsZW1lbnRzQnlOYW1lIiwic2tpcElkIiwiZmllbGRzIiwiZmllbGRPYmoiLCJleHBvcnRWYWx1ZXMiLCJleHBvcnRWYWx1ZSIsImRvbUVsZW1lbnQiLCJnZXRFbGVtZW50c0J5TmFtZSIsIm1heWJlU2hvdyIsImZvcmNlSGlkZSIsImdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAiLCJhZGRIaWdobGlnaHRBcmVhIiwidHJpZ2dlcnMiLCJfZWRpdE9uRG91YmxlQ2xpY2siLCJhbm5vdGF0aW9uRWRpdG9yVHlwZSIsImlzVG9vbHRpcE9ubHkiLCJsaW5rIiwiaXNCb3VuZCIsIl9iaW5kTmFtZWRBY3Rpb24iLCJhdHRhY2htZW50IiwiYmluZEF0dGFjaG1lbnQiLCJhdHRhY2htZW50RGVzdCIsImJpbmRTZXRPQ0dTdGF0ZSIsIl9iaW5kTGluayIsIkFjdGlvbiIsIl9iaW5kSlNBY3Rpb24iLCJyZXNldEZvcm0iLCJfYmluZFJlc2V0Rm9ybUFjdGlvbiIsInNldEludGVybmFsTGluayIsImRlc3RpbmF0aW9uIiwiZ2V0RGVzdGluYXRpb25IYXNoIiwib25jbGljayIsImdvVG9EZXN0aW5hdGlvbiIsImdldEFuY2hvclVybCIsImV4ZWN1dGVOYW1lZEFjdGlvbiIsIm9wZW5PckRvd25sb2FkRGF0YSIsImV4ZWN1dGVTZXRPQ0dTdGF0ZSIsIm90aGVyQ2xpY2tBY3Rpb24iLCJyZXNldEZvcm1GaWVsZHMiLCJyZWZzIiwicmVzZXRGb3JtUmVmcyIsImluY2x1ZGUiLCJhbGxGaWVsZHMiLCJmaWVsZElkcyIsImZpZWxkTmFtZSIsImZpZWxkIiwiYWxsSWRzIiwiZGlzcGF0Y2hFdmVudCIsIkV2ZW50Iiwic2hvd0VsZW1lbnRBbmRIaWRlQ2FudmFzIiwicHJldmlvdXNTaWJsaW5nIiwiX2dldEtleU1vZGlmaWVyIiwiX3NldEV2ZW50TGlzdGVuZXIiLCJlbGVtZW50RGF0YSIsImJhc2VOYW1lIiwiZXZlbnROYW1lIiwidmFsdWVHZXR0ZXIiLCJtb2RpZmllciIsImZvY3VzZWQiLCJfc2V0RXZlbnRMaXN0ZW5lcnMiLCJnZXR0ZXIiLCJCbHVyIiwiRm9jdXMiLCJfc2V0QmFja2dyb3VuZENvbG9yIiwiX3NldFRleHRTdHlsZSIsIlRFWFRfQUxJR05NRU5UIiwiZm9udENvbG9yIiwiZGVmYXVsdEFwcGVhcmFuY2VEYXRhIiwiY29tcHV0ZWRGb250U2l6ZSIsInJvdW5kVG9PbmVEZWNpbWFsIiwibXVsdGlMaW5lIiwibnVtYmVyT2ZMaW5lcyIsInRleHRBbGlnbm1lbnQiLCJ0ZXh0QWxpZ24iLCJpc1JlcXVpcmVkIiwiaGFzQXBwZWFyYW5jZSIsImZpZWxkVmFsdWUiLCJzZXRQcm9wZXJ0eU9uU2libGluZ3MiLCJrZXlJblN0b3JhZ2UiLCJtYXhMZW4iLCJjaGFyTGltaXQiLCJmaWVsZEZvcm1hdHRlZFZhbHVlcyIsImZvcm1hdHRlZFZhbHVlIiwiY29tYiIsInVzZXJWYWx1ZSIsImxhc3RDb21taXR0ZWRWYWx1ZSIsImNvbW1pdEtleSIsImRvTm90U2Nyb2xsIiwib3ZlcmZsb3dZIiwib3ZlcmZsb3dYIiwicmVhZE9ubHkiLCJtYXhMZW5ndGgiLCJkZWZhdWx0RmllbGRWYWx1ZSIsImJsdXJMaXN0ZW5lciIsInNjcm9sbExlZnQiLCJzZWxSYW5nZSIsInNldFNlbGVjdGlvblJhbmdlIiwid2lsbENvbW1pdCIsInNlbFN0YXJ0Iiwic2VsZWN0aW9uU3RhcnQiLCJzZWxFbmQiLCJzZWxlY3Rpb25FbmQiLCJfYmx1ckxpc3RlbmVyIiwiS2V5c3Ryb2tlIiwiaW5wdXRUeXBlIiwiY2hhbmdlIiwiZmllbGRXaWR0aCIsImNvbWJXaWR0aCIsImxldHRlclNwYWNpbmciLCJ2ZXJ0aWNhbEFsaWduIiwiY2hlY2tib3giLCJjdXJDaGVja2VkIiwiYnV0dG9uVmFsdWUiLCJyYWRpbyIsInBkZkJ1dHRvblZhbHVlIiwibGlua0VsZW1lbnQiLCJzZWxlY3RFbGVtZW50IiwiYWRkQW5FbXB0eUVudHJ5IiwiY29tYm8iLCJtdWx0aVNlbGVjdCIsIm11bHRpcGxlIiwib3B0aW9uRWxlbWVudCIsImRpc3BsYXlWYWx1ZSIsInJlbW92ZUVtcHR5RW50cnkiLCJub25lT3B0aW9uRWxlbWVudCIsImlzRXhwb3J0Iiwic2VsZWN0ZWRWYWx1ZXMiLCJnZXRJdGVtcyIsIm11bHRpcGxlU2VsZWN0aW9uIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJzZWxlY3RDaGlsZCIsImluZGljZXMiLCJlZGl0YWJsZSIsImNoYW5nZUV4Iiwia2V5RG93biIsIlBvcHVwRWxlbWVudCIsImVsZW1lbnRJZHMiLCJhcmlhSGFzUG9wdXAiLCJib3VuZEtleURvd24iLCJib3VuZEhpZGUiLCJib3VuZFNob3ciLCJib3VuZFRvZ2dsZSIsImRhdGVPYmoiLCJwaW5uZWQiLCJ3YXNWaXNpYmxlIiwidHJpZ2dlciIsImZsYXRNYXAiLCJiYXNlQ29sb3IiLCJvdXRsaW5lQ29sb3IiLCJoZWFkZXIiLCJ2YWx1ZU9mIiwiY29udGVudHMiLCJfZm9ybWF0Q29udGVudHMiLCJtYWtlUG9wdXBDb250ZW50IiwicG9wdXBMaW5lcyIsInBvcHVwQ29udGVudCIsImxpbmVBdHRyaWJ1dGVzIiwibGluZSIsImxpbmVzIiwic2V0UG9zaXRpb24iLCJ1c2VQYXJlbnRSZWN0Iiwibm9ybWFsaXplZFJlY3QiLCJIT1JJWk9OVEFMX1NQQUNFX0FGVEVSX0FOTk9UQVRJT04iLCJwb3B1cExlZnQiLCJwb3B1cFRvcCIsInRleHRQb3NpdGlvbiIsImxpbmVTcGFuIiwibGluZUNvb3JkaW5hdGVzIiwic3F1YXJlIiwiY2lyY2xlIiwicG9seWxpbmUiLCJjb250YWluZXJDbGFzc05hbWUiLCJzdmdFbGVtZW50TmFtZSIsInZlcnRpY2VzIiwicG9pbnRzIiwicG9seWxpbmVzR3JvdXBFbGVtZW50IiwicG9seWxpbmVzIiwiaXQiLCJpbmtMaXN0cyIsInRoaWNrbmVzcyIsImRvd25sb2FkIiwiQW5ub3RhdGlvbkxheWVyIiwiYWNjZXNzaWJpbGl0eU1hbmFnZXIiLCJlZGl0YWJsZUFubm90YXRpb25zIiwic3RydWN0VHJlZUxheWVyIiwiYW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlciIsIl9hbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyIiwiaGFzRWRpdGFibGVBbm5vdGF0aW9ucyIsImFwcGVuZEVsZW1lbnQiLCJjb250ZW50RWxlbWVudCIsImFyaWFBdHRyaWJ1dGVzIiwiZ2V0QXJpYUF0dHJpYnV0ZXMiLCJtb3ZlRWxlbWVudEluRE9NIiwiYW5ub3RhdGlvbnMiLCJwb3B1cFRvRWxlbWVudHMiLCJlbGVtZW50UGFyYW1zIiwibm9IVE1MIiwiaXNQb3B1cEFubm90YXRpb24iLCJyZW5kZXJlZCIsInNldEFubm90YXRpb25DYW52YXNNYXAiLCJhZGRMaW5rQW5ub3RhdGlvbnMiLCJfZGVmYXVsdEJvcmRlclN0eWxlIiwicmVwbGFjZVdpdGgiLCJhZnRlciIsImVkaXRhYmxlQW5ub3RhdGlvbiIsIl9oYXNOb0NhbnZhcyIsImdldEVkaXRhYmxlQW5ub3RhdGlvbnMiLCJnZXRFZGl0YWJsZUFubm90YXRpb24iLCJyYXdXaWR0aCIsIkVPTF9QQVRURVJOIiwiRnJlZVRleHRFZGl0b3IiLCJlZGl0b3JEaXZJZCIsImVkaXRNb2RlQUMiLCJfZnJlZVRleHREZWZhdWx0Q29udGVudCIsIl9pbnRlcm5hbFBhZGRpbmciLCJfZGVmYXVsdENvbG9yIiwiX2RlZmF1bHRGb250U2l6ZSIsIl90cmFuc2xhdGVFbXB0eSIsIl9lZGl0b3JUeXBlIiwidXBkYXRlRm9udFNpemUiLCJzZXRGb250c2l6ZSIsImVkaXRvckRpdiIsInNldEVkaXRvckRpbWVuc2lvbnMiLCJzYXZlZEZvbnRzaXplIiwiY29sIiwic2F2ZWRDb2xvciIsIm92ZXJsYXlEaXYiLCJjb250ZW50RWRpdGFibGUiLCJlZGl0b3JEaXZLZXlkb3duIiwiZWRpdG9yRGl2Rm9jdXMiLCJlZGl0b3JEaXZCbHVyIiwiZWRpdG9yRGl2SW5wdXQiLCJlZGl0b3JEaXZQYXN0ZSIsImlubmVyVGV4dCIsImV4dHJhY3RUZXh0IiwicHJldkNoaWxkIiwiY2hpbGROb2RlcyIsImdldE5vZGVDb250ZW50Iiwic2F2ZWREaXNwbGF5Iiwic2F2ZWRWaXNpYmlsaXR5Iiwic2F2ZWRUZXh0IiwibmV3VGV4dCIsInRyaW1FbmQiLCJzZXRUZXh0Iiwic2V0Q29udGVudCIsImRibGNsaWNrIiwicG9zWCIsInBvc1kiLCJub2RlVmFsdWUiLCJkZXNlcmlhbGl6ZUNvbnRlbnQiLCJkZWxldGVGcm9tRG9jdW1lbnQiLCJpbnNlcnROb2RlIiwiY29sbGFwc2VUb1N0YXJ0Iiwic3RhcnRDb250YWluZXIiLCJzdGFydE9mZnNldCIsImJ1ZmZlckJlZm9yZSIsImJ1ZmZlckFmdGVyIiwibmV3UmFuZ2UiLCJSYW5nZSIsImJlZm9yZUxlbmd0aCIsInNldFN0YXJ0Iiwic2V0RW5kIiwicmVtb3ZlQWxsUmFuZ2VzIiwiYWRkUmFuZ2UiLCJyZXBsYWNlQ2hpbGRyZW4iLCJzZXJpYWxpemVDb250ZW50IiwicGFkZGluZyIsInN0cnVjdFRyZWVQYXJlbnRJZCIsImhhc0VsZW1lbnRDaGFuZ2VkIiwiT3V0bGluZSIsIlBSRUNJU0lPTiIsInRvU1ZHUGF0aCIsIl9yb3RhdGlvbiIsIl9yZXNjYWxlIiwiX3Jlc2NhbGVBbmRTd2FwIiwiX3RyYW5zbGF0ZSIsInN2Z1JvdW5kIiwiX25vcm1hbGl6ZVBvaW50IiwiX25vcm1hbGl6ZVBhZ2VQb2ludCIsImNyZWF0ZUJlemllclBvaW50cyIsIkZyZWVEcmF3T3V0bGluZXIiLCJpbm5lck1hcmdpbiIsImxhc3QiLCJtaW5fZGlzdCIsInNjYWxlRmFjdG9yIiwiTUlOX0RJU1QiLCJNSU5fRElGRiIsIk1JTiIsImdldExhc3RDb29yZHMiLCJsYXN0VG9wIiwibGFzdEJvdHRvbSIsImRpZmZYIiwiZGlmZlkiLCJkaWZmRCIsIm5YIiwiblkiLCJ0aFgiLCJ0aFkiLCJ0b1NWR1BhdGhUd29Qb2ludHMiLCJ0b1NWR1BhdGhFbmQiLCJ0b1NWR1BhdGhTdGFydCIsImxhc3RUb3BYIiwibGFzdFRvcFkiLCJsYXN0Qm90dG9tWCIsImxhc3RCb3R0b21ZIiwibmV3RnJlZURyYXdPdXRsaW5lIiwib3V0bGluZSIsIkZyZWVEcmF3T3V0bGluZSIsImdldE91dGxpbmVzIiwiZ2V0T3V0bGluZVR3b1BvaW50cyIsIk4iLCJnZXRPdXRsaW5lRW5kIiwiZ2V0T3V0bGluZVN0YXJ0IiwibGFzdFBvaW50IiwiY29tcHV0ZU1pbk1heCIsImxhc3RQb2ludFgiLCJsYXN0UG9pbnRZIiwibHRyQ2FsbGJhY2siLCJuZXdPdXRsaW5lciIsImdldE5ld091dGxpbmUiLCJvdXRsaW5lciIsIkhpZ2hsaWdodE91dGxpbmVyIiwidmVydGljYWxFZGdlcyIsImludGVydmFscyIsIk5VTUJFUl9PRl9ESUdJVFMiLCJFUFNJTE9OIiwic2hpZnRlZE1pblgiLCJzaGlmdGVkTWluWSIsImxhc3RFZGdlIiwiZWRnZSIsInNvcnQiLCJvdXRsaW5lVmVydGljYWxFZGdlcyIsImJyZWFrRWRnZSIsImVkZ2VzIiwiYWxsRWRnZXMiLCJlZGdlMSIsImVkZ2UyIiwib3V0bGluZXMiLCJIaWdobGlnaHRPdXRsaW5lIiwiYmluYXJ5U2VhcmNoIiwibWlkZGxlIiwieTQiLCJwb2x5Z29uIiwicHJldlgiLCJwcmV2WSIsImNsYXNzTmFtZXNGb3JPdXRsaW5pbmciLCJGcmVlSGlnaGxpZ2h0T3V0bGluZXIiLCJGcmVlSGlnaGxpZ2h0T3V0bGluZSIsIkNvbG9yUGlja2VyIiwiYnV0dG9uU3dhdGNoIiwiZGVmYXVsdENvbG9yIiwiZHJvcGRvd24iLCJkcm9wZG93bldhc0Zyb21LZXlib2FyZCIsImlzTWFpbkNvbG9yUGlja2VyIiwib3BlbkRyb3Bkb3duQUMiLCJsMTBuQ29sb3IiLCJfaGlkZURyb3Bkb3duRnJvbUtleWJvYXJkIiwiX2NvbG9yU2VsZWN0RnJvbUtleWJvYXJkIiwiX21vdmVUb05leHQiLCJfbW92ZVRvUHJldmlvdXMiLCJfbW92ZVRvQmVnaW5uaW5nIiwiX21vdmVUb0VuZCIsImJsdWUiLCJncmVlbiIsInBpbmsiLCJyZWQiLCJ5ZWxsb3ciLCJvcGVuRHJvcGRvd24iLCJzd2F0Y2giLCJyZW5kZXJNYWluRHJvcGRvd24iLCJnZXREcm9wZG93blJvb3QiLCJyb2xlIiwiY29sb3JTZWxlY3QiLCJpc0Ryb3Bkb3duVmlzaWJsZSIsIm5leHRTaWJsaW5nIiwiSGlnaGxpZ2h0RWRpdG9yIiwiY2xpcFBhdGhJZCIsImZvY3VzT3V0bGluZXMiLCJoaWdobGlnaHREaXYiLCJoaWdobGlnaHRPdXRsaW5lcyIsImlzRnJlZUhpZ2hsaWdodCIsIm91dGxpbmVJZCIsIl9kZWZhdWx0T3BhY2l0eSIsIl9kZWZhdWx0VGhpY2tuZXNzIiwiX2ZyZWVIaWdobGlnaHRJZCIsIl9mcmVlSGlnaGxpZ2h0IiwiX2ZyZWVIaWdobGlnaHRDbGlwSWQiLCJfbW92ZUNhcmV0IiwiaGlnaGxpZ2h0SWQiLCJjcmVhdGVGcmVlT3V0bGluZXMiLCJhZGRUb0RyYXdMYXllciIsImNyZWF0ZU91dGxpbmVzIiwibnVtYmVyT2ZDb2xvcnMiLCJvdXRsaW5lckZvck91dGxpbmUiLCJleHRyYVRoaWNrbmVzcyIsImRyYXdMYXllciIsImZpbmFsaXplRHJhdyIsImRyYXdPdXRsaW5lIiwicm9vdENsYXNzIiwiaGlnaGxpZ2h0T3V0bGluZSIsImZyZWUiLCJ1cGRhdGVQcm9wZXJ0aWVzIiwicm90YXRlQmJveCIsInVwZGF0ZVRoaWNrbmVzcyIsInNldENvbG9yQW5kT3BhY2l0eSIsIm9wYSIsInNhdmVkT3BhY2l0eSIsInNhdmVkVGhpY2tuZXNzIiwic2V0VGhpY2tuZXNzIiwidGgiLCJjaGFuZ2VUaGlja25lc3MiLCJnZXRSb3RhdGlvbiIsImFkZFVuZG9hYmxlRWRpdG9yIiwiY2xlYW5EcmF3TGF5ZXIiLCJtdXN0QmVTZWxlY3RlZCIsImRyYXciLCJwb2ludGVyb3ZlciIsImhvdmVyZWQiLCJwb2ludGVybGVhdmUiLCJzZXRDYXJldCIsInNlcmlhbGl6ZUJveGVzIiwic2VyaWFsaXplT3V0bGluZXMiLCJzdGFydEhpZ2hsaWdodGluZyIsImVuZEhpZ2hsaWdodCIsImhpZ2hsaWdodE1vdmUiLCJEcmF3aW5nT3B0aW9ucyIsInN2Z1Byb3BlcnRpZXMiLCJ1cGRhdGVQcm9wZXJ0eSIsInVwZGF0ZVNWR1Byb3BlcnR5IiwidG9TVkdQcm9wZXJ0aWVzIiwidXBkYXRlQWxsIiwiRHJhd2luZ0VkaXRvciIsImRyYXdPdXRsaW5lcyIsIm11c3RCZUNvbW1pdHRlZCIsIl9jdXJyZW50RHJhd0lkIiwiX2N1cnJlbnRQYXJlbnQiLCJjdXJyZW50RHJhdyIsImN1cnJlbnREcmF3aW5nQUMiLCJjdXJyZW50RHJhd2luZ09wdGlvbnMiLCJjdXJyZW50UG9pbnRlcklkIiwiY3VycmVudFBvaW50ZXJUeXBlIiwiY3VycmVudFBvaW50ZXJJZHMiLCJjdXJyZW50TW92ZVRpbWVzdGFtcCIsIl9JTk5FUl9NQVJHSU4iLCJfZHJhd0lkIiwiX2FkZE91dGxpbmVzIiwiY3JlYXRlRHJhd091dGxpbmVzIiwiZHJhd0lkIiwiZHJhd2luZ09wdGlvbnMiLCJfZHJhd2luZ09wdGlvbnMiLCJkZWZhdWx0UHJvcGVydGllcyIsImNyZWF0ZURyYXdpbmciLCJ1cGRhdGVCYm94IiwiX21lcmdlU1ZHUHJvcGVydGllcyIsImRlZmF1bHRTVkdQcm9wZXJ0aWVzIiwicDFLZXlzIiwiZ2V0RGVmYXVsdERyYXdpbmdPcHRpb25zIiwiX29wdGlvbnMiLCJ0eXBlc01hcCIsInN1cHBvcnRNdWx0aXBsZURyYXdpbmdzIiwicHJvcGVydHlOYW1lIiwiX2RlZmF1bHREcmF3aW5nT3B0aW9ucyIsIl91cGRhdGVQcm9wZXJ0eSIsInNhdmVkVmFsdWUiLCJzZXR0ZXIiLCJnZXRQYXRoUmVzaXppbmdTVkdQcm9wZXJ0aWVzIiwiY29udmVydFRvRHJhd1NwYWNlIiwicm90YXRlQm94IiwiZ2V0UGF0aFJlc2l6ZWRTVkdQcm9wZXJ0aWVzIiwiX3giLCJfeSIsImdldFBhdGhUcmFuc2xhdGVkU1ZHUHJvcGVydGllcyIsIm1vdmluZyIsInVwZGF0ZVBhcmVudCIsImNvbnZlcnRUb1BhcmVudFNwYWNlIiwicFciLCJwSCIsInVwZGF0ZVJvdGF0aW9uIiwidXBkYXRlUGFyZW50RGltZW5zaW9ucyIsIm9uU2NhbGVDaGFuZ2luZ1doZW5EcmF3aW5nIiwiZHJhd0RpdiIsImNyZWF0ZURyYXdlckluc3RhbmNlIiwiX3BhcmVudFdpZHRoIiwiX3BhcmVudEhlaWdodCIsInN0YXJ0RHJhd2luZyIsIl9pc0xUUiIsIl9lbmREcmF3IiwiaXNDYW5jZWxsYWJsZSIsInJlbW92ZUxhc3RFbGVtZW50IiwiX2RyYXdNb3ZlIiwidGltZVN0YW1wIiwic3RhcnROZXciLCJfY2xlYW51cCIsImxhc3RFbGVtZW50IiwiZ2V0TGFzdEVsZW1lbnQiLCJzZXRMYXN0RWxlbWVudCIsImlzQWJvcnRlZCIsImNyZWF0ZURyYXdpbmdPcHRpb25zIiwiX2RhdGEiLCJkZXNlcmlhbGl6ZURyYXciLCJfcGFnZVgiLCJfcGFnZVkiLCJfcGFnZVdpZHRoIiwiX3BhZ2VIZWlnaHQiLCJfaW5uZXJXaWR0aCIsInNlcmlhbGl6ZURyYXciLCJJbmtEcmF3T3V0bGluZXIiLCJsYXN0U1ZHUGF0aCIsImxhc3RJbmRleCIsIkZsb2F0NjRBcnJheSIsIklua0RyYXdPdXRsaW5lIiwibm9ybWFsaXplUG9pbnQiLCJmaXJzdFgiLCJmaXJzdFkiLCJzZWNvbmRYIiwic2Vjb25kWSIsImMxeCIsImMxeSIsImMyeCIsImMyeSIsImN1cnJlbnRSb3RhdGlvbiIsImNvbXB1dGVCYm94Iiwic2VyaWFsaXplZExpbmVzIiwic2VyaWFsaXplZFBvaW50cyIsImdldEJCb3hXaXRoTm9NYXJnaW4iLCJyZXNjYWxlRm4iLCJuZXdMaW5lcyIsImdldE1hcmdpbkNvbXBvbmVudHMiLCJtYXJnaW4iLCJtYXJnaW5YIiwibWFyZ2luWSIsIm9sZE1hcmdpblgiLCJvbGRNYXJnaW5ZIiwibmV3TWFyZ2luWCIsIm5ld01hcmdpblkiLCJkaWZmTWFyZ2luWCIsImRpZmZNYXJnaW5ZIiwicm90YXRpb25UcmFuc2Zvcm0iLCJzMXgiLCJzMXkiLCJzMngiLCJzMnkiLCJuZXdQYXJlbnRXaWR0aCIsIm5ld1BhcmVudEhlaWdodCIsIklua0RyYXdpbmdPcHRpb25zIiwidmlld2VyUGFyYW1ldGVycyIsIl92aWV3UGFyYW1ldGVycyIsIklua0VkaXRvciIsIkNvbnRvdXJEcmF3T3V0bGluZSIsIkJBU0VfSEVBREVSX0xFTkdUSCIsIlBPSU5UU19QUk9QRVJUSUVTX05VTUJFUiIsIlNpZ25hdHVyZUV4dHJhY3RvciIsIlBBUkFNRVRFUlMiLCJzaWdtYVNGYWN0b3IiLCJzaWdtYVIiLCJrZXJuZWxTaXplIiwibmVpZ2hib3JJbmRleFRvSWQiLCJpMCIsImowIiwibmVpZ2hib3JJZFRvSW5kZXgiLCJJbnQzMkFycmF5IiwiY2xvY2t3aXNlTm9uWmVybyIsImtrIiwic2hpZnRJIiwic2hpZnRKIiwiY291bnRlckNsb2Nrd2lzZU5vblplcm8iLCJmaW5kQ29udG91cnMiLCJ0aHJlc2hvbGQiLCJuYmQiLCJsbmJkIiwiY29udG91cnMiLCJpaiIsInBpeCIsImkyIiwiajIiLCJpc0hvbGUiLCJjb250b3VyIiwiY29udG91cjAiLCJpMSIsImoxIiwiaTMiLCJqMyIsImk0IiwiajQiLCJpajMiLCJkb3VnbGFzUGV1Y2tlckhlbHBlciIsImF4IiwiYXkiLCJhYngiLCJhYnkiLCJkaXN0IiwibmFieCIsIm5hYnkiLCJhYSIsImludlMiLCJwaGkiLCJhdGFuIiwiY29zUGhpIiwic2luUGhpIiwidG1heCIsInBvbHkiLCJwYXJ0aWFsUGhpIiwiZG1heCIsImRvdWdsYXNQZXVja2VyIiwiYmlsYXRlcmFsRmlsdGVyIiwic2lnbWFTIiwia2VybmVsIiwic2lnbWFTMiIsImhhbGZTaXplIiwiZXhwIiwicmFuZ2VWYWx1ZXMiLCJzaWdtYVIyIiwib3V0IiwiaGlzdG9ncmFtIiwic3VtIiwibm9ybSIsImwiLCJuZWlnaGJvdXIiLCJnZXRIaXN0b2dyYW0iLCJ0b1VpbnQ4IiwiVWludDhDbGFtcGVkQXJyYXkiLCJBIiwiZ3Vlc3NUaHJlc2hvbGQiLCJNIiwiTCIsInNwb3MiLCJnZXRHcmF5UGl4ZWxzIiwib3JpZ2luYWxCaXRtYXAiLCJwcmV2V2lkdGgiLCJwcmV2SGVpZ2h0IiwibG9nMiIsImlzdGVwcyIsImdyYXlJbWFnZSIsInVpbnQ4QnVmIiwiZXh0cmFjdENvbnRvdXJzRnJvbVRleHQiLCJmb250U3R5bGUiLCJhY3R1YWxCb3VuZGluZ0JveExlZnQiLCJhY3R1YWxCb3VuZGluZ0JveFJpZ2h0IiwiYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQiLCJhY3R1YWxCb3VuZGluZ0JveERlc2NlbnQiLCJTQ0FMRSIsImNvbnRvdXJMaXN0IiwicHJvY2Vzc0RyYXduTGluZXMiLCJjdXJ2ZXMiLCJtdXN0U21vb3RoIiwiYXJlQ29udG91cnMiLCJsaW5lc0FuZFBvaW50cyIsInhTY2FsZSIsInlTY2FsZSIsIm5ld0N1cnZlcyIsInJlZHVjZWRQb2ludHMiLCJuZXdQb2ludHMiLCJjb21wcmVzc1NpZ25hdHVyZSIsIm1pbkRpZmYiLCJtYXhEaWZmIiwib3V0bGluZXNMZW5ndGgiLCJkeCIsImJ1ZmZlclR5cGUiLCJJbnQ4QXJyYXkiLCJJbnQxNkFycmF5IiwiaGVhZGVyTGVuZ3RoIiwiQllURVNfUEVSX0VMRU1FTlQiLCJDb21wcmVzc2lvblN0cmVhbSIsIndyaXRlciIsImdldFdyaXRlciIsIndyaXRlIiwiQnVmZmVyQ3RvciIsImRpZmZzIiwicmVhZGFibGUiLCJkZWNvbXByZXNzU2lnbmF0dXJlIiwic2lnbmF0dXJlRGF0YSIsIkRlY29tcHJlc3Npb25TdHJlYW0iLCJudW1iZXJPZkRyYXdpbmdzIiwiZGlmZnNPZmZzZXQiLCJTaWduYXR1cmVPcHRpb25zIiwiRHJhd25TaWduYXR1cmVPcHRpb25zIiwiU2lnbmF0dXJlRWRpdG9yIiwiaXNFeHRyYWN0ZWQiLCJzaWduYXR1cmVVVUlEIiwiX2RlZmF1bHREcmF3blNpZ25hdHVyZU9wdGlvbnMiLCJoYXNEZXNjcmlwdGlvbiIsImhhc0Rlc2NyaXB0aW9uU3RhdHMiLCJoYXNOb0FsdFRleHQiLCJ1dWlkIiwiaGVpZ2h0SW5QYWdlIiwiYWRkU2lnbmF0dXJlIiwic2V0VXVpZCIsImdldFNpZ25hdHVyZVByZXZpZXciLCJvdXRsaW5lRGF0YSIsImhhc0JlZW5TYXZlZCIsImdldEZyb21JbWFnZSIsImdldEZyb21UZXh0IiwiZm9udEluZm8iLCJnZXREcmF3blNpZ25hdHVyZSIsImlzU2lnbmF0dXJlIiwiYWx0IiwiU3RhbXBFZGl0b3IiLCJiaXRtYXBJZCIsImJpdG1hcFByb21pc2UiLCJiaXRtYXBVcmwiLCJiaXRtYXBGaWxlIiwiYml0bWFwRmlsZU5hbWUiLCJtaXNzaW5nQ2FudmFzIiwicmVzaXplVGltZW91dElkIiwiaGFzQmVlbkFkZGVkSW5VbmRvU3RhY2siLCJwYXN0ZUVkaXRvciIsImdldEFzRmlsZSIsImhhc0FsdFRleHRTdGF0cyIsImdldEJpdG1hcEZldGNoZWQiLCJmcm9tSWQiLCJnZXRCaXRtYXBEb25lIiwiYWx0X3RleHRfbW9kYWwiLCJhbHRfdGV4dF90eXBlIiwibWxHdWVzc0FsdFRleHQiLCJ1cGRhdGVBbHRUZXh0RGF0YSIsImlzRW5hYmxlZEZvciIsImNvcHlDYW52YXMiLCJndWVzcyIsImNoYW5uZWxzIiwiZ2V0Qml0bWFwIiwiYWNjZXB0IiwiZmlsZXMiLCJjbGljayIsImRyYXdCaXRtYXAiLCJNQVhfUkFUSU8iLCJtYXhEYXRhRGltZW5zaW9uIiwibWF4UHJldmlld0RpbWVuc2lvbiIsImJpdG1hcFdpZHRoIiwiYml0bWFwSGVpZ2h0Iiwib3V0cHV0U2NhbGUiLCJzY2FsZWRXaWR0aCIsInNjYWxlZEhlaWdodCIsInNjYWxlQml0bWFwIiwiYm94RGltIiwiYm94RGltV2lkdGgiLCJib3hEaW1IZWlnaHQiLCJwYXR0ZXJuQ3R4IiwiZGF0YVdpZHRoIiwiZGF0YUhlaWdodCIsIm9mZnNjcmVlbkN0eCIsInNlcmlhbGl6ZUJpdG1hcCIsInRvVXJsIiwidG9EYXRhVVJMIiwic3RydWN0UGFyZW50IiwiX3N0cnVjdFRyZWUiLCJjaGFuZ2VzIiwiaXNTYW1lIiwiaXNTYW1lQWx0VGV4dCIsInN0YW1wcyIsImFyZWEiLCJwcmV2RGF0YSIsImlzU2FtZVBhZ2VJbmRleCIsIkFubm90YXRpb25FZGl0b3JMYXllciIsImFsbG93Q2xpY2siLCJhbm5vdGF0aW9uTGF5ZXIiLCJjbGlja0FDIiwiZWRpdG9yRm9jdXNUaW1lb3V0SWQiLCJoYWRQb2ludGVyRG93biIsImlzRGlzYWJsaW5nIiwiaXNFbmFibGluZyIsImRyYXdpbmdBQyIsImZvY3VzZWRFbGVtZW50IiwidGV4dFNlbGVjdGlvbkFDIiwiX2luaXRpYWxpemVkIiwiaXNJbnZpc2libGUiLCJkaXNhYmxlVGV4dFNlbGVjdGlvbiIsInRvZ2dsZUFubm90YXRpb25MYXllclBvaW50ZXJFdmVudHMiLCJlbmFibGVUZXh0U2VsZWN0aW9uIiwiYW5ub3RhdGlvbkVsZW1lbnRJZHMiLCJlZGl0YWJsZXMiLCJjaGFuZ2VkQW5ub3RhdGlvbnMiLCJyZXNldEFubm90YXRpb25zIiwiY3VycmVudEFjdGl2ZSIsInRleHRMYXllclBvaW50ZXJEb3duIiwiYXR0YWNoIiwiZGV0YWNoIiwicmVtb3ZlUG9pbnRlckluVGV4dExheWVyIiwiY3VycmVudEVkaXRvclR5cGUiLCJjcmVhdGVOZXdFZGl0b3IiLCJnZXRDZW50ZXJQb2ludCIsImN1cnJlbnRNb2RlIiwic3RhcnREcmF3aW5nU2Vzc2lvbiIsInBhdXNlIiwib2xkUm90YXRpb24iLCJEcmF3TGF5ZXIiLCJtYXBwaW5nIiwidG9VcGRhdGUiLCJfc3ZnRmFjdG9yeSIsInNldEJveCIsImNyZWF0ZVNWRyIsImNyZWF0ZUNsaXBQYXRoIiwicGF0aElkIiwiY2xpcFBhdGhVc2UiLCJpc1BhdGhVcGRhdGFibGUiLCJoYXNDbGlwIiwidXNlIiwibXVzdFJlbW92ZVNlbGZJbnRlcnNlY3Rpb25zIiwibWFza0lkIiwidXNlMSIsInVzZTIiLCJjbG9uZU5vZGUiLCJlbGVtZW50T3JJZCIsInBhdGhFbGVtZW50IiwicGRmanNWZXJzaW9uIiwicGRmanNCdWlsZCIsInBkZmpzVGVzdGluZ1V0aWxzIiwicGRmanNMaWIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pdfjs-dist/build/pdf.mjs\n");

/***/ })

};
;